language: d
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpagen7z9s.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpagen7z9s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int cap = 0;\n \
    \       int sm = 0;\n        foreach(c; extension)\n        {\n            if(c.isUpper)\n\
    \                cap++;\n            else\n                sm++;\n        }\n\
    \        int strength = cap - sm;\n        if(strength > max_strength)\n     \
    \   {\n            max_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoyw9delc.d(32): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoyw9delc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > max_strength)\n        {\n   \
    \         max_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy1sximgp.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpy1sximgp.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy1sximgp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = -1;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if (c.isUpper)\n      \
    \          strength++;\n            else if (c.isLower)\n                strength--;\n\
    \        }\n        if (strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpha5d1q62.d(31): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpha5d1q62.d(33): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpha5d1q62.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1itke4o4.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1itke4o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max = 0;\n    string result = \"\";\n \
    \   foreach(string ext; extensions)\n    {\n        double strength = 0;\n   \
    \     foreach(char c; ext)\n        {\n            if(c.isUpper)\n           \
    \     strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max)\n        {\n            max = strength;\n\
    \            result = ext;\n        }\n    }\n    return class_name ~ \".\" ~\
    \ result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa5xyaec9.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpa5xyaec9.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa5xyaec9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int[] strength = new int[extensions.length];\n\
    \    int max = 0;\n    int index = 0;\n    foreach(i, extension; extensions)\n\
    \    {\n        int cap = 0;\n        int sm = 0;\n        foreach(c; extension)\n\
    \        {\n            if(c.isUpper)\n                cap++;\n            else\n\
    \                sm++;\n        }\n        strength[i] = cap - sm;\n        if(strength[i]\
    \ > max)\n        {\n            max = strength[i];\n            index = i;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ extensions[index];\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl055n1s7.d(33): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpl055n1s7.d(42): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl055n1s7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_extension_strength = 0;\n    foreach(string extension; extensions)\n\
    \    {\n        double extension_strength = 0;\n        foreach(char c; extension)\n\
    \        {\n            if(isUpper(c))\n            {\n                extension_strength++;\n\
    \            }\n            else if(isLower(c))\n            {\n             \
    \   extension_strength--;\n            }\n        }\n        if(extension_strength\
    \ > strongest_extension_strength)\n        {\n            strongest_extension_strength\
    \ = extension_strength;\n            strongest_extension = extension;\n      \
    \  }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_467zarg.d(31): Error: undefined identifier `isUpper`

    /tmp/tmp_467zarg.d(35): Error: undefined identifier `isLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_467zarg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    float\
    \ strongest_extension_strength = 0;\n    foreach(extension; extensions)\n    {\n\
    \        float extension_strength = 0;\n        foreach(char c; extension)\n \
    \       {\n            if(c.isUpper)\n                extension_strength++;\n\
    \            else\n                extension_strength--;\n        }\n        if(extension_strength\
    \ > strongest_extension_strength)\n        {\n            strongest_extension_strength\
    \ = extension_strength;\n            strongest_extension = extension;\n      \
    \  }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz36tc2th.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz36tc2th.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg20ze2mv.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg20ze2mv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg20ze2mv.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg20ze2mv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int[] strengths = extensions.map!(ext => ext.count!(c\
    \ => c.isUpper) - ext.count!(c => c.isLower));\n    int max_strength = strengths.max;\n\
    \    int max_index = strengths.indexOf(max_strength);\n    return class_name ~\
    \ \".\" ~ extensions[max_index];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi9o97dtd.d(24): Error: no property `map` for type `string[]`

    /tmp/tmpi9o97dtd.d(25): Error: no property `max` for type `int[]`

    /tmp/tmpi9o97dtd.d(26): Error: no property `indexOf` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi9o97dtd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg20ze2mv.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg20ze2mv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg20ze2mv.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg20ze2mv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv6nxeim3.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpv6nxeim3.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv6nxeim3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int CAP = 0;\n \
    \       int SM = 0;\n        foreach(c; extension)\n        {\n            if(c.isUpper)\n\
    \                CAP++;\n            else\n                SM++;\n        }\n\
    \        int strength = CAP - SM;\n        if(strength > max_strength)\n     \
    \   {\n            max_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2_lb8t1e.d(32): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2_lb8t1e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float strongest = 0.0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        float strength =\
    \ 0.0;\n        foreach(c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength += 1.0;\n            else\n                strength\
    \ -= 1.0;\n        }\n        if(strength > strongest)\n        {\n          \
    \  strongest = strength;\n            strongest_extension = extension;\n     \
    \   }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcn67r47l.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcn67r47l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(abs(strength) > max_strength)\n        {\n            max_strength\
    \ = abs(strength);\n            strongest_extension = extension;\n        }\n\
    \    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbcusc417.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbcusc417.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > max_strength)\n        {\n   \
    \         max_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr2mgj2gx.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpr2mgj2gx.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr2mgj2gx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string result = \"\";\n    int max_strength =\
    \ 0;\n    foreach(string ext; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; ext)\n        {\n            if(c.isUpper)\n        \
    \        strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            result = class_name ~ \".\" ~ ext;\n        }\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwwiqxgt0.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpwwiqxgt0.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwwiqxgt0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_extension_strength = 0;\n    foreach(string extension; extensions)\n\
    \    {\n        double extension_strength = 0;\n        foreach(char c; extension)\n\
    \        {\n            if(c.isUpper)\n                extension_strength += 1;\n\
    \            else\n                extension_strength -= 1;\n        }\n     \
    \   if(extension_strength > strongest_extension_strength)\n        {\n       \
    \     strongest_extension_strength = extension_strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2nz39bla.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2nz39bla.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpviy8bsak.d(31): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpviy8bsak.d(33): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpviy8bsak.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > max_strength)\n        {\n   \
    \         max_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy1sximgp.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpy1sximgp.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy1sximgp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > max_strength)\n        {\n   \
    \         max_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy1sximgp.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpy1sximgp.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy1sximgp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = -1;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgnqo_vde.d(31): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpgnqo_vde.d(33): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgnqo_vde.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_strength = 0;\n    foreach(extension; extensions)\n    {\n       \
    \ double strength = 0;\n        foreach(char c; extension)\n        {\n      \
    \      if(c.isUpper)\n                strength += 1;\n            else\n     \
    \           strength -= 1;\n        }\n        if(strength > strongest_strength)\n\
    \        {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm0ycaqe3.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm0ycaqe3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int maxStrength = 0;\n    int strength = 0;\n\
    \    string strongestExtension = \"\";\n    foreach(string extension; extensions)\n\
    \    {\n        strength = 0;\n        foreach(char c; extension)\n        {\n\
    \            if(isupper(c))\n                strength++;\n            else if(islower(c))\n\
    \                strength--;\n        }\n        if(strength > maxStrength)\n\
    \        {\n            maxStrength = strength;\n            strongestExtension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongestExtension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpldiv_c1f.d(32): Error: undefined identifier `isupper`

    /tmp/tmpldiv_c1f.d(34): Error: undefined identifier `islower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpldiv_c1f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int strongest = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int cap =\
    \ 0;\n        int sm = 0;\n        foreach(char c; extension)\n        {\n   \
    \         if(c.isUpper)\n                cap++;\n            else\n          \
    \      sm++;\n        }\n        int strength = cap - sm;\n        if(strength\
    \ > strongest)\n        {\n            strongest = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptbpcn12w.d(32): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptbpcn12w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv6nxeim3.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpv6nxeim3.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv6nxeim3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv6nxeim3.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpv6nxeim3.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv6nxeim3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_extension_strength = 0;\n    foreach(extension; extensions)\n    {\n\
    \        double strength = 0;\n        foreach(char c; extension)\n        {\n\
    \            if(c.isUpper)\n                strength += 1;\n            else\n\
    \                strength -= 1;\n        }\n        if(strength > strongest_extension_strength)\n\
    \        {\n            strongest_extension_strength = strength;\n           \
    \ strongest_extension = extension;\n        }\n    }\n    return class_name ~\
    \ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpitt7mg_l.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpitt7mg_l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = -1;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(isupper(c))\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp71jid_6m.d(31): Error: undefined identifier `isupper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp71jid_6m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max_strength = double.min;\n    string\
    \ strongest_extension = \"\";\n    foreach(extension; extensions)\n    {\n   \
    \     double strength = 0;\n        foreach(c; extension)\n        {\n       \
    \     if(c.isUpper)\n                strength++;\n            else\n         \
    \       strength--;\n        }\n        if(strength > max_strength)\n        {\n\
    \            max_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3z0aezis.d(24): Error: no property `min` for type `double`

    /tmp/tmp3z0aezis.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3z0aezis.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpagen7z9s.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpagen7z9s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_strength = 0;\n    foreach(string extension; extensions)\n    {\n\
    \        double strength = 0;\n        foreach(char c; extension)\n        {\n\
    \            if(c.isUpper)\n                strength++;\n            else\n  \
    \              strength--;\n        }\n        if(abs(strength) > abs(strongest_strength))\n\
    \        {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxq98fsqa.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxq98fsqa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    real strongest = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        real strength =\
    \ 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest)\n        {\n      \
    \      strongest = strength;\n            strongest_extension = extension;\n \
    \       }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd5oo5vph.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpd5oo5vph.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd5oo5vph.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_strength = 0;\n    foreach(string extension; extensions)\n    {\n\
    \        double strength = 0;\n        foreach(char c; extension)\n        {\n\
    \            if(c.isUpper)\n                strength++;\n            else\n  \
    \              strength--;\n        }\n        if(abs(strength) > abs(strongest_strength))\n\
    \        {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxq98fsqa.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxq98fsqa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > max_strength)\n        {\n   \
    \         max_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy1sximgp.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpy1sximgp.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy1sximgp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strength = 0;\n    foreach(string extension; extensions)\n    {\n        double\
    \ cap = 0;\n        double sm = 0;\n        foreach(char c; extension)\n     \
    \   {\n            if(isUpper(c))\n                cap++;\n            else\n\
    \                sm++;\n        }\n        double current_strength = cap - sm;\n\
    \        if(current_strength > strength)\n        {\n            strength = current_strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpagxi90ww.d(32): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpagxi90ww.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > max_strength)\n        {\n   \
    \         max_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy1sximgp.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpy1sximgp.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy1sximgp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int[] strength = new int[extensions.length];\n\
    \    int max_strength = 0;\n    int max_index = 0;\n    foreach(int i, string\
    \ ext; extensions)\n    {\n        int cap = 0;\n        int sm = 0;\n       \
    \ foreach(char c; ext)\n        {\n            if(c.isUpper)\n               \
    \ cap++;\n            else\n                sm++;\n        }\n        strength[i]\
    \ = cap - sm;\n        if(strength[i] > max_strength)\n        {\n           \
    \ max_strength = strength[i];\n            max_index = i;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ extensions[max_index];\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_jf8mv94.d(33): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_jf8mv94.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(letter; extension)\n        {\n            if(letter.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjk8k2_tt.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjk8k2_tt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1itke4o4.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1itke4o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv6nxeim3.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpv6nxeim3.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv6nxeim3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1itke4o4.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1itke4o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_strength = 0;\n    foreach(extension; extensions)\n    {\n       \
    \ double strength = 0;\n        foreach(char c; extension)\n        {\n      \
    \      if(c.isUpper)\n                strength++;\n            else\n        \
    \        strength--;\n        }\n        if(strength > strongest_strength)\n \
    \       {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_sgxdb72.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_sgxdb72.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest = \"\";\n    double strongest_strength\
    \ = 0;\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest_strength)\n        {\n\
    \            strongest_strength = strength;\n            strongest = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxd0oybiw.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpxd0oybiw.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxd0oybiw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        float current_strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                current_strength++;\n            else\n                current_strength--;\n\
    \        }\n        if(current_strength > strength)\n        {\n            strength\
    \ = current_strength;\n            strongest_extension = extension;\n        }\n\
    \    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn3a_wyxp.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn3a_wyxp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1itke4o4.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1itke4o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    float\
    \ strongest_strength = 0.0f;\n    foreach(string extension; extensions)\n    {\n\
    \        float strength = 0.0f;\n        foreach(char c; extension)\n        {\n\
    \            if(isUpper(c))\n                strength += 1.0f;\n            else\
    \ if(isLower(c))\n                strength -= 1.0f;\n        }\n        if(strength\
    \ > strongest_strength)\n        {\n            strongest_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1rnvwilk.d(31): Error: undefined identifier `isUpper`

    /tmp/tmp1rnvwilk.d(33): Error: undefined identifier `isLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1rnvwilk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int[] strengths = new int[extensions.length];\n\
    \    int max_strength = 0;\n    int max_strength_index = 0;\n    for (int i =\
    \ 0; i < extensions.length; i++)\n    {\n        int cap = 0;\n        int sm\
    \ = 0;\n        foreach (char c; extensions[i])\n        {\n            if (c.isUpper)\n\
    \                cap++;\n            else if (c.isLower)\n                sm++;\n\
    \        }\n        strengths[i] = cap - sm;\n        if (strengths[i] > max_strength)\n\
    \        {\n            max_strength = strengths[i];\n            max_strength_index\
    \ = i;\n        }\n    }\n    return class_name ~ \".\" ~ extensions[max_strength_index];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprnvpr_qn.d(33): Error: no property `isUpper` for type `char`

    /tmp/tmprnvpr_qn.d(35): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprnvpr_qn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1itke4o4.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1itke4o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max = 0;\n    string max_extension = \"\"\
    ;\n    foreach(string extension; extensions)\n    {\n        int upper = 0;\n\
    \        int lower = 0;\n        foreach(char c; extension)\n        {\n     \
    \       if(isUpper(c))\n                upper++;\n            else\n         \
    \       lower++;\n        }\n        if(upper - lower > max)\n        {\n    \
    \        max = upper - lower;\n            max_extension = extension;\n      \
    \  }\n    }\n    return class_name ~ \".\" ~ max_extension;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp3doegpm.d(32): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp3doegpm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(letter; extension)\n        {\n            if(letter.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjk8k2_tt.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjk8k2_tt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = -1;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc_s05sz_.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc_s05sz_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv6nxeim3.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpv6nxeim3.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv6nxeim3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_extension_strength = 0;\n    foreach(string extension; extensions)\n\
    \    {\n        double extension_strength = 0;\n        foreach(char c; extension)\n\
    \        {\n            if(c.isUpper)\n                extension_strength++;\n\
    \            else if(c.isLower)\n                extension_strength--;\n     \
    \   }\n        if(extension_strength > strongest_extension_strength)\n       \
    \ {\n            strongest_extension_strength = extension_strength;\n        \
    \    strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpelugxwxk.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpelugxwxk.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpelugxwxk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strength = 0;\n    string strongest = \"\
    \";\n    foreach(string extension; extensions)\n    {\n        double cap = 0;\n\
    \        double sm = 0;\n        foreach(char c; extension)\n        {\n     \
    \       if(c.isUpper)\n                cap++;\n            else\n            \
    \    sm++;\n        }\n        double temp = cap - sm;\n        if(temp > strength)\n\
    \        {\n            strength = temp;\n            strongest = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps21su5s2.d(32): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps21su5s2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    float\
    \ strongest_strength = -1.0f;\n    foreach(extension; extensions)\n    {\n   \
    \     float strength = 0.0f;\n        foreach(char c; extension)\n        {\n\
    \            if(c.isUpper)\n                strength += 1.0f;\n            else\
    \ if(c.isLower)\n                strength -= 1.0f;\n        }\n        if(strength\
    \ > strongest_strength)\n        {\n            strongest_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_ocwxv72.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmp_ocwxv72.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ocwxv72.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int cap = 0;\n \
    \       int sm = 0;\n        foreach(c; extension)\n        {\n            if(c.isUpper)\n\
    \                cap++;\n            else\n                sm++;\n        }\n\
    \        int strength = cap - sm;\n        if(strength > max_strength)\n     \
    \   {\n            max_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoyw9delc.d(32): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoyw9delc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1itke4o4.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1itke4o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    float\
    \ strongest_strength = 0.0f;\n    foreach(string extension; extensions)\n    {\n\
    \        float strength = 0.0f;\n        foreach(char c; extension)\n        {\n\
    \            if(c.isUpper)\n                strength += 1.0f;\n            else\
    \ if(c.isLower)\n                strength -= 1.0f;\n        }\n        if(strength\
    \ > strongest_strength)\n        {\n            strongest_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiq1mgoht.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpiq1mgoht.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiq1mgoht.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto strongest = extensions[0];\n    auto strongest_strength\
    \ = 0;\n    foreach(extension; extensions)\n    {\n        auto strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > strongest_strength)\n        {\n            strongest\
    \ = extension;\n            strongest_strength = strength;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpviwndz7l.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpviwndz7l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto strongest = extensions[0];\n    auto strongest_strength\
    \ = 0;\n    foreach(extension; extensions)\n    {\n        auto strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > strongest_strength)\n        {\n            strongest\
    \ = extension;\n            strongest_strength = strength;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpviwndz7l.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpviwndz7l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_extension_strength = 0;\n    foreach(string extension; extensions)\n\
    \    {\n        double extension_strength = 0;\n        foreach(char c; extension)\n\
    \        {\n            if(c.isUpper)\n                extension_strength++;\n\
    \            else if(c.isLower)\n                extension_strength--;\n     \
    \   }\n        if(extension_strength > strongest_extension_strength)\n       \
    \ {\n            strongest_extension_strength = extension_strength;\n        \
    \    strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpelugxwxk.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpelugxwxk.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpelugxwxk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_strength = 0;\n    foreach(string extension; extensions)\n    {\n\
    \        double strength = 0;\n        foreach(char c; extension)\n        {\n\
    \            if(c.isUpper)\n                strength++;\n            else\n  \
    \              strength--;\n        }\n        if(strength > strongest_strength)\n\
    \        {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9hjwnelj.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9hjwnelj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max_strength = -1;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(c; extension)\n        {\n            if(isUpper(c))\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx8xftqfb.d(31): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx8xftqfb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    import std.algorithm;\n    import std.array;\n\
    \    import std.conv;\n    import std.math;\n    import std.range;\n    import\
    \ std.stdio;\n    import std.string;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import std.typecons;\n    import std.typecons;\n\
    \    import std.typecons;\n    import\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeakpdcdo.d(89): Error: identifier expected following `import`

    /tmp/tmpeakpdcdo.d(89): Error: `;` expected

    /tmp/tmpeakpdcdo.d(103): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeakpdcdo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double strongest = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(abs(strength) > abs(strongest))\n        {\n          \
    \  strongest = strength;\n            strongest_extension = extension;\n     \
    \   }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqwgrlmnp.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqwgrlmnp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double[] strengths = new double[extensions.length];\n\
    \    int i = 0;\n    foreach(string ext; extensions)\n    {\n        int upper\
    \ = 0;\n        int lower = 0;\n        foreach(char c; ext)\n        {\n    \
    \        if(c.isUpper)\n                upper++;\n            else\n         \
    \       lower++;\n        }\n        strengths[i] = (double)upper - (double)lower;\n\
    \        i++;\n    }\n    int max_index = 0;\n    foreach(int j; 0..strengths.length)\n\
    \    {\n        if(strengths[j] > strengths[max_index])\n            max_index\
    \ = j;\n    }\n    return class_name ~ \".\" ~ extensions[max_index];\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxad74iy9.d(37): Error: C style cast illegal, use `cast(double)upper`

    /tmp/tmpxad74iy9.d(37): Error: C style cast illegal, use `cast(double)lower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxad74iy9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpagen7z9s.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpagen7z9s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(letter; extension)\n        {\n            if(letter.isUpper)\n\
    \            {\n                strength += 1;\n            }\n            else\n\
    \            {\n                strength -= 1;\n            }\n        }\n   \
    \     if(strength > max_strength)\n        {\n            max_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptq_o5d6p.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptq_o5d6p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(letter; extension)\n        {\n            if(letter.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return format(\"%s.%s\", class_name, strongest_extension);\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7ukq_bcd.d(31): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmp7ukq_bcd.d(42): Error: undefined identifier `format`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ukq_bcd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_extension_strength = 0;\n    foreach(extension; extensions)\n    {\n\
    \        double extension_strength = 0;\n        foreach(char c; extension)\n\
    \        {\n            if(isUpper(c))\n            {\n                extension_strength++;\n\
    \            }\n            else if(isLower(c))\n            {\n             \
    \   extension_strength--;\n            }\n        }\n        if(extension_strength\
    \ > strongest_extension_strength)\n        {\n            strongest_extension_strength\
    \ = extension_strength;\n            strongest_extension = extension;\n      \
    \  }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe0ului4y.d(31): Error: undefined identifier `isUpper`

    /tmp/tmpe0ului4y.d(35): Error: undefined identifier `isLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe0ului4y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_strength = 0;\n    foreach(string extension; extensions)\n    {\n\
    \        double strength = 0;\n        foreach(char c; extension)\n        {\n\
    \            if(isUpper(c))\n                strength++;\n            else\n \
    \               strength--;\n        }\n        if(strength > strongest_strength)\n\
    \        {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeeoe6idv.d(31): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeeoe6idv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max = 0;\n    string result = \"\";\n    foreach(string\
    \ ext; extensions)\n    {\n        int cap = 0;\n        int sm = 0;\n       \
    \ foreach(char c; ext)\n        {\n            if(c >= 'A' && c <= 'Z')\n    \
    \            cap++;\n            else if(c >= 'a' && c <= 'z')\n             \
    \   sm++;\n        }\n        if(cap - sm > max)\n        {\n            max =\
    \ cap - sm;\n            result = class_name ~ \".\" ~ ext;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpngszw8o3.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x4291e5]

    ??:? void tmpngszw8o3.__unittest_L45_C1() [0x427f1b]

    ??:? void tmpngszw8o3.__modtest() [0x42844c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42dabf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x428f3e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42a96d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42a9fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42a8f9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x428f15]

    ??:? runModuleUnitTests [0x42d895]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x429634]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int[] strength = new int[extensions.length];\n\
    \    int max_strength = 0;\n    int max_strength_index = 0;\n    for (int i =\
    \ 0; i < extensions.length; i++)\n    {\n        int upper_case = 0;\n       \
    \ int lower_case = 0;\n        foreach (char c; extensions[i])\n        {\n  \
    \          if (isUpper(c))\n                upper_case++;\n            else if\
    \ (isLower(c))\n                lower_case++;\n        }\n        strength[i]\
    \ = upper_case - lower_case;\n        if (strength[i] > max_strength)\n      \
    \  {\n            max_strength = strength[i];\n            max_strength_index\
    \ = i;\n        }\n    }\n    return class_name ~ \".\" ~ extensions[max_strength_index];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsr6oos41.d(33): Error: undefined identifier `isUpper`

    /tmp/tmpsr6oos41.d(35): Error: undefined identifier `isLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsr6oos41.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpagen7z9s.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpagen7z9s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\n/*\nYou will be given\
    \ a list of integers. You should find the smallest integer in the list.\n    Example:\n\
    \    >>> Smallest_Integer([1, 2, 3, 4, 5])\n    1\n*/\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp10cprmgx.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp10cprmgx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    // Your code here\n    int max_strength = 0;\n\
    \    string strongest_extension = \"\";\n    foreach(string extension; extensions)\n\
    \    {\n        int strength = 0;\n        foreach(char c; extension)\n      \
    \  {\n            if(c.isUpper)\n                strength++;\n            else\n\
    \                strength--;\n        }\n        if(strength > max_strength)\n\
    \        {\n            max_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd8mjyjpb.d(32): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd8mjyjpb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int[] strength = new int[extensions.length];\n\
    \    int max_strength = 0;\n    int max_strength_index = 0;\n    foreach(i, ext;\
    \ extensions)\n    {\n        int cap = 0;\n        int sm = 0;\n        foreach(c;\
    \ ext)\n        {\n            if(c.isUpper)\n                cap++;\n       \
    \     else\n                sm++;\n        }\n        strength[i] = cap - sm;\n\
    \        if(strength[i] > max_strength)\n        {\n            max_strength =\
    \ strength[i];\n            max_strength_index = i;\n        }\n    }\n    return\
    \ class_name ~ \".\" ~ extensions[max_strength_index];\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7aeqe778.d(33): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmp7aeqe778.d(42): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7aeqe778.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1itke4o4.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1itke4o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int[] strengths = extensions.map!(ext => ext.count!(c\
    \ => c.isUpper) - ext.count!(c => c.isLower));\n    int max_strength = strengths.max;\n\
    \    int max_strength_index = strengths.indexOf(max_strength);\n    return class_name\
    \ ~ \".\" ~ extensions[max_strength_index];\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl9rc8qdr.d(24): Error: no property `map` for type `string[]`

    /tmp/tmpl9rc8qdr.d(25): Error: no property `max` for type `int[]`

    /tmp/tmpl9rc8qdr.d(26): Error: no property `indexOf` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl9rc8qdr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg20ze2mv.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg20ze2mv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1itke4o4.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1itke4o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpviy8bsak.d(31): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpviy8bsak.d(33): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpviy8bsak.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv6nxeim3.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpv6nxeim3.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv6nxeim3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpagen7z9s.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpagen7z9s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv6nxeim3.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpv6nxeim3.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv6nxeim3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1itke4o4.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1itke4o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_extension_strength = 0;\n    foreach(string extension; extensions)\n\
    \    {\n        double extension_strength = 0;\n        foreach(char c; extension)\n\
    \        {\n            if(c.isUpper)\n                extension_strength += 1;\n\
    \            else\n                extension_strength -= 1;\n        }\n     \
    \   if(extension_strength > strongest_extension_strength)\n        {\n       \
    \     strongest_extension_strength = extension_strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2nz39bla.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2nz39bla.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int[] strengths = extensions.map!(ext => ext.count!(c\
    \ => c.isUpper) - ext.count!(c => c.isLower));\n    int max_strength = strengths.max;\n\
    \    int max_index = strengths.indexOf(max_strength);\n    return class_name ~\
    \ \".\" ~ extensions[max_index];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi9o97dtd.d(24): Error: no property `map` for type `string[]`

    /tmp/tmpi9o97dtd.d(25): Error: no property `max` for type `int[]`

    /tmp/tmpi9o97dtd.d(26): Error: no property `indexOf` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi9o97dtd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpagen7z9s.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpagen7z9s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_strength = 0;\n    foreach(string extension; extensions)\n    {\n\
    \        double strength = 0;\n        foreach(char c; extension)\n        {\n\
    \            if(c.isUpper)\n                strength += 1;\n            else\n\
    \                strength -= 1;\n        }\n        if(strength > strongest_strength)\n\
    \        {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpom4dptlo.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpom4dptlo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_strength = 0;\n    foreach(string extension; extensions)\n    {\n\
    \        double strength = 0;\n        foreach(char c; extension)\n        {\n\
    \            if(c.isUpper)\n                strength += 1;\n            else\n\
    \                strength -= 1;\n        }\n        if(strength > strongest_strength)\n\
    \        {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpom4dptlo.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpom4dptlo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1itke4o4.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1itke4o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_strength = 0;\n    foreach(extension; extensions)\n    {\n       \
    \ double strength = 0;\n        foreach(char c; extension)\n        {\n      \
    \      if(isUpper(c))\n                strength++;\n            else\n       \
    \         strength--;\n        }\n        if(strength > strongest_strength)\n\
    \        {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg1llo4h3.d(31): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg1llo4h3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(abs(strength) > max_strength)\n        {\n            max_strength\
    \ = abs(strength);\n            strongest_extension = extension;\n        }\n\
    \    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6lu62g8q.d(31): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmp6lu62g8q.d(33): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6lu62g8q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpagen7z9s.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpagen7z9s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int[] strength = new int[extensions.length];\n\
    \    int max = 0;\n    int index = 0;\n    for (int i = 0; i < extensions.length;\
    \ i++)\n    {\n        int cap = 0;\n        int sm = 0;\n        foreach (char\
    \ c; extensions[i])\n        {\n            if (c >= 'A' && c <= 'Z')\n      \
    \          cap++;\n            else if (c >= 'a' && c <= 'z')\n              \
    \  sm++;\n        }\n        strength[i] = cap - sm;\n        if (strength[i]\
    \ > max)\n        {\n            max = strength[i];\n            index = i;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ extensions[index];\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpck3m68ti.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x42952d]

    ??:? void tmpck3m68ti.__unittest_L47_C1() [0x428267]

    ??:? void tmpck3m68ti.__modtest() [0x428798]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42e0bb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x429286]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42ad85]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ae14]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42ad11]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42925d]

    ??:? runModuleUnitTests [0x42de91]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4299f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int cap = 0;\n \
    \       int sm = 0;\n        foreach(c; extension)\n        {\n            if(c.isUpper)\n\
    \                cap++;\n            else if(c.isLower)\n                sm++;\n\
    \        }\n        int strength = cap - sm;\n        if(strength > max_strength)\n\
    \        {\n            max_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphou31nx7.d(32): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmphou31nx7.d(34): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphou31nx7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int cap = 0;\n \
    \       int sm = 0;\n        foreach(c; extension)\n        {\n            if(c.isUpper)\n\
    \                cap++;\n            else\n                sm++;\n        }\n\
    \        int strength = cap - sm;\n        if(strength > max_strength)\n     \
    \   {\n            max_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoyw9delc.d(32): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoyw9delc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpviy8bsak.d(31): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpviy8bsak.d(33): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpviy8bsak.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1itke4o4.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1itke4o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = -1;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphwbj8zbf.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphwbj8zbf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    int strongest_extension_strength\
    \ = 0;\n    foreach(extension; extensions)\n    {\n        int extension_strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                extension_strength++;\n            else if(c.isLower)\n     \
    \           extension_strength--;\n        }\n        if(extension_strength >\
    \ strongest_extension_strength)\n        {\n            strongest_extension_strength\
    \ = extension_strength;\n            strongest_extension = extension;\n      \
    \  }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphfc5cf9k.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmphfc5cf9k.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphfc5cf9k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(abs(strength) > max_strength)\n        {\n            max_strength\
    \ = abs(strength);\n            strongest_extension = extension;\n        }\n\
    \    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbcusc417.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbcusc417.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_strength = 0;\n    foreach(string extension; extensions)\n    {\n\
    \        double strength = 0;\n        foreach(char c; extension)\n        {\n\
    \            if(c.isUpper)\n                strength++;\n            else\n  \
    \              strength--;\n        }\n        if(strength > strongest_strength)\n\
    \        {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9hjwnelj.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9hjwnelj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > max_strength)\n        {\n   \
    \         max_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy1sximgp.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpy1sximgp.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy1sximgp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_strength = 0;\n    foreach(string extension; extensions)\n    {\n\
    \        double strength = 0;\n        foreach(char c; extension)\n        {\n\
    \            if(c.isUpper)\n                strength++;\n            else\n  \
    \              strength--;\n        }\n        if(abs(strength) > abs(strongest_strength))\n\
    \        {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxq98fsqa.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxq98fsqa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_extension_strength = 0;\n    foreach(string extension; extensions)\n\
    \    {\n        double extension_strength = 0;\n        foreach(char c; extension)\n\
    \        {\n            if(isUpper(c))\n            {\n                extension_strength++;\n\
    \            }\n            else if(isLower(c))\n            {\n             \
    \   extension_strength--;\n            }\n        }\n        if(extension_strength\
    \ > strongest_extension_strength)\n        {\n            strongest_extension_strength\
    \ = extension_strength;\n            strongest_extension = extension;\n      \
    \  }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_467zarg.d(31): Error: undefined identifier `isUpper`

    /tmp/tmp_467zarg.d(35): Error: undefined identifier `isLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_467zarg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_strength = 0;\n    foreach(string extension; extensions)\n    {\n\
    \        double strength = 0;\n        foreach(char c; extension)\n        {\n\
    \            if(c.isUpper)\n                strength++;\n            else\n  \
    \              strength--;\n        }\n        if(abs(strength) > abs(strongest_strength))\n\
    \        {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxq98fsqa.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxq98fsqa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = -1;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > max_strength)\n        {\n   \
    \         max_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjbbw2v9t.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpjbbw2v9t.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjbbw2v9t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest = \"\";\n    double strength\
    \ = 0;\n    foreach(string extension; extensions)\n    {\n        int cap = 0;\n\
    \        int sm = 0;\n        foreach(char c; extension)\n        {\n        \
    \    if(c.isUpper)\n                cap++;\n            else\n               \
    \ sm++;\n        }\n        double new_strength = cap - sm;\n        if(new_strength\
    \ > strength)\n        {\n            strength = new_strength;\n            strongest\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxikjj511.d(32): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxikjj511.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max_strength = -1;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpimcng2di.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpimcng2di.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpagen7z9s.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpagen7z9s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(letter; extension)\n        {\n            if(isUpper(letter))\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpteucj7ze.d(31): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpteucj7ze.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    int max_index = 0;\n\
    \    foreach(i, extension; extensions)\n    {\n        int strength = 0;\n   \
    \     foreach(c; extension)\n        {\n            if(isUpper(c))\n         \
    \       strength++;\n            else\n                strength--;\n        }\n\
    \        if(strength > max_strength)\n        {\n            max_strength = strength;\n\
    \            max_index = i;\n        }\n    }\n    return class_name ~ \".\" ~\
    \ extensions[max_index];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfdoa511m.d(31): Error: undefined identifier `isUpper`

    /tmp/tmpfdoa511m.d(39): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfdoa511m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto strongest = extensions[0];\n    double strongest_strength\
    \ = 0;\n    foreach(ext; extensions)\n    {\n        int cap = 0;\n        int\
    \ sm = 0;\n        foreach(c; ext)\n        {\n            if(c.isUpper)\n   \
    \             cap++;\n            else if(c.isLower)\n                sm++;\n\
    \        }\n        double strength = cap - sm;\n        if(strength > strongest_strength)\n\
    \        {\n            strongest = ext;\n            strongest_strength = strength;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj9fzi9me.d(32): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpj9fzi9me.d(34): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj9fzi9me.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    int strength = 0;\n\
    \    string strongest_extension = \"\";\n    foreach(extension; extensions)\n\
    \    {\n        strength = 0;\n        foreach(char c; extension)\n        {\n\
    \            if(c.isUpper)\n                strength++;\n            else if(c.isLower)\n\
    \                strength--;\n        }\n        if(strength > max_strength)\n\
    \        {\n            max_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphmecrs7d.d(32): Error: no property `isUpper` for type `char`

    /tmp/tmphmecrs7d.d(34): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphmecrs7d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_extension_strength = 0;\n    foreach(string extension; extensions)\n\
    \    {\n        double extension_strength = 0;\n        foreach(char c; extension)\n\
    \        {\n            if(c.isUpper)\n                extension_strength++;\n\
    \            else if(c.isLower)\n                extension_strength--;\n     \
    \   }\n        if(extension_strength > strongest_extension_strength)\n       \
    \ {\n            strongest_extension_strength = extension_strength;\n        \
    \    strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpelugxwxk.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpelugxwxk.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpelugxwxk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max = 0;\n    string strongest = \"\";\n \
    \   foreach(string ext; extensions)\n    {\n        int cap = 0;\n        int\
    \ sm = 0;\n        foreach(char c; ext)\n        {\n            if(c.isUpper)\n\
    \                cap++;\n            else\n                sm++;\n        }\n\
    \        int strength = cap - sm;\n        if(strength > max)\n        {\n   \
    \         max = strength;\n            strongest = ext;\n        }\n    }\n  \
    \  return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7wb9icxp.d(32): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7wb9icxp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int CAP = 0;\n \
    \       int SM = 0;\n        foreach(char c; extension)\n        {\n         \
    \   if(c.isUpper)\n                CAP++;\n            else\n                SM++;\n\
    \        }\n        int strength = CAP - SM;\n        if(strength > max_strength)\n\
    \        {\n            max_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp784axa0t.d(32): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp784axa0t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_strength = 0;\n    foreach(string extension; extensions)\n    {\n\
    \        double strength = 0;\n        foreach(char c; extension)\n        {\n\
    \            if(c.isUpper)\n                strength++;\n            else\n  \
    \              strength--;\n        }\n        if(strength > strongest_strength)\n\
    \        {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9hjwnelj.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9hjwnelj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg20ze2mv.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg20ze2mv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg20ze2mv.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg20ze2mv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpviy8bsak.d(31): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpviy8bsak.d(33): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpviy8bsak.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        float strength =\
    \ 0;\n        foreach(c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa9gljk4g.d(31): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpa9gljk4g.d(33): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa9gljk4g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ max_strength = 0;\n    foreach(extension; extensions)\n    {\n        int lowercase_count\
    \ = 0;\n        int uppercase_count = 0;\n        foreach(letter; extension)\n\
    \        {\n            if(letter.isUpper)\n            {\n                uppercase_count++;\n\
    \            }\n            else\n            {\n                lowercase_count++;\n\
    \            }\n        }\n        double strength = uppercase_count - lowercase_count;\n\
    \        if(strength > max_strength)\n        {\n            max_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqjeik17l.d(32): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqjeik17l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1itke4o4.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1itke4o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1itke4o4.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1itke4o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int[] strength = new int[extensions.length];\n\
    \    int max_strength = 0;\n    int max_index = 0;\n    foreach(i, ext; extensions)\n\
    \    {\n        strength[i] = ext.count!(c => c.isUpper) - ext.count!(c => c.isLower);\n\
    \        if(strength[i] > max_strength)\n        {\n            max_strength =\
    \ strength[i];\n            max_index = i;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ extensions[max_index];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu6bfll3d.d(29): Error: no property `count` for type `string`

    /tmp/tmpu6bfll3d.d(29): Error: no property `count` for type `string`

    /tmp/tmpu6bfll3d.d(33): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu6bfll3d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int[] strengths = extensions.map!(x => x.count!(isUpper)\
    \ - x.count!(isLower));\n    int max_strength = strengths.max;\n    int max_strength_index\
    \ = strengths.indexOf(max_strength);\n    return class_name ~ \".\" ~ extensions[max_strength_index];\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1b0919oz.d(24): Error: no property `map` for type `string[]`

    /tmp/tmp1b0919oz.d(25): Error: no property `max` for type `int[]`

    /tmp/tmp1b0919oz.d(26): Error: no property `indexOf` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1b0919oz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > max_strength)\n        {\n   \
    \         max_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr2mgj2gx.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpr2mgj2gx.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr2mgj2gx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(isUpper(c))\n\
    \                strength += 1;\n            else if(isLower(c))\n           \
    \     strength -= 1;\n        }\n        if(strength > max_strength)\n       \
    \ {\n            max_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbfl_n2gb.d(31): Error: undefined identifier `isUpper`

    /tmp/tmpbfl_n2gb.d(33): Error: undefined identifier `isLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbfl_n2gb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > max_strength)\n        {\n   \
    \         max_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy1sximgp.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpy1sximgp.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy1sximgp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float strongest = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        float strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest)\n        {\n      \
    \      strongest = strength;\n            strongest_extension = extension;\n \
    \       }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvqireoss.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpvqireoss.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvqireoss.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv6nxeim3.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpv6nxeim3.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv6nxeim3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(abs(strength) > max_strength)\n        {\n            max_strength\
    \ = abs(strength);\n            strongest_extension = extension;\n        }\n\
    \    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n\
    \    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbcusc417.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbcusc417.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_strength = 0;\n    foreach(extension; extensions)\n    {\n       \
    \ double strength = 0;\n        foreach(c; extension)\n        {\n           \
    \ if(c.isUpper)\n                strength += 1;\n            else\n          \
    \      strength -= 1;\n        }\n        if(strength > strongest_strength)\n\
    \        {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsgl439l2.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsgl439l2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1itke4o4.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1itke4o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    int max_strength_index\
    \ = 0;\n    for (int i = 0; i < extensions.length; i++)\n    {\n        int CAP\
    \ = 0;\n        int SM = 0;\n        foreach (char c; extensions[i])\n       \
    \ {\n            if (c.isUpper)\n                CAP++;\n            else if (c.isLower)\n\
    \                SM++;\n        }\n        int strength = CAP - SM;\n        if\
    \ (strength > max_strength)\n        {\n            max_strength = strength;\n\
    \            max_strength_index = i;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ extensions[max_strength_index];\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8190qmp0.d(32): Error: no property `isUpper` for type `char`

    /tmp/tmp8190qmp0.d(34): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8190qmp0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int[] strength = new int[extensions.length];\n\
    \    int max = 0;\n    int index = 0;\n    foreach(i, e; extensions)\n    {\n\
    \        int cap = 0;\n        int sm = 0;\n        foreach(c; e)\n        {\n\
    \            if(c.isUpper)\n                cap++;\n            else\n       \
    \         sm++;\n        }\n        strength[i] = cap - sm;\n        if(strength[i]\
    \ > max)\n        {\n            max = strength[i];\n            index = i;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ extensions[index];\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8b0s4ddx.d(33): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmp8b0s4ddx.d(42): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8b0s4ddx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1itke4o4.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1itke4o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg20ze2mv.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg20ze2mv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double[] strengths = new double[extensions.length];\n\
    \    int[] caps = new int[extensions.length];\n    int[] smalls = new int[extensions.length];\n\
    \    foreach(i, ext; extensions)\n    {\n        foreach(c; ext)\n        {\n\
    \            if(c.isUpper)\n                caps[i]++;\n            else\n   \
    \             smalls[i]++;\n        }\n        strengths[i] = caps[i] - smalls[i];\n\
    \    }\n    int max_index = 0;\n    foreach(i, s; strengths)\n    {\n        if(s\
    \ > strengths[max_index])\n            max_index = i;\n    }\n    return class_name\
    \ ~ \".\" ~ extensions[max_index];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1mcwg9_1.d(31): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmp1mcwg9_1.d(42): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1mcwg9_1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > max_strength)\n        {\n   \
    \         max_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy1sximgp.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpy1sximgp.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy1sximgp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv6nxeim3.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpv6nxeim3.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv6nxeim3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = -1;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprmv0kwif.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprmv0kwif.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float strongest = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        float strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > strongest)\n        {\n      \
    \      strongest = strength;\n            strongest_extension = extension;\n \
    \       }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvqireoss.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpvqireoss.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvqireoss.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    float\
    \ strongest_strength = 0;\n    foreach(string extension; extensions)\n    {\n\
    \        float strength = 0;\n        foreach(char c; extension)\n        {\n\
    \            if(c.isUpper)\n                strength++;\n            else\n  \
    \              strength--;\n        }\n        if(strength > strongest_strength)\n\
    \        {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpscwpzajr.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpscwpzajr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_extension_strength = 0;\n    foreach(string extension; extensions)\n\
    \    {\n        double extension_strength = 0;\n        foreach(char c; extension)\n\
    \        {\n            if(isUpper(c))\n            {\n                extension_strength++;\n\
    \            }\n            else if(isLower(c))\n            {\n             \
    \   extension_strength--;\n            }\n        }\n        if(extension_strength\
    \ > strongest_extension_strength)\n        {\n            strongest_extension_strength\
    \ = extension_strength;\n            strongest_extension = extension;\n      \
    \  }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_467zarg.d(31): Error: undefined identifier `isUpper`

    /tmp/tmp_467zarg.d(35): Error: undefined identifier `isLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_467zarg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int cap = 0;\n \
    \       int sm = 0;\n        foreach(ch; extension)\n        {\n            if(isUpper(ch))\n\
    \                cap++;\n            else if(isLower(ch))\n                sm++;\n\
    \        }\n        int strength = cap - sm;\n        if(strength > max_strength)\n\
    \        {\n            max_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2v71wx0w.d(32): Error: undefined identifier `isUpper`

    /tmp/tmp2v71wx0w.d(34): Error: undefined identifier `isLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2v71wx0w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int cap =\
    \ 0;\n        int sm = 0;\n        foreach(char c; extension)\n        {\n   \
    \         if(c.isUpper)\n                cap++;\n            else if(c.isLower)\n\
    \                sm++;\n        }\n        int strength = cap - sm;\n        if(strength\
    \ > max_strength)\n        {\n            max_strength = strength;\n         \
    \   strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5jvo426u.d(32): Error: no property `isUpper` for type `char`

    /tmp/tmp5jvo426u.d(34): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5jvo426u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpagen7z9s.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpagen7z9s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv6nxeim3.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpv6nxeim3.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv6nxeim3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_extension_strength = 0;\n    foreach(string extension; extensions)\n\
    \    {\n        double strength = 0;\n        foreach(char c; extension)\n   \
    \     {\n            if(c.isUpper)\n                strength += 1;\n         \
    \   else\n                strength -= 1;\n        }\n        if(strength > strongest_extension_strength)\n\
    \        {\n            strongest_extension_strength = strength;\n           \
    \ strongest_extension = extension;\n        }\n    }\n    return class_name ~\
    \ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsz0p1u9a.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsz0p1u9a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest = \"\";\n    double strength\
    \ = 0;\n    foreach(string ext; extensions)\n    {\n        double cap = 0;\n\
    \        double sm = 0;\n        foreach(char c; ext)\n        {\n           \
    \ if(c.isUpper)\n                cap++;\n            else\n                sm++;\n\
    \        }\n        double curr_strength = cap - sm;\n        if(curr_strength\
    \ > strength)\n        {\n            strength = curr_strength;\n            strongest\
    \ = ext;\n        }\n    }\n    return class_name ~ \".\" ~ strongest;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxj_4eip7.d(32): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxj_4eip7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > max_strength)\n        {\n   \
    \         max_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy1sximgp.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpy1sximgp.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy1sximgp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(isUpper(c))\n\
    \                strength++;\n            else if(isLower(c))\n              \
    \  strength--;\n        }\n        if(strength > max_strength)\n        {\n  \
    \          max_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsepwmng4.d(31): Error: undefined identifier `isUpper`

    /tmp/tmpsepwmng4.d(33): Error: undefined identifier `isLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsepwmng4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpagen7z9s.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpagen7z9s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(character; extension)\n        {\n            if(character.isUpper)\n\
    \            {\n                strength++;\n            }\n            else\n\
    \            {\n                strength--;\n            }\n        }\n      \
    \  if(strength > max_strength)\n        {\n            max_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppu8pscs2.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppu8pscs2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpviy8bsak.d(31): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpviy8bsak.d(33): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpviy8bsak.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        float cap\
    \ = 0;\n        float sm = 0;\n        foreach(char c; extension)\n        {\n\
    \            if(c.isUpper)\n                cap++;\n            else\n       \
    \         sm++;\n        }\n        float current_strength = cap - sm;\n     \
    \   if(current_strength > strength)\n        {\n            strength = current_strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkfjus1n5.d(32): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkfjus1n5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = -1;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprmv0kwif.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprmv0kwif.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = -1;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgnqo_vde.d(31): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpgnqo_vde.d(33): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgnqo_vde.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjm2vzm15.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjm2vzm15.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(isUpper(c))\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1wa2a9ub.d(31): Error: undefined identifier `isUpper`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1wa2a9ub.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1itke4o4.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1itke4o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double[] strengths = new double[extensions.length];\n\
    \    foreach(i, extension; extensions)\n    {\n        int cap = 0;\n        int\
    \ sm = 0;\n        foreach(c; extension)\n        {\n            if(c.isUpper)\n\
    \                cap++;\n            else\n                sm++;\n        }\n\
    \        strengths[i] = cap - sm;\n    }\n    int strongest_index = 0;\n    double\
    \ strongest_strength = strengths[0];\n    foreach(i, strength; strengths)\n  \
    \  {\n        if(strength > strongest_strength)\n        {\n            strongest_index\
    \ = i;\n            strongest_strength = strength;\n        }\n    }\n    return\
    \ class_name ~ \".\" ~ extensions[strongest_index];\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqhm0lr1e.d(31): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpqhm0lr1e.d(44): Error: cannot implicitly convert expression `i` of type
    `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqhm0lr1e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    double max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        double strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgb1hvql2.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgb1hvql2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max = 0;\n    string result = \"\";\n    foreach(string\
    \ ext; extensions)\n    {\n        int cap = 0;\n        int sm = 0;\n       \
    \ foreach(char c; ext)\n        {\n            if(c.isUpper)\n               \
    \ cap++;\n            else\n                sm++;\n        }\n        if(cap -\
    \ sm > max)\n        {\n            max = cap - sm;\n            result = ext;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ result;\n}\nunittest\n{\n \
    \   alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcg15sqe5.d(32): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcg15sqe5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpviy8bsak.d(31): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpviy8bsak.d(33): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpviy8bsak.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto strongest = extensions[0];\n    auto strongest_strength\
    \ = 0;\n    foreach(extension; extensions)\n    {\n        auto strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > strongest_strength)\n        {\n            strongest\
    \ = extension;\n            strongest_strength = strength;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpviwndz7l.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpviwndz7l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg20ze2mv.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg20ze2mv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_strength = 0;\n    foreach(string extension; extensions)\n    {\n\
    \        double strength = 0;\n        foreach(char c; extension)\n        {\n\
    \            if(c.isUpper)\n                strength++;\n            else\n  \
    \              strength--;\n        }\n        if(abs(strength) > abs(strongest_strength))\n\
    \        {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxq98fsqa.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxq98fsqa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpagen7z9s.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpagen7z9s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpagen7z9s.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpagen7z9s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpviy8bsak.d(31): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpviy8bsak.d(33): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpviy8bsak.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_extension_strength = 0;\n    foreach(string extension; extensions)\n\
    \    {\n        double extension_strength = 0;\n        foreach(char c; extension)\n\
    \        {\n            if(isUpper(c))\n            {\n                extension_strength++;\n\
    \            }\n            else if(isLower(c))\n            {\n             \
    \   extension_strength--;\n            }\n        }\n        if(extension_strength\
    \ > strongest_extension_strength)\n        {\n            strongest_extension_strength\
    \ = extension_strength;\n            strongest_extension = extension;\n      \
    \  }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_467zarg.d(31): Error: undefined identifier `isUpper`

    /tmp/tmp_467zarg.d(35): Error: undefined identifier `isLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_467zarg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg20ze2mv.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg20ze2mv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1itke4o4.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1itke4o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_strength = 0;\n    foreach(extension; extensions)\n    {\n       \
    \ int upper_case_count = 0;\n        int lower_case_count = 0;\n        foreach(letter;\
    \ extension)\n        {\n            if(letter.isUpper)\n            {\n     \
    \           upper_case_count++;\n            }\n            else\n           \
    \ {\n                lower_case_count++;\n            }\n        }\n        double\
    \ strength = (double)upper_case_count - (double)lower_case_count;\n        if(strength\
    \ > strongest_strength)\n        {\n            strongest_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphvkb7s76.d(41): Error: C style cast illegal, use `cast(double)upper_case_count`

    /tmp/tmphvkb7s76.d(41): Error: C style cast illegal, use `cast(double)lower_case_count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphvkb7s76.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_strength = 0;\n    foreach(string extension; extensions)\n    {\n\
    \        double strength = 0;\n        foreach(char c; extension)\n        {\n\
    \            if(isUpper(c))\n                strength++;\n            else if(isLower(c))\n\
    \                strength--;\n        }\n        if(strength > strongest_strength)\n\
    \        {\n            strongest_strength = strength;\n            strongest_extension\
    \ = extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ock0quc.d(31): Error: undefined identifier `isUpper`

    /tmp/tmp4ock0quc.d(33): Error: undefined identifier `isLower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ock0quc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_extension_strength = 0;\n    foreach(string extension; extensions)\n\
    \    {\n        double extension_strength = 0;\n        foreach(char c; extension)\n\
    \        {\n            if(c.isUpper)\n                extension_strength++;\n\
    \            else if(c.isLower)\n                extension_strength--;\n     \
    \   }\n        if(extension_strength > strongest_extension_strength)\n       \
    \ {\n            strongest_extension_strength = extension_strength;\n        \
    \    strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpelugxwxk.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpelugxwxk.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpelugxwxk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else\n                strength--;\n  \
    \      }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1itke4o4.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1itke4o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int cap = 0;\n \
    \       int sm = 0;\n        foreach(c; extension)\n        {\n            if(c.isUpper)\n\
    \                cap++;\n            else\n                sm++;\n        }\n\
    \        int strength = cap - sm;\n        if(strength > max_strength)\n     \
    \   {\n            max_strength = strength;\n            strongest_extension =\
    \ extension;\n        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n\
    }\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoyw9delc.d(32): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoyw9delc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto strongest = extensions[0];\n    double strength\
    \ = 0;\n    foreach(ext; extensions)\n    {\n        auto cap = ext.count!(x =>\
    \ x.isUpper);\n        auto sm = ext.count!(x => x.isLower);\n        auto new_strength\
    \ = cap - sm;\n        if(new_strength > strength)\n        {\n            strength\
    \ = new_strength;\n            strongest = ext;\n        }\n    }\n    return\
    \ class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw9ej5sp6.d(28): Error: no property `count` for type `string`

    /tmp/tmpw9ej5sp6.d(29): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw9ej5sp6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    string strongest_extension = \"\";\n    double\
    \ strongest_extension_strength = 0;\n    foreach(string extension; extensions)\n\
    \    {\n        double extension_strength = 0;\n        foreach(char c; extension)\n\
    \        {\n            if(c.isUpper)\n                extension_strength++;\n\
    \            else if(c.isLower)\n                extension_strength--;\n     \
    \   }\n        if(extension_strength > strongest_extension_strength)\n       \
    \ {\n            strongest_extension_strength = extension_strength;\n        \
    \    strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpelugxwxk.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpelugxwxk.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpelugxwxk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    float max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        float strength =\
    \ 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > max_strength)\n        {\n   \
    \         max_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi95ls__n.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpi95ls__n.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi95ls__n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    auto strongest = extensions[0];\n    int strongest_strength\
    \ = 0;\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > strongest_strength)\n        {\n            strongest\
    \ = extension;\n            strongest_strength = strength;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest;\n}\nunittest\n{\n    alias candidate\
    \ = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\"\
    , [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa7npgl1q.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa7npgl1q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else if(c.isLower)\n               \
    \ strength--;\n        }\n        if(strength > max_strength)\n        {\n   \
    \         max_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n\
    {\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\"\
    , [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy1sximgp.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpy1sximgp.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy1sximgp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max = 0;\n    string result = \"\";\n    foreach(string\
    \ ext; extensions)\n    {\n        int cap = 0;\n        int sm = 0;\n       \
    \ foreach(char c; ext)\n        {\n            if(c.isUpper)\n               \
    \ cap++;\n            else\n                sm++;\n        }\n        int strength\
    \ = cap - sm;\n        if(strength > max)\n        {\n            max = strength;\n\
    \            result = class_name ~ \".\" ~ ext;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\n    assert(candidate(\"\
    Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n  \
    \  assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"__YESIMHERE\", [\"t\",\
    \ \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\"\
    );\n    assert(candidate(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"\
    K.TAR\");\n    assert(candidate(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"\
    -_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"YameRore\", [\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\");\n\
    \    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"])\
    \ == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"Bb\", \"91245\"]) ==\
    \ \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"Bb\"]) == \"Sp.671235\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps2nvkb_a.d(32): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps2nvkb_a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(char c; extension)\n        {\n            if(c.isUpper)\n  \
    \              strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv6nxeim3.d(31): Error: no property `isUpper` for type `char`

    /tmp/tmpv6nxeim3.d(33): Error: no property `isLower` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv6nxeim3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else if(c.isLower)\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpviy8bsak.d(31): Error: no property `isUpper` for type `immutable(char)`

    /tmp/tmpviy8bsak.d(33): Error: no property `isLower` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpviy8bsak.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = -1;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprmv0kwif.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprmv0kwif.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpagen7z9s.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpagen7z9s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int[] strengths = extensions.map!(ext => ext.count!(c\
    \ => c.isUpper) - ext.count!(c => c.isLower));\n    int max_strength = strengths.max;\n\
    \    int max_index = strengths.indexOf(max_strength);\n    return class_name ~\
    \ \".\" ~ extensions[max_index];\n}\nunittest\n{\n    alias candidate = Strongest_Extension;\n\
    \n    assert(candidate(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"\
    Watashi.eIGHt8OKe\");\n    assert(candidate(\"Boku123\", [\"nani\", \"NazeDa\"\
    , \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\");\n    assert(candidate(\"\
    __YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"K\", [\"Ta\", \"TAR\",\
    \ \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"__HAHA\", [\"\
    Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi9o97dtd.d(24): Error: no property `map` for type `string[]`

    /tmp/tmpi9o97dtd.d(25): Error: no property `max` for type `int[]`

    /tmp/tmpi9o97dtd.d(26): Error: no property `indexOf` for type `int[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi9o97dtd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(extension; extensions)\n    {\n        int strength = 0;\n\
    \        foreach(c; extension)\n        {\n            if(c.isUpper)\n       \
    \         strength++;\n            else\n                strength--;\n       \
    \ }\n        if(strength > max_strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg20ze2mv.d(31): Error: no property `isUpper` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg20ze2mv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164227
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nYou will be given the name\
    \ of a class (a string) and a list of extensions.\n    The extensions are to be\
    \ used to load additional classes to the class. The\n    strength of the extension\
    \ is as follows: Let CAP be the number of the uppercase\n    letters in the extension's\
    \ name, and let SM be the number of lowercase letters \n    in the extension's\
    \ name, the strength is given by the fraction CAP - SM. \n    You should find\
    \ the strongest extension and return a string in this \n    format: ClassName.StrongestExtensionName.\n\
    \    If there are two or more extensions with the same strength, you should\n\
    \    choose the one that comes first in the list.\n    For example, if you are\
    \ given \"Slices\" as the class and a list of the\n    extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    (its strength is -1).\n   \
    \ Example:\n    >>> Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"\
    ])\n    \"my_class.AA\"\n    \n*/\nstring Strongest_Extension(string class_name,\
    \ string[] extensions) \n{\n    int max_strength = 0;\n    string strongest_extension\
    \ = \"\";\n    foreach(string extension; extensions)\n    {\n        int strength\
    \ = 0;\n        foreach(char c; extension)\n        {\n            if(c.isUpper)\n\
    \                strength++;\n            else\n                strength--;\n\
    \        }\n        if(max_strength < strength)\n        {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name ~ \".\" ~ strongest_extension;\n}\nunittest\n{\n    alias\
    \ candidate = Strongest_Extension;\n\n    assert(candidate(\"Watashi\", [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\");\n    assert(candidate(\"\
    Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\"\
    );\n    assert(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\"\
    , \"NuLl__\", \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\");\n    assert(candidate(\"\
    K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\");\n    assert(candidate(\"\
    __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\");\n    assert(candidate(\"\
    YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"\
    YameRore.okIWILL123\");\n    assert(candidate(\"finNNalLLly\", [\"Die\", \"NowW\"\
    , \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\");\n    assert(candidate(\"_\", [\"\
    Bb\", \"91245\"]) == \"_.Bb\");\n    assert(candidate(\"Sp\", [\"671235\", \"\
    Bb\"]) == \"Sp.671235\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpabogl9d2.d(31): Error: no property `isUpper` for type `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpabogl9d2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164228
