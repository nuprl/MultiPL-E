language: d
name: HumanEval_58_common
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (elem; l1) \n    {\n        if (elem\
    \ in l2) \n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1,\
    \ 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\nunittest\n{\n   \
    \ alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaxldzzhn.d(24): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaxldzzhn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) {\n        if (l2.canFind(l))\
    \ {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppyioi7ms.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmppyioi7ms.d(16): Error: no property `canFind` for type `long[]`

    /tmp/tmppyioi7ms.d(20): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppyioi7ms.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1iig2_rv.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp1iig2_rv.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp1iig2_rv.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1iig2_rv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    long[] l1_sorted = sort(l1);\n \
    \   long[] l2_sorted = sort(l2);\n    long i = 0L;\n    long j = 0L;\n    while\
    \ (i < l1_sorted.length && j < l2_sorted.length)\n    {\n        if (l1_sorted[i]\
    \ == l2_sorted[j])\n        {\n            result = result ~ l1_sorted[i];\n \
    \           i++;\n            j++;\n        }\n        else if (l1_sorted[i] <\
    \ l2_sorted[j])\n        {\n            i++;\n        }\n        else\n      \
    \  {\n            j++;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp34yfslof.d(15): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmp34yfslof.d(16): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp34yfslof.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result;\n}\n\
    /*\nReturn sorted unique common elements for two lists.\n    >>> common([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n\
    \    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5y5dvtub.d(24): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5y5dvtub.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n   \
    \     foreach (long j; l2)\n        {\n            if (i == j)\n            {\n\
    \                result ~= i;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptyo1ejy_.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptyo1ejy_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if\
    \ (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0urg98q2.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0urg98q2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp0urg98q2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0urg98q2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; sort(l1))\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd2s99kp_.d(15): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd2s99kp_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_copy = l1.dup;\n    long[] l2_copy =\
    \ l2.dup;\n    l1_copy.sort;\n    l2_copy.sort;\n    foreach(long i; l1_copy)\n\
    \    {\n        if(l2_copy.canFind(i))\n        {\n            result ~= i;\n\
    \        }\n    }\n    return result.dup.sort.uniq;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp473d4p6k.d(17): Error: no property `sort` for type `long[]`

    /tmp/tmp473d4p6k.d(18): Error: no property `sort` for type `long[]`

    /tmp/tmp473d4p6k.d(21): Error: no property `canFind` for type `long[]`

    /tmp/tmp473d4p6k.d(26): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp473d4p6k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    long[] l1_unique_sorted = l1_unique.sort;\n    long[]\
    \ l2_unique_sorted = l2_unique.sort;\n    long[] l1_unique_sorted_set = l1_unique_sorted.toSet.array;\n\
    \    long[] l2_unique_sorted_set = l2_unique_sorted.toSet.array;\n    long[] l1_unique_sorted_set_sorted\
    \ = l1_unique_sorted_set.sort;\n    long[] l2_unique_sorted_set_sorted = l2_unique_sorted_set.sort;\n\
    \    long[] l1_unique_sorted_set_sorted_unique = l1_unique_sorted_set_sorted.unique;\n\
    \    long[] l2_unique_sorted_set_sorted_unique = l2_unique_sorted_set_sorted.unique;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted = l1_unique_sorted_set_sorted_unique.sort;\n\
    \    long[] l2_unique_sorted_set_sorted_unique_sorted = l2_unique_sorted_set_sorted_unique.sort;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted_set = l1_unique_sorted_set_sorted_unique_sorted.toSet.array;\n\
    \    long[] l2_unique_sorted_set_sorted_unique_sorted_set = l2_unique_sorted_set_sorted_unique_sorted.toSet.array;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted_set_sorted = l1_unique_sorted_set_sorted_unique_sorted\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppbl6a7_f.d(32): Error: semicolon expected, not `unittest`

    /tmp/tmppbl6a7_f.d(32): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppbl6a7_f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = [];\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            res ~= e;\n        }\n    }\n    return res.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi02sozvf.d(17): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmpi02sozvf.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi02sozvf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (elem; l1) \n    {\n        if (elem\
    \ in l2) \n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplnsnyyde.d(17): Error: incompatible types for `(elem) in (l2)`:
    `long` and `long[]`

    /tmp/tmplnsnyyde.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplnsnyyde.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphv5swjq2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmphv5swjq2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphv5swjq2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{ \n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5itl9ezn.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp5itl9ezn.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5itl9ezn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (e1; l1) \n    {\n       \
    \ foreach (e2; l2) \n        {\n            if (e1 == e2) \n            {\n  \
    \              result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwi_20pnp.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpwi_20pnp.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwi_20pnp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    return l1.intersect(l2).sort().uniq;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdef5wsmi.d(16): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdef5wsmi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwoohvyf2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmpwoohvyf2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwoohvyf2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    if (l1.length == 0 || l2.length ==\
    \ 0)\n        return result;\n    long[] l1s = l1.dup.sort;\n    long[] l2s =\
    \ l2.dup.sort;\n    long[] l1u = l1s.dup.uniq;\n    long[] l2u = l2s.dup.uniq;\n\
    \    long[] l1l = l1u.dup.length;\n    long[] l2l = l2u.dup.length;\n    long[]\
    \ l1i = l1u.dup.indices;\n    long[] l2i = l2u.dup.indices;\n    long[] l1f =\
    \ l1u.dup.front;\n    long[] l2f = l2u.dup.front;\n    long[] l1b = l1u.dup.back;\n\
    \    long[] l2b = l2u.dup.back;\n    long[] l1m = l1u.dup.mid;\n    long[] l2m\
    \ = l2u.dup.mid;\n    long[] l1e = l1u.dup.empty;\n    long[] l2e = l2u.dup.empty;\n\
    \    long[] l1r = l1u.dup.retro;\n    long[] l2r = l2u.dup.retro;\n    long[]\
    \ l1d = l1u.dup.dup;\n    long[] l2d = l2u.dup.dup;\n    long[] l1c = l1u.dup.idup;\n\
    \    long[] l2c = l2u.dup.idup;\n    long[] l1t = l1u.dup.take;\n    long[] l2t\
    \ = l2u.dup.take;\n    long[] l1g = l1u.dup.takeExactly;\n    long[] l2g = l2u.dup.takeExactly;\n\
    \    long[] l1o = l1u.dup.takeExactly;\n    long[] l2\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp51cphezs.d(45): Error: semicolon expected, not `unittest`

    /tmp/tmp51cphezs.d(45): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp51cphezs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    return l1.filter!(a => l2.canFind(a)).sort().uniq;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj3zv6z_t.d(14): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj3zv6z_t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto s1 = l1.sort().uniq;\n    auto s2 = l2.sort().uniq;\n    long[]\
    \ result;\n    foreach(i; s1)\n    {\n        if(s2.canFind(i))\n        {\n \
    \           result ~= i;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptji7rd50.d(14): Error: no property `sort` for type `long[]`

    /tmp/tmptji7rd50.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptji7rd50.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l in\
    \ l2) \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv36u9mwz.d(17): Error: incompatible types for `(l) in (l2)`: `long`
    and `long[]`

    /tmp/tmpv36u9mwz.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv36u9mwz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1iig2_rv.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp1iig2_rv.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp1iig2_rv.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1iig2_rv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwoohvyf2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmpwoohvyf2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwoohvyf2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.count(l)\
    \ > 0)\n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxnaq3en2.d(17): Error: no property `count` for type `long[]`

    /tmp/tmpxnaq3en2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxnaq3en2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    long[] l1_sorted = sort(l1);\n  \
    \  long[] l2_sorted = sort(l2);\n    long[] l1_unique = unique(l1_sorted);\n \
    \   long[] l2_unique = unique(l2_sorted);\n    long[] l1_unique_sorted = sort(l1_unique);\n\
    \    long[] l2_unique_sorted = sort(l2_unique);\n    long[] l1_unique_sorted_reversed\
    \ = reverse(l1_unique_sorted);\n    long[] l2_unique_sorted_reversed = reverse(l2_unique_sorted);\n\
    \    long[] l1_unique_sorted_reversed_unique = unique(l1_unique_sorted_reversed);\n\
    \    long[] l2_unique_sorted_reversed_unique = unique(l2_unique_sorted_reversed);\n\
    \    long[] l1_unique_sorted_reversed_unique_sorted = sort(l1_unique_sorted_reversed_unique);\n\
    \    long[] l2_unique_sorted_reversed_unique_sorted = sort(l2_unique_sorted_reversed_unique);\n\
    \    long[] l1_unique_sorted_reversed_unique_sorted_reversed = reverse(l1_unique_sorted_reversed_unique_sorted);\n\
    \    long[] l2_unique_sorted_reversed_unique_sorted_reversed = reverse(l2_unique_sorted_reversed_unique_sorted);\n\
    \    long[] l1_unique_sorted_reversed_unique_sorted_reversed_unique = unique(l1_unique_sorted_reversed_unique_sorted_reversed);\n\
    \    long[] l2_unique_sorted_reversed_unique_sorted_reversed_unique = unique(l2_unique_sorted_reversed_unique_sorted_reversed);\n\
    \    long[] l1_unique_sorted_reversed_unique_s\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeskl9ewg.d(32): Error: semicolon expected, not `unittest`

    /tmp/tmpeskl9ewg.d(32): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeskl9ewg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n        foreach\
    \ (e2; l2)\n        {\n            if (e1 == e2)\n            {\n            \
    \    result ~= e1;\n            }\n        }\n    }\n    return result.sort().unique;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpthb3lpzx.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpthb3lpzx.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpthb3lpzx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n        foreach (e2;\
    \ l2)\n        {\n            if (e1 == e2)\n            {\n                result\
    \ ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa0ll7l8x.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa0ll7l8x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (long i; l1) \n    {\n  \
    \      if (l2.canFind(i)) \n        {\n            result ~= i;\n        }\n \
    \   }\n    return result.sort().dup.unique;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptokbqm3b.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmptokbqm3b.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptokbqm3b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n   \
    \     if (l2.canFind(i))\n        {\n            result ~= i;\n        }\n   \
    \ }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfb1zljaf.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmpfb1zljaf.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfb1zljaf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements of two lists.\n    >>> unique([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L,\
    \ 5L, 653L, 7L, 9L, 121L, 34L]\n    >>> unique([5L, 3L, 2L, 8L], [3L, 2L])\n \
    \   [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[] l1, long[] l2) \n{\n    long[]\
    \ result = [];\n    foreach (l; l1)\n    {\n        result ~= l;\n    }\n    foreach\
    \ (l; l2)\n    {\n        result ~= l;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements of two lists.\n    >>> unique([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L,\
    \ 5L, 653L, 7L, 9L, 121L, 34L]\n    >>> unique([5L, 3L, 2L, 8L], [3L, 2L])\n \
    \   [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[] l1, long[] l2) \n{\n    long[]\
    \ result = [];\n    foreach (l; l1)\n    {\n        result ~= l;\n    }\n    foreach\
    \ (l; l2)\n    {\n        result ~= l;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements of two lists.\n\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq2rt7g9y.d(64): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq2rt7g9y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            res ~= l;\n        }\n    }\n    return res.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp__tgwz8l.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp__tgwz8l.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp__tgwz8l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ret = new long[0];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            ret ~= l;\n        }\n    }\n    ret = ret.sort().uniq;\n\
    \    return ret;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf90zh65n.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmpf90zh65n.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf90zh65n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphv5swjq2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmphv5swjq2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphv5swjq2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            if (!result.canFind(l))\n          \
    \  {\n                result ~= l;\n            }\n        }\n    }\n    return\
    \ result;\n}\n/*\nReturn sorted unique elements for two lists.\n    >>> unique([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L,\
    \ 3L, 4L, 5L, 7L, 9L, 34L, 121L, 653L]\n    >>> unique([5L, 3L, 2L, 8L], [3L,\
    \ 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[] l1, long[] l2) \n{\n  \
    \  long[] result = new long[];\n    foreach (l; l1)\n    {\n        if (!result.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    foreach (l; l2)\n\
    \    {\n        if (!result.canFind(l))\n        {\n            result ~= l;\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements for\
    \ two lists.\n    >>> unique([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L,\
    \ 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L, 5L, 7L, 9L, 34L, 121L, 653L]\n    >>>\
    \ unique([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n \
    \   {\n        if (!result.can\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpovofl8yo.d(66): Error: found `unittest` when expecting `)`

    /tmp/tmpovofl8yo.d(75): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpovofl8yo.d(75): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpovofl8yo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    foreach(l; l1_unique)\n    {\n        if(l2_unique.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5lw_gec0.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmp5lw_gec0.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmp5lw_gec0.d(17): Error: no property `unique` for type `long[]`

    /tmp/tmp5lw_gec0.d(18): Error: no property `unique` for type `long[]`

    /tmp/tmp5lw_gec0.d(21): Error: no property `canFind` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5lw_gec0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1) \n    {\n       \
    \ if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort.uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx1veaw1_.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmpx1veaw1_.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx1veaw1_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            if (!result.canFind(l))\n          \
    \  {\n                result ~= l;\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1zmbe4n0.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp1zmbe4n0.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp1zmbe4n0.d(19): Error: no property `canFind` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1zmbe4n0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    return l1.filter!(x => l2.canFind(x)).sort().uniq;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphgm7up19.d(14): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphgm7up19.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1iig2_rv.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp1iig2_rv.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp1iig2_rv.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1iig2_rv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().dup.unique;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe9fvi4r_.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpe9fvi4r_.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmpe9fvi4r_.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe9fvi4r_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (long l; l1) \n    {\n  \
    \      if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n \
    \   }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnx_s8s8u.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmpnx_s8s8u.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnx_s8s8u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto s1 = set(l1);\n    auto s2 = set(l2);\n    return s1.intersection(s2).array;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr59hlzt8.d(14): Error: undefined identifier `set`, did you mean
    template `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?

    /tmp/tmpr59hlzt8.d(15): Error: undefined identifier `set`, did you mean template
    `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr59hlzt8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if\
    \ (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0urg98q2.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0urg98q2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp0urg98q2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0urg98q2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            res ~= l;\n        }\n    }\n    return res.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp__tgwz8l.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp__tgwz8l.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp__tgwz8l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1iig2_rv.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp1iig2_rv.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp1iig2_rv.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1iig2_rv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1iig2_rv.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp1iig2_rv.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp1iig2_rv.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1iig2_rv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto l1_set = set(l1);\n    auto l2_set = set(l2);\n    auto common_set\
    \ = l1_set & l2_set;\n    return common_set.array;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe8rzv0ef.d(14): Error: undefined identifier `set`, did you mean
    template `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?

    /tmp/tmpe8rzv0ef.d(15): Error: undefined identifier `set`, did you mean template
    `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe8rzv0ef.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1) \n    {\n       \
    \ if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5t5gdwrh.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp5t5gdwrh.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5t5gdwrh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = new long[l1.length + l2.length];\n    long[] l4 = new long[l1.length\
    \ + l2.length];\n    long[] l5 = new long[l1.length + l2.length];\n    long[]\
    \ l6 = new long[l1.length + l2.length];\n    long[] l7 = new long[l1.length +\
    \ l2.length];\n    long[] l8 = new long[l1.length + l2.length];\n    long[] l9\
    \ = new long[l1.length + l2.length];\n    long[] l10 = new long[l1.length + l2.length];\n\
    \    long[] l11 = new long[l1.length + l2.length];\n    long[] l12 = new long[l1.length\
    \ + l2.length];\n    long[] l13 = new long[l1.length + l2.length];\n    long[]\
    \ l14 = new long[l1.length + l2.length];\n    long[] l15 = new long[l1.length\
    \ + l2.length];\n    long[] l16 = new long[l1.length + l2.length];\n    long[]\
    \ l17 = new long[l1.length + l2.length];\n    long[] l18 = new long[l1.length\
    \ + l2.length];\n    long[] l19 = new long[l1.length + l2.length];\n    long[]\
    \ l20 = new long[l1.length + l2.length];\n    long[] l21 = new long[l1.length\
    \ + l2.length];\n    long[] l22 = new long[l1.length + l2.length];\n    long[]\
    \ l23 = new long[l1.length + l2.length];\n    long[] l24 = new long[l1.length\
    \ + l2.length];\n    long[] l25 = new long[l1.length + l2.length];\n    long[]\
    \ l26 = new long[l1.length + l2.length];\n    long[] l27 = new long[l1.length\
    \ + l2.length];\n    long[] l28 = new long[\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp91kz2pyb.d(40): Error: expression expected, not `unittest`

    /tmp/tmp91kz2pyb.d(41): Error: found `{` when expecting `]`

    /tmp/tmp91kz2pyb.d(42): Error: semicolon expected, not `alias`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp91kz2pyb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ret = new long[0];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            ret ~= l;\n        }\n    }\n    return ret.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeea3r484.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmpeea3r484.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeea3r484.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphv5swjq2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmphv5swjq2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphv5swjq2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_unique;\n    long[] l2_unique;\n    long[]\
    \ l1_sorted;\n    long[] l2_sorted;\n    long[] l1_sorted_unique;\n    long[]\
    \ l2_sorted_unique;\n    long[] l1_sorted_unique_common;\n    long[] l2_sorted_unique_common;\n\
    \    long[] l1_sorted_unique_common_sorted;\n    long[] l2_sorted_unique_common_sorted;\n\
    \    long[] l1_sorted_unique_common_sorted_unique;\n    long[] l2_sorted_unique_common_sorted_unique;\n\
    \    long[] l1_sorted_unique_common_sorted_unique_common;\n    long[] l2_sorted_unique_common_sorted_unique_common;\n\
    \    long[] l1_sorted_unique_common_sorted_unique_common_sorted;\n    long[] l2_sorted_unique_common_sorted_unique_common_sorted;\n\
    \    long[] l1_sorted_unique_common_sorted_unique_common_sorted_unique;\n    long[]\
    \ l2_sorted_unique_common_sorted_unique_common_sorted_unique;\n    long[] l1_sorted_unique_common_sorted_unique_common_sorted_unique_common;\n\
    \    long[] l2_sorted_unique_common_sorted_unique_common_sorted_unique_common;\n\
    \    long[] l1_sorted_unique_common_sorted_unique_common_sorted_unique_common_sorted;\n\
    \    long[] l2_sorted_unique_common_sorted_unique_common_sorted_unique_common_sorted;\n\
    \    long[] l1_sorted_unique_common_sorted_unique_common_sorted_unique_common_sorted_unique;\n\
    \    long[] l2_sorted_unique_common_sorted_unique_common_sorted_unique_common_sorted_unique;\n\
    \    long[] l1_sorted_unique_common_sorted\nunittest\n{\n    alias candidate =\
    \ common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L,\
    \ 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L,\
    \ 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwm679ab7.d(40): Error: semicolon expected, not `unittest`

    /tmp/tmpwm679ab7.d(40): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwm679ab7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    foreach (e; l1)\n    {\n       \
    \ if (e in l2)\n        {\n            result ~= e;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc8wgzmiu.d(17): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmpc8wgzmiu.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc8wgzmiu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if\
    \ (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0urg98q2.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0urg98q2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp0urg98q2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0urg98q2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1iig2_rv.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp1iig2_rv.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp1iig2_rv.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1iig2_rv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (e1; l1) \n    {\n        foreach\
    \ (e2; l2) \n        {\n            if (e1 == e2) \n            {\n          \
    \      result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw5ag3wkq.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw5ag3wkq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_sorted = sort(l1);\n    long[] l2_sorted\
    \ = sort(l2);\n    long[] l1_unique = uniq(l1_sorted);\n    long[] l2_unique =\
    \ uniq(l2_sorted);\n    foreach(l1_u; l1_unique)\n    {\n        foreach(l2_u;\
    \ l2_unique)\n        {\n            if(l1_u == l2_u)\n            {\n       \
    \         result ~= l1_u;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1i7zmqd_.d(15): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmp1i7zmqd_.d(16): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmp1i7zmqd_.d(17): Error: undefined identifier `uniq`

    /tmp/tmp1i7zmqd_.d(18): Error: undefined identifier `uniq`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1i7zmqd_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = new long[l1.length];\n    int j = 0;\n    foreach(l; l1)\n\
    \    {\n        foreach(l2; l2)\n        {\n            if(l == l2)\n        \
    \    {\n                l3[j] = l;\n                j++;\n            }\n    \
    \    }\n    }\n    return l3;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp755ysxbd.d(18): Error: variable `l2` is shadowing variable `tmp755ysxbd.common.l2`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp755ysxbd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    if (l1.length == 0 || l2.length ==\
    \ 0)\n    {\n        return result;\n    }\n    long[] l1_sorted = l1.dup.sort;\n\
    \    long[] l2_sorted = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n\
    \    long[] l2_unique = l2_sorted.unique;\n    foreach (l1_elem; l1_unique)\n\
    \    {\n        foreach (l2_elem; l2_unique)\n        {\n            if (l1_elem\
    \ == l2_elem)\n            {\n                result ~= l1_elem;\n           \
    \ }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp69e8h0fi.d(19): Error: no property `sort` for type `long[]`

    /tmp/tmp69e8h0fi.d(20): Error: no property `sort` for type `long[]`

    /tmp/tmp69e8h0fi.d(21): Error: no property `unique` for type `long[]`

    /tmp/tmp69e8h0fi.d(22): Error: no property `unique` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp69e8h0fi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto l1_set = l1.sort().uniq;\n    auto l2_set = l2.sort().uniq;\n\
    \    auto result = new long[](max(l1_set.length, l2_set.length));\n    auto result_len\
    \ = 0;\n    foreach (i, e; l1_set) {\n        if (l2_set.canFind(e)) {\n     \
    \       result[result_len] = e;\n            result_len++;\n        }\n    }\n\
    \    return result[0..result_len];\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkf0eef6g.d(14): Error: no property `sort` for type `long[]`

    /tmp/tmpkf0eef6g.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmpkf0eef6g.d(16): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkf0eef6g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    foreach(l1_u; l1_unique)\n    {\n        foreach(l2_u;\
    \ l2_unique)\n        {\n            if(l1_u == l2_u)\n            {\n       \
    \         result ~= l1_u;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbv3chj1f.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmpbv3chj1f.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmpbv3chj1f.d(17): Error: no property `unique` for type `long[]`

    /tmp/tmpbv3chj1f.d(18): Error: no property `unique` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbv3chj1f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = new long[l1.length + l2.length];\n    long[] l4 = new long[l1.length\
    \ + l2.length];\n    long[] l5 = new long[l1.length + l2.length];\n    long[]\
    \ l6 = new long[l1.length + l2.length];\n    long[] l7 = new long[l1.length +\
    \ l2.length];\n    long[] l8 = new long[l1.length + l2.length];\n    long[] l9\
    \ = new long[l1.length + l2.length];\n    long[] l10 = new long[l1.length + l2.length];\n\
    \    long[] l11 = new long[l1.length + l2.length];\n    long[] l12 = new long[l1.length\
    \ + l2.length];\n    long[] l13 = new long[l1.length + l2.length];\n    long[]\
    \ l14 = new long[l1.length + l2.length];\n    long[] l15 = new long[l1.length\
    \ + l2.length];\n    long[] l16 = new long[l1.length + l2.length];\n    long[]\
    \ l17 = new long[l1.length + l2.length];\n    long[] l18 = new long[l1.length\
    \ + l2.length];\n    long[] l19 = new long[l1.length + l2.length];\n    long[]\
    \ l20 = new long[l1.length + l2.length];\n    long[] l21 = new long[l1.length\
    \ + l2.length];\n    long[] l22 = new long[l1.length + l2.length];\n    long[]\
    \ l23 = new long[l1.length + l2.length];\n    long[] l24 = new long[l1.length\
    \ + l2.length];\n    long[] l25 = new long[l1.length + l2.length];\n    long[]\
    \ l26 = new long[l1.length + l2.length];\n    long[] l27 = new long[l1.length\
    \ + l2.length];\n    long[] l28 = new long[\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp91kz2pyb.d(40): Error: expression expected, not `unittest`

    /tmp/tmp91kz2pyb.d(41): Error: found `{` when expecting `]`

    /tmp/tmp91kz2pyb.d(42): Error: semicolon expected, not `alias`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp91kz2pyb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto result = new long[](0);\n    auto l1_set = new long[](0);\n  \
    \  auto l2_set = new long[](0);\n    l1_set = l1.dup;\n    l2_set = l2.dup;\n\
    \    l1_set.sort;\n    l2_set.sort;\n    l1_set = l1_set.uniq;\n    l2_set = l2_set.uniq;\n\
    \    foreach(i; 0..l1_set.length)\n    {\n        foreach(j; 0..l2_set.length)\n\
    \        {\n            if(l1_set[i] == l2_set[j])\n            {\n          \
    \      result ~= l1_set[i];\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpszpc70fi.d(19): Error: no property `sort` for type `long[]`

    /tmp/tmpszpc70fi.d(20): Error: no property `sort` for type `long[]`

    /tmp/tmpszpc70fi.d(21): Error: no property `uniq` for type `long[]`

    /tmp/tmpszpc70fi.d(22): Error: no property `uniq` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpszpc70fi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            if (!result.canFind(l))\n          \
    \  {\n                result ~= l;\n            }\n        }\n    }\n    return\
    \ result;\n}\n/*\nReturn sorted unique common elements for two lists.\n    >>>\
    \ common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaitkveld.d(27): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaitkveld.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            if (!result.canFind(l))\n          \
    \  {\n                result ~= l;\n            }\n        }\n    }\n    return\
    \ result;\n}\n/*\nReturn sorted unique common elements for two lists.\n    >>>\
    \ common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaitkveld.d(27): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaitkveld.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1iig2_rv.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp1iig2_rv.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp1iig2_rv.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1iig2_rv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto s1 = l1.sort().unique;\n    auto s2 = l2.sort().unique;\n    long[]\
    \ result;\n    foreach(e; s1)\n    {\n        if(s2.canFind(e))\n        {\n \
    \           result ~= e;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0ztj_j86.d(14): Error: no property `sort` for type `long[]`

    /tmp/tmp0ztj_j86.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ztj_j86.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (elem; l1) \n    {\n    \
    \    if (elem in l2) \n        {\n            result ~= elem;\n        }\n   \
    \ }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpww_ayvy6.d(17): Error: incompatible types for `(elem) in (l2)`:
    `long` and `long[]`

    /tmp/tmpww_ayvy6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpww_ayvy6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1iig2_rv.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp1iig2_rv.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp1iig2_rv.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1iig2_rv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    return l1.filter!(x => l2.canFind(x)).sort().uniq;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphgm7up19.d(14): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphgm7up19.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            if (!result.canFind(l)) \n            {\n         \
    \       result ~= l;\n            }\n        }\n    }\n    return result.sort();\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplfwwi42t.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmplfwwi42t.d(19): Error: no property `canFind` for type `long[]`

    /tmp/tmplfwwi42t.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplfwwi42t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            res ~= l;\n        }\n    }\n    return res.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp__tgwz8l.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp__tgwz8l.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp__tgwz8l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphv5swjq2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmphv5swjq2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphv5swjq2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto s1 = l1.sort().unique;\n    auto s2 = l2.sort().unique;\n    long[]\
    \ result;\n    foreach(e; s1)\n    {\n        if(s2.canFind(e))\n        {\n \
    \           result ~= e;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0ztj_j86.d(14): Error: no property `sort` for type `long[]`

    /tmp/tmp0ztj_j86.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ztj_j86.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) {\n        if (l2.canFind(l))\
    \ {\n            result ~= l;\n        }\n    }\n    return result.sort.uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiteizur1.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpiteizur1.d(16): Error: no property `canFind` for type `long[]`

    /tmp/tmpiteizur1.d(20): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiteizur1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_unique = l1.unique;\n    long[] l2_unique\
    \ = l2.unique;\n    foreach(l; l1_unique)\n    {\n        if(l2_unique.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpki0zbcas.d(15): Error: no property `unique` for type `long[]`

    /tmp/tmpki0zbcas.d(16): Error: no property `unique` for type `long[]`

    /tmp/tmpki0zbcas.d(19): Error: no property `canFind` for type `long[]`

    /tmp/tmpki0zbcas.d(24): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpki0zbcas.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\n/*\nReturn sorted unique elements for two lists.\n\
    \    >>> unique([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 2L, 3L, 4L, 5L, 653L, 7L, 9L, 121L, 34L]\n    >>> unique([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        result\
    \ ~= l;\n    }\n    foreach (l; l2)\n    {\n        result ~= l;\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique elements for two lists.\n \
    \   >>> unique([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 2L, 3L, 4L, 5L, 653L, 7L, 9L, 121L, 34L]\n    >>> unique([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        result\
    \ ~= l;\n    }\n    foreach (l; l2)\n    {\n        result ~= l;\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\n\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3brfxuvp.d(64): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3brfxuvp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto s1 = l1.sort().unique;\n    auto s2 = l2.sort().unique;\n    long[]\
    \ res;\n    foreach(e; s1)\n    {\n        if(s2.canFind(e))\n        {\n    \
    \        res ~= e;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbgrih0is.d(14): Error: no property `sort` for type `long[]`

    /tmp/tmpbgrih0is.d(15): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbgrih0is.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if\
    \ (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0urg98q2.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0urg98q2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp0urg98q2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0urg98q2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    foreach (l; l1)\n    {\n       \
    \ if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_jiopc_i.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp_jiopc_i.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_jiopc_i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    long[] l1_unique = unique(l1);\n\
    \    long[] l2_unique = unique(l2);\n    foreach (l1_item; l1_unique)\n    {\n\
    \        foreach (l2_item; l2_unique)\n        {\n            if (l1_item == l2_item)\n\
    \            {\n                result ~= l1_item;\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps8hy75s3.d(15): Error: undefined identifier `unique`, did you mean
    struct `Unique(T)`?

    /tmp/tmps8hy75s3.d(16): Error: undefined identifier `unique`, did you mean struct
    `Unique(T)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps8hy75s3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphv5swjq2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmphv5swjq2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphv5swjq2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    long[] l1_sorted = sort(l1);\n \
    \   long[] l2_sorted = sort(l2);\n    long i = 0L;\n    long j = 0L;\n    while\
    \ (i < l1_sorted.length && j < l2_sorted.length)\n    {\n        if (l1_sorted[i]\
    \ == l2_sorted[j])\n        {\n            result = result ~ l1_sorted[i];\n \
    \           i++;\n            j++;\n        }\n        else if (l1_sorted[i] <\
    \ l2_sorted[j])\n        {\n            i++;\n        }\n        else\n      \
    \  {\n            j++;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp34yfslof.d(15): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmp34yfslof.d(16): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp34yfslof.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    long[] l1_unique_sorted = l1_unique.sort;\n    long[]\
    \ l2_unique_sorted = l2_unique.sort;\n    long[] l1_unique_sorted_set = l1_unique_sorted.set;\n\
    \    long[] l2_unique_sorted_set = l2_unique_sorted.set;\n    long[] l1_unique_sorted_set_sorted\
    \ = l1_unique_sorted_set.sort;\n    long[] l2_unique_sorted_set_sorted = l2_unique_sorted_set.sort;\n\
    \    long[] l1_unique_sorted_set_sorted_unique = l1_unique_sorted_set_sorted.unique;\n\
    \    long[] l2_unique_sorted_set_sorted_unique = l2_unique_sorted_set_sorted.unique;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted = l1_unique_sorted_set_sorted_unique.sort;\n\
    \    long[] l2_unique_sorted_set_sorted_unique_sorted = l2_unique_sorted_set_sorted_unique.sort;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted_set = l1_unique_sorted_set_sorted_unique_sorted.set;\n\
    \    long[] l2_unique_sorted_set_sorted_unique_sorted_set = l2_unique_sorted_set_sorted_unique_sorted.set;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted_set_sorted = l1_unique_sorted_set_sorted_unique_sorted_set.sort;\n\
    \    long[] l2_\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc9af9w72.d(33): Error: semicolon expected, not `unittest`

    /tmp/tmpc9af9w72.d(33): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc9af9w72.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (long i; l1)\n    {\n        foreach\
    \ (long j; l2)\n        {\n            if (i == j)\n            {\n          \
    \      result ~= i;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptkewug06.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptkewug06.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n        foreach\
    \ (e2; l2)\n        {\n            if (e1 == e2)\n            {\n            \
    \    result ~= e1;\n            }\n        }\n    }\n    return result.sort.uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp28df0bgg.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp28df0bgg.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp28df0bgg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwoohvyf2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmpwoohvyf2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwoohvyf2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if\
    \ (l2.canFind(l)) \n        {\n            if (!result.canFind(l)) \n        \
    \    {\n                result ~= l;\n            }\n        }\n    }\n    return\
    \ result.sort();\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqn8czeee.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpqn8czeee.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmpqn8czeee.d(19): Error: no property `canFind` for type `long[]`

    /tmp/tmpqn8czeee.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqn8czeee.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n        foreach (e2;\
    \ l2)\n        {\n            if (e1 == e2)\n            {\n                result\
    \ ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa0ll7l8x.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa0ll7l8x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    foreach (l; l1)\n    {\n       \
    \ if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_jiopc_i.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp_jiopc_i.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_jiopc_i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1iig2_rv.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp1iig2_rv.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp1iig2_rv.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1iig2_rv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1iig2_rv.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp1iig2_rv.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp1iig2_rv.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1iig2_rv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = l1.dup;\n    l3 ~= l2;\n    l3.sort;\n    l3 = l3.uniq;\n\
    \    return l3;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpekbnk9qa.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmpekbnk9qa.d(17): Error: no property `uniq` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpekbnk9qa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ret = new long[0];\n    long[] l3 = new long[0];\n    long[]\
    \ l4 = new long[0];\n    if (l1.length < l2.length) \n    {\n        l3 = l1;\n\
    \        l4 = l2;\n    }\n    else \n    {\n        l3 = l2;\n        l4 = l1;\n\
    \    }\n    foreach (e; l3) \n    {\n        if (e in l4) \n        {\n      \
    \      ret ~= e;\n        }\n    }\n    ret.sort();\n    return ret;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0aepmv79.d(29): Error: incompatible types for `(e) in (l4)`: `long`
    and `long[]`

    /tmp/tmp0aepmv79.d(34): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0aepmv79.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto r = new long[](0);\n    foreach (e; l1)\n    {\n        if (e\
    \ in l2)\n        {\n            r ~= e;\n        }\n    }\n    return r.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcanen0dt.d(17): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    /tmp/tmpcanen0dt.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcanen0dt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    long[] l1_sorted = sort(l1);\n  \
    \  long[] l2_sorted = sort(l2);\n    int i = 0;\n    int j = 0;\n    while (i\
    \ < l1_sorted.length && j < l2_sorted.length) \n    {\n        if (l1_sorted[i]\
    \ == l2_sorted[j]) \n        {\n            result ~= l1_sorted[i];\n        \
    \    i++;\n            j++;\n        }\n        else if (l1_sorted[i] < l2_sorted[j])\
    \ \n        {\n            i++;\n        }\n        else \n        {\n       \
    \     j++;\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements of two lists.\n    >>> union([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L, 5L, 7L, 9L, 34L, 121L, 653L]\n\
    \    >>> union([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] union(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[0];\n    long[] l1_sorted =\
    \ sort(l1);\n    long[] l2_sorted = sort(l2);\n    int i = 0;\n    int j = 0;\n\
    \    while (i < l1_sorted.length && j < l2_sorted.length) \n    {\n        if\
    \ (l1_sorted[i] == l2_sorted[j]) \n        {\n            result ~= l1_sorted[i];\n\
    \            i++;\n            j++;\n        }\n        else if (l1_sorted[i]\
    \ < l2_sorted[j]) \n        {\n            result ~= l1_s\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjws_zxhv.d(45): Error: no identifier for declarator `long[]`

    /tmp/tmpjws_zxhv.d(45): Error: { } expected following `union` declaration

    /tmp/tmpjws_zxhv.d(45): Error: declaration expected, not `(`

    /tmp/tmpjws_zxhv.d(52): Error: declaration expected, not `while`

    /tmp/tmpjws_zxhv.d(57): Error: no identifier for declarator `i`

    /tmp/tmpjws_zxhv.d(57): Error: declaration expected, not `++`

    /tmp/tmpjws_zxhv.d(58): Error: no identifier for declarator `j`

    /tmp/tmpjws_zxhv.d(58): Error: declaration expected, not `++`

    /tmp/tmpjws_zxhv.d(59): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjws_zxhv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{ \n    return l1.filter!(x => l2.canFind(x)).sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6sc0pgio.d(14): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6sc0pgio.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (long l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjdz7dhk3.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmpjdz7dhk3.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjdz7dhk3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwoohvyf2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmpwoohvyf2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwoohvyf2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n   \
    \     foreach (long j; l2)\n        {\n            if (i == j)\n            {\n\
    \                result ~= i;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptyo1ejy_.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptyo1ejy_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if\
    \ (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0urg98q2.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0urg98q2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp0urg98q2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0urg98q2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    result = new long[l1.length];\n    int i = 0;\n\
    \    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n            result[i]\
    \ = e;\n            i++;\n        }\n    }\n    return result[0..i];\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9y9omqrr.d(19): Error: incompatible types for `(e) in (l2)`: `long`
    and `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9y9omqrr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if\
    \ (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0urg98q2.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0urg98q2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp0urg98q2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0urg98q2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = new long[l1.length];\n    long[] l4 = new long[l2.length];\n\
    \    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n\
    \    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n\
    \    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n\
    \    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int ab =\
    \ 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n    int af = 0;\n   \
    \ int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj = 0;\n    int ak =\
    \ 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n    int ao = 0;\n   \
    \ int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as = 0;\n    int at =\
    \ 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n    int ax = 0;\n   \
    \ int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb = 0;\n    int bc =\
    \ 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n    int bg = 0;\n   \
    \ int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk = 0;\n    int bl =\
    \ 0;\n    int bm = 0;\n    int bn = 0;\n    int bo = 0;\n    int bp = 0;\n   \
    \ int bq = 0;\n    int br = 0;\n    int bs = 0;\n    int bt = 0;\n    int bu =\
    \ 0;\n    int bv =\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9rynvxat.d(82): Error: expression expected, not `unittest`

    /tmp/tmp9rynvxat.d(83): Error: semicolon expected, not `{`

    /tmp/tmp9rynvxat.d(91): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9rynvxat.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n        foreach (e2;\
    \ l2)\n        {\n            if (e1 == e2)\n            {\n                result\
    \ ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa0ll7l8x.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa0ll7l8x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n        foreach\
    \ (e2; l2)\n        {\n            if (e1 == e2)\n            {\n            \
    \    result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8wzt2fnm.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp8wzt2fnm.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8wzt2fnm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n   \
    \     foreach (long j; l2)\n        {\n            if (i == j)\n            {\n\
    \                result ~= i;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptyo1ejy_.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptyo1ejy_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1iig2_rv.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp1iig2_rv.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp1iig2_rv.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1iig2_rv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort();\n    long[] l2_sorted\
    \ = l2.dup.sort();\n    long[] l1_unique = l1_sorted.dup.uniq;\n    long[] l2_unique\
    \ = l2_sorted.dup.uniq;\n    long[] l1_unique_sorted = l1_unique.dup.sort;\n \
    \   long[] l2_unique_sorted = l2_unique.dup.sort;\n    long[] l1_unique_sorted_set\
    \ = l1_unique_sorted.dup.toSet;\n    long[] l2_unique_sorted_set = l2_unique_sorted.dup.toSet;\n\
    \    long[] l1_unique_sorted_set_intersection = l1_unique_sorted_set.dup.intersection(l2_unique_sorted_set);\n\
    \    result = l1_unique_sorted_set_intersection.dup.toArray;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf5qrr5vm.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmpf5qrr5vm.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmpf5qrr5vm.d(17): Error: no property `uniq` for type `long[]`

    /tmp/tmpf5qrr5vm.d(18): Error: no property `uniq` for type `long[]`

    /tmp/tmpf5qrr5vm.d(19): Error: no property `sort` for type `long[]`

    /tmp/tmpf5qrr5vm.d(20): Error: no property `sort` for type `long[]`

    /tmp/tmpf5qrr5vm.d(21): Error: no property `toSet` for type `long[]`

    /tmp/tmpf5qrr5vm.d(22): Error: no property `toSet` for type `long[]`

    /tmp/tmpf5qrr5vm.d(23): Error: no property `intersection` for type `long[]`

    /tmp/tmpf5qrr5vm.d(24): Error: no property `toArray` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf5qrr5vm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\n/*\nReturn sorted unique elements that are in\
    \ either of the lists.\n    >>> union([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L, 5L, 653L, 7L, 9L, 121L, 34L]\n\
    \    >>> union([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] union(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n \
    \   {\n        result ~= l;\n    }\n    foreach (l; l2)\n    {\n        result\
    \ ~= l;\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements\
    \ that are in both lists.\n    >>> intersection([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> intersection([5L,\
    \ 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\n*/\nlong[] intersection(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n     \
    \   if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements that are\
    \ in the first list but not in the second.\n    >>> difference([1L, 4L\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpve7eu4rm.d(31): Error: no identifier for declarator `long[]`

    /tmp/tmpve7eu4rm.d(31): Error: { } expected following `union` declaration

    /tmp/tmpve7eu4rm.d(31): Error: declaration expected, not `(`

    /tmp/tmpve7eu4rm.d(34): Error: declaration expected, not `foreach`

    /tmp/tmpve7eu4rm.d(34): Error: no identifier for declarator `l1`

    /tmp/tmpve7eu4rm.d(34): Error: declaration expected, not `)`

    /tmp/tmpve7eu4rm.d(37): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpve7eu4rm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{ \n    return l1.filter!(x => l2.canFind(x)).sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6sc0pgio.d(14): Error: no property `filter` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6sc0pgio.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto result = new long[](0);\n    foreach (i; l1) \n    {\n       \
    \ if (l2.canFind(i)) \n        {\n            result ~= i;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_ultw7qe.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp_ultw7qe.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ultw7qe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1iig2_rv.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp1iig2_rv.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp1iig2_rv.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1iig2_rv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1iig2_rv.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp1iig2_rv.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp1iig2_rv.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1iig2_rv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    foreach (l; l1) \n    {\n      \
    \  if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp51dtkkiu.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp51dtkkiu.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp51dtkkiu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto result = new long[](max(l1.length, l2.length));\n    size_t i\
    \ = 0;\n    foreach (e1; l1)\n    {\n        foreach (e2; l2)\n        {\n   \
    \         if (e1 == e2)\n            {\n                result[i] = e1;\n    \
    \            i++;\n            }\n        }\n    }\n    return result[0 .. i];\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxbzu9o3h.d(14): Error: undefined identifier `max`, did you mean
    function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxbzu9o3h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    if (l1.length < l2.length) \n    {\n        result\
    \ = common(l2, l1);\n    }\n    else \n    {\n        result = new long[l1.length];\n\
    \        size_t j = 0;\n        foreach (i; l1) \n        {\n            if (l2.canFind(i))\
    \ \n            {\n                result[j] = i;\n                j++;\n    \
    \        }\n        }\n        result = result[0..j];\n    }\n    return result.sort().unique;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgcnudyyg.d(25): Error: no property `canFind` for type `long[]`

    /tmp/tmpgcnudyyg.d(33): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgcnudyyg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{ \n    long[] result = new long[0]; \n    long[] l1_sorted = sort(l1); \n\
    \    long[] l2_sorted = sort(l2); \n    long[] l1_unique = unique(l1_sorted);\
    \ \n    long[] l2_unique = unique(l2_sorted); \n    foreach (long i; l1_unique)\
    \ \n    { \n        foreach (long j; l2_unique) \n        { \n            if (i\
    \ == j) \n            { \n                result ~= i; \n            } \n    \
    \    } \n    } \n    return result; \n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpheb1v7a5.d(15): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpheb1v7a5.d(16): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmpheb1v7a5.d(17): Error: undefined identifier `unique`, did you mean struct
    `Unique(T)`?

    /tmp/tmpheb1v7a5.d(18): Error: undefined identifier `unique`, did you mean struct
    `Unique(T)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpheb1v7a5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    return sort(uniq(l1)).intersect(sort(uniq(l2)));\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_hy2oqfh.d(14): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_hy2oqfh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1iig2_rv.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp1iig2_rv.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp1iig2_rv.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1iig2_rv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwoohvyf2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmpwoohvyf2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwoohvyf2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwoohvyf2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmpwoohvyf2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwoohvyf2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n        if\
    \ (e in l2)\n        {\n            if (e !in result)\n            {\n       \
    \         result ~= e;\n            }\n        }\n    }\n    return result.sort();\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9pbj0pxc.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp9pbj0pxc.d(17): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmp9pbj0pxc.d(19): Error: incompatible types for `(e) in (result)`: `long`
    and `long[]`

    /tmp/tmp9pbj0pxc.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9pbj0pxc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    foreach(l1_elem; l1_unique)\n    {\n        foreach(l2_elem;\
    \ l2_unique)\n        {\n            if(l1_elem == l2_elem)\n            {\n \
    \               result ~= l1_elem;\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoju1tf2m.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmpoju1tf2m.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmpoju1tf2m.d(17): Error: no property `unique` for type `long[]`

    /tmp/tmpoju1tf2m.d(18): Error: no property `unique` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoju1tf2m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[l1.length];\n    int i = 0;\n    foreach(l;\
    \ l1)\n    {\n        if (l2.canFind(l))\n        {\n            result[i] = l;\n\
    \            i++;\n        }\n    }\n    return result[0..i];\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmueqzhyr.d(18): Error: no property `canFind` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmueqzhyr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n        foreach (e2;\
    \ l2)\n        {\n            if (e1 == e2)\n            {\n                result\
    \ ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa0ll7l8x.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa0ll7l8x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ret = [];\n    foreach(e1; l1)\n    {\n        foreach(e2; l2)\n\
    \        {\n            if(e1 == e2)\n            {\n                ret ~= e1;\n\
    \            }\n        }\n    }\n    return ret.sort().uniq;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfk17ms8u.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfk17ms8u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n   \
    \     if (l2.canFind(i))\n        {\n            result ~= i;\n        }\n   \
    \ }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfb1zljaf.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmpfb1zljaf.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfb1zljaf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1iig2_rv.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp1iig2_rv.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp1iig2_rv.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1iig2_rv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (elem; l1)\n    {\n     \
    \   if (elem in l2)\n        {\n            result ~= elem;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkk5yjv50.d(17): Error: incompatible types for `(elem) in (l2)`:
    `long` and `long[]`

    /tmp/tmpkk5yjv50.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkk5yjv50.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = new long[l1.length];\n    int i = 0;\n    foreach(long\
    \ l; l1)\n    {\n        if(l2.find(l) != -1)\n        {\n            l3[i] =\
    \ l;\n            i++;\n        }\n    }\n    l3 = l3[0..i];\n    l3.sort();\n\
    \    return l3.dup.unique;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwfunim15.d(18): Error: no property `find` for type `long[]`

    /tmp/tmpwfunim15.d(25): Error: no property `sort` for type `long[]`

    /tmp/tmpwfunim15.d(26): Error: no property `unique` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwfunim15.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n   \
    \     if (l2.canFind(i))\n        {\n            result ~= i;\n        }\n   \
    \ }\n    return result.sort().dup.unique;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6iuptlis.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp6iuptlis.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6iuptlis.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto s1 = l1.sort();\n    auto s2 = l2.sort();\n    long[] res = new\
    \ long[];\n    foreach(i; 0 .. s1.length)\n    {\n        if(s1[i] == s2[i])\n\
    \        {\n            res ~= s1[i];\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjen27ciy.d(14): Error: no property `sort` for type `long[]`

    /tmp/tmpjen27ciy.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmpjen27ciy.d(16): Error: new can only create structs, dynamic arrays or
    class objects, not `long[]`''s

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjen27ciy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    long[] l1_unique_sorted = l1_unique.sort;\n    long[]\
    \ l2_unique_sorted = l2_unique.sort;\n    long[] l1_unique_sorted_common = l1_unique_sorted.common;\n\
    \    long[] l2_unique_sorted_common = l2_unique_sorted.common;\n    long[] l1_unique_sorted_common_sorted\
    \ = l1_unique_sorted_common.sort;\n    long[] l2_unique_sorted_common_sorted =\
    \ l2_unique_sorted_common.sort;\n    result = l1_unique_sorted_common_sorted.common;\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2yc5b08v.d(15): Error: no property `sort` for type `long[]`

    /tmp/tmp2yc5b08v.d(16): Error: no property `sort` for type `long[]`

    /tmp/tmp2yc5b08v.d(17): Error: no property `unique` for type `long[]`

    /tmp/tmp2yc5b08v.d(18): Error: no property `unique` for type `long[]`

    /tmp/tmp2yc5b08v.d(19): Error: no property `sort` for type `long[]`

    /tmp/tmp2yc5b08v.d(20): Error: no property `sort` for type `long[]`

    /tmp/tmp2yc5b08v.d(21): Error: function `tmp2yc5b08v.common(long[] l1, long[]
    l2)` is not callable using argument types `(long[])`

    /tmp/tmp2yc5b08v.d(22): Error: function `tmp2yc5b08v.common(long[] l1, long[]
    l2)` is not callable using argument types `(long[])`

    /tmp/tmp2yc5b08v.d(23): Error: no property `sort` for type `long[]`

    /tmp/tmp2yc5b08v.d(24): Error: no property `sort` for type `long[]`

    /tmp/tmp2yc5b08v.d(25): Error: function `tmp2yc5b08v.common(long[] l1, long[]
    l2)` is not callable using argument types `(long[])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2yc5b08v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = new long[l1.length];\n    int i = 0;\n    foreach(l; l1)\n\
    \    {\n        foreach(l4; l2)\n        {\n            if(l == l4)\n        \
    \    {\n                l3[i] = l;\n                i++;\n            }\n    \
    \    }\n    }\n    l3 = l3.sort();\n    l3 = l3.uniq;\n    return l3;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv03z_04a.d(27): Error: no property `sort` for type `long[]`

    /tmp/tmpv03z_04a.d(28): Error: no property `uniq` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv03z_04a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    return sort(toSet(l1) & toSet(l2));\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmbih0g04.d(14): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmbih0g04.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    return sort(array(uniq(l1) & uniq(l2)));\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsfdu8r6q.d(14): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsfdu8r6q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = new long[l1.length];\n    int i = 0;\n    foreach(l; l1)\n\
    \    {\n        if(l2.canFind(l))\n        {\n            res[i] = l;\n      \
    \      i++;\n        }\n    }\n    return res[0..i];\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0gtm80_6.d(18): Error: no property `canFind` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0gtm80_6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    long[] l1_sorted = sort(l1);\n  \
    \  long[] l2_sorted = sort(l2);\n    long[] l1_unique = unique(l1_sorted);\n \
    \   long[] l2_unique = unique(l2_sorted);\n    foreach(long i; l1_unique)\n  \
    \  {\n        foreach(long j; l2_unique)\n        {\n            if(i == j)\n\
    \            {\n                result ~= i;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv6lcof3e.d(15): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpv6lcof3e.d(16): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmpv6lcof3e.d(17): Error: undefined identifier `unique`, did you mean struct
    `Unique(T)`?

    /tmp/tmpv6lcof3e.d(18): Error: undefined identifier `unique`, did you mean struct
    `Unique(T)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv6lcof3e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1) \n    {\n       \
    \ if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5t5gdwrh.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp5t5gdwrh.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5t5gdwrh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{ \n    auto l1_set = set(l1);\n    auto l2_set = set(l2);\n    auto l1_set_len\
    \ = l1_set.length;\n    auto l2_set_len = l2_set.length;\n    auto l1_set_max\
    \ = max(l1_set);\n    auto l2_set_max = max(l2_set);\n    auto max_len = max(l1_set_len,\
    \ l2_set_len);\n    auto max_val = max(l1_set_max, l2_set_max);\n    auto result\
    \ = new long[](max_len);\n    auto result_len = 0;\n    foreach (i; 0 .. max_val\
    \ + 1)\n    {\n        if (l1_set.count(i) && l2_set.count(i))\n        {\n  \
    \          result[result_len] = i;\n            result_len++;\n        }\n   \
    \ }\n    return result[0 .. result_len];\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9wbdqeeb.d(14): Error: undefined identifier `set`, did you mean
    template `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?

    /tmp/tmp9wbdqeeb.d(15): Error: undefined identifier `set`, did you mean template
    `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?

    /tmp/tmp9wbdqeeb.d(18): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp9wbdqeeb.d(19): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp9wbdqeeb.d(20): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp9wbdqeeb.d(21): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9wbdqeeb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if\
    \ (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0urg98q2.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0urg98q2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp0urg98q2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0urg98q2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            if (!result.canFind(l))\n          \
    \  {\n                result ~= l;\n            }\n        }\n    }\n    return\
    \ result;\n}\n/*\nReturn sorted unique elements for two lists.\n    >>> unique([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L,\
    \ 3L, 4L, 5L, 653L, 7L, 9L, 121L, 34L]\n    >>> unique([5L, 3L, 2L, 8L], [3L,\
    \ 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[] l1, long[] l2) \n{\n  \
    \  long[] result = new long[];\n    foreach (l; l1)\n    {\n        if (!result.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    foreach (l; l2)\n\
    \    {\n        if (!result.canFind(l))\n        {\n            result ~= l;\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements for\
    \ two lists.\n    >>> unique([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L,\
    \ 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L, 5L, 653L, 7L, 9L, 121L, 34L]\n    >>>\
    \ unique([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n \
    \   {\n        if (!result.can\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvzqbqlf4.d(66): Error: found `unittest` when expecting `)`

    /tmp/tmpvzqbqlf4.d(75): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpvzqbqlf4.d(75): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvzqbqlf4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphv5swjq2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmphv5swjq2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphv5swjq2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto l1_set = set(l1);\n    auto l2_set = set(l2);\n    auto common_set\
    \ = l1_set.intersection(l2_set);\n    return common_set.array;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaqhigugv.d(14): Error: undefined identifier `set`, did you mean
    template `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?

    /tmp/tmpaqhigugv.d(15): Error: undefined identifier `set`, did you mean template
    `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaqhigugv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphv5swjq2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmphv5swjq2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphv5swjq2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto result = new long[](0);\n    auto l1_set = new long[](0);\n  \
    \  auto l2_set = new long[](0);\n    foreach(i; l1)\n    {\n        l1_set ~=\
    \ i;\n    }\n    foreach(i; l2)\n    {\n        l2_set ~= i;\n    }\n    l1_set\
    \ = sort(l1_set);\n    l2_set = sort(l2_set);\n    l1_set = unique(l1_set);\n\
    \    l2_set = unique(l2_set);\n    foreach(i; l1_set)\n    {\n        if(i in\
    \ l2_set)\n        {\n            result ~= i;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmpqjs42t.d(25): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpmpqjs42t.d(26): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmpmpqjs42t.d(27): Error: undefined identifier `unique`, did you mean struct
    `Unique(T)`?

    /tmp/tmpmpqjs42t.d(28): Error: undefined identifier `unique`, did you mean struct
    `Unique(T)`?

    /tmp/tmpmpqjs42t.d(31): Error: incompatible types for `(i) in (l2_set)`: `long`
    and `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmpqjs42t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if\
    \ (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0urg98q2.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp0urg98q2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp0urg98q2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0urg98q2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1iig2_rv.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp1iig2_rv.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp1iig2_rv.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1iig2_rv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n        foreach\
    \ (e2; l2)\n        {\n            if (e1 == e2)\n            {\n            \
    \    result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8wzt2fnm.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp8wzt2fnm.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8wzt2fnm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (elem; l1) \n    {\n        if (elem\
    \ in l2) \n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplnsnyyde.d(17): Error: incompatible types for `(elem) in (l2)`:
    `long` and `long[]`

    /tmp/tmplnsnyyde.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplnsnyyde.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1iig2_rv.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp1iig2_rv.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp1iig2_rv.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1iig2_rv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    long[] l1_sorted = sort(l1);\n \
    \   long[] l2_sorted = sort(l2);\n    long l1_len = l1_sorted.length;\n    long\
    \ l2_len = l2_sorted.length;\n    long i = 0L;\n    long j = 0L;\n    while (i\
    \ < l1_len && j < l2_len)\n    {\n        if (l1_sorted[i] == l2_sorted[j])\n\
    \        {\n            result ~= l1_sorted[i];\n            i++;\n          \
    \  j++;\n        }\n        else if (l1_sorted[i] < l2_sorted[j])\n        {\n\
    \            i++;\n        }\n        else\n        {\n            j++;\n    \
    \    }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements for two\
    \ lists.\n    >>> union([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L,\
    \ 653L, 121L])\n    [1L, 2L, 3L, 4L, 5L, 7L, 9L, 34L, 121L, 653L]\n    >>> union([5L,\
    \ 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] union(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[0L];\n    long[] l1_sorted = sort(l1);\n\
    \    long[] l2_sorted = sort(l2);\n    long l1_len = l1_sorted.length;\n    long\
    \ l2_len = l2_sorted.length;\n    long i = 0L;\n    long j = 0L;\n    while (i\
    \ < l1_len && j < l2_len)\n    {\n        if (l1_sorted[i] == l2_sorted[j])\n\
    \        {\n            result ~= l1\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1r7augwy.d(47): Error: no identifier for declarator `long[]`

    /tmp/tmp1r7augwy.d(47): Error: { } expected following `union` declaration

    /tmp/tmp1r7augwy.d(47): Error: declaration expected, not `(`

    /tmp/tmp1r7augwy.d(56): Error: declaration expected, not `while`

    /tmp/tmp1r7augwy.d(65): Error: declaration expected, not `assert`

    /tmp/tmp1r7augwy.d(66): Error: declaration expected, not `assert`

    /tmp/tmp1r7augwy.d(67): Error: declaration expected, not `assert`

    /tmp/tmp1r7augwy.d(68): Error: declaration expected, not `assert`

    /tmp/tmp1r7augwy.d(69): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1r7augwy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n        if\
    \ (e in l2)\n        {\n            result ~= e;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpko09e7du.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpko09e7du.d(17): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmpko09e7du.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpko09e7du.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n        foreach (e2;\
    \ l2)\n        {\n            if (e1 == e2)\n            {\n                result\
    \ ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa0ll7l8x.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa0ll7l8x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n        foreach (e2;\
    \ l2)\n        {\n            if (e1 == e2)\n            {\n                result\
    \ ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa0ll7l8x.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa0ll7l8x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto l1_set = set(l1);\n    auto l2_set = set(l2);\n    auto common_set\
    \ = l1_set & l2_set;\n    return common_set.array;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe8rzv0ef.d(14): Error: undefined identifier `set`, did you mean
    template `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?

    /tmp/tmpe8rzv0ef.d(15): Error: undefined identifier `set`, did you mean template
    `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe8rzv0ef.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ret = new long[];\n    foreach(e; l1)\n    {\n        if(e in\
    \ l2)\n        {\n            ret ~= e;\n        }\n    }\n    return ret.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeohjmy64.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpeohjmy64.d(17): Error: incompatible types for `(e) in (l2)`: `long` and
    `long[]`

    /tmp/tmpeohjmy64.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeohjmy64.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    return sort(uniq(l1)).filter!(x => l2.canFind(x));\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5pn80onb.d(14): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5pn80onb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            res ~= l;\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyqn_cn25.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpyqn_cn25.d(17): Error: no property `canFind` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyqn_cn25.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = new long[l1.length];\n    int i = 0;\n    foreach(long\
    \ x; l1)\n    {\n        foreach(long y; l2)\n        {\n            if(x == y)\n\
    \            {\n                l3[i] = x;\n                i++;\n           \
    \ }\n        }\n    }\n    l3 = l3[0..i];\n    l3.sort();\n    l3 = l3.dup.uniq;\n\
    \    return l3;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkhl6sl05.d(28): Error: no property `sort` for type `long[]`

    /tmp/tmpkhl6sl05.d(29): Error: no property `uniq` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkhl6sl05.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1iig2_rv.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmp1iig2_rv.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp1iig2_rv.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1iig2_rv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n        foreach (e2;\
    \ l2)\n        {\n            if (e1 == e2)\n            {\n                result\
    \ ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa0ll7l8x.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa0ll7l8x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    long[] l1_unique = unique(l1);\n\
    \    long[] l2_unique = unique(l2);\n    foreach (l1_elem; l1_unique) \n    {\n\
    \        foreach (l2_elem; l2_unique) \n        {\n            if (l1_elem ==\
    \ l2_elem) \n            {\n                result ~= l1_elem;\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv7ijiw53.d(15): Error: undefined identifier `unique`, did you mean
    struct `Unique(T)`?

    /tmp/tmpv7ijiw53.d(16): Error: undefined identifier `unique`, did you mean struct
    `Unique(T)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv7ijiw53.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    long[] l1_sorted = sort(l1);\n \
    \   long[] l2_sorted = sort(l2);\n    long i = 0L;\n    while (i < l1_sorted.length)\n\
    \    {\n        long j = 0L;\n        while (j < l2_sorted.length)\n        {\n\
    \            if (l1_sorted[i] == l2_sorted[j])\n            {\n              \
    \  result = result ~ l1_sorted[i];\n                break;\n            }\n  \
    \          j += 1L;\n        }\n        i += 1L;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpum0kma86.d(15): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpum0kma86.d(16): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpum0kma86.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ejrjcl6.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp4ejrjcl6.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ejrjcl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwoohvyf2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmpwoohvyf2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwoohvyf2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            if(!result.canFind(l))\n            {\n              \
    \  result ~= l;\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwcab9z9k.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpwcab9z9k.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmpwcab9z9k.d(19): Error: no property `canFind` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwcab9z9k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphv5swjq2.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmphv5swjq2.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphv5swjq2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    foreach (l; l1)\n    {\n       \
    \ if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_jiopc_i.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmp_jiopc_i.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_jiopc_i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (e1; l1) \n    {\n        foreach\
    \ (e2; l2) \n        {\n            if (e1 == e2) \n            {\n          \
    \      result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw5ag3wkq.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw5ag3wkq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163028
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            if (!result.canFind(l))\n            {\n             \
    \   result ~= l;\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphte92dbg.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmphte92dbg.d(19): Error: no property `canFind` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphte92dbg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach(l; l1)\n    {\n        foreach(r;\
    \ l2)\n        {\n            if(l == r)\n            {\n                result\
    \ ~= l;\n            }\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqqml52ra.d(14): Error: new can only create structs, dynamic arrays
    or class objects, not `long[]`''s

    /tmp/tmpqqml52ra.d(25): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqqml52ra.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[l1.length];\n    int result_index = 0;\n \
    \   foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n            result[result_index]\
    \ = l;\n            result_index++;\n        }\n    }\n    return result[0..result_index];\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxd88yu7w.d(18): Error: no property `canFind` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxd88yu7w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (long i; l1) \n    {\n        if (l2.canFind(i))\
    \ \n        {\n            result ~= i;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo3un127p.d(17): Error: no property `canFind` for type `long[]`

    /tmp/tmpo3un127p.d(22): Error: no property `sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo3un127p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163029
