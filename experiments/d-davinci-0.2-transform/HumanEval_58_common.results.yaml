language: d
name: HumanEval_58_common
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (elem; l1) \n    {\n        if (elem\
    \ in l2) \n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1,\
    \ 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\nunittest\n{\n   \
    \ alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgm8fodn5.d(24): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpgm8fodn5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) {\n        if (l2.canFind(l))\
    \ {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwsvxjyig.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpwsvxjyig.d(16): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpwsvxjyig.d(20): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwsvxjyig.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyecope36.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpyecope36.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpyecope36.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyecope36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    long[] l1_sorted = sort(l1);\n \
    \   long[] l2_sorted = sort(l2);\n    long i = 0L;\n    long j = 0L;\n    while\
    \ (i < l1_sorted.length && j < l2_sorted.length)\n    {\n        if (l1_sorted[i]\
    \ == l2_sorted[j])\n        {\n            result = result ~ l1_sorted[i];\n \
    \           i++;\n            j++;\n        }\n        else if (l1_sorted[i] <\
    \ l2_sorted[j])\n        {\n            i++;\n        }\n        else\n      \
    \  {\n            j++;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg8lljc2a.d(15): Error: undefined identifier `sort`, did you
    mean function `sqrt`?\n/tmp/tmpg8lljc2a.d(16): Error: undefined identifier `sort`,
    did you mean function `sqrt`?\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg8lljc2a.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result;\n}\n\
    /*\nReturn sorted unique common elements for two lists.\n    >>> common([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n\
    \    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppiyjixe_.d(24): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmppiyjixe_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n   \
    \     foreach (long j; l2)\n        {\n            if (i == j)\n            {\n\
    \                result ~= i;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpth3nlchu.d(25): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpth3nlchu.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if\
    \ (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6yd4ofzv.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmp6yd4ofzv.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmp6yd4ofzv.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6yd4ofzv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; sort(l1))\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj4jz1inr.d(15): Error: undefined identifier `sort`, did you
    mean function `sqrt`?\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj4jz1inr.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_copy = l1.dup;\n    long[] l2_copy =\
    \ l2.dup;\n    l1_copy.sort;\n    l2_copy.sort;\n    foreach(long i; l1_copy)\n\
    \    {\n        if(l2_copy.canFind(i))\n        {\n            result ~= i;\n\
    \        }\n    }\n    return result.dup.sort.uniq;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0nwok6ve.d(17): Error: no property `sort` for type `long[]`\n/tmp/tmp0nwok6ve.d(18):
    Error: no property `sort` for type `long[]`\n/tmp/tmp0nwok6ve.d(21): Error: no
    property `canFind` for type `long[]`\n/tmp/tmp0nwok6ve.d(26): Error: no property
    `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0nwok6ve.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    long[] l1_unique_sorted = l1_unique.sort;\n    long[]\
    \ l2_unique_sorted = l2_unique.sort;\n    long[] l1_unique_sorted_set = l1_unique_sorted.toSet.array;\n\
    \    long[] l2_unique_sorted_set = l2_unique_sorted.toSet.array;\n    long[] l1_unique_sorted_set_sorted\
    \ = l1_unique_sorted_set.sort;\n    long[] l2_unique_sorted_set_sorted = l2_unique_sorted_set.sort;\n\
    \    long[] l1_unique_sorted_set_sorted_unique = l1_unique_sorted_set_sorted.unique;\n\
    \    long[] l2_unique_sorted_set_sorted_unique = l2_unique_sorted_set_sorted.unique;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted = l1_unique_sorted_set_sorted_unique.sort;\n\
    \    long[] l2_unique_sorted_set_sorted_unique_sorted = l2_unique_sorted_set_sorted_unique.sort;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted_set = l1_unique_sorted_set_sorted_unique_sorted.toSet.array;\n\
    \    long[] l2_unique_sorted_set_sorted_unique_sorted_set = l2_unique_sorted_set_sorted_unique_sorted.toSet.array;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted_set_sorted = l1_unique_sorted_set_sorted_unique_sorted\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoki5f478.d(32): Error: semicolon expected, not `unittest`\n/tmp/tmpoki5f478.d(32):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpoki5f478.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = [];\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            res ~= e;\n        }\n    }\n    return res.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvm4rco_n.d(17): Error: incompatible types for `(e) in (l2)`:
    `long` and `long[]`\n/tmp/tmpvm4rco_n.d(22): Error: no property `sort` for type
    `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvm4rco_n.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (elem; l1) \n    {\n        if (elem\
    \ in l2) \n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt2gcnceg.d(17): Error: incompatible types for `(elem) in (l2)`:
    `long` and `long[]`\n/tmp/tmpt2gcnceg.d(22): Error: no property `sort` for type
    `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt2gcnceg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4qvemtfi.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp4qvemtfi.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp4qvemtfi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{ \n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpms0h_3h_.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmpms0h_3h_.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpms0h_3h_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (e1; l1) \n    {\n       \
    \ foreach (e2; l2) \n        {\n            if (e1 == e2) \n            {\n  \
    \              result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpts39oks8.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpts39oks8.d(25): Error: no property
    `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpts39oks8.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    return l1.intersect(l2).sort().uniq;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps_tp_lo1.d(16): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmps_tp_lo1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd4edwya7.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmpd4edwya7.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpd4edwya7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    if (l1.length == 0 || l2.length ==\
    \ 0)\n        return result;\n    long[] l1s = l1.dup.sort;\n    long[] l2s =\
    \ l2.dup.sort;\n    long[] l1u = l1s.dup.uniq;\n    long[] l2u = l2s.dup.uniq;\n\
    \    long[] l1l = l1u.dup.length;\n    long[] l2l = l2u.dup.length;\n    long[]\
    \ l1i = l1u.dup.indices;\n    long[] l2i = l2u.dup.indices;\n    long[] l1f =\
    \ l1u.dup.front;\n    long[] l2f = l2u.dup.front;\n    long[] l1b = l1u.dup.back;\n\
    \    long[] l2b = l2u.dup.back;\n    long[] l1m = l1u.dup.mid;\n    long[] l2m\
    \ = l2u.dup.mid;\n    long[] l1e = l1u.dup.empty;\n    long[] l2e = l2u.dup.empty;\n\
    \    long[] l1r = l1u.dup.retro;\n    long[] l2r = l2u.dup.retro;\n    long[]\
    \ l1d = l1u.dup.dup;\n    long[] l2d = l2u.dup.dup;\n    long[] l1c = l1u.dup.idup;\n\
    \    long[] l2c = l2u.dup.idup;\n    long[] l1t = l1u.dup.take;\n    long[] l2t\
    \ = l2u.dup.take;\n    long[] l1g = l1u.dup.takeExactly;\n    long[] l2g = l2u.dup.takeExactly;\n\
    \    long[] l1o = l1u.dup.takeExactly;\n    long[] l2\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdos4jlbp.d(45): Error: semicolon expected, not `unittest`\n/tmp/tmpdos4jlbp.d(45):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpdos4jlbp.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    return l1.filter!(a => l2.canFind(a)).sort().uniq;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj0qx95hk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto s1 = l1.sort().uniq;\n    auto s2 = l2.sort().uniq;\n    long[]\
    \ result;\n    foreach(i; s1)\n    {\n        if(s2.canFind(i))\n        {\n \
    \           result ~= i;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcn7b41eb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l in\
    \ l2) \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ep02spf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyecope36.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpyecope36.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpyecope36.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyecope36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd4edwya7.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmpd4edwya7.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpd4edwya7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.count(l)\
    \ > 0)\n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqwwal8pp.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    long[] l1_sorted = sort(l1);\n  \
    \  long[] l2_sorted = sort(l2);\n    long[] l1_unique = unique(l1_sorted);\n \
    \   long[] l2_unique = unique(l2_sorted);\n    long[] l1_unique_sorted = sort(l1_unique);\n\
    \    long[] l2_unique_sorted = sort(l2_unique);\n    long[] l1_unique_sorted_reversed\
    \ = reverse(l1_unique_sorted);\n    long[] l2_unique_sorted_reversed = reverse(l2_unique_sorted);\n\
    \    long[] l1_unique_sorted_reversed_unique = unique(l1_unique_sorted_reversed);\n\
    \    long[] l2_unique_sorted_reversed_unique = unique(l2_unique_sorted_reversed);\n\
    \    long[] l1_unique_sorted_reversed_unique_sorted = sort(l1_unique_sorted_reversed_unique);\n\
    \    long[] l2_unique_sorted_reversed_unique_sorted = sort(l2_unique_sorted_reversed_unique);\n\
    \    long[] l1_unique_sorted_reversed_unique_sorted_reversed = reverse(l1_unique_sorted_reversed_unique_sorted);\n\
    \    long[] l2_unique_sorted_reversed_unique_sorted_reversed = reverse(l2_unique_sorted_reversed_unique_sorted);\n\
    \    long[] l1_unique_sorted_reversed_unique_sorted_reversed_unique = unique(l1_unique_sorted_reversed_unique_sorted_reversed);\n\
    \    long[] l2_unique_sorted_reversed_unique_sorted_reversed_unique = unique(l2_unique_sorted_reversed_unique_sorted_reversed);\n\
    \    long[] l1_unique_sorted_reversed_unique_s\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbzqjj24z.d(32): Error: semicolon expected, not \''unittest\''\n/tmp/tmpbzqjj24z.d(32):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpbzqjj24z.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n        foreach\
    \ (e2; l2)\n        {\n            if (e1 == e2)\n            {\n            \
    \    result ~= e1;\n            }\n        }\n    }\n    return result.sort().unique;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1uly24z7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n        foreach (e2;\
    \ l2)\n        {\n            if (e1 == e2)\n            {\n                result\
    \ ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6nvylkhl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (long i; l1) \n    {\n  \
    \      if (l2.canFind(i)) \n        {\n            result ~= i;\n        }\n \
    \   }\n    return result.sort().dup.unique;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3touzjg5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n   \
    \     if (l2.canFind(i))\n        {\n            result ~= i;\n        }\n   \
    \ }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd1yfvams.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements of two lists.\n    >>> unique([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L,\
    \ 5L, 653L, 7L, 9L, 121L, 34L]\n    >>> unique([5L, 3L, 2L, 8L], [3L, 2L])\n \
    \   [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[] l1, long[] l2) \n{\n    long[]\
    \ result = [];\n    foreach (l; l1)\n    {\n        result ~= l;\n    }\n    foreach\
    \ (l; l2)\n    {\n        result ~= l;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements of two lists.\n    >>> unique([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L,\
    \ 5L, 653L, 7L, 9L, 121L, 34L]\n    >>> unique([5L, 3L, 2L, 8L], [3L, 2L])\n \
    \   [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[] l1, long[] l2) \n{\n    long[]\
    \ result = [];\n    foreach (l; l1)\n    {\n        result ~= l;\n    }\n    foreach\
    \ (l; l2)\n    {\n        result ~= l;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements of two lists.\n\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb5safwxb.d(64): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpb5safwxb.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            res ~= l;\n        }\n    }\n    return res.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp92gokbss.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ret = new long[0];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            ret ~= l;\n        }\n    }\n    ret = ret.sort().uniq;\n\
    \    return ret;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpser0us21.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4qvemtfi.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp4qvemtfi.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp4qvemtfi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            if (!result.canFind(l))\n          \
    \  {\n                result ~= l;\n            }\n        }\n    }\n    return\
    \ result;\n}\n/*\nReturn sorted unique elements for two lists.\n    >>> unique([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L,\
    \ 3L, 4L, 5L, 7L, 9L, 34L, 121L, 653L]\n    >>> unique([5L, 3L, 2L, 8L], [3L,\
    \ 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[] l1, long[] l2) \n{\n  \
    \  long[] result = new long[];\n    foreach (l; l1)\n    {\n        if (!result.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    foreach (l; l2)\n\
    \    {\n        if (!result.canFind(l))\n        {\n            result ~= l;\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements for\
    \ two lists.\n    >>> unique([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L,\
    \ 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L, 5L, 7L, 9L, 34L, 121L, 653L]\n    >>>\
    \ unique([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n \
    \   {\n        if (!result.can\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvk3j8_6c.d(66): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmpvk3j8_6c.d(75):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpvk3j8_6c.d(75):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvk3j8_6c.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    foreach(l; l1_unique)\n    {\n        if(l2_unique.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9xgkfrvx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1) \n    {\n       \
    \ if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort.uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpapar9y3l.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            if (!result.canFind(l))\n          \
    \  {\n                result ~= l;\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpreouhoex.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    return l1.filter!(x => l2.canFind(x)).sort().uniq;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsify6qk1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyecope36.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpyecope36.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpyecope36.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyecope36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().dup.unique;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk154r246.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (long l; l1) \n    {\n  \
    \      if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n \
    \   }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdnhqlthv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto s1 = set(l1);\n    auto s2 = set(l2);\n    return s1.intersection(s2).array;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3bpm9zsz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if\
    \ (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6yd4ofzv.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmp6yd4ofzv.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmp6yd4ofzv.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6yd4ofzv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            res ~= l;\n        }\n    }\n    return res.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp92gokbss.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyecope36.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpyecope36.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpyecope36.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyecope36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyecope36.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpyecope36.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpyecope36.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyecope36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto l1_set = set(l1);\n    auto l2_set = set(l2);\n    auto common_set\
    \ = l1_set & l2_set;\n    return common_set.array;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqzx8zxpq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1) \n    {\n       \
    \ if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5iohd17w.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = new long[l1.length + l2.length];\n    long[] l4 = new long[l1.length\
    \ + l2.length];\n    long[] l5 = new long[l1.length + l2.length];\n    long[]\
    \ l6 = new long[l1.length + l2.length];\n    long[] l7 = new long[l1.length +\
    \ l2.length];\n    long[] l8 = new long[l1.length + l2.length];\n    long[] l9\
    \ = new long[l1.length + l2.length];\n    long[] l10 = new long[l1.length + l2.length];\n\
    \    long[] l11 = new long[l1.length + l2.length];\n    long[] l12 = new long[l1.length\
    \ + l2.length];\n    long[] l13 = new long[l1.length + l2.length];\n    long[]\
    \ l14 = new long[l1.length + l2.length];\n    long[] l15 = new long[l1.length\
    \ + l2.length];\n    long[] l16 = new long[l1.length + l2.length];\n    long[]\
    \ l17 = new long[l1.length + l2.length];\n    long[] l18 = new long[l1.length\
    \ + l2.length];\n    long[] l19 = new long[l1.length + l2.length];\n    long[]\
    \ l20 = new long[l1.length + l2.length];\n    long[] l21 = new long[l1.length\
    \ + l2.length];\n    long[] l22 = new long[l1.length + l2.length];\n    long[]\
    \ l23 = new long[l1.length + l2.length];\n    long[] l24 = new long[l1.length\
    \ + l2.length];\n    long[] l25 = new long[l1.length + l2.length];\n    long[]\
    \ l26 = new long[l1.length + l2.length];\n    long[] l27 = new long[l1.length\
    \ + l2.length];\n    long[] l28 = new long[\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpubhae7co.d(40): Error: expression expected, not \''unittest\''\n/tmp/tmpubhae7co.d(41):
    Error: found \''{\'' when expecting \'']\''\n/tmp/tmpubhae7co.d(42): Error: semicolon
    expected, not \''alias\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpubhae7co.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ret = new long[0];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            ret ~= l;\n        }\n    }\n    return ret.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt6ovde9b.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4qvemtfi.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp4qvemtfi.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp4qvemtfi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_unique;\n    long[] l2_unique;\n    long[]\
    \ l1_sorted;\n    long[] l2_sorted;\n    long[] l1_sorted_unique;\n    long[]\
    \ l2_sorted_unique;\n    long[] l1_sorted_unique_common;\n    long[] l2_sorted_unique_common;\n\
    \    long[] l1_sorted_unique_common_sorted;\n    long[] l2_sorted_unique_common_sorted;\n\
    \    long[] l1_sorted_unique_common_sorted_unique;\n    long[] l2_sorted_unique_common_sorted_unique;\n\
    \    long[] l1_sorted_unique_common_sorted_unique_common;\n    long[] l2_sorted_unique_common_sorted_unique_common;\n\
    \    long[] l1_sorted_unique_common_sorted_unique_common_sorted;\n    long[] l2_sorted_unique_common_sorted_unique_common_sorted;\n\
    \    long[] l1_sorted_unique_common_sorted_unique_common_sorted_unique;\n    long[]\
    \ l2_sorted_unique_common_sorted_unique_common_sorted_unique;\n    long[] l1_sorted_unique_common_sorted_unique_common_sorted_unique_common;\n\
    \    long[] l2_sorted_unique_common_sorted_unique_common_sorted_unique_common;\n\
    \    long[] l1_sorted_unique_common_sorted_unique_common_sorted_unique_common_sorted;\n\
    \    long[] l2_sorted_unique_common_sorted_unique_common_sorted_unique_common_sorted;\n\
    \    long[] l1_sorted_unique_common_sorted_unique_common_sorted_unique_common_sorted_unique;\n\
    \    long[] l2_sorted_unique_common_sorted_unique_common_sorted_unique_common_sorted_unique;\n\
    \    long[] l1_sorted_unique_common_sorted\nunittest\n{\n    alias candidate =\
    \ common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L,\
    \ 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L,\
    \ 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5b1bxty4.d(40): Error: semicolon expected, not \''unittest\''\n/tmp/tmp5b1bxty4.d(40):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp5b1bxty4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    foreach (e; l1)\n    {\n       \
    \ if (e in l2)\n        {\n            result ~= e;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdl38c4iq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if\
    \ (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6yd4ofzv.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmp6yd4ofzv.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmp6yd4ofzv.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6yd4ofzv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyecope36.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpyecope36.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpyecope36.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyecope36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (e1; l1) \n    {\n        foreach\
    \ (e2; l2) \n        {\n            if (e1 == e2) \n            {\n          \
    \      result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzco8grx7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_sorted = sort(l1);\n    long[] l2_sorted\
    \ = sort(l2);\n    long[] l1_unique = uniq(l1_sorted);\n    long[] l2_unique =\
    \ uniq(l2_sorted);\n    foreach(l1_u; l1_unique)\n    {\n        foreach(l2_u;\
    \ l2_unique)\n        {\n            if(l1_u == l2_u)\n            {\n       \
    \         result ~= l1_u;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx_l6e1ot.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = new long[l1.length];\n    int j = 0;\n    foreach(l; l1)\n\
    \    {\n        foreach(l2; l2)\n        {\n            if(l == l2)\n        \
    \    {\n                l3[j] = l;\n                j++;\n            }\n    \
    \    }\n    }\n    return l3;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmk4twlff.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    if (l1.length == 0 || l2.length ==\
    \ 0)\n    {\n        return result;\n    }\n    long[] l1_sorted = l1.dup.sort;\n\
    \    long[] l2_sorted = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n\
    \    long[] l2_unique = l2_sorted.unique;\n    foreach (l1_elem; l1_unique)\n\
    \    {\n        foreach (l2_elem; l2_unique)\n        {\n            if (l1_elem\
    \ == l2_elem)\n            {\n                result ~= l1_elem;\n           \
    \ }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpze_9k41i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto l1_set = l1.sort().uniq;\n    auto l2_set = l2.sort().uniq;\n\
    \    auto result = new long[](max(l1_set.length, l2_set.length));\n    auto result_len\
    \ = 0;\n    foreach (i, e; l1_set) {\n        if (l2_set.canFind(e)) {\n     \
    \       result[result_len] = e;\n            result_len++;\n        }\n    }\n\
    \    return result[0..result_len];\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqp1wwnpc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    foreach(l1_u; l1_unique)\n    {\n        foreach(l2_u;\
    \ l2_unique)\n        {\n            if(l1_u == l2_u)\n            {\n       \
    \         result ~= l1_u;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvoo9gq4l.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = new long[l1.length + l2.length];\n    long[] l4 = new long[l1.length\
    \ + l2.length];\n    long[] l5 = new long[l1.length + l2.length];\n    long[]\
    \ l6 = new long[l1.length + l2.length];\n    long[] l7 = new long[l1.length +\
    \ l2.length];\n    long[] l8 = new long[l1.length + l2.length];\n    long[] l9\
    \ = new long[l1.length + l2.length];\n    long[] l10 = new long[l1.length + l2.length];\n\
    \    long[] l11 = new long[l1.length + l2.length];\n    long[] l12 = new long[l1.length\
    \ + l2.length];\n    long[] l13 = new long[l1.length + l2.length];\n    long[]\
    \ l14 = new long[l1.length + l2.length];\n    long[] l15 = new long[l1.length\
    \ + l2.length];\n    long[] l16 = new long[l1.length + l2.length];\n    long[]\
    \ l17 = new long[l1.length + l2.length];\n    long[] l18 = new long[l1.length\
    \ + l2.length];\n    long[] l19 = new long[l1.length + l2.length];\n    long[]\
    \ l20 = new long[l1.length + l2.length];\n    long[] l21 = new long[l1.length\
    \ + l2.length];\n    long[] l22 = new long[l1.length + l2.length];\n    long[]\
    \ l23 = new long[l1.length + l2.length];\n    long[] l24 = new long[l1.length\
    \ + l2.length];\n    long[] l25 = new long[l1.length + l2.length];\n    long[]\
    \ l26 = new long[l1.length + l2.length];\n    long[] l27 = new long[l1.length\
    \ + l2.length];\n    long[] l28 = new long[\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpubhae7co.d(40): Error: expression expected, not \''unittest\''\n/tmp/tmpubhae7co.d(41):
    Error: found \''{\'' when expecting \'']\''\n/tmp/tmpubhae7co.d(42): Error: semicolon
    expected, not \''alias\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpubhae7co.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto result = new long[](0);\n    auto l1_set = new long[](0);\n  \
    \  auto l2_set = new long[](0);\n    l1_set = l1.dup;\n    l2_set = l2.dup;\n\
    \    l1_set.sort;\n    l2_set.sort;\n    l1_set = l1_set.uniq;\n    l2_set = l2_set.uniq;\n\
    \    foreach(i; 0..l1_set.length)\n    {\n        foreach(j; 0..l2_set.length)\n\
    \        {\n            if(l1_set[i] == l2_set[j])\n            {\n          \
    \      result ~= l1_set[i];\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphqyckgpi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            if (!result.canFind(l))\n          \
    \  {\n                result ~= l;\n            }\n        }\n    }\n    return\
    \ result;\n}\n/*\nReturn sorted unique common elements for two lists.\n    >>>\
    \ common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6hf143i3.d(27): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp6hf143i3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            if (!result.canFind(l))\n          \
    \  {\n                result ~= l;\n            }\n        }\n    }\n    return\
    \ result;\n}\n/*\nReturn sorted unique common elements for two lists.\n    >>>\
    \ common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6hf143i3.d(27): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp6hf143i3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyecope36.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpyecope36.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpyecope36.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyecope36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto s1 = l1.sort().unique;\n    auto s2 = l2.sort().unique;\n    long[]\
    \ result;\n    foreach(e; s1)\n    {\n        if(s2.canFind(e))\n        {\n \
    \           result ~= e;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptsymksn1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (elem; l1) \n    {\n    \
    \    if (elem in l2) \n        {\n            result ~= elem;\n        }\n   \
    \ }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1yas2lkx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyecope36.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpyecope36.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpyecope36.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyecope36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    return l1.filter!(x => l2.canFind(x)).sort().uniq;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsify6qk1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            if (!result.canFind(l)) \n            {\n         \
    \       result ~= l;\n            }\n        }\n    }\n    return result.sort();\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqkkkplfx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            res ~= l;\n        }\n    }\n    return res.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp92gokbss.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4qvemtfi.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp4qvemtfi.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp4qvemtfi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto s1 = l1.sort().unique;\n    auto s2 = l2.sort().unique;\n    long[]\
    \ result;\n    foreach(e; s1)\n    {\n        if(s2.canFind(e))\n        {\n \
    \           result ~= e;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptsymksn1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) {\n        if (l2.canFind(l))\
    \ {\n            result ~= l;\n        }\n    }\n    return result.sort.uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzuz0asx9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_unique = l1.unique;\n    long[] l2_unique\
    \ = l2.unique;\n    foreach(l; l1_unique)\n    {\n        if(l2_unique.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp215_b0ta.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\n/*\nReturn sorted unique elements for two lists.\n\
    \    >>> unique([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 2L, 3L, 4L, 5L, 653L, 7L, 9L, 121L, 34L]\n    >>> unique([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        result\
    \ ~= l;\n    }\n    foreach (l; l2)\n    {\n        result ~= l;\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique elements for two lists.\n \
    \   >>> unique([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 2L, 3L, 4L, 5L, 653L, 7L, 9L, 121L, 34L]\n    >>> unique([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        result\
    \ ~= l;\n    }\n    foreach (l; l2)\n    {\n        result ~= l;\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\n\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpn5l_6hp2.d(64): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpn5l_6hp2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto s1 = l1.sort().unique;\n    auto s2 = l2.sort().unique;\n    long[]\
    \ res;\n    foreach(e; s1)\n    {\n        if(s2.canFind(e))\n        {\n    \
    \        res ~= e;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpasg0p8ls.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if\
    \ (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6yd4ofzv.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmp6yd4ofzv.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmp6yd4ofzv.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6yd4ofzv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    foreach (l; l1)\n    {\n       \
    \ if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0m5e_vf0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    long[] l1_unique = unique(l1);\n\
    \    long[] l2_unique = unique(l2);\n    foreach (l1_item; l1_unique)\n    {\n\
    \        foreach (l2_item; l2_unique)\n        {\n            if (l1_item == l2_item)\n\
    \            {\n                result ~= l1_item;\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb9av7wgy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4qvemtfi.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp4qvemtfi.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp4qvemtfi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    long[] l1_sorted = sort(l1);\n \
    \   long[] l2_sorted = sort(l2);\n    long i = 0L;\n    long j = 0L;\n    while\
    \ (i < l1_sorted.length && j < l2_sorted.length)\n    {\n        if (l1_sorted[i]\
    \ == l2_sorted[j])\n        {\n            result = result ~ l1_sorted[i];\n \
    \           i++;\n            j++;\n        }\n        else if (l1_sorted[i] <\
    \ l2_sorted[j])\n        {\n            i++;\n        }\n        else\n      \
    \  {\n            j++;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg8lljc2a.d(15): Error: undefined identifier `sort`, did you
    mean function `sqrt`?\n/tmp/tmpg8lljc2a.d(16): Error: undefined identifier `sort`,
    did you mean function `sqrt`?\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg8lljc2a.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    long[] l1_unique_sorted = l1_unique.sort;\n    long[]\
    \ l2_unique_sorted = l2_unique.sort;\n    long[] l1_unique_sorted_set = l1_unique_sorted.set;\n\
    \    long[] l2_unique_sorted_set = l2_unique_sorted.set;\n    long[] l1_unique_sorted_set_sorted\
    \ = l1_unique_sorted_set.sort;\n    long[] l2_unique_sorted_set_sorted = l2_unique_sorted_set.sort;\n\
    \    long[] l1_unique_sorted_set_sorted_unique = l1_unique_sorted_set_sorted.unique;\n\
    \    long[] l2_unique_sorted_set_sorted_unique = l2_unique_sorted_set_sorted.unique;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted = l1_unique_sorted_set_sorted_unique.sort;\n\
    \    long[] l2_unique_sorted_set_sorted_unique_sorted = l2_unique_sorted_set_sorted_unique.sort;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted_set = l1_unique_sorted_set_sorted_unique_sorted.set;\n\
    \    long[] l2_unique_sorted_set_sorted_unique_sorted_set = l2_unique_sorted_set_sorted_unique_sorted.set;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted_set_sorted = l1_unique_sorted_set_sorted_unique_sorted_set.sort;\n\
    \    long[] l2_\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6fjibokk.d(33): Error: semicolon expected, not \''unittest\''\n/tmp/tmp6fjibokk.d(33):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp6fjibokk.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (long i; l1)\n    {\n        foreach\
    \ (long j; l2)\n        {\n            if (i == j)\n            {\n          \
    \      result ~= i;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4cxzd_6r.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n        foreach\
    \ (e2; l2)\n        {\n            if (e1 == e2)\n            {\n            \
    \    result ~= e1;\n            }\n        }\n    }\n    return result.sort.uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj7el7ux0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd4edwya7.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmpd4edwya7.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpd4edwya7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if\
    \ (l2.canFind(l)) \n        {\n            if (!result.canFind(l)) \n        \
    \    {\n                result ~= l;\n            }\n        }\n    }\n    return\
    \ result.sort();\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqlq504k9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n        foreach (e2;\
    \ l2)\n        {\n            if (e1 == e2)\n            {\n                result\
    \ ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6nvylkhl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    foreach (l; l1)\n    {\n       \
    \ if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0m5e_vf0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyecope36.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpyecope36.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpyecope36.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyecope36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyecope36.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpyecope36.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpyecope36.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyecope36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = l1.dup;\n    l3 ~= l2;\n    l3.sort;\n    l3 = l3.uniq;\n\
    \    return l3;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph3njhmnc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ret = new long[0];\n    long[] l3 = new long[0];\n    long[]\
    \ l4 = new long[0];\n    if (l1.length < l2.length) \n    {\n        l3 = l1;\n\
    \        l4 = l2;\n    }\n    else \n    {\n        l3 = l2;\n        l4 = l1;\n\
    \    }\n    foreach (e; l3) \n    {\n        if (e in l4) \n        {\n      \
    \      ret ~= e;\n        }\n    }\n    ret.sort();\n    return ret;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7hl43gm_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto r = new long[](0);\n    foreach (e; l1)\n    {\n        if (e\
    \ in l2)\n        {\n            r ~= e;\n        }\n    }\n    return r.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa4s4bxa5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    long[] l1_sorted = sort(l1);\n  \
    \  long[] l2_sorted = sort(l2);\n    int i = 0;\n    int j = 0;\n    while (i\
    \ < l1_sorted.length && j < l2_sorted.length) \n    {\n        if (l1_sorted[i]\
    \ == l2_sorted[j]) \n        {\n            result ~= l1_sorted[i];\n        \
    \    i++;\n            j++;\n        }\n        else if (l1_sorted[i] < l2_sorted[j])\
    \ \n        {\n            i++;\n        }\n        else \n        {\n       \
    \     j++;\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements of two lists.\n    >>> union([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L, 5L, 7L, 9L, 34L, 121L, 653L]\n\
    \    >>> union([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] union(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[0];\n    long[] l1_sorted =\
    \ sort(l1);\n    long[] l2_sorted = sort(l2);\n    int i = 0;\n    int j = 0;\n\
    \    while (i < l1_sorted.length && j < l2_sorted.length) \n    {\n        if\
    \ (l1_sorted[i] == l2_sorted[j]) \n        {\n            result ~= l1_sorted[i];\n\
    \            i++;\n            j++;\n        }\n        else if (l1_sorted[i]\
    \ < l2_sorted[j]) \n        {\n            result ~= l1_s\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdxhv7dsb.d(45): Error: no identifier for declarator long[]\n/tmp/tmpdxhv7dsb.d(45):
    Error: { } expected following aggregate declaration\n/tmp/tmpdxhv7dsb.d(45): Error:
    Declaration expected, not \''(\''\n/tmp/tmpdxhv7dsb.d(52): Error: Declaration
    expected, not \''while\''\n/tmp/tmpdxhv7dsb.d(57): Error: no identifier for declarator
    i\n/tmp/tmpdxhv7dsb.d(57): Error: Declaration expected, not \''++\''\n/tmp/tmpdxhv7dsb.d(58):
    Error: no identifier for declarator j\n/tmp/tmpdxhv7dsb.d(58): Error: Declaration
    expected, not \''++\''\n/tmp/tmpdxhv7dsb.d(59): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdxhv7dsb.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{ \n    return l1.filter!(x => l2.canFind(x)).sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2_qo42fi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (long l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp36dmdcc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd4edwya7.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmpd4edwya7.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpd4edwya7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n   \
    \     foreach (long j; l2)\n        {\n            if (i == j)\n            {\n\
    \                result ~= i;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpth3nlchu.d(25): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpth3nlchu.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if\
    \ (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6yd4ofzv.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmp6yd4ofzv.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmp6yd4ofzv.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6yd4ofzv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    result = new long[l1.length];\n    int i = 0;\n\
    \    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n            result[i]\
    \ = e;\n            i++;\n        }\n    }\n    return result[0..i];\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb_5lg4fs.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if\
    \ (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6yd4ofzv.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmp6yd4ofzv.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmp6yd4ofzv.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6yd4ofzv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = new long[l1.length];\n    long[] l4 = new long[l2.length];\n\
    \    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n\
    \    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n\
    \    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n\
    \    int x = 0;\n    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int ab =\
    \ 0;\n    int ac = 0;\n    int ad = 0;\n    int ae = 0;\n    int af = 0;\n   \
    \ int ag = 0;\n    int ah = 0;\n    int ai = 0;\n    int aj = 0;\n    int ak =\
    \ 0;\n    int al = 0;\n    int am = 0;\n    int an = 0;\n    int ao = 0;\n   \
    \ int ap = 0;\n    int aq = 0;\n    int ar = 0;\n    int as = 0;\n    int at =\
    \ 0;\n    int au = 0;\n    int av = 0;\n    int aw = 0;\n    int ax = 0;\n   \
    \ int ay = 0;\n    int az = 0;\n    int ba = 0;\n    int bb = 0;\n    int bc =\
    \ 0;\n    int bd = 0;\n    int be = 0;\n    int bf = 0;\n    int bg = 0;\n   \
    \ int bh = 0;\n    int bi = 0;\n    int bj = 0;\n    int bk = 0;\n    int bl =\
    \ 0;\n    int bm = 0;\n    int bn = 0;\n    int bo = 0;\n    int bp = 0;\n   \
    \ int bq = 0;\n    int br = 0;\n    int bs = 0;\n    int bt = 0;\n    int bu =\
    \ 0;\n    int bv =\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpody32o08.d(82): Error: expression expected, not \''unittest\''\n/tmp/tmpody32o08.d(83):
    Error: semicolon expected, not \''{\''\n/tmp/tmpody32o08.d(91): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpody32o08.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n        foreach (e2;\
    \ l2)\n        {\n            if (e1 == e2)\n            {\n                result\
    \ ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6nvylkhl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n        foreach\
    \ (e2; l2)\n        {\n            if (e1 == e2)\n            {\n            \
    \    result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppefeyf2p.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n   \
    \     foreach (long j; l2)\n        {\n            if (i == j)\n            {\n\
    \                result ~= i;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpth3nlchu.d(25): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpth3nlchu.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyecope36.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpyecope36.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpyecope36.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyecope36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort();\n    long[] l2_sorted\
    \ = l2.dup.sort();\n    long[] l1_unique = l1_sorted.dup.uniq;\n    long[] l2_unique\
    \ = l2_sorted.dup.uniq;\n    long[] l1_unique_sorted = l1_unique.dup.sort;\n \
    \   long[] l2_unique_sorted = l2_unique.dup.sort;\n    long[] l1_unique_sorted_set\
    \ = l1_unique_sorted.dup.toSet;\n    long[] l2_unique_sorted_set = l2_unique_sorted.dup.toSet;\n\
    \    long[] l1_unique_sorted_set_intersection = l1_unique_sorted_set.dup.intersection(l2_unique_sorted_set);\n\
    \    result = l1_unique_sorted_set_intersection.dup.toArray;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnq4e9518.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\n/*\nReturn sorted unique elements that are in\
    \ either of the lists.\n    >>> union([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L, 5L, 653L, 7L, 9L, 121L, 34L]\n\
    \    >>> union([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] union(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n \
    \   {\n        result ~= l;\n    }\n    foreach (l; l2)\n    {\n        result\
    \ ~= l;\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements\
    \ that are in both lists.\n    >>> intersection([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> intersection([5L,\
    \ 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\n*/\nlong[] intersection(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n     \
    \   if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements that are\
    \ in the first list but not in the second.\n    >>> difference([1L, 4L\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbezm8b_y.d(31): Error: no identifier for declarator long[]\n/tmp/tmpbezm8b_y.d(31):
    Error: { } expected following aggregate declaration\n/tmp/tmpbezm8b_y.d(31): Error:
    Declaration expected, not \''(\''\n/tmp/tmpbezm8b_y.d(34): Error: Declaration
    expected, not \''foreach\''\n/tmp/tmpbezm8b_y.d(34): Error: no identifier for
    declarator l1\n/tmp/tmpbezm8b_y.d(34): Error: Declaration expected, not \'')\''\n/tmp/tmpbezm8b_y.d(37):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbezm8b_y.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{ \n    return l1.filter!(x => l2.canFind(x)).sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2_qo42fi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto result = new long[](0);\n    foreach (i; l1) \n    {\n       \
    \ if (l2.canFind(i)) \n        {\n            result ~= i;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfyt303as.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyecope36.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpyecope36.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpyecope36.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyecope36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyecope36.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpyecope36.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpyecope36.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyecope36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    foreach (l; l1) \n    {\n      \
    \  if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ow_1jhk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto result = new long[](max(l1.length, l2.length));\n    size_t i\
    \ = 0;\n    foreach (e1; l1)\n    {\n        foreach (e2; l2)\n        {\n   \
    \         if (e1 == e2)\n            {\n                result[i] = e1;\n    \
    \            i++;\n            }\n        }\n    }\n    return result[0 .. i];\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp69mm36vn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    if (l1.length < l2.length) \n    {\n        result\
    \ = common(l2, l1);\n    }\n    else \n    {\n        result = new long[l1.length];\n\
    \        size_t j = 0;\n        foreach (i; l1) \n        {\n            if (l2.canFind(i))\
    \ \n            {\n                result[j] = i;\n                j++;\n    \
    \        }\n        }\n        result = result[0..j];\n    }\n    return result.sort().unique;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk7ksddhn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{ \n    long[] result = new long[0]; \n    long[] l1_sorted = sort(l1); \n\
    \    long[] l2_sorted = sort(l2); \n    long[] l1_unique = unique(l1_sorted);\
    \ \n    long[] l2_unique = unique(l2_sorted); \n    foreach (long i; l1_unique)\
    \ \n    { \n        foreach (long j; l2_unique) \n        { \n            if (i\
    \ == j) \n            { \n                result ~= i; \n            } \n    \
    \    } \n    } \n    return result; \n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprt41rvrb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    return sort(uniq(l1)).intersect(sort(uniq(l2)));\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqfkyspxf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyecope36.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpyecope36.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpyecope36.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyecope36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd4edwya7.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmpd4edwya7.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpd4edwya7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd4edwya7.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmpd4edwya7.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpd4edwya7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n        if\
    \ (e in l2)\n        {\n            if (e !in result)\n            {\n       \
    \         result ~= e;\n            }\n        }\n    }\n    return result.sort();\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprj2h02v2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    foreach(l1_elem; l1_unique)\n    {\n        foreach(l2_elem;\
    \ l2_unique)\n        {\n            if(l1_elem == l2_elem)\n            {\n \
    \               result ~= l1_elem;\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz57gzs48.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[l1.length];\n    int i = 0;\n    foreach(l;\
    \ l1)\n    {\n        if (l2.canFind(l))\n        {\n            result[i] = l;\n\
    \            i++;\n        }\n    }\n    return result[0..i];\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppx_vmoa7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n        foreach (e2;\
    \ l2)\n        {\n            if (e1 == e2)\n            {\n                result\
    \ ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6nvylkhl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ret = [];\n    foreach(e1; l1)\n    {\n        foreach(e2; l2)\n\
    \        {\n            if(e1 == e2)\n            {\n                ret ~= e1;\n\
    \            }\n        }\n    }\n    return ret.sort().uniq;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4utwn9y5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n   \
    \     if (l2.canFind(i))\n        {\n            result ~= i;\n        }\n   \
    \ }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd1yfvams.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyecope36.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpyecope36.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpyecope36.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyecope36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (elem; l1)\n    {\n     \
    \   if (elem in l2)\n        {\n            result ~= elem;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_7adq60r.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = new long[l1.length];\n    int i = 0;\n    foreach(long\
    \ l; l1)\n    {\n        if(l2.find(l) != -1)\n        {\n            l3[i] =\
    \ l;\n            i++;\n        }\n    }\n    l3 = l3[0..i];\n    l3.sort();\n\
    \    return l3.dup.unique;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfh_9o226.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n   \
    \     if (l2.canFind(i))\n        {\n            result ~= i;\n        }\n   \
    \ }\n    return result.sort().dup.unique;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprls8gqwr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto s1 = l1.sort();\n    auto s2 = l2.sort();\n    long[] res = new\
    \ long[];\n    foreach(i; 0 .. s1.length)\n    {\n        if(s1[i] == s2[i])\n\
    \        {\n            res ~= s1[i];\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp1fhw_6p.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    long[] l1_unique_sorted = l1_unique.sort;\n    long[]\
    \ l2_unique_sorted = l2_unique.sort;\n    long[] l1_unique_sorted_common = l1_unique_sorted.common;\n\
    \    long[] l2_unique_sorted_common = l2_unique_sorted.common;\n    long[] l1_unique_sorted_common_sorted\
    \ = l1_unique_sorted_common.sort;\n    long[] l2_unique_sorted_common_sorted =\
    \ l2_unique_sorted_common.sort;\n    result = l1_unique_sorted_common_sorted.common;\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7cnvu1jn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = new long[l1.length];\n    int i = 0;\n    foreach(l; l1)\n\
    \    {\n        foreach(l4; l2)\n        {\n            if(l == l4)\n        \
    \    {\n                l3[i] = l;\n                i++;\n            }\n    \
    \    }\n    }\n    l3 = l3.sort();\n    l3 = l3.uniq;\n    return l3;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy8nxn90u.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    return sort(toSet(l1) & toSet(l2));\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyxvgqql1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    return sort(array(uniq(l1) & uniq(l2)));\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq462hwv7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = new long[l1.length];\n    int i = 0;\n    foreach(l; l1)\n\
    \    {\n        if(l2.canFind(l))\n        {\n            res[i] = l;\n      \
    \      i++;\n        }\n    }\n    return res[0..i];\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ou74_40.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    long[] l1_sorted = sort(l1);\n  \
    \  long[] l2_sorted = sort(l2);\n    long[] l1_unique = unique(l1_sorted);\n \
    \   long[] l2_unique = unique(l2_sorted);\n    foreach(long i; l1_unique)\n  \
    \  {\n        foreach(long j; l2_unique)\n        {\n            if(i == j)\n\
    \            {\n                result ~= i;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7duwkrgl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1) \n    {\n       \
    \ if (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5iohd17w.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{ \n    auto l1_set = set(l1);\n    auto l2_set = set(l2);\n    auto l1_set_len\
    \ = l1_set.length;\n    auto l2_set_len = l2_set.length;\n    auto l1_set_max\
    \ = max(l1_set);\n    auto l2_set_max = max(l2_set);\n    auto max_len = max(l1_set_len,\
    \ l2_set_len);\n    auto max_val = max(l1_set_max, l2_set_max);\n    auto result\
    \ = new long[](max_len);\n    auto result_len = 0;\n    foreach (i; 0 .. max_val\
    \ + 1)\n    {\n        if (l1_set.count(i) && l2_set.count(i))\n        {\n  \
    \          result[result_len] = i;\n            result_len++;\n        }\n   \
    \ }\n    return result[0 .. result_len];\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7tbt3odd.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if\
    \ (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6yd4ofzv.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmp6yd4ofzv.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmp6yd4ofzv.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6yd4ofzv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            if (!result.canFind(l))\n          \
    \  {\n                result ~= l;\n            }\n        }\n    }\n    return\
    \ result;\n}\n/*\nReturn sorted unique elements for two lists.\n    >>> unique([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 2L,\
    \ 3L, 4L, 5L, 653L, 7L, 9L, 121L, 34L]\n    >>> unique([5L, 3L, 2L, 8L], [3L,\
    \ 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[] l1, long[] l2) \n{\n  \
    \  long[] result = new long[];\n    foreach (l; l1)\n    {\n        if (!result.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    foreach (l; l2)\n\
    \    {\n        if (!result.canFind(l))\n        {\n            result ~= l;\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements for\
    \ two lists.\n    >>> unique([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L,\
    \ 9L, 653L, 121L])\n    [1L, 2L, 3L, 4L, 5L, 653L, 7L, 9L, 121L, 34L]\n    >>>\
    \ unique([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] unique(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach (l; l1)\n \
    \   {\n        if (!result.can\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpw7t9ee6c.d(66): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmpw7t9ee6c.d(75):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmpw7t9ee6c.d(75):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw7t9ee6c.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4qvemtfi.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp4qvemtfi.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp4qvemtfi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto l1_set = set(l1);\n    auto l2_set = set(l2);\n    auto common_set\
    \ = l1_set.intersection(l2_set);\n    return common_set.array;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5toju9rc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4qvemtfi.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp4qvemtfi.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp4qvemtfi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto result = new long[](0);\n    auto l1_set = new long[](0);\n  \
    \  auto l2_set = new long[](0);\n    foreach(i; l1)\n    {\n        l1_set ~=\
    \ i;\n    }\n    foreach(i; l2)\n    {\n        l2_set ~= i;\n    }\n    l1_set\
    \ = sort(l1_set);\n    l2_set = sort(l2_set);\n    l1_set = unique(l1_set);\n\
    \    l2_set = unique(l2_set);\n    foreach(i; l1_set)\n    {\n        if(i in\
    \ l2_set)\n        {\n            result ~= i;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6rfnomis.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if\
    \ (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6yd4ofzv.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmp6yd4ofzv.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmp6yd4ofzv.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6yd4ofzv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyecope36.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpyecope36.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpyecope36.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyecope36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (e1; l1)\n    {\n        foreach\
    \ (e2; l2)\n        {\n            if (e1 == e2)\n            {\n            \
    \    result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppefeyf2p.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (elem; l1) \n    {\n        if (elem\
    \ in l2) \n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt2gcnceg.d(17): Error: incompatible types for `(elem) in (l2)`:
    `long` and `long[]`\n/tmp/tmpt2gcnceg.d(22): Error: no property `sort` for type
    `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt2gcnceg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyecope36.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpyecope36.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpyecope36.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyecope36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    long[] l1_sorted = sort(l1);\n \
    \   long[] l2_sorted = sort(l2);\n    long l1_len = l1_sorted.length;\n    long\
    \ l2_len = l2_sorted.length;\n    long i = 0L;\n    long j = 0L;\n    while (i\
    \ < l1_len && j < l2_len)\n    {\n        if (l1_sorted[i] == l2_sorted[j])\n\
    \        {\n            result ~= l1_sorted[i];\n            i++;\n          \
    \  j++;\n        }\n        else if (l1_sorted[i] < l2_sorted[j])\n        {\n\
    \            i++;\n        }\n        else\n        {\n            j++;\n    \
    \    }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements for two\
    \ lists.\n    >>> union([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L,\
    \ 653L, 121L])\n    [1L, 2L, 3L, 4L, 5L, 7L, 9L, 34L, 121L, 653L]\n    >>> union([5L,\
    \ 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L, 5L, 8L]\n*/\nlong[] union(long[] l1, long[]\
    \ l2) \n{\n    long[] result = new long[0L];\n    long[] l1_sorted = sort(l1);\n\
    \    long[] l2_sorted = sort(l2);\n    long l1_len = l1_sorted.length;\n    long\
    \ l2_len = l2_sorted.length;\n    long i = 0L;\n    long j = 0L;\n    while (i\
    \ < l1_len && j < l2_len)\n    {\n        if (l1_sorted[i] == l2_sorted[j])\n\
    \        {\n            result ~= l1\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph2fmj163.d(47): Error: no identifier for declarator long[]\n/tmp/tmph2fmj163.d(47):
    Error: { } expected following aggregate declaration\n/tmp/tmph2fmj163.d(47): Error:
    Declaration expected, not \''(\''\n/tmp/tmph2fmj163.d(56): Error: Declaration
    expected, not \''while\''\n/tmp/tmph2fmj163.d(65): Error: Declaration expected,
    not \''assert\''\n/tmp/tmph2fmj163.d(66): Error: Declaration expected, not \''assert\''\n/tmp/tmph2fmj163.d(67):
    Error: Declaration expected, not \''assert\''\n/tmp/tmph2fmj163.d(68): Error:
    Declaration expected, not \''assert\''\n/tmp/tmph2fmj163.d(69): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph2fmj163.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (e; l1)\n    {\n        if\
    \ (e in l2)\n        {\n            result ~= e;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa83ffp8g.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n        foreach (e2;\
    \ l2)\n        {\n            if (e1 == e2)\n            {\n                result\
    \ ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6nvylkhl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n        foreach (e2;\
    \ l2)\n        {\n            if (e1 == e2)\n            {\n                result\
    \ ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6nvylkhl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    auto l1_set = set(l1);\n    auto l2_set = set(l2);\n    auto common_set\
    \ = l1_set & l2_set;\n    return common_set.array;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqzx8zxpq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ret = new long[];\n    foreach(e; l1)\n    {\n        if(e in\
    \ l2)\n        {\n            ret ~= e;\n        }\n    }\n    return ret.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4huzhdwb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    return sort(uniq(l1)).filter!(x => l2.canFind(x));\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm2lqhtmz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            res ~= l;\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj1ac5iaq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = new long[l1.length];\n    int i = 0;\n    foreach(long\
    \ x; l1)\n    {\n        foreach(long y; l2)\n        {\n            if(x == y)\n\
    \            {\n                l3[i] = x;\n                i++;\n           \
    \ }\n        }\n    }\n    l3 = l3[0..i];\n    l3.sort();\n    l3 = l3.dup.uniq;\n\
    \    return l3;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxfnog4k3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyecope36.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpyecope36.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpyecope36.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyecope36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (e1; l1)\n    {\n        foreach (e2;\
    \ l2)\n        {\n            if (e1 == e2)\n            {\n                result\
    \ ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6nvylkhl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    long[] l1_unique = unique(l1);\n\
    \    long[] l2_unique = unique(l2);\n    foreach (l1_elem; l1_unique) \n    {\n\
    \        foreach (l2_elem; l2_unique) \n        {\n            if (l1_elem ==\
    \ l2_elem) \n            {\n                result ~= l1_elem;\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsxfuuzb6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    long[] l1_sorted = sort(l1);\n \
    \   long[] l2_sorted = sort(l2);\n    long i = 0L;\n    while (i < l1_sorted.length)\n\
    \    {\n        long j = 0L;\n        while (j < l2_sorted.length)\n        {\n\
    \            if (l1_sorted[i] == l2_sorted[j])\n            {\n              \
    \  result = result ~ l1_sorted[i];\n                break;\n            }\n  \
    \          j += 1L;\n        }\n        i += 1L;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprfit10yy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp14d_umum.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd4edwya7.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmpd4edwya7.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpd4edwya7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            if(!result.canFind(l))\n            {\n              \
    \  result ~= l;\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzxodko_e.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp14d_umum.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4qvemtfi.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp4qvemtfi.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp4qvemtfi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    foreach (l; l1)\n    {\n       \
    \ if (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n\
    \    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0m5e_vf0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (e1; l1) \n    {\n        foreach\
    \ (e2; l2) \n        {\n            if (e1 == e2) \n            {\n          \
    \      result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzco8grx7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            if (!result.canFind(l))\n            {\n             \
    \   result ~= l;\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdetfhhbz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach(l; l1)\n    {\n        foreach(r;\
    \ l2)\n        {\n            if(l == r)\n            {\n                result\
    \ ~= l;\n            }\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvsu98f76.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[l1.length];\n    int result_index = 0;\n \
    \   foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n            result[result_index]\
    \ = l;\n            result_index++;\n        }\n    }\n    return result[0..result_index];\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfmj6ttzx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (long i; l1) \n    {\n        if (l2.canFind(i))\
    \ \n        {\n            result ~= i;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr26ath3g.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659794158
