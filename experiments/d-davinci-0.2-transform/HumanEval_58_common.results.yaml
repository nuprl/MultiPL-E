language: d
name: HumanEval_58_common
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (elem; l1) \n    {\n        if (elem\
    \ in l2) \n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\n/*\nReturn sorted unique common elements for two lists.\n\
    \    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1,\
    \ 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\nunittest\n{\n   \
    \ alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgm8fodn5.d(24): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpgm8fodn5.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) {\n        if (l2.canFind(l))\
    \ {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwsvxjyig.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpwsvxjyig.d(16): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpwsvxjyig.d(20): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwsvxjyig.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyecope36.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpyecope36.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmpyecope36.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyecope36.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0L];\n    long[] l1_sorted = sort(l1);\n \
    \   long[] l2_sorted = sort(l2);\n    long i = 0L;\n    long j = 0L;\n    while\
    \ (i < l1_sorted.length && j < l2_sorted.length)\n    {\n        if (l1_sorted[i]\
    \ == l2_sorted[j])\n        {\n            result = result ~ l1_sorted[i];\n \
    \           i++;\n            j++;\n        }\n        else if (l1_sorted[i] <\
    \ l2_sorted[j])\n        {\n            i++;\n        }\n        else\n      \
    \  {\n            j++;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg8lljc2a.d(15): Error: undefined identifier `sort`, did you
    mean function `sqrt`?\n/tmp/tmpg8lljc2a.d(16): Error: undefined identifier `sort`,
    did you mean function `sqrt`?\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg8lljc2a.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result;\n}\n\
    /*\nReturn sorted unique common elements for two lists.\n    >>> common([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n\
    \    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppiyjixe_.d(24): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmppiyjixe_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (long i; l1)\n    {\n   \
    \     foreach (long j; l2)\n        {\n            if (i == j)\n            {\n\
    \                result ~= i;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpth3nlchu.d(25): Error: no property `sort` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpth3nlchu.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (l; l1) \n    {\n        if\
    \ (l2.canFind(l)) \n        {\n            result ~= l;\n        }\n    }\n  \
    \  return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6yd4ofzv.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmp6yd4ofzv.d(17): Error: no property
    `canFind` for type `long[]`\n/tmp/tmp6yd4ofzv.d(22): Error: no property `sort`
    for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6yd4ofzv.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; sort(l1))\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj4jz1inr.d(15): Error: undefined identifier `sort`, did you
    mean function `sqrt`?\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj4jz1inr.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_copy = l1.dup;\n    long[] l2_copy =\
    \ l2.dup;\n    l1_copy.sort;\n    l2_copy.sort;\n    foreach(long i; l1_copy)\n\
    \    {\n        if(l2_copy.canFind(i))\n        {\n            result ~= i;\n\
    \        }\n    }\n    return result.dup.sort.uniq;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0nwok6ve.d(17): Error: no property `sort` for type `long[]`\n/tmp/tmp0nwok6ve.d(18):
    Error: no property `sort` for type `long[]`\n/tmp/tmp0nwok6ve.d(21): Error: no
    property `canFind` for type `long[]`\n/tmp/tmp0nwok6ve.d(26): Error: no property
    `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0nwok6ve.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result;\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted\
    \ = l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    long[] l1_unique_sorted = l1_unique.sort;\n    long[]\
    \ l2_unique_sorted = l2_unique.sort;\n    long[] l1_unique_sorted_set = l1_unique_sorted.toSet.array;\n\
    \    long[] l2_unique_sorted_set = l2_unique_sorted.toSet.array;\n    long[] l1_unique_sorted_set_sorted\
    \ = l1_unique_sorted_set.sort;\n    long[] l2_unique_sorted_set_sorted = l2_unique_sorted_set.sort;\n\
    \    long[] l1_unique_sorted_set_sorted_unique = l1_unique_sorted_set_sorted.unique;\n\
    \    long[] l2_unique_sorted_set_sorted_unique = l2_unique_sorted_set_sorted.unique;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted = l1_unique_sorted_set_sorted_unique.sort;\n\
    \    long[] l2_unique_sorted_set_sorted_unique_sorted = l2_unique_sorted_set_sorted_unique.sort;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted_set = l1_unique_sorted_set_sorted_unique_sorted.toSet.array;\n\
    \    long[] l2_unique_sorted_set_sorted_unique_sorted_set = l2_unique_sorted_set_sorted_unique_sorted.toSet.array;\n\
    \    long[] l1_unique_sorted_set_sorted_unique_sorted_set_sorted = l1_unique_sorted_set_sorted_unique_sorted\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoki5f478.d(32): Error: semicolon expected, not `unittest`\n/tmp/tmpoki5f478.d(32):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpoki5f478.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = [];\n    foreach (e; l1)\n    {\n        if (e in l2)\n\
    \        {\n            res ~= e;\n        }\n    }\n    return res.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvm4rco_n.d(17): Error: incompatible types for `(e) in (l2)`:
    `long` and `long[]`\n/tmp/tmpvm4rco_n.d(22): Error: no property `sort` for type
    `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvm4rco_n.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0ouhim2e.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp0ouhim2e.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp0ouhim2e.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (elem; l1) \n    {\n        if (elem\
    \ in l2) \n        {\n            result ~= elem;\n        }\n    }\n    return\
    \ result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt2gcnceg.d(17): Error: incompatible types for `(elem) in (l2)`:
    `long` and `long[]`\n/tmp/tmpt2gcnceg.d(22): Error: no property `sort` for type
    `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt2gcnceg.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = [];\n    foreach (l; l1) \n    {\n        if (l2.canFind(l))\
    \ \n        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4qvemtfi.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmp4qvemtfi.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp4qvemtfi.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{ \n    long[] result = [];\n    foreach (l; l1)\n    {\n        if (l2.canFind(l))\n\
    \        {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpms0h_3h_.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmpms0h_3h_.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpms0h_3h_.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[];\n    foreach (e1; l1) \n    {\n       \
    \ foreach (e2; l2) \n        {\n            if (e1 == e2) \n            {\n  \
    \              result ~= e1;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpts39oks8.d(14): Error: new can only create structs, dynamic
    arrays or class objects, not `long[]`\''s\n/tmp/tmpts39oks8.d(25): Error: no property
    `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpts39oks8.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    return l1.intersect(l2).sort().uniq;\n}\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps_tp_lo1.d(16): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmps_tp_lo1.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    foreach (l; l1)\n    {\n        if\
    \ (l2.canFind(l))\n        {\n            result ~= l;\n        }\n    }\n   \
    \ return result.sort().uniq;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd4edwya7.d(17): Error: no property `canFind` for type `long[]`\n/tmp/tmpd4edwya7.d(22):
    Error: no property `sort` for type `long[]`\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpd4edwya7.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[0];\n    if (l1.length == 0 || l2.length ==\
    \ 0)\n        return result;\n    long[] l1s = l1.dup.sort;\n    long[] l2s =\
    \ l2.dup.sort;\n    long[] l1u = l1s.dup.uniq;\n    long[] l2u = l2s.dup.uniq;\n\
    \    long[] l1l = l1u.dup.length;\n    long[] l2l = l2u.dup.length;\n    long[]\
    \ l1i = l1u.dup.indices;\n    long[] l2i = l2u.dup.indices;\n    long[] l1f =\
    \ l1u.dup.front;\n    long[] l2f = l2u.dup.front;\n    long[] l1b = l1u.dup.back;\n\
    \    long[] l2b = l2u.dup.back;\n    long[] l1m = l1u.dup.mid;\n    long[] l2m\
    \ = l2u.dup.mid;\n    long[] l1e = l1u.dup.empty;\n    long[] l2e = l2u.dup.empty;\n\
    \    long[] l1r = l1u.dup.retro;\n    long[] l2r = l2u.dup.retro;\n    long[]\
    \ l1d = l1u.dup.dup;\n    long[] l2d = l2u.dup.dup;\n    long[] l1c = l1u.dup.idup;\n\
    \    long[] l2c = l2u.dup.idup;\n    long[] l1t = l1u.dup.take;\n    long[] l2t\
    \ = l2u.dup.take;\n    long[] l1g = l1u.dup.takeExactly;\n    long[] l2g = l2u.dup.takeExactly;\n\
    \    long[] l1o = l1u.dup.takeExactly;\n    long[] l2\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdos4jlbp.d(45): Error: semicolon expected, not `unittest`\n/tmp/tmpdos4jlbp.d(45):
    Error: found `unittest` instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpdos4jlbp.d", "-I/tmp"]\n'''
  stdout: b''
