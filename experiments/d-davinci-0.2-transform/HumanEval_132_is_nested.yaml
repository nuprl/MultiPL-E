name: HumanEval_132_is_nested
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
  \ takes a string as input which contains only square brackets.\n    The function\
  \ should return True if and only if there is a valid subsequence of brackets \n\
  \    where at least one bracket in the subsequence is nested.\n\n    >>> is_nested(\"\
  [[]]\")\n    true\n    >>> is_nested(\"[]]]]]]][[[[[]\")\n    false\n    >>> is_nested(\"\
  [][]\")\n    false\n    >>> is_nested(\"[]\")\n    false\n    >>> is_nested(\"[[][]]\"\
  )\n    true\n    >>> is_nested(\"[[]][[\")\n    true\n    \n*/\nbool is_nested(string\
  \ string) \n"
tests: "unittest\n{\n    alias candidate = is_nested;\n\n    assert(candidate(\"[[]]\"\
  ) == true);\n    assert(candidate(\"[]]]]]]][[[[[]\") == false);\n    assert(candidate(\"\
  [][]\") == false);\n    assert(candidate(\"[]\") == false);\n    assert(candidate(\"\
  [[[[]]]]\") == true);\n    assert(candidate(\"[]]]]]]]]]]\") == false);\n    assert(candidate(\"\
  [][][[]]\") == true);\n    assert(candidate(\"[[]\") == false);\n    assert(candidate(\"\
  []]\") == false);\n    assert(candidate(\"[[]][[\") == true);\n    assert(candidate(\"\
  [[][]]\") == true);\n    assert(candidate(\"\") == false);\n    assert(candidate(\"\
  [[[[[[[[\") == false);\n    assert(candidate(\"]]]]]]]]\") == false);\n}\nvoid main(){}"
completions: ["{\n    auto stack = new Stack!char;\n    foreach(c; string) {\n   \
    \     if(c == '[') {\n            stack.push(c);\n        } else if(c == ']')\
    \ {\n            if(stack.empty) {\n                return false;\n          \
    \  } else {\n                stack.pop();\n            }\n        }\n    }\n \
    \   return stack.empty;\n}", "{\n    int count = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n            count++;\n        else if(c == ']')\n\
    \            count--;\n        if(count < 0)\n            return false;\n    }\n\
    \    return count == 0;\n}", "{\n    // Create a stack to store the brackets\n\
    \    Stack!char stack;\n    // Iterate through the string\n    foreach(char c;\
    \ string)\n    {\n        // If the character is an opening bracket, push it onto\
    \ the stack\n        if(c == '[')\n            stack.push(c);\n        // If the\
    \ character is a closing bracket, pop the stack\n        else if(c == ']')\n \
    \       {\n            // If the stack is empty, return false\n            if(stack.empty)\n\
    \                return false;\n            stack.pop();\n        }\n    }\n \
    \   // If the stack is empty, return true\n    return stack.empty;\n}", "{\n \
    \   int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n    \
    \        count++;\n        else if(c == ']')\n            count--;\n        if(count\
    \ < 0)\n            return false;\n    }\n    return count == 0;\n}", "{\n   \
    \ int count = 0;\n    foreach(c; string)\n    {\n        if(c == '[')\n      \
    \      count++;\n        else if(c == ']')\n            count--;\n        if(count\
    \ < 0)\n            return false;\n    }\n    return count == 0;\n}", "{\n   \
    \ int count = 0;\n    foreach(char c; string)\n    {\n        if(c == '[')\n \
    \           count++;\n        else if(c == ']')\n            count--;\n      \
    \  if(count < 0)\n            return false;\n    }\n    return count == 0;\n}",
  "{\n    // Create a stack to store the brackets\n    Stack!char stack;\n    // Iterate\
    \ over the string\n    foreach(char c; string)\n    {\n        // If the character\
    \ is an opening bracket, push it to the stack\n        if(c == '[')\n        \
    \    stack.push(c);\n        // If the character is a closing bracket, pop the\
    \ stack\n        else if(c == ']')\n        {\n            // If the stack is\
    \ empty, return false\n            if(stack.empty)\n                return false;\n\
    \            // If the stack is not empty, pop the stack\n            else\n \
    \               stack.pop();\n        }\n    }\n    // If the stack is empty,\
    \ return true\n    if(stack.empty)\n        return true;\n    // If the stack\
    \ is not empty, return false\n    else\n        return false;\n}", "{\n    //\
    \ TODO\n    return false;\n}", "{\n    int count = 0;\n    foreach(c; string)\n\
    \    {\n        if(c == '[')\n            count++;\n        else if(c == ']')\n\
    \            count--;\n        if(count < 0)\n            return false;\n    }\n\
    \    return count == 0;\n}", "{\n    int count = 0;\n    foreach(c; string)\n\
    \    {\n        if(c == '[')\n            count++;\n        else if(c == ']')\n\
    \            count--;\n        if(count < 0)\n            return false;\n    }\n\
    \    return count == 0;\n}", "{\n    auto stack = new Stack!char;\n    foreach(c;\
    \ string)\n    {\n        if(c == '[')\n        {\n            stack.push(c);\n\
    \        }\n        else if(c == ']')\n        {\n            if(stack.empty)\n\
    \            {\n                return false;\n            }\n            else\n\
    \            {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return stack.empty;\n}", "{\n    bool result = false;\n    int count = 0;\n\
    \    foreach(char c; string)\n    {\n        if(c == '[')\n        {\n       \
    \     count++;\n        }\n        else if(c == ']')\n        {\n            count--;\n\
    \        }\n        if(count < 0)\n        {\n            return false;\n    \
    \    }\n    }\n    if(count > 0)\n    {\n        return false;\n    }\n    return\
    \ true;\n}", "{\n    int count = 0;\n    foreach(char c; string)\n    {\n    \
    \    if(c == '[')\n            count++;\n        else if(c == ']')\n         \
    \   count--;\n        if(count < 0)\n            return false;\n    }\n    return\
    \ count == 0;\n}", "{\n    int count = 0;\n    foreach(char c; string)\n    {\n\
    \        if(c == '[')\n            count++;\n        else if(c == ']')\n     \
    \       count--;\n        if(count < 0)\n            return false;\n    }\n  \
    \  return count == 0;\n}", "{\n    int count = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n            count++;\n        else if(c == ']')\n\
    \            count--;\n        if(count < 0)\n            return false;\n    }\n\
    \    return count == 0;\n}", "{\n    int count = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n            count++;\n        else if(c == ']')\n\
    \            count--;\n        if(count < 0)\n            return false;\n    }\n\
    \    return count == 0;\n}", "{\n    int count = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n            count++;\n        else if(c == ']')\n\
    \            count--;\n        if(count < 0)\n            return false;\n    }\n\
    \    return count == 0;\n}", "{\n    int count = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n            count++;\n        else if(c == ']')\n\
    \            count--;\n        if(count < 0)\n            return false;\n    }\n\
    \    return count == 0;\n}", "{\n    int count = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n            count++;\n        else if(c == ']')\n\
    \            count--;\n        if(count < 0)\n            return false;\n    }\n\
    \    return count == 0;\n}", "{\n    int count = 0;\n    foreach(char c; string)\n\
    \    {\n        if(c == '[')\n            count++;\n        else if(c == ']')\n\
    \            count--;\n        if(count < 0)\n            return false;\n    }\n\
    \    return count == 0;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
