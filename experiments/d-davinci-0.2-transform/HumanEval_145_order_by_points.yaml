name: HumanEval_145_order_by_points
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Write a function which\
  \ sorts the given list of integers\n    in ascending order according to the sum\
  \ of their digits.\n    Note: if there are several items with similar sum of their\
  \ digits,\n    order them based on their index in original list.\n\n    For example:\n\
  \    >>> order_by_points([1L, 11L, -1L, -11L, -12L])\n    [-1L, -11L, 1L, -12L,\
  \ 11L]\n    >>> order_by_points([])\n    []\n    \n*/\nlong[] order_by_points(long[]\
  \ nums) \n"
tests: "unittest\n{\n    alias candidate = order_by_points;\n\n    assert(candidate([1L,\
  \ 11L, -1L, -11L, -12L]) == [-1L, -11L, 1L, -12L, 11L]);\n    assert(candidate([1234L,\
  \ 423L, 463L, 145L, 2L, 423L, 423L, 53L, 6L, 37L, 3457L, 3L, 56L, 0L, 46L]) == [0L,\
  \ 2L, 3L, 6L, 53L, 423L, 423L, 423L, 1234L, 145L, 37L, 46L, 56L, 463L, 3457L]);\n\
  \    assert(candidate([]) == []);\n    assert(candidate([1L, -11L, -32L, 43L, 54L,\
  \ -98L, 2L, -3L]) == [-3L, -32L, -98L, -11L, 1L, 2L, 43L, 54L]);\n    assert(candidate([1L,\
  \ 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L]) == [1L, 10L, 2L, 11L, 3L, 4L, 5L, 6L,\
  \ 7L, 8L, 9L]);\n    assert(candidate([0L, 6L, 6L, -76L, -21L, 23L, 4L]) == [-76L,\
  \ -21L, 0L, 4L, 23L, 6L, 6L]);\n}\nvoid main(){}"
completions: ["{\n    long[] result = new long[nums.length];\n    int[] sums = new\
    \ int[nums.length];\n    foreach(i, n; nums)\n    {\n        sums[i] = sumDigits(n);\n\
    \    }\n    auto sorted = sort(zip(sums, nums));\n    foreach(i, t; sorted)\n\
    \    {\n        result[i] = t[1];\n    }\n    return result;\n}", "{\n    // your\
    \ code here\n    long[] result = new long[nums.length];\n    int[] sum = new int[nums.length];\n\
    \    for(int i = 0; i < nums.length; i++)\n    {\n        int temp = nums[i];\n\
    \        if(temp < 0)\n            temp = -temp;\n        while(temp != 0)\n \
    \       {\n            sum[i] += temp % 10;\n            temp /= 10;\n       \
    \ }\n    }\n    int[] index = new int[nums.length];\n    for(int i = 0; i < nums.length;\
    \ i++)\n        index[i] = i;\n    for(int i = 0; i < nums.length; i++)\n    {\n\
    \        for(int j = i + 1; j < nums.length; j++)\n        {\n            if(sum[i]\
    \ > sum[j])\n            {\n                int temp = sum[i];\n             \
    \   sum[i] = sum[j];\n                sum[j] = temp;\n                temp = index[i];\n\
    \                index[i] = index[j];\n                index[j] = temp;\n    \
    \        }\n            else if(sum[i] == sum[j])\n            {\n           \
    \     if(index[i] > index[j])\n                {\n                    int temp\
    \ = index[i];\n                    index[i] = index[j];\n                    index[j]\
    \ = temp;\n                }\n            }\n        }\n    }\n    for(int i =\
    \ 0; i < nums.length; i++)\n        result[i] = nums[index[i]];\n    return result;\n\
    }", "{\n    long[] result = new long[nums.length];\n    int[] sums = new int[nums.length];\n\
    \    for (int i = 0; i < nums.length; i++)\n    {\n        sums[i] = sumDigits(nums[i]);\n\
    \    }\n    int[] sorted = sort(sums);\n    for (int i = 0; i < nums.length; i++)\n\
    \    {\n        result[i] = nums[sorted[i]];\n    }\n    return result;\n}", "{\n\
    \    if (nums.length == 0)\n        return nums;\n    long[] sums = new long[nums.length];\n\
    \    foreach (i, v; nums)\n    {\n        long sum = 0;\n        foreach (c; v.to!string)\n\
    \        {\n            if (c >= '0' && c <= '9')\n                sum += c -\
    \ '0';\n        }\n        sums[i] = sum;\n    }\n    auto sorted = zip(sums,\
    \ nums).sort!((a, b) => a[0] < b[0]);\n    return sorted.map!(a => a[1]).array;\n\
    }", "{\n    auto result = nums.dup;\n    auto sums = new long[nums.length];\n\
    \    foreach(i, num; nums)\n    {\n        sums[i] = sumDigits(num);\n    }\n\
    \    sort!((a, b) => a < b)(result, sums);\n    return result;\n}", "{\n    if\
    \ (nums.length == 0)\n        return nums;\n    auto nums_with_points = new Tuple!(long,\
    \ long)[nums.length];\n    foreach (i, num; nums)\n    {\n        nums_with_points[i]\
    \ = tuple(num, sum_of_digits(num));\n    }\n    nums_with_points.sort!((a, b)\
    \ => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    foreach (i, num; nums_with_points)\n\
    \    {\n        nums[i] = num[0];\n    }\n    return nums;\n}", "{\n    long[]\
    \ result;\n    int[] sum;\n    int i;\n    int j;\n    int temp;\n    int temp2;\n\
    \    int temp3;\n    int temp4;\n    int temp5;\n    int temp6;\n    int temp7;\n\
    \    int temp8;\n    int temp9;\n    int temp10;\n    int temp11;\n    int temp12;\n\
    \    int temp13;\n    int temp14;\n    int temp15;\n    int temp16;\n    int temp17;\n\
    \    int temp18;\n    int temp19;\n    int temp20;\n    int temp21;\n    int temp22;\n\
    \    int temp23;\n    int temp24;\n    int temp25;\n    int temp26;\n    int temp27;\n\
    \    int temp28;\n    int temp29;\n    int temp30;\n    int temp31;\n    int temp32;\n\
    \    int temp33;\n    int temp34;\n    int temp35;\n    int temp36;\n    int temp37;\n\
    \    int temp38;\n    int temp39;\n    int temp40;\n    int temp41;\n    int temp42;\n\
    \    int temp43;\n    int temp44;\n    int temp45;\n    int temp46;\n    int temp47;\n\
    \    int temp48;\n    int temp49;\n    int temp50;\n    int temp51;\n    int temp52;\n\
    \    int temp53;\n    int temp54;\n    int temp55;\n    int temp56;\n    int temp57;\n\
    \    int temp58;\n    int temp59;\n    int temp60;\n    int temp61;\n    int temp62;\n\
    \    int temp63;\n    int temp64;\n    int temp65;\n    int temp66;\n    int temp67;\n\
    \    int temp68;\n    int temp69;\n    int temp70;\n    int temp71;\n    int temp72;\n\
    \    int temp73;\n    int temp74;\n    int temp75;\n    int temp76;\n    int temp77;\n\
    \    int temp78;\n    int temp79;\n    int temp80;\n    int temp81;\n    int",
  "{\n    long[] result;\n    int[] sums;\n    int i;\n    int j;\n    int temp;\n\
    \    int temp2;\n    int sum;\n    int[] indices;\n    int[] indices2;\n    int[]\
    \ indices3;\n    int[] indices4;\n    int[] indices5;\n    int[] indices6;\n \
    \   int[] indices7;\n    int[] indices8;\n    int[] indices9;\n    int[] indices10;\n\
    \    int[] indices11;\n    int[] indices12;\n    int[] indices13;\n    int[] indices14;\n\
    \    int[] indices15;\n    int[] indices16;\n    int[] indices17;\n    int[] indices18;\n\
    \    int[] indices19;\n    int[] indices20;\n    int[] indices21;\n    int[] indices22;\n\
    \    int[] indices23;\n    int[] indices24;\n    int[] indices25;\n    int[] indices26;\n\
    \    int[] indices27;\n    int[] indices28;\n    int[] indices29;\n    int[] indices30;\n\
    \    int[] indices31;\n    int[] indices32;\n    int[] indices33;\n    int[] indices34;\n\
    \    int[] indices35;\n    int[] indices36;\n    int[] indices37;\n    int[] indices38;\n\
    \    int[] indices39;\n    int[] indices40;\n    int[] indices41;\n    int[] indices42;\n\
    \    int[] indices43;\n    int[] indices44;\n    int[] indices45;\n    int[] indices46;\n\
    \    int[] indices47;\n    int[] indices48;\n    int[] indices49;\n    int[] indices50;\n\
    \    int[] indices51;\n    int[] indices52;\n    int[] indices53;\n    int[] indices54;\n\
    \    int[] indices55;\n    int[] indices56;\n    int[] indices57;\n    int[] indices58;\n\
    \    int[] indices59;\n    int[] indices60;\n    int[] indices61;\n    int[] indices62;\n\
    \    int[] indices63;\n    int[] indices64;\n    int[] indices65;\n    int[] indices66;\n\
    \    int[] indices67;\n    int[]", "{\n    auto nums_with_points = nums.map!(x\
    \ => tuple(x, x.abs.sumOfDigits));\n    nums_with_points.sort!((a, b) => a[1]\
    \ < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return nums_with_points.map!(x\
    \ => x[0]).array;\n}", "{\n    auto nums_with_points = zip(nums, map!(a => a.reduce!((a,\
    \ b) => a + b).to!long)(map!(a => a.to!string.map!(a => a.to!long).array)(nums)));\n\
    \    nums_with_points.sort!((a, b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n\
    \    return nums_with_points.map!(a => a[0]).array;\n}", "{\n    long[] result\
    \ = nums.dup;\n    sort!((a, b) => sumDigits(a) < sumDigits(b))(result);\n   \
    \ return result;\n}", "{\n    if (nums.length == 0)\n        return nums;\n  \
    \  else\n    {\n        long[] sums = new long[nums.length];\n        foreach\
    \ (i, n; nums)\n        {\n            long sum = 0;\n            foreach (c;\
    \ to!string(n))\n                sum += c.to!long - '0'.to!long;\n           \
    \ sums[i] = sum;\n        }\n        auto zipped = zip(nums, sums);\n        zipped.sort!((a,\
    \ b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n        return zipped.map!(a\
    \ => a[0]).array;\n    }\n}", "{\n    if (nums.length == 0)\n        return nums;\n\
    \    auto sum = new long[nums.length];\n    foreach (i, ref n; nums)\n    {\n\
    \        long s = 0;\n        while (n != 0)\n        {\n            s += n %\
    \ 10;\n            n /= 10;\n        }\n        sum[i] = s;\n    }\n    auto t\
    \ = tuple(nums, sum);\n    t.sort!((a, b) => a[1] < b[1] || (a[1] == b[1] && a[0]\
    \ < b[0]));\n    return t[0];\n}", "{\n    auto result = nums.dup;\n    auto sums\
    \ = new long[result.length];\n    foreach(i, ref n; result)\n    {\n        sums[i]\
    \ = sumDigits(n);\n    }\n    sort!(\"a < b\", \"a > b\")(result, sums);\n   \
    \ return result;\n}", "{\n    long[] result = new long[nums.length];\n    int[][]\
    \ sums = new int[nums.length][2];\n    for (int i = 0; i < nums.length; i++)\n\
    \    {\n        sums[i][0] = i;\n        sums[i][1] = nums[i] < 0 ? -nums[i] :\
    \ nums[i];\n        while (sums[i][1] > 0)\n        {\n            sums[i][1]\
    \ = sums[i][1] / 10;\n            sums[i][1] += nums[i] % 10;\n        }\n   \
    \ }\n    sums.sort!((a, b) => a[1] < b[1]);\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        result[i] = nums[sums[i][0]];\n    }\n    return result;\n\
    }", "{\n    if (nums.length == 0)\n        return nums;\n    int[] sums = new\
    \ int[nums.length];\n    foreach (i, n; nums)\n    {\n        int sum = 0;\n \
    \       while (n != 0)\n        {\n            sum += n % 10;\n            n /=\
    \ 10;\n        }\n        sums[i] = sum;\n    }\n    auto sorted = sort(zip(sums,\
    \ nums));\n    return map!(a => a[1])(sorted);\n}", "{\n    if (nums.length ==\
    \ 0)\n        return nums;\n    auto sum = new long[nums.length];\n    foreach\
    \ (i, v; nums)\n    {\n        sum[i] = v.abs;\n        while (sum[i] >= 10)\n\
    \        {\n            sum[i] = sum[i] / 10 + sum[i] % 10;\n        }\n    }\n\
    \    auto t = tuple(nums, sum);\n    t.sort!((a, b) => a[1] < b[1] || (a[1] ==\
    \ b[1] && a[0] < b[0]));\n    return t.map!(a => a[0]).array;\n}", "{\n    return\
    \ nums.sort!((a, b) => sumDigits(a) < sumDigits(b));\n}", "{\n    struct Points\n\
    \    {\n        long num;\n        long points;\n        size_t index;\n    }\n\
    \    Points[] points;\n    foreach(i, num; nums)\n    {\n        long sum = 0;\n\
    \        foreach(c; num.to!string)\n        {\n            if(c.isDigit)\n   \
    \             sum += c.to!long;\n        }\n        points ~= Points(num, sum,\
    \ i);\n    }\n    sort!((a, b) => a.points < b.points || (a.points == b.points\
    \ && a.index < b.index))(points);\n    return points.map!(a => a.num).array;\n\
    }", "{\n    if (nums.length == 0) return nums;\n    long[] sums = new long[nums.length];\n\
    \    for (int i = 0; i < nums.length; i++)\n    {\n        long sum = 0;\n   \
    \     long num = nums[i];\n        while (num != 0)\n        {\n            sum\
    \ += num % 10;\n            num /= 10;\n        }\n        sums[i] = sum;\n  \
    \  }\n    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        long min = sums[0];\n        int min_index = 0;\n     \
    \   for (int j = 1; j < nums.length; j++)\n        {\n            if (sums[j]\
    \ < min)\n            {\n                min = sums[j];\n                min_index\
    \ = j;\n            }\n        }\n        result[i] = nums[min_index];\n     \
    \   sums[min_index] = long.max;\n    }\n    return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
