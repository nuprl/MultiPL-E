language: d
name: HumanEval_136_largest_smallest_integers
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(elem; lst) \n    {\n        if (elem\
    \ < 0) \n        {\n            if (largest_negative is null || largest_negative\
    \ < elem) \n            {\n                largest_negative = elem;\n        \
    \    }\n        } \n        else if (elem > 0) \n        {\n            if (smallest_positive\
    \ is null || smallest_positive > elem) \n            {\n                smallest_positive\
    \ = elem;\n            }\n        }\n    }\n    return tuple(largest_negative,\
    \ smallest_positive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm2_yhod_.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpm2_yhod_.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpm2_yhod_.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpm2_yhod_.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm2_yhod_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n        \
    \    if(largestNegative is null || l > largestNegative)\n            {\n     \
    \           largestNegative = l;\n            }\n        }\n        else if(l\
    \ > 0)\n        {\n            if(smallestPositive is null || l < smallestPositive)\n\
    \            {\n                smallestPositive = l;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3nd017rc.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp3nd017rc.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3nd017rc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null || i > largest_negative)\n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0)\n        {\n            if(smallest_positive is null\
    \ || i < smallest_positive)\n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbz_0nt6c.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbz_0nt6c.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbz_0nt6c.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpbz_0nt6c.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbz_0nt6c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = Nullable!(long)();\n    Nullable!(long)\
    \ smallest_positive = Nullable!(long)();\n    foreach(l; lst)\n    {\n       \
    \ if(l < 0)\n        {\n            if(largest_negative.isNull || l > largest_negative.get)\n\
    \            {\n                largest_negative = Nullable!(long)(l);\n     \
    \       }\n        }\n        else if(l > 0)\n        {\n            if(smallest_positive.isNull\
    \ || l < smallest_positive.get)\n            {\n                smallest_positive\
    \ = Nullable!(long)(l);\n            }\n        }\n    }\n    return tuple(largest_negative,\
    \ smallest_positive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164171
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(l; lst) \n    {\n        if(l < 0) \n\
    \        {\n            if(largest_negative is null || l > largest_negative) \n\
    \            {\n                largest_negative = l;\n            }\n       \
    \ }\n        else if(l > 0) \n        {\n            if(smallest_positive is null\
    \ || l < smallest_positive) \n            {\n                smallest_positive\
    \ = l;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp08tgk3td.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp08tgk3td.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp08tgk3td.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp08tgk3td.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp08tgk3td.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largest is null || i > largest)\n            {\n                largest\
    \ = i;\n            }\n        }\n        else if(i > 0)\n        {\n        \
    \    if(smallest is null || i < smallest)\n            {\n                smallest\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp76md2bjk.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp76md2bjk.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp76md2bjk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n        \
    \    if(largestNegative.isNull || largestNegative.get > l)\n            {\n  \
    \              largestNegative = l;\n            }\n        }\n        else if(l\
    \ > 0)\n        {\n            if(smallestPositive.isNull || smallestPositive.get\
    \ < l)\n            {\n                smallestPositive = l;\n            }\n\
    \        }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxi2p8xct.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpxi2p8xct.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxi2p8xct.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = Nullable!(long)();\n    Nullable!(long)\
    \ smallestPositive = Nullable!(long)();\n    foreach(i; lst)\n    {\n        if(i\
    \ < 0)\n        {\n            if(!largestNegative.isNull)\n            {\n  \
    \              if(i > largestNegative.get)\n                {\n              \
    \      largestNegative.set(i);\n                }\n            }\n           \
    \ else\n            {\n                largestNegative.set(i);\n            }\n\
    \        }\n        else if(i > 0)\n        {\n            if(!smallestPositive.isNull)\n\
    \            {\n                if(i < smallestPositive.get)\n               \
    \ {\n                    smallestPositive.set(i);\n                }\n       \
    \     }\n            else\n            {\n                smallestPositive.set(i);\n\
    \            }\n        }\n    }\n    return tuple(largestNegative, smallestPositive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4mf9v3ms.d(31): Error: no property `set` for type `Nullable!long`,
    did you mean `std.typecons.Nullable!long.Nullable.get`?

    /tmp/tmp4mf9v3ms.d(36): Error: no property `set` for type `Nullable!long`, did
    you mean `std.typecons.Nullable!long.Nullable.get`?

    /tmp/tmp4mf9v3ms.d(45): Error: no property `set` for type `Nullable!long`, did
    you mean `std.typecons.Nullable!long.Nullable.get`?

    /tmp/tmp4mf9v3ms.d(50): Error: no property `set` for type `Nullable!long`, did
    you mean `std.typecons.Nullable!long.Nullable.get`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4mf9v3ms.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst) \n    {\n        if(i < 0) \n        {\n      \
    \      if(largestNegative is null || i > largestNegative) \n            {\n  \
    \              largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0) \n        {\n            if(smallestPositive is null || i < smallestPositive)\
    \ \n            {\n                smallestPositive = i;\n            }\n    \
    \    }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp643tskkj.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp643tskkj.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp643tskkj.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp643tskkj.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp643tskkj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(num; lst) \n    {\n        if(num < 0)\
    \ \n        {\n            if(largest_negative is null || num > largest_negative)\
    \ \n            {\n                largest_negative = num;\n            }\n  \
    \      }\n        else if(num > 0) \n        {\n            if(smallest_positive\
    \ is null || num < smallest_positive) \n            {\n                smallest_positive\
    \ = num;\n            }\n        }\n    }\n    return tuple(largest_negative,\
    \ smallest_positive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeg1t_k6h.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpeg1t_k6h.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpeg1t_k6h.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpeg1t_k6h.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeg1t_k6h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largest is null || i > largest)\n            {\n                largest\
    \ = i;\n            }\n        }\n        else if(i > 0)\n        {\n        \
    \    if(smallest is null || i < smallest)\n            {\n                smallest\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp76md2bjk.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp76md2bjk.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp76md2bjk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null || i > largest_negative)\n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0)\n        {\n            if(smallest_positive is null\
    \ || i < smallest_positive)\n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbz_0nt6c.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbz_0nt6c.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbz_0nt6c.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpbz_0nt6c.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbz_0nt6c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null || i > largest_negative)\n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0)\n        {\n            if(smallest_positive is null\
    \ || i < smallest_positive)\n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbz_0nt6c.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbz_0nt6c.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbz_0nt6c.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpbz_0nt6c.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbz_0nt6c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(l; lst) \n    {\n        if(l < 0) \n\
    \        {\n            if(largest_negative is null || l > largest_negative) \n\
    \            {\n                largest_negative = l;\n            }\n       \
    \ }\n        else if(l > 0) \n        {\n            if(smallest_positive is null\
    \ || l < smallest_positive) \n            {\n                smallest_positive\
    \ = l;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp08tgk3td.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp08tgk3td.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp08tgk3td.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp08tgk3td.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp08tgk3td.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n        \
    \    if(largestNegative is null || l > largestNegative)\n            {\n     \
    \           largestNegative = l;\n            }\n        }\n        else if(l\
    \ > 0)\n        {\n            if(smallestPositive is null || l < smallestPositive)\n\
    \            {\n                smallestPositive = l;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3nd017rc.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp3nd017rc.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3nd017rc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largest is null || i > largest)\n            {\n                largest\
    \ = i;\n            }\n        }\n        else if(i > 0)\n        {\n        \
    \    if(smallest is null || i < smallest)\n            {\n                smallest\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp76md2bjk.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp76md2bjk.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp76md2bjk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = Nullable!(long).init;\n    Nullable!(long)\
    \ smallest = Nullable!(long).init;\n    foreach(i; lst)\n    {\n        if(i <\
    \ 0)\n        {\n            if(largest.isNull || largest.get > i)\n         \
    \   {\n                largest = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallest.isNull || smallest.get < i)\n     \
    \       {\n                smallest = i;\n            }\n        }\n    }\n  \
    \  return tuple(largest, smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmputgtkqr2.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x456979]

    ??:? void tmputgtkqr2.__unittest_L42_C1() [0x441f11]

    ??:? void tmputgtkqr2.__modtest() [0x454488]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x45f97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x455fa6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45b1bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45b24c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45b149]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x455f7d]

    ??:? runModuleUnitTests [0x45f751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x457904]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164171
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largest is null || i > largest)\n            {\n                largest\
    \ = i;\n            }\n        }\n        else if(i > 0)\n        {\n        \
    \    if(smallest is null || i < smallest)\n            {\n                smallest\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp76md2bjk.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp76md2bjk.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp76md2bjk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null || i > largest_negative)\n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0)\n        {\n            if(smallest_positive is null\
    \ || i < smallest_positive)\n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbz_0nt6c.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbz_0nt6c.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbz_0nt6c.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpbz_0nt6c.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbz_0nt6c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_neg = null;\n    Nullable!(long) smallest_pos\
    \ = null;\n    foreach(elem; lst)\n    {\n        if(elem < 0)\n        {\n  \
    \          if(largest_neg is null)\n            {\n                largest_neg\
    \ = elem;\n            }\n            else\n            {\n                largest_neg\
    \ = max(largest_neg, elem);\n            }\n        }\n        else if(elem >\
    \ 0)\n        {\n            if(smallest_pos is null)\n            {\n       \
    \         smallest_pos = elem;\n            }\n            else\n            {\n\
    \                smallest_pos = min(smallest_pos, elem);\n            }\n    \
    \    }\n    }\n    return tuple(largest_neg, smallest_pos);\n}\nunittest\n{\n\
    \    alias candidate = largest_smallest_integers;\n\n{\n        auto result =\
    \ candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n  \
    \      assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw41p003r.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpw41p003r.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpw41p003r.d(27): Error: incompatible types for `(largest_neg) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpw41p003r.d(33): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpw41p003r.d(38): Error: incompatible types for `(smallest_pos) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpw41p003r.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw41p003r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_neg = Nullable!(long)();\n    Nullable!(long)\
    \ smallest_pos = Nullable!(long)();\n    foreach(elem; lst) \n    {\n        if\
    \ (elem < 0) \n        {\n            if (largest_neg.isNull || elem > largest_neg.get)\
    \ \n            {\n                largest_neg = Nullable!(long)(elem);\n    \
    \        }\n        } \n        else if (elem > 0) \n        {\n            if\
    \ (smallest_pos.isNull || elem < smallest_pos.get) \n            {\n         \
    \       smallest_pos = Nullable!(long)(elem);\n            }\n        }\n    }\n\
    \    return tuple(largest_neg, smallest_pos);\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164171
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null)\n            {\n         \
    \       largest_negative = i;\n            }\n            else\n            {\n\
    \                largest_negative = max(largest_negative, i);\n            }\n\
    \        }\n        else if(i > 0)\n        {\n            if(smallest_positive\
    \ is null)\n            {\n                smallest_positive = i;\n          \
    \  }\n            else\n            {\n                smallest_positive = min(smallest_positive,\
    \ i);\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5hcradp1.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(33): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp5hcradp1.d(38): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5hcradp1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n        \
    \    if(largestNegative is null || l > largestNegative)\n            {\n     \
    \           largestNegative = l;\n            }\n        }\n        else if(l\
    \ > 0)\n        {\n            if(smallestPositive is null || l < smallestPositive)\n\
    \            {\n                smallestPositive = l;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3nd017rc.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp3nd017rc.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3nd017rc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = Nullable!(long).init;\n    Nullable!(long)\
    \ smallest = Nullable!(long).init;\n    foreach(i; lst)\n    {\n        if(i <\
    \ 0)\n        {\n            if(largest.isNull || i > largest.get)\n         \
    \   {\n                largest = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallest.isNull || i < smallest.get)\n     \
    \       {\n                smallest = i;\n            }\n        }\n    }\n  \
    \  return tuple(largest, smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164171
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(item; lst)\n    {\n        if(item < 0)\n        {\n  \
    \          if(largestNegative is null || item > largestNegative)\n           \
    \ {\n                largestNegative = item;\n            }\n        }\n     \
    \   else if(item > 0)\n        {\n            if(smallestPositive is null || item\
    \ < smallestPositive)\n            {\n                smallestPositive = item;\n\
    \            }\n        }\n    }\n    return tuple(largestNegative, smallestPositive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp37rg588n.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp37rg588n.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp37rg588n.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp37rg588n.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp37rg588n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = Nullable!(long)();\n    Nullable!(long)\
    \ smallest_positive = Nullable!(long)();\n    foreach(i; lst)\n    {\n       \
    \ if(i < 0)\n        {\n            if(largest_negative.isNull || i > largest_negative.get)\n\
    \            {\n                largest_negative = Nullable!(long)(i);\n     \
    \       }\n        }\n        else if(i > 0)\n        {\n            if(smallest_positive.isNull\
    \ || i < smallest_positive.get)\n            {\n                smallest_positive\
    \ = Nullable!(long)(i);\n            }\n        }\n    }\n    return tuple(largest_negative,\
    \ smallest_positive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164171
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_neg = null;\n    Nullable!(long) smallest_pos\
    \ = null;\n    foreach(elem; lst)\n    {\n        if(elem < 0)\n        {\n  \
    \          if(largest_neg is null || elem > largest_neg)\n            {\n    \
    \            largest_neg = elem;\n            }\n        }\n        else if(elem\
    \ > 0)\n        {\n            if(smallest_pos is null || elem < smallest_pos)\n\
    \            {\n                smallest_pos = elem;\n            }\n        }\n\
    \    }\n    return tuple(largest_neg, smallest_pos);\n}\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5r1g8ful.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5r1g8ful.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5r1g8ful.d(27): Error: incompatible types for `(largest_neg) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp5r1g8ful.d(34): Error: incompatible types for `(smallest_pos) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5r1g8ful.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n        \
    \    if(largestNegative is null || l > largestNegative)\n            {\n     \
    \           largestNegative = l;\n            }\n        }\n        else if(l\
    \ > 0)\n        {\n            if(smallestPositive is null || l < smallestPositive)\n\
    \            {\n                smallestPositive = l;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3nd017rc.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp3nd017rc.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3nd017rc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    auto largest = Nullable!(long)();\n    auto smallest = Nullable!(long)();\n\
    \    foreach(e; lst)\n    {\n        if(e < 0)\n        {\n            if(largest.isNull\
    \ || e > largest.get)\n            {\n                largest = e;\n         \
    \   }\n        }\n        else if(e > 0)\n        {\n            if(smallest.isNull\
    \ || e < smallest.get)\n            {\n                smallest = e;\n       \
    \     }\n        }\n    }\n    return tuple(largest, smallest);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164171
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative.isNull || largest_negative < i)\n \
    \           {\n                largest_negative = i;\n            }\n        }\n\
    \        else if(i > 0)\n        {\n            if(smallest_positive.isNull ||\
    \ smallest_positive > i)\n            {\n                smallest_positive = i;\n\
    \            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2gxh94jk.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp2gxh94jk.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2gxh94jk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = Nullable!(long)();\n    Nullable!(long)\
    \ smallestPositive = Nullable!(long)();\n    foreach(i; lst)\n    {\n        if(i\
    \ < 0)\n        {\n            if(largestNegative.isNull || largestNegative.get\
    \ > i)\n            {\n                largestNegative = Nullable!(long)(i);\n\
    \            }\n        }\n        else if(i > 0)\n        {\n            if(smallestPositive.isNull\
    \ || smallestPositive.get > i)\n            {\n                smallestPositive\
    \ = Nullable!(long)(i);\n            }\n        }\n    }\n    return tuple(largestNegative,\
    \ smallestPositive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_3fu6gea.d(90): unittest failure

    ----------------

    ??:? _d_unittestp [0x456961]

    ??:? void tmp_3fu6gea.__unittest_L42_C1() [0x44234f]

    ??:? void tmp_3fu6gea.__modtest() [0x45446c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x45f963]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x455f8e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45b1a5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45b234]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45b131]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x455f65]

    ??:? runModuleUnitTests [0x45f739]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4578ec]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164171
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst) \n    {\n        if(i < 0) \n\
    \        {\n            if(largest_negative.isNull || i > largest_negative.get)\
    \ \n            {\n                largest_negative = i;\n            }\n    \
    \    }\n        else if(i > 0) \n        {\n            if(smallest_positive.isNull\
    \ || i < smallest_positive.get) \n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpztywjd5r.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpztywjd5r.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpztywjd5r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largest is null || i > largest)\n            {\n                largest\
    \ = i;\n            }\n        }\n        else if(i > 0)\n        {\n        \
    \    if(smallest is null || i < smallest)\n            {\n                smallest\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp76md2bjk.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp76md2bjk.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp76md2bjk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst) \n    {\n        if(i < 0) \n\
    \        {\n            if(largest_negative is null || i > largest_negative) \n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0) \n        {\n            if(smallest_positive is null\
    \ || i < smallest_positive) \n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp43ti6gcx.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp43ti6gcx.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp43ti6gcx.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp43ti6gcx.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp43ti6gcx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n \
    \       {\n            if(largest_negative is null || l > largest_negative)\n\
    \            {\n                largest_negative = l;\n            }\n       \
    \ }\n        else if(l > 0)\n        {\n            if(smallest_positive is null\
    \ || l < smallest_positive)\n            {\n                smallest_positive\
    \ = l;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm71wmah2.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpm71wmah2.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpm71wmah2.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpm71wmah2.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm71wmah2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = Nullable!(long).init;\n    Nullable!(long)\
    \ smallest = Nullable!(long).init;\n    foreach(i; lst)\n    {\n        if(i <\
    \ 0)\n        {\n            if(largest.isNull || i > largest.get)\n         \
    \   {\n                largest = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallest.isNull || i < smallest.get)\n     \
    \       {\n                smallest = i;\n            }\n        }\n    }\n  \
    \  return tuple(largest, smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164171
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(num; lst) \n    {\n        if(num < 0L)\
    \ \n        {\n            if(largest_negative is null || num > largest_negative)\
    \ \n            {\n                largest_negative = num;\n            }\n  \
    \      }\n        else if(num > 0L) \n        {\n            if(smallest_positive\
    \ is null || num < smallest_positive) \n            {\n                smallest_positive\
    \ = num;\n            }\n        }\n    }\n    return tuple(largest_negative,\
    \ smallest_positive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq8l5i8hq.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpq8l5i8hq.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpq8l5i8hq.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpq8l5i8hq.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq8l5i8hq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst) \n    {\n        if(i < 0) \n\
    \        {\n            if(largest_negative is null || i > largest_negative) \n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0) \n        {\n            if(smallest_positive is null\
    \ || i < smallest_positive) \n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp43ti6gcx.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp43ti6gcx.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp43ti6gcx.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp43ti6gcx.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp43ti6gcx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n        \
    \    if(largestNegative is null || l > largestNegative)\n            {\n     \
    \           largestNegative = l;\n            }\n        }\n        else if(l\
    \ > 0)\n        {\n            if(smallestPositive is null || l < smallestPositive)\n\
    \            {\n                smallestPositive = l;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3nd017rc.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp3nd017rc.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3nd017rc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(elem; lst)\n    {\n        if(elem < 0L)\n        {\n \
    \           if(largestNegative is null || elem > largestNegative)\n          \
    \  {\n                largestNegative = elem;\n            }\n        }\n    \
    \    else if(elem > 0L)\n        {\n            if(smallestPositive is null ||\
    \ elem < smallestPositive)\n            {\n                smallestPositive =\
    \ elem;\n            }\n        }\n    }\n    return tuple(largestNegative, smallestPositive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_had4x4g.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp_had4x4g.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp_had4x4g.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp_had4x4g.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_had4x4g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n \
    \       {\n            if(largest_negative is null || l > largest_negative)\n\
    \            {\n                largest_negative = l;\n            }\n       \
    \ }\n        else if(l > 0)\n        {\n            if(smallest_positive is null\
    \ || l < smallest_positive)\n            {\n                smallest_positive\
    \ = l;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm71wmah2.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpm71wmah2.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpm71wmah2.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpm71wmah2.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm71wmah2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = Nullable!(long).init;\n    Nullable!(long)\
    \ smallest = Nullable!(long).init;\n    foreach(x; lst) \n    {\n        if (x\
    \ < 0) \n        {\n            if (largest.isNull || largest.get > x) \n    \
    \        {\n                largest = x;\n            }\n        }\n        else\
    \ if (x > 0) \n        {\n            if (smallest.isNull || smallest.get < x)\
    \ \n            {\n                smallest = x;\n            }\n        }\n \
    \   }\n    return tuple(largest, smallest);\n}\nunittest\n{\n    alias candidate\
    \ = largest_smallest_integers;\n\n{\n        auto result = candidate([2L, 4L,\
    \ 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpn40cx15c.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x456979]

    ??:? void tmpn40cx15c.__unittest_L42_C1() [0x441f11]

    ??:? void tmpn40cx15c.__modtest() [0x454488]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x45f97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x455fa6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45b1bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45b24c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45b149]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x455f7d]

    ??:? runModuleUnitTests [0x45f751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x457904]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164173
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = Nullable!(long).init;\n    Nullable!(long)\
    \ smallest = Nullable!(long).init;\n    foreach(i; lst)\n    {\n        if(i <\
    \ 0)\n        {\n            if(largest.isNull || i > largest.get)\n         \
    \   {\n                largest = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallest.isNull || i < smallest.get)\n     \
    \       {\n                smallest = i;\n            }\n        }\n    }\n  \
    \  return tuple(largest, smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164171
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = Nullable!(long)();\n    Nullable!(long)\
    \ smallestPositive = Nullable!(long)();\n    foreach(l; lst)\n    {\n        if(l\
    \ < 0)\n        {\n            if(largestNegative.isNull || l > largestNegative.get)\n\
    \            {\n                largestNegative = Nullable!(long)(l);\n      \
    \      }\n        }\n        else if(l > 0)\n        {\n            if(smallestPositive.isNull\
    \ || l < smallestPositive.get)\n            {\n                smallestPositive\
    \ = Nullable!(long)(l);\n            }\n        }\n    }\n    return tuple(largestNegative,\
    \ smallestPositive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164173
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(elem; lst)\n    {\n        if(elem <\
    \ 0)\n        {\n            if(largest_negative is null)\n            {\n   \
    \             largest_negative = elem;\n            }\n            else\n    \
    \        {\n                largest_negative = max(largest_negative, elem);\n\
    \            }\n        }\n        else if(elem > 0)\n        {\n            if(smallest_positive\
    \ is null)\n            {\n                smallest_positive = elem;\n       \
    \     }\n            else\n            {\n                smallest_positive =\
    \ min(smallest_positive, elem);\n            }\n        }\n    }\n    return tuple(largest_negative,\
    \ smallest_positive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn102y5_2.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpn102y5_2.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpn102y5_2.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpn102y5_2.d(33): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmpn102y5_2.d(38): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    /tmp/tmpn102y5_2.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn102y5_2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n        \
    \    if(largestNegative is null || l > largestNegative)\n            {\n     \
    \           largestNegative = l;\n            }\n        }\n        else if(l\
    \ > 0)\n        {\n            if(smallestPositive is null || l < smallestPositive)\n\
    \            {\n                smallestPositive = l;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3nd017rc.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp3nd017rc.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3nd017rc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n \
    \       {\n            if(largest_negative is null)\n            {\n         \
    \       largest_negative = l;\n            }\n            else\n            {\n\
    \                largest_negative = max(largest_negative, l);\n            }\n\
    \        }\n        else if(l > 0)\n        {\n            if(smallest_positive\
    \ is null)\n            {\n                smallest_positive = l;\n          \
    \  }\n            else\n            {\n                smallest_positive = min(smallest_positive,\
    \ l);\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3sxf5rxr.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3sxf5rxr.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3sxf5rxr.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp3sxf5rxr.d(33): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp3sxf5rxr.d(38): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    /tmp/tmp3sxf5rxr.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3sxf5rxr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = Nullable!(long)();\n    Nullable!(long)\
    \ smallestPositive = Nullable!(long)();\n    foreach(i; lst)\n    {\n        if(i\
    \ < 0)\n        {\n            if(largestNegative.isNull || i > largestNegative.get)\n\
    \            {\n                largestNegative = Nullable!(long)(i);\n      \
    \      }\n        }\n        else if(i > 0)\n        {\n            if(smallestPositive.isNull\
    \ || i < smallestPositive.get)\n            {\n                smallestPositive\
    \ = Nullable!(long)(i);\n            }\n        }\n    }\n    return tuple(largestNegative,\
    \ smallestPositive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164173
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(long i; lst) \n    {\n        if(i < 0) \n        {\n \
    \           if(largestNegative is null || i > largestNegative) \n            {\n\
    \                largestNegative = i;\n            }\n        }\n        else\
    \ if(i > 0) \n        {\n            if(smallestPositive is null || i < smallestPositive)\
    \ \n            {\n                smallestPositive = i;\n            }\n    \
    \    }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnj7xv3oo.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpnj7xv3oo.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpnj7xv3oo.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpnj7xv3oo.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnj7xv3oo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = Nullable!(long).init;\n    Nullable!(long)\
    \ smallest = Nullable!(long).init;\n    foreach(e; lst)\n    {\n        if(e <\
    \ 0)\n        {\n            if(largest.isNull)\n            {\n             \
    \   largest = e;\n            }\n            else\n            {\n           \
    \     largest = max(largest, e);\n            }\n        }\n        else if(e\
    \ > 0)\n        {\n            if(smallest.isNull)\n            {\n          \
    \      smallest = e;\n            }\n            else\n            {\n       \
    \         smallest = min(smallest, e);\n            }\n        }\n    }\n    return\
    \ tuple(largest, smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx_vut5mr.d(33): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmpx_vut5mr.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx_vut5mr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null)\n            {\n         \
    \       largest_negative = i;\n            }\n            else\n            {\n\
    \                largest_negative = max(largest_negative, i);\n            }\n\
    \        }\n        else if(i > 0)\n        {\n            if(smallest_positive\
    \ is null)\n            {\n                smallest_positive = i;\n          \
    \  }\n            else\n            {\n                smallest_positive = min(smallest_positive,\
    \ i);\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5hcradp1.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(33): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp5hcradp1.d(38): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5hcradp1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = Nullable!(long)();\n    Nullable!(long)\
    \ smallestPositive = Nullable!(long)();\n    foreach(l; lst)\n    {\n        if(l\
    \ < 0)\n        {\n            if(largestNegative.isNull || l > largestNegative.get)\n\
    \            {\n                largestNegative = Nullable!(long)(l);\n      \
    \      }\n        }\n        else if(l > 0)\n        {\n            if(smallestPositive.isNull\
    \ || l < smallestPositive.get)\n            {\n                smallestPositive\
    \ = Nullable!(long)(l);\n            }\n        }\n    }\n    return tuple(largestNegative,\
    \ smallestPositive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164173
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n        \
    \    if(largestNegative is null || l > largestNegative)\n            {\n     \
    \           largestNegative = l;\n            }\n        }\n        else if(l\
    \ > 0)\n        {\n            if(smallestPositive is null || l < smallestPositive)\n\
    \            {\n                smallestPositive = l;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3nd017rc.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp3nd017rc.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3nd017rc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst) \n    {\n        if(i < 0) \n        {\n      \
    \      if(largest is null || i > largest) \n            {\n                largest\
    \ = i;\n            }\n        }\n        else if(i > 0) \n        {\n       \
    \     if(smallest is null || i < smallest) \n            {\n                smallest\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppgucfscs.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmppgucfscs.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmppgucfscs.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmppgucfscs.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppgucfscs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(long i; lst)\n    {\n        if(i < 0)\n        {\n   \
    \         if(largestNegative is null || i > largestNegative)\n            {\n\
    \                largestNegative = i;\n            }\n        }\n        else\
    \ if(i > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmt0klet8.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpmt0klet8.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpmt0klet8.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpmt0klet8.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmt0klet8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative.isNull || i > largest_negative.get)\n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0)\n        {\n            if(smallest_positive.isNull\
    \ || i < smallest_positive.get)\n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0v4bmdwv.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp0v4bmdwv.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0v4bmdwv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative;\n    Nullable!(long) smallest_positive;\n\
    \    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n            if(!largest_negative.isNull\
    \ || i > largest_negative.get)\n            {\n                largest_negative\
    \ = i;\n            }\n        }\n        else if(i > 0)\n        {\n        \
    \    if(!smallest_positive.isNull || i < smallest_positive.get)\n            {\n\
    \                smallest_positive = i;\n            }\n        }\n    }\n   \
    \ return tuple(largest_negative, smallest_positive);\n}\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(2845):
    Called `get'' on null Nullable!long.

    ----------------

    ??:? _d_assert_msg [0x45689a]

    ??:? inout pure nothrow ref @property @nogc @safe inout(long) std.typecons.Nullable!(long).Nullable.get()
    [0x442d15]

    ??:? std.typecons.Tuple!(std.typecons.Nullable!(long).Nullable, std.typecons.Nullable!(long).Nullable).Tuple
    tmpw7pvi84l.largest_smallest_integers(long[]) [0x441e16]

    ??:? void tmpw7pvi84l.__unittest_L42_C1() [0x441ec6]

    ??:? void tmpw7pvi84l.__modtest() [0x454490]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x45f983]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x455fae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45b1c5]

    ??:? int '
  stdout: ''
  timestamp: 1660164173
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i > 0)\n        {\n        \
    \    if(smallest is null)\n            {\n                smallest = i;\n    \
    \        }\n            else\n            {\n                smallest = min(smallest,\
    \ i);\n            }\n        }\n        else if(i < 0)\n        {\n         \
    \   if(largest is null)\n            {\n                largest = i;\n       \
    \     }\n            else\n            {\n                largest = max(largest,\
    \ i);\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4lg8sr_l.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp4lg8sr_l.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp4lg8sr_l.d(27): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp4lg8sr_l.d(33): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmp4lg8sr_l.d(38): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp4lg8sr_l.d(44): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4lg8sr_l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164171
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n        \
    \    if(largestNegative is null || l > largestNegative)\n            {\n     \
    \           largestNegative = l;\n            }\n        }\n        else if(l\
    \ > 0)\n        {\n            if(smallestPositive is null || l < smallestPositive)\n\
    \            {\n                smallestPositive = l;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3nd017rc.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp3nd017rc.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3nd017rc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = Nullable!(long)();\n    Nullable!(long)\
    \ smallestPositive = Nullable!(long)();\n    foreach(i; lst)\n    {\n        if(i\
    \ < 0)\n        {\n            if(largestNegative.isNull || i > largestNegative.get)\n\
    \            {\n                largestNegative = Nullable!(long)(i);\n      \
    \      }\n        }\n        else if(i > 0)\n        {\n            if(smallestPositive.isNull\
    \ || i < smallestPositive.get)\n            {\n                smallestPositive\
    \ = Nullable!(long)(i);\n            }\n        }\n    }\n    return tuple(largestNegative,\
    \ smallestPositive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164173
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n \
    \       {\n            if(largest_negative is null)\n            {\n         \
    \       largest_negative = l;\n            }\n            else\n            {\n\
    \                largest_negative = max(largest_negative, l);\n            }\n\
    \        }\n        else if(l > 0)\n        {\n            if(smallest_positive\
    \ is null)\n            {\n                smallest_positive = l;\n          \
    \  }\n            else\n            {\n                smallest_positive = min(smallest_positive,\
    \ l);\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3sxf5rxr.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3sxf5rxr.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3sxf5rxr.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp3sxf5rxr.d(33): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp3sxf5rxr.d(38): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    /tmp/tmp3sxf5rxr.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3sxf5rxr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = Nullable!(long)();\n    Nullable!(long)\
    \ smallestPositive = Nullable!(long)();\n    foreach(i; lst)\n    {\n        if(i\
    \ < 0)\n        {\n            if(largestNegative.isNull || i > largestNegative.get)\n\
    \            {\n                largestNegative = Nullable!(long)(i);\n      \
    \      }\n        }\n        else if(i > 0)\n        {\n            if(smallestPositive.isNull\
    \ || i < smallestPositive.get)\n            {\n                smallestPositive\
    \ = Nullable!(long)(i);\n            }\n        }\n    }\n    return tuple(largestNegative,\
    \ smallestPositive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164173
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n \
    \       {\n            if(largest_negative is null || l > largest_negative)\n\
    \            {\n                largest_negative = l;\n            }\n       \
    \ }\n        else if(l > 0)\n        {\n            if(smallest_positive is null\
    \ || l < smallest_positive)\n            {\n                smallest_positive\
    \ = l;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm71wmah2.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpm71wmah2.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpm71wmah2.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpm71wmah2.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm71wmah2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative.isNull || i > largestNegative.get)\n            {\n  \
    \              largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive.isNull || i < smallestPositive.get)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7xmu8f73.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp7xmu8f73.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7xmu8f73.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(elem; lst)\n    {\n        if(elem <\
    \ 0)\n        {\n            if(largest_negative is null || elem > largest_negative)\n\
    \            {\n                largest_negative = elem;\n            }\n    \
    \    }\n        else if(elem > 0)\n        {\n            if(smallest_positive\
    \ is null || elem < smallest_positive)\n            {\n                smallest_positive\
    \ = elem;\n            }\n        }\n    }\n    return tuple(largest_negative,\
    \ smallest_positive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfv4wwxe1.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpfv4wwxe1.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpfv4wwxe1.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpfv4wwxe1.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfv4wwxe1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null || i > largest_negative)\n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0)\n        {\n            if(smallest_positive is null\
    \ || i < smallest_positive)\n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbz_0nt6c.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbz_0nt6c.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbz_0nt6c.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpbz_0nt6c.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbz_0nt6c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative.isNull || i > largest_negative.get)\n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0)\n        {\n            if(smallest_positive.isNull\
    \ || i < smallest_positive.get)\n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0v4bmdwv.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp0v4bmdwv.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0v4bmdwv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n        \
    \    if(largestNegative is null || l > largestNegative)\n            {\n     \
    \           largestNegative = l;\n            }\n        }\n        else if(l\
    \ > 0)\n        {\n            if(smallestPositive is null || l < smallestPositive)\n\
    \            {\n                smallestPositive = l;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3nd017rc.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp3nd017rc.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3nd017rc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || largestNegative < i)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || smallestPositive\
    \ > i)\n            {\n                smallestPositive = i;\n            }\n\
    \        }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpze8lszl4.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpze8lszl4.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpze8lszl4.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpze8lszl4.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpze8lszl4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largest is null || i > largest)\n            {\n                largest\
    \ = i;\n            }\n        }\n        else if(i > 0)\n        {\n        \
    \    if(smallest is null || i < smallest)\n            {\n                smallest\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp76md2bjk.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp76md2bjk.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp76md2bjk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = Nullable!(long).init;\n    Nullable!(long)\
    \ smallest = Nullable!(long).init;\n    foreach(i; lst)\n    {\n        if(i <\
    \ 0)\n        {\n            if(!largest.isNull)\n            {\n            \
    \    if(i > largest.get)\n                {\n                    largest.set(i);\n\
    \                }\n            }\n            else\n            {\n         \
    \       largest.set(i);\n            }\n        }\n        else if(i > 0)\n  \
    \      {\n            if(!smallest.isNull)\n            {\n                if(i\
    \ < smallest.get)\n                {\n                    smallest.set(i);\n \
    \               }\n            }\n            else\n            {\n          \
    \      smallest.set(i);\n            }\n        }\n    }\n    return tuple(largest,\
    \ smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphvd7_m7y.d(31): Error: no property `set` for type `Nullable!long`,
    did you mean `std.typecons.Nullable!long.Nullable.get`?

    /tmp/tmphvd7_m7y.d(36): Error: no property `set` for type `Nullable!long`, did
    you mean `std.typecons.Nullable!long.Nullable.get`?

    /tmp/tmphvd7_m7y.d(45): Error: no property `set` for type `Nullable!long`, did
    you mean `std.typecons.Nullable!long.Nullable.get`?

    /tmp/tmphvd7_m7y.d(50): Error: no property `set` for type `Nullable!long`, did
    you mean `std.typecons.Nullable!long.Nullable.get`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphvd7_m7y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largest is null || i > largest)\n            {\n                largest\
    \ = i;\n            }\n        }\n        else if(i > 0)\n        {\n        \
    \    if(smallest is null || i < smallest)\n            {\n                smallest\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp76md2bjk.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp76md2bjk.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp76md2bjk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n \
    \       {\n            if(largest_negative.isNull || l > largest_negative.get)\n\
    \            {\n                largest_negative = l;\n            }\n       \
    \ }\n        else if(l > 0)\n        {\n            if(smallest_positive.isNull\
    \ || l < smallest_positive.get)\n            {\n                smallest_positive\
    \ = l;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplfm2x3xj.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmplfm2x3xj.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplfm2x3xj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = Nullable!(long)();\n    Nullable!(long)\
    \ smallestPositive = Nullable!(long)();\n    foreach(l; lst)\n    {\n        if(l\
    \ < 0)\n        {\n            if(largestNegative.isNull || l > largestNegative.get)\n\
    \            {\n                largestNegative = Nullable!(long)(l);\n      \
    \      }\n        }\n        else if(l > 0)\n        {\n            if(smallestPositive.isNull\
    \ || l < smallestPositive.get)\n            {\n                smallestPositive\
    \ = Nullable!(long)(l);\n            }\n        }\n    }\n    return tuple(largestNegative,\
    \ smallestPositive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164173
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null || i > largest_negative)\n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0)\n        {\n            if(smallest_positive is null\
    \ || i < smallest_positive)\n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbz_0nt6c.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbz_0nt6c.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbz_0nt6c.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpbz_0nt6c.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbz_0nt6c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largest is null || largest < i)\n            {\n                largest\
    \ = i;\n            }\n        }\n        else if(i > 0)\n        {\n        \
    \    if(smallest is null || smallest > i)\n            {\n                smallest\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmponfvtr4f.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmponfvtr4f.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmponfvtr4f.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmponfvtr4f.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmponfvtr4f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(elem; lst) \n    {\n        if (elem\
    \ < 0) \n        {\n            if (largest_negative is null || elem > largest_negative)\
    \ \n            {\n                largest_negative = elem;\n            }\n \
    \       } \n        else if (elem > 0) \n        {\n            if (smallest_positive\
    \ is null || elem < smallest_positive) \n            {\n                smallest_positive\
    \ = elem;\n            }\n        }\n    }\n    return tuple(largest_negative,\
    \ smallest_positive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp27dbia6d.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp27dbia6d.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp27dbia6d.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp27dbia6d.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp27dbia6d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = Nullable!(long).init;\n    Nullable!(long)\
    \ smallest = Nullable!(long).init;\n    foreach(e; lst)\n    {\n        if(e <\
    \ 0)\n        {\n            if(largest.isNull || e > largest.get)\n         \
    \   {\n                largest = e;\n            }\n        }\n        else if(e\
    \ > 0)\n        {\n            if(smallest.isNull || e < smallest.get)\n     \
    \       {\n                smallest = e;\n            }\n        }\n    }\n  \
    \  return tuple(largest, smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164174
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative.isNull || i > largestNegative.get)\n            {\n  \
    \              largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive.isNull || i < smallestPositive.get)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7xmu8f73.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp7xmu8f73.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7xmu8f73.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    auto min_pos = Nullable!(long)();\n    auto max_neg = Nullable!(long)();\n\
    \    foreach(e; lst)\n    {\n        if(e > 0)\n        {\n            if(min_pos.isNull\
    \ || e < min_pos.get)\n                min_pos = e;\n        }\n        else if(e\
    \ < 0)\n        {\n            if(max_neg.isNull || e > max_neg.get)\n       \
    \         max_neg = e;\n        }\n    }\n    return tuple(max_neg, min_pos);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164174
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst) \n    {\n        if(i < 0) \n\
    \        {\n            if(largest_negative is null || i > largest_negative) \n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0) \n        {\n            if(smallest_positive is null\
    \ || i < smallest_positive) \n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp43ti6gcx.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp43ti6gcx.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp43ti6gcx.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp43ti6gcx.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp43ti6gcx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative.isNull || largest_negative.get < i)\n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0)\n        {\n            if(smallest_positive.isNull\
    \ || smallest_positive.get > i)\n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplnjipd68.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmplnjipd68.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplnjipd68.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null)\n            {\n         \
    \       largest_negative = i;\n            }\n            else\n            {\n\
    \                largest_negative = max(largest_negative, i);\n            }\n\
    \        }\n        else if(i > 0)\n        {\n            if(smallest_positive\
    \ is null)\n            {\n                smallest_positive = i;\n          \
    \  }\n            else\n            {\n                smallest_positive = min(smallest_positive,\
    \ i);\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5hcradp1.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(33): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp5hcradp1.d(38): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5hcradp1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null || i > largest_negative)\n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0)\n        {\n            if(smallest_positive is null\
    \ || i < smallest_positive)\n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbz_0nt6c.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbz_0nt6c.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbz_0nt6c.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpbz_0nt6c.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbz_0nt6c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_neg = null;\n    Nullable!(long) smallest_pos\
    \ = null;\n    foreach(num; lst)\n    {\n        if(num < 0)\n        {\n    \
    \        if(largest_neg is null || num > largest_neg)\n            {\n       \
    \         largest_neg = num;\n            }\n        }\n        else if(num >\
    \ 0)\n        {\n            if(smallest_pos is null || num < smallest_pos)\n\
    \            {\n                smallest_pos = num;\n            }\n        }\n\
    \    }\n    return tuple(largest_neg, smallest_pos);\n}\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_sklhw_h.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp_sklhw_h.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp_sklhw_h.d(27): Error: incompatible types for `(largest_neg) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp_sklhw_h.d(34): Error: incompatible types for `(smallest_pos) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_sklhw_h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = Nullable!(long).init;\n    Nullable!(long)\
    \ smallest = Nullable!(long).init;\n    foreach(i; lst)\n    {\n        if(i <\
    \ 0)\n        {\n            if(largest.isNull)\n            {\n             \
    \   largest = i;\n            }\n            else\n            {\n           \
    \     largest = max(largest, i);\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallest.isNull)\n            {\n          \
    \      smallest = i;\n            }\n            else\n            {\n       \
    \         smallest = min(smallest, i);\n            }\n        }\n    }\n    return\
    \ tuple(largest, smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6w3yc4km.d(33): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmp6w3yc4km.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6w3yc4km.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(num; lst) \n    {\n        if(num < 0) \n        {\n  \
    \          if(largestNegative is null || num > largestNegative) \n           \
    \ {\n                largestNegative = num;\n            }\n        }\n      \
    \  else if(num > 0) \n        {\n            if(smallestPositive is null || num\
    \ < smallestPositive) \n            {\n                smallestPositive = num;\n\
    \            }\n        }\n    }\n    return tuple(largestNegative, smallestPositive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprjb76tp1.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmprjb76tp1.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmprjb76tp1.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmprjb76tp1.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprjb76tp1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative.isNull || i > largest_negative.get)\n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0)\n        {\n            if(smallest_positive.isNull\
    \ || i < smallest_positive.get)\n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0v4bmdwv.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp0v4bmdwv.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0v4bmdwv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n        \
    \    if(largestNegative.isNull || l > largestNegative.get)\n            {\n  \
    \              largestNegative = l;\n            }\n        }\n        else if(l\
    \ > 0)\n        {\n            if(smallestPositive.isNull || l < smallestPositive.get)\n\
    \            {\n                smallestPositive = l;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbjnfq_sw.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbjnfq_sw.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbjnfq_sw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(e; lst)\n    {\n        if(e < 0)\n        {\n        \
    \    if(largest is null || e > largest)\n            {\n                largest\
    \ = e;\n            }\n        }\n        else if(e > 0)\n        {\n        \
    \    if(smallest is null || e < smallest)\n            {\n                smallest\
    \ = e;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5oj4nytg.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5oj4nytg.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5oj4nytg.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp5oj4nytg.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5oj4nytg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = Nullable!(long)();\n    Nullable!(long)\
    \ smallestPositive = Nullable!(long)();\n    foreach(i; lst)\n    {\n        if(i\
    \ < 0)\n        {\n            if(largestNegative.isNull || i > largestNegative.get)\n\
    \            {\n                largestNegative = Nullable!(long)(i);\n      \
    \      }\n        }\n        else if(i > 0)\n        {\n            if(smallestPositive.isNull\
    \ || i < smallestPositive.get)\n            {\n                smallestPositive\
    \ = Nullable!(long)(i);\n            }\n        }\n    }\n    return tuple(largestNegative,\
    \ smallestPositive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164173
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i > 0)\n        {\n        \
    \    if(smallest.isNull)\n            {\n                smallest = i;\n     \
    \       }\n            else\n            {\n                smallest = min(smallest,\
    \ i);\n            }\n        }\n        else if(i < 0)\n        {\n         \
    \   if(largest.isNull)\n            {\n                largest = i;\n        \
    \    }\n            else\n            {\n                largest = max(largest,\
    \ i);\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgk0d0or1.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpgk0d0or1.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpgk0d0or1.d(33): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpgk0d0or1.d(44): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgk0d0or1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164173
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(num; lst) \n    {\n        if(num < 0) \n        {\n  \
    \          if(largestNegative is null || num > largestNegative) \n           \
    \ {\n                largestNegative = num;\n            }\n        }\n      \
    \  else if(num > 0) \n        {\n            if(smallestPositive is null || num\
    \ < smallestPositive) \n            {\n                smallestPositive = num;\n\
    \            }\n        }\n    }\n    return tuple(largestNegative, smallestPositive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprjb76tp1.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmprjb76tp1.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmprjb76tp1.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmprjb76tp1.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprjb76tp1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n        \
    \    if(largestNegative.isNull || l > largestNegative.get)\n            {\n  \
    \              largestNegative = l;\n            }\n        }\n        else if(l\
    \ > 0)\n        {\n            if(smallestPositive.isNull || l < smallestPositive.get)\n\
    \            {\n                smallestPositive = l;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbjnfq_sw.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbjnfq_sw.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbjnfq_sw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largest is null || i > largest)\n            {\n                largest\
    \ = i;\n            }\n        }\n        else if(i > 0)\n        {\n        \
    \    if(smallest is null || i < smallest)\n            {\n                smallest\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp76md2bjk.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp76md2bjk.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp76md2bjk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) maxNeg = null;\n    Nullable!(long) minPos = null;\n\
    \    foreach(e; lst)\n    {\n        if(e < 0)\n        {\n            if(maxNeg\
    \ is null || e > maxNeg)\n                maxNeg = e;\n        }\n        else\
    \ if(e > 0)\n        {\n            if(minPos is null || e < minPos)\n       \
    \         minPos = e;\n        }\n    }\n    return tuple(maxNeg, minPos);\n}\n\
    unittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgg87k_ba.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpgg87k_ba.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpgg87k_ba.d(27): Error: incompatible types for `(maxNeg) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmpgg87k_ba.d(32): Error: incompatible types for `(minPos) is (null)`: `Nullable!long`
    and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgg87k_ba.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164173
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null || i > largest_negative)\n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0)\n        {\n            if(smallest_positive is null\
    \ || i < smallest_positive)\n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbz_0nt6c.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbz_0nt6c.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbz_0nt6c.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpbz_0nt6c.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbz_0nt6c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null)\n            {\n         \
    \       largest_negative = i;\n            }\n            else\n            {\n\
    \                largest_negative = max(largest_negative, i);\n            }\n\
    \        }\n        else if(i > 0)\n        {\n            if(smallest_positive\
    \ is null)\n            {\n                smallest_positive = i;\n          \
    \  }\n            else\n            {\n                smallest_positive = min(smallest_positive,\
    \ i);\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5hcradp1.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(33): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp5hcradp1.d(38): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5hcradp1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n        \
    \    if(largestNegative.isNull || l > largestNegative.get)\n            {\n  \
    \              largestNegative = l;\n            }\n        }\n        else if(l\
    \ > 0)\n        {\n            if(smallestPositive.isNull || l < smallestPositive.get)\n\
    \            {\n                smallestPositive = l;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbjnfq_sw.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbjnfq_sw.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbjnfq_sw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(e; lst)\n    {\n        if(e > 0)\n        {\n        \
    \    if(smallest is null || e < smallest)\n            {\n                smallest\
    \ = e;\n            }\n        }\n        else if(e < 0)\n        {\n        \
    \    if(largest is null || e > largest)\n            {\n                largest\
    \ = e;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp45mtxwwj.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp45mtxwwj.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp45mtxwwj.d(27): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp45mtxwwj.d(34): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp45mtxwwj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164173
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null || i > largest_negative)\n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0)\n        {\n            if(smallest_positive is null\
    \ || i < smallest_positive)\n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbz_0nt6c.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbz_0nt6c.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbz_0nt6c.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpbz_0nt6c.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbz_0nt6c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = Nullable!(long)();\n    Nullable!(long)\
    \ smallestPositive = Nullable!(long)();\n    foreach(i; lst)\n    {\n        if(i\
    \ < 0)\n        {\n            if(largestNegative.isNull || i > largestNegative.get)\n\
    \            {\n                largestNegative = Nullable!(long)(i);\n      \
    \      }\n        }\n        else if(i > 0)\n        {\n            if(smallestPositive.isNull\
    \ || i < smallestPositive.get)\n            {\n                smallestPositive\
    \ = Nullable!(long)(i);\n            }\n        }\n    }\n    return tuple(largestNegative,\
    \ smallestPositive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164173
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst) \n    {\n        if(i < 0) \n\
    \        {\n            if(largest_negative is null || i > largest_negative) \n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0) \n        {\n            if(smallest_positive is null\
    \ || i < smallest_positive) \n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp43ti6gcx.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp43ti6gcx.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp43ti6gcx.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp43ti6gcx.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp43ti6gcx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(l; lst) \n    {\n        if(l < 0L) \n\
    \        {\n            if(largest_negative is null || l > largest_negative) \n\
    \            {\n                largest_negative = l;\n            }\n       \
    \ }\n        else if(l > 0L) \n        {\n            if(smallest_positive is\
    \ null || l < smallest_positive) \n            {\n                smallest_positive\
    \ = l;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpip45pki5.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpip45pki5.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpip45pki5.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpip45pki5.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpip45pki5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164173
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largest is null || i > largest)\n            {\n                largest\
    \ = i;\n            }\n        }\n        else if(i > 0)\n        {\n        \
    \    if(smallest is null || i < smallest)\n            {\n                smallest\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp76md2bjk.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp76md2bjk.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp76md2bjk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    long largest_negative = long.min;\n    long smallest_positive\
    \ = long.max;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n    \
    \        largest_negative = max(largest_negative, i);\n        }\n        else\
    \ if(i > 0)\n        {\n            smallest_positive = min(smallest_positive,\
    \ i);\n        }\n    }\n    return tuple(largest_negative == long.min ? null\
    \ : largest_negative, smallest_positive == long.max ? null : smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpriybs94f.d(27): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmpriybs94f.d(31): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmpriybs94f.d(34): Error: incompatible types for `(null) : (largest_negative)`:
    `typeof(null)` and `long`

    /tmp/tmpriybs94f.d(34): Error: incompatible types for `(null) : (smallest_positive)`:
    `typeof(null)` and `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpriybs94f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164174
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst) \n    {\n        if(i < 0L) \n\
    \        {\n            if(largest_negative is null) \n            {\n       \
    \         largest_negative = i;\n            } \n            else \n         \
    \   {\n                largest_negative = max(largest_negative, i);\n        \
    \    }\n        } \n        else if(i > 0L) \n        {\n            if(smallest_positive\
    \ is null) \n            {\n                smallest_positive = i;\n         \
    \   } \n            else \n            {\n                smallest_positive =\
    \ min(smallest_positive, i);\n            }\n        }\n    }\n    return tuple(largest_negative,\
    \ smallest_positive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0fnwjw35.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp0fnwjw35.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp0fnwjw35.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp0fnwjw35.d(33): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp0fnwjw35.d(38): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    /tmp/tmp0fnwjw35.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0fnwjw35.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164174
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst) \n    {\n        if(i < 0) \n\
    \        {\n            if(largest_negative is null || i > largest_negative) \n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0) \n        {\n            if(smallest_positive is null\
    \ || i < smallest_positive) \n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp43ti6gcx.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp43ti6gcx.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp43ti6gcx.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp43ti6gcx.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp43ti6gcx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n        \
    \    if(largestNegative is null || l > largestNegative)\n            {\n     \
    \           largestNegative = l;\n            }\n        }\n        else if(l\
    \ > 0)\n        {\n            if(smallestPositive is null || l < smallestPositive)\n\
    \            {\n                smallestPositive = l;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3nd017rc.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp3nd017rc.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3nd017rc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = Nullable!(long).init;\n    Nullable!(long)\
    \ smallest = Nullable!(long).init;\n    foreach(i; lst) \n    {\n        if(i\
    \ < 0) \n        {\n            if(largest.isNull || i > largest.get) \n     \
    \       {\n                largest = i;\n            }\n        }\n        else\
    \ if(i > 0) \n        {\n            if(smallest.isNull || i < smallest.get) \n\
    \            {\n                smallest = i;\n            }\n        }\n    }\n\
    \    return tuple(largest, smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164175
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(e; lst)\n    {\n        if(e < 0)\n        {\n        \
    \    if(largest is null || e > largest)\n            {\n                largest\
    \ = e;\n            }\n        }\n        else if(e > 0)\n        {\n        \
    \    if(smallest is null || e < smallest)\n            {\n                smallest\
    \ = e;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5oj4nytg.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5oj4nytg.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5oj4nytg.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp5oj4nytg.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5oj4nytg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative.isNull || i > largestNegative.get)\n            {\n  \
    \              largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive.isNull || i < smallestPositive.get)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7xmu8f73.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp7xmu8f73.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7xmu8f73.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = Nullable!(long)();\n    Nullable!(long)\
    \ smallest_positive = Nullable!(long)();\n    foreach(l; lst)\n    {\n       \
    \ if(l < 0)\n        {\n            if(!largest_negative.isNull)\n           \
    \ {\n                if(l > largest_negative.get)\n                {\n       \
    \             largest_negative.set(l);\n                }\n            }\n   \
    \         else\n            {\n                largest_negative.set(l);\n    \
    \        }\n        }\n        else if(l > 0)\n        {\n            if(!smallest_positive.isNull)\n\
    \            {\n                if(l < smallest_positive.get)\n              \
    \  {\n                    smallest_positive.set(l);\n                }\n     \
    \       }\n            else\n            {\n                smallest_positive.set(l);\n\
    \            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5wm0pj99.d(31): Error: no property `set` for type `Nullable!long`,
    did you mean `std.typecons.Nullable!long.Nullable.get`?

    /tmp/tmp5wm0pj99.d(36): Error: no property `set` for type `Nullable!long`, did
    you mean `std.typecons.Nullable!long.Nullable.get`?

    /tmp/tmp5wm0pj99.d(45): Error: no property `set` for type `Nullable!long`, did
    you mean `std.typecons.Nullable!long.Nullable.get`?

    /tmp/tmp5wm0pj99.d(50): Error: no property `set` for type `Nullable!long`, did
    you mean `std.typecons.Nullable!long.Nullable.get`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5wm0pj99.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164174
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n        \
    \    if(largestNegative is null || l > largestNegative)\n            {\n     \
    \           largestNegative = l;\n            }\n        }\n        else if(l\
    \ > 0)\n        {\n            if(smallestPositive is null || l < smallestPositive)\n\
    \            {\n                smallestPositive = l;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3nd017rc.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp3nd017rc.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3nd017rc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = Nullable!(long).init;\n    Nullable!(long)\
    \ smallest = Nullable!(long).init;\n    foreach(i; lst)\n    {\n        if(i <\
    \ 0)\n        {\n            if(!largest.isNull)\n            {\n            \
    \    if(i > largest.get)\n                {\n                    largest.set(i);\n\
    \                }\n            }\n            else\n            {\n         \
    \       largest.set(i);\n            }\n        }\n        else if(i > 0)\n  \
    \      {\n            if(!smallest.isNull)\n            {\n                if(i\
    \ < smallest.get)\n                {\n                    smallest.set(i);\n \
    \               }\n            }\n            else\n            {\n          \
    \      smallest.set(i);\n            }\n        }\n    }\n    return tuple(largest,\
    \ smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphvd7_m7y.d(31): Error: no property `set` for type `Nullable!long`,
    did you mean `std.typecons.Nullable!long.Nullable.get`?

    /tmp/tmphvd7_m7y.d(36): Error: no property `set` for type `Nullable!long`, did
    you mean `std.typecons.Nullable!long.Nullable.get`?

    /tmp/tmphvd7_m7y.d(45): Error: no property `set` for type `Nullable!long`, did
    you mean `std.typecons.Nullable!long.Nullable.get`?

    /tmp/tmphvd7_m7y.d(50): Error: no property `set` for type `Nullable!long`, did
    you mean `std.typecons.Nullable!long.Nullable.get`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphvd7_m7y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null)\n            {\n         \
    \       largest_negative = i;\n            }\n            else\n            {\n\
    \                largest_negative = max(largest_negative, i);\n            }\n\
    \        }\n        else if(i > 0)\n        {\n            if(smallest_positive\
    \ is null)\n            {\n                smallest_positive = i;\n          \
    \  }\n            else\n            {\n                smallest_positive = min(smallest_positive,\
    \ i);\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5hcradp1.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(33): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp5hcradp1.d(38): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5hcradp1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null)\n            {\n         \
    \       largest_negative = i;\n            }\n            else\n            {\n\
    \                largest_negative = max(largest_negative, i);\n            }\n\
    \        }\n        else if(i > 0)\n        {\n            if(smallest_positive\
    \ is null)\n            {\n                smallest_positive = i;\n          \
    \  }\n            else\n            {\n                smallest_positive = min(smallest_positive,\
    \ i);\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5hcradp1.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(33): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp5hcradp1.d(38): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5hcradp1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largest is null || i > largest)\n            {\n                largest\
    \ = i;\n            }\n        }\n        else if(i > 0)\n        {\n        \
    \    if(smallest is null || i < smallest)\n            {\n                smallest\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp76md2bjk.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp76md2bjk.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp76md2bjk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n        \
    \    if(largestNegative is null || l > largestNegative)\n            {\n     \
    \           largestNegative = l;\n            }\n        }\n        else if(l\
    \ > 0)\n        {\n            if(smallestPositive is null || l < smallestPositive)\n\
    \            {\n                smallestPositive = l;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3nd017rc.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp3nd017rc.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3nd017rc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n        \
    \    if(largestNegative is null || l > largestNegative)\n            {\n     \
    \           largestNegative = l;\n            }\n        }\n        else if(l\
    \ > 0)\n        {\n            if(smallestPositive is null || l < smallestPositive)\n\
    \            {\n                smallestPositive = l;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3nd017rc.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp3nd017rc.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3nd017rc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n \
    \       {\n            if(largest_negative is null || l > largest_negative)\n\
    \            {\n                largest_negative = l;\n            }\n       \
    \ }\n        else if(l > 0)\n        {\n            if(smallest_positive is null\
    \ || l < smallest_positive)\n            {\n                smallest_positive\
    \ = l;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm71wmah2.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpm71wmah2.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpm71wmah2.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpm71wmah2.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm71wmah2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = Nullable!(long)();\n    Nullable!(long)\
    \ smallestPositive = Nullable!(long)();\n    foreach(i; lst) \n    {\n       \
    \ if(i < 0) \n        {\n            if(!largestNegative.isNull) \n          \
    \  {\n                if(i > largestNegative.get) \n                {\n      \
    \              largestNegative.set(i);\n                }\n            }\n   \
    \         else \n            {\n                largestNegative.set(i);\n    \
    \        }\n        }\n        else if(i > 0) \n        {\n            if(!smallestPositive.isNull)\
    \ \n            {\n                if(i < smallestPositive.get) \n           \
    \     {\n                    smallestPositive.set(i);\n                }\n   \
    \         }\n            else \n            {\n                smallestPositive.set(i);\n\
    \            }\n        }\n    }\n    return tuple(largestNegative, smallestPositive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps9wiec9k.d(31): Error: no property `set` for type `Nullable!long`,
    did you mean `std.typecons.Nullable!long.Nullable.get`?

    /tmp/tmps9wiec9k.d(36): Error: no property `set` for type `Nullable!long`, did
    you mean `std.typecons.Nullable!long.Nullable.get`?

    /tmp/tmps9wiec9k.d(45): Error: no property `set` for type `Nullable!long`, did
    you mean `std.typecons.Nullable!long.Nullable.get`?

    /tmp/tmps9wiec9k.d(50): Error: no property `set` for type `Nullable!long`, did
    you mean `std.typecons.Nullable!long.Nullable.get`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps9wiec9k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164174
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst) \n    {\n        if(i < 0) \n\
    \        {\n            if(largest_negative is null || i > largest_negative) \n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0) \n        {\n            if(smallest_positive is null\
    \ || i < smallest_positive) \n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp43ti6gcx.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp43ti6gcx.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp43ti6gcx.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp43ti6gcx.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp43ti6gcx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative;\n    Nullable!(long) smallest_positive;\n\
    \    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n            if(largest_negative.isNull)\n\
    \            {\n                largest_negative = l;\n            }\n       \
    \     else\n            {\n                largest_negative = max(largest_negative,\
    \ l);\n            }\n        }\n        else if(l > 0)\n        {\n         \
    \   if(smallest_positive.isNull)\n            {\n                smallest_positive\
    \ = l;\n            }\n            else\n            {\n                smallest_positive\
    \ = min(smallest_positive, l);\n            }\n        }\n    }\n    return tuple(largest_negative,\
    \ smallest_positive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj62vzaut.d(33): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmpj62vzaut.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj62vzaut.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164174
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(l; lst) \n    {\n        if(l < 0) \n\
    \        {\n            if(largest_negative.isNull || l > largest_negative.get)\
    \ \n            {\n                largest_negative = l;\n            }\n    \
    \    }\n        else if(l > 0) \n        {\n            if(smallest_positive.isNull\
    \ || l < smallest_positive.get) \n            {\n                smallest_positive\
    \ = l;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpws06_kgf.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpws06_kgf.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpws06_kgf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164174
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = Nullable!(long)();\n    Nullable!(long)\
    \ smallestPositive = Nullable!(long)();\n    foreach(i; lst)\n    {\n        if(i\
    \ < 0)\n        {\n            if(largestNegative.isNull || i > largestNegative.get)\n\
    \            {\n                largestNegative = Nullable!(long)(i);\n      \
    \      }\n        }\n        else if(i > 0)\n        {\n            if(smallestPositive.isNull\
    \ || i < smallestPositive.get)\n            {\n                smallestPositive\
    \ = Nullable!(long)(i);\n            }\n        }\n    }\n    return tuple(largestNegative,\
    \ smallestPositive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164173
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null)\n            {\n         \
    \       largest_negative = i;\n            }\n            else\n            {\n\
    \                largest_negative = max(largest_negative, i);\n            }\n\
    \        }\n        else if(i > 0)\n        {\n            if(smallest_positive\
    \ is null)\n            {\n                smallest_positive = i;\n          \
    \  }\n            else\n            {\n                smallest_positive = min(smallest_positive,\
    \ i);\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5hcradp1.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(33): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp5hcradp1.d(38): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5hcradp1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largest is null || i > largest)\n            {\n                largest\
    \ = i;\n            }\n        }\n        else if(i > 0)\n        {\n        \
    \    if(smallest is null || i < smallest)\n            {\n                smallest\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp76md2bjk.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp76md2bjk.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp76md2bjk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n        \
    \    if(largest is null || l > largest)\n            {\n                largest\
    \ = l;\n            }\n        }\n        else if(l > 0)\n        {\n        \
    \    if(smallest is null || l < smallest)\n            {\n                smallest\
    \ = l;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcw5rz78k.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpcw5rz78k.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpcw5rz78k.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmpcw5rz78k.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcw5rz78k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164174
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = Nullable!(long).init;\n    Nullable!(long)\
    \ smallest = Nullable!(long).init;\n    foreach(i; lst)\n    {\n        if(i <\
    \ 0)\n        {\n            if(largest.isNull || i > largest.get)\n         \
    \   {\n                largest = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallest.isNull || i < smallest.get)\n     \
    \       {\n                smallest = i;\n            }\n        }\n    }\n  \
    \  return tuple(largest, smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164171
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst) \n    {\n        if(i < 0) \n        {\n      \
    \      if(largest is null || i > largest) \n            {\n                largest\
    \ = i;\n            }\n        }\n        else if(i > 0) \n        {\n       \
    \     if(smallest is null || i < smallest) \n            {\n                smallest\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppgucfscs.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmppgucfscs.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmppgucfscs.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmppgucfscs.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppgucfscs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative.isNull || i > largest_negative.get)\n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0)\n        {\n            if(smallest_positive.isNull\
    \ || i < smallest_positive.get)\n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0v4bmdwv.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp0v4bmdwv.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0v4bmdwv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst) \n    {\n        if(i < 0) \n\
    \        {\n            if(largest_negative is null || i > largest_negative) \n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0) \n        {\n            if(smallest_positive is null\
    \ || i < smallest_positive) \n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp43ti6gcx.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp43ti6gcx.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp43ti6gcx.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp43ti6gcx.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp43ti6gcx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = Nullable!(long).init;\n    Nullable!(long)\
    \ smallest = Nullable!(long).init;\n    foreach(i; lst)\n    {\n        if(i <\
    \ 0)\n        {\n            if(largest.isNull || i > largest.get)\n         \
    \   {\n                largest = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallest.isNull || i < smallest.get)\n     \
    \       {\n                smallest = i;\n            }\n        }\n    }\n  \
    \  return tuple(largest, smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164171
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = Nullable!(long).init;\n    Nullable!(long)\
    \ smallest = Nullable!(long).init;\n    foreach(i; lst) \n    {\n        if(i\
    \ < 0) \n        {\n            if(largest.isNull || i > largest.get) \n     \
    \       {\n                largest = i;\n            }\n        }\n        else\
    \ if(i > 0) \n        {\n            if(smallest.isNull || i < smallest.get) \n\
    \            {\n                smallest = i;\n            }\n        }\n    }\n\
    \    return tuple(largest, smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164175
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_neg = null;\n    Nullable!(long) smallest_pos\
    \ = null;\n    foreach(elem; lst)\n    {\n        if(elem < 0)\n        {\n  \
    \          if(largest_neg is null || largest_neg < elem)\n            {\n    \
    \            largest_neg = elem;\n            }\n        }\n        else if(elem\
    \ > 0)\n        {\n            if(smallest_pos is null || smallest_pos > elem)\n\
    \            {\n                smallest_pos = elem;\n            }\n        }\n\
    \    }\n    return tuple(largest_neg, smallest_pos);\n}\nunittest\n{\n    alias\
    \ candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp018_aimu.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp018_aimu.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp018_aimu.d(27): Error: incompatible types for `(largest_neg) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp018_aimu.d(34): Error: incompatible types for `(smallest_pos) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp018_aimu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164174
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largest is null || i > largest)\n            {\n                largest\
    \ = i;\n            }\n        }\n        else if(i > 0)\n        {\n        \
    \    if(smallest is null || i < smallest)\n            {\n                smallest\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp76md2bjk.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp76md2bjk.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp76md2bjk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = Nullable!(long).init;\n    Nullable!(long)\
    \ smallest = Nullable!(long).init;\n    foreach(i; lst)\n    {\n        if(i <\
    \ 0)\n        {\n            if(largest.isNull)\n            {\n             \
    \   largest = i;\n            }\n            else\n            {\n           \
    \     largest = max(largest, i);\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallest.isNull)\n            {\n          \
    \      smallest = i;\n            }\n            else\n            {\n       \
    \         smallest = min(smallest, i);\n            }\n        }\n    }\n    return\
    \ tuple(largest, smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6w3yc4km.d(33): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmp6w3yc4km.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6w3yc4km.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largest is null || i > largest)\n            {\n                largest\
    \ = i;\n            }\n        }\n        else if(i > 0)\n        {\n        \
    \    if(smallest is null || i < smallest)\n            {\n                smallest\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp76md2bjk.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp76md2bjk.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp76md2bjk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n        \
    \    if(largestNegative is null || l > largestNegative)\n            {\n     \
    \           largestNegative = l;\n            }\n        }\n        else if(l\
    \ > 0)\n        {\n            if(smallestPositive is null || l < smallestPositive)\n\
    \            {\n                smallestPositive = l;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3nd017rc.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp3nd017rc.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3nd017rc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(item; lst)\n    {\n        if(item < 0)\n        {\n  \
    \          if(largestNegative is null || item > largestNegative)\n           \
    \ {\n                largestNegative = item;\n            }\n        }\n     \
    \   else if(item > 0)\n        {\n            if(smallestPositive is null || item\
    \ < smallestPositive)\n            {\n                smallestPositive = item;\n\
    \            }\n        }\n    }\n    return tuple(largestNegative, smallestPositive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp37rg588n.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp37rg588n.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp37rg588n.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp37rg588n.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp37rg588n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(num; lst)\n    {\n        if(num < 0)\n\
    \        {\n            if(largest_negative is null || num > largest_negative)\n\
    \            {\n                largest_negative = num;\n            }\n     \
    \   }\n        else if(num > 0)\n        {\n            if(smallest_positive is\
    \ null || num < smallest_positive)\n            {\n                smallest_positive\
    \ = num;\n            }\n        }\n    }\n    return tuple(largest_negative,\
    \ smallest_positive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqiw3pvzn.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpqiw3pvzn.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpqiw3pvzn.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpqiw3pvzn.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqiw3pvzn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164174
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null)\n            {\n         \
    \       largest_negative = i;\n            }\n            else\n            {\n\
    \                largest_negative = max(largest_negative, i);\n            }\n\
    \        }\n        else if(i > 0)\n        {\n            if(smallest_positive\
    \ is null)\n            {\n                smallest_positive = i;\n          \
    \  }\n            else\n            {\n                smallest_positive = min(smallest_positive,\
    \ i);\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5hcradp1.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(33): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp5hcradp1.d(38): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5hcradp1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative.isNull || i > largestNegative.get)\n            {\n  \
    \              largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive.isNull || i < smallestPositive.get)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7xmu8f73.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp7xmu8f73.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7xmu8f73.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null)\n            {\n         \
    \       largest_negative = i;\n            }\n            else\n            {\n\
    \                largest_negative = max(largest_negative, i);\n            }\n\
    \        }\n        else if(i > 0)\n        {\n            if(smallest_positive\
    \ is null)\n            {\n                smallest_positive = i;\n          \
    \  }\n            else\n            {\n                smallest_positive = min(smallest_positive,\
    \ i);\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5hcradp1.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(33): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp5hcradp1.d(38): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5hcradp1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst) \n    {\n        if(i > 0) \n        {\n      \
    \      if(smallest.isNull || i < smallest.get) \n            {\n             \
    \   smallest = i;\n            }\n        } \n        else if(i < 0) \n      \
    \  {\n            if(largest.isNull || i > largest.get) \n            {\n    \
    \            largest = i;\n            }\n        }\n    }\n    return tuple(largest,\
    \ smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1g47z07t.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp1g47z07t.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    '
  stdout: ''
  timestamp: 1660164174
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    long largest = long.min;\n    long smallest = long.max;\n    foreach(i;\
    \ lst) \n    {\n        if (i < 0) \n        {\n            largest = max(largest,\
    \ i);\n        }\n        else if (i > 0) \n        {\n            smallest =\
    \ min(smallest, i);\n        }\n    }\n    return tuple(largest == long.min ?\
    \ null : largest, smallest == long.max ? null : smallest);\n}\nunittest\n{\n \
    \   alias candidate = largest_smallest_integers;\n\n{\n        auto result = candidate([2L,\
    \ 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([2L, 4L, 1L,\
    \ 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n{\n        auto result = candidate([1L, 3L, 2L,\
    \ 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull && result[0].get == -2L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -7L);\n        assert(!result[1].isNull && result[1].get\
    \ == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L, 4L, 9L, 2L, 5L,\
    \ -9L]);\n        assert(!result[0].isNull && result[0].get == -9L);\n       \
    \ assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n        auto result\
    \ = candidate([]);\n        assert(result[0].isNull);\n        assert(result[1].isNull);\n\
    }\n\n{\n        auto result = candidate([0L]);\n        assert(result[0].isNull);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-1L,\
    \ -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull && result[0].get == -1L);\n\
    \        assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([-6L,\
    \ -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([-6L, -4L, -4L, -3L, -100L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4b3v88_r.d(27): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmp4b3v88_r.d(31): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmp4b3v88_r.d(34): Error: incompatible types for `(null) : (largest)`: `typeof(null)`
    and `long`

    /tmp/tmp4b3v88_r.d(34): Error: incompatible types for `(null) : (smallest)`: `typeof(null)`
    and `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4b3v88_r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164174
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative.isNull || i > largest_negative.get)\n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0)\n        {\n            if(smallest_positive.isNull\
    \ || i < smallest_positive.get)\n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0v4bmdwv.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp0v4bmdwv.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0v4bmdwv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null || i > largest_negative)\n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0)\n        {\n            if(smallest_positive is null\
    \ || i < smallest_positive)\n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbz_0nt6c.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbz_0nt6c.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpbz_0nt6c.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpbz_0nt6c.d(34): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbz_0nt6c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i > 0)\n        {\n        \
    \    if(smallest is null)\n            {\n                smallest = i;\n    \
    \        }\n            else\n            {\n                smallest = min(smallest,\
    \ i);\n            }\n        }\n        else if(i < 0)\n        {\n         \
    \   if(largest is null)\n            {\n                largest = i;\n       \
    \     }\n            else\n            {\n                largest = max(largest,\
    \ i);\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4lg8sr_l.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp4lg8sr_l.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp4lg8sr_l.d(27): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp4lg8sr_l.d(33): Error: undefined identifier `min`, did you mean function
    `main`?

    /tmp/tmp4lg8sr_l.d(38): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp4lg8sr_l.d(44): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4lg8sr_l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164171
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0 && (largest is null ||\
    \ i > largest))\n        {\n            largest = i;\n        }\n        else\
    \ if(i > 0 && (smallest is null || i < smallest))\n        {\n            smallest\
    \ = i;\n        }\n    }\n    return tuple(largest, smallest);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8grnld6x.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp8grnld6x.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp8grnld6x.d(25): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp8grnld6x.d(29): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8grnld6x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164174
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = Nullable!(long).init;\n    Nullable!(long)\
    \ smallest = Nullable!(long).init;\n    foreach(i; lst)\n    {\n        if(i <\
    \ 0)\n        {\n            if(largest.isNull || i > largest.get)\n         \
    \   {\n                largest = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallest.isNull || i < smallest.get)\n     \
    \       {\n                smallest = i;\n            }\n        }\n    }\n  \
    \  return tuple(largest, smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164171
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || largestNegative < i)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || smallestPositive\
    \ > i)\n            {\n                smallestPositive = i;\n            }\n\
    \        }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpze8lszl4.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpze8lszl4.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpze8lszl4.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpze8lszl4.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpze8lszl4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null)\n            {\n         \
    \       largest_negative = i;\n            }\n            else\n            {\n\
    \                largest_negative = max(largest_negative, i);\n            }\n\
    \        }\n        else if(i > 0)\n        {\n            if(smallest_positive\
    \ is null)\n            {\n                smallest_positive = i;\n          \
    \  }\n            else\n            {\n                smallest_positive = min(smallest_positive,\
    \ i);\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5hcradp1.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(33): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp5hcradp1.d(38): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5hcradp1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative.isNull || i > largest_negative.get)\n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0)\n        {\n            if(smallest_positive.isNull\
    \ || i < smallest_positive.get)\n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0v4bmdwv.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp0v4bmdwv.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0v4bmdwv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = Nullable!(long)();\n    Nullable!(long)\
    \ smallestPositive = Nullable!(long)();\n    foreach(i; lst)\n    {\n        if(i\
    \ < 0)\n        {\n            if(!largestNegative.isNull)\n            {\n  \
    \              if(i > largestNegative.get)\n                {\n              \
    \      largestNegative.set(i);\n                }\n            }\n           \
    \ else\n            {\n                largestNegative.set(i);\n            }\n\
    \        }\n        else if(i > 0)\n        {\n            if(!smallestPositive.isNull)\n\
    \            {\n                if(i < smallestPositive.get)\n               \
    \ {\n                    smallestPositive.set(i);\n                }\n       \
    \     }\n            else\n            {\n                smallestPositive.set(i);\n\
    \            }\n        }\n    }\n    return tuple(largestNegative, smallestPositive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4mf9v3ms.d(31): Error: no property `set` for type `Nullable!long`,
    did you mean `std.typecons.Nullable!long.Nullable.get`?

    /tmp/tmp4mf9v3ms.d(36): Error: no property `set` for type `Nullable!long`, did
    you mean `std.typecons.Nullable!long.Nullable.get`?

    /tmp/tmp4mf9v3ms.d(45): Error: no property `set` for type `Nullable!long`, did
    you mean `std.typecons.Nullable!long.Nullable.get`?

    /tmp/tmp4mf9v3ms.d(50): Error: no property `set` for type `Nullable!long`, did
    you mean `std.typecons.Nullable!long.Nullable.get`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4mf9v3ms.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst) \n    {\n        if(i < 0) \n        {\n      \
    \      if(largestNegative is null || i > largestNegative) \n            {\n  \
    \              largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0) \n        {\n            if(smallestPositive is null || i < smallestPositive)\
    \ \n            {\n                smallestPositive = i;\n            }\n    \
    \    }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp643tskkj.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp643tskkj.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp643tskkj.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp643tskkj.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp643tskkj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = Nullable!(long).init;\n    Nullable!(long)\
    \ smallest = Nullable!(long).init;\n    foreach(i; lst)\n    {\n        if(i <\
    \ 0)\n        {\n            if(largest.isNull || i > largest.get)\n         \
    \   {\n                largest = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallest.isNull || i < smallest.get)\n     \
    \       {\n                smallest = i;\n            }\n        }\n    }\n  \
    \  return tuple(largest, smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164171
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative.isNull || i > largestNegative.get)\n            {\n  \
    \              largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive.isNull || i < smallestPositive.get)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7xmu8f73.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp7xmu8f73.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7xmu8f73.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = Nullable!(long).init;\n    Nullable!(long)\
    \ smallest = Nullable!(long).init;\n    foreach(i; lst)\n    {\n        if(i <\
    \ 0)\n        {\n            if(largest.isNull || i > largest.get)\n         \
    \   {\n                largest = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallest.isNull || i < smallest.get)\n     \
    \       {\n                smallest = i;\n            }\n        }\n    }\n  \
    \  return tuple(largest, smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164171
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = Nullable!(long).init;\n    Nullable!(long)\
    \ smallest = Nullable!(long).init;\n    foreach(i; lst)\n    {\n        if(i <\
    \ 0)\n        {\n            if(largest.isNull || largest.get > i)\n         \
    \   {\n                largest = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallest.isNull || smallest.get < i)\n     \
    \       {\n                smallest = i;\n            }\n        }\n    }\n  \
    \  return tuple(largest, smallest);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmputgtkqr2.d(49): unittest failure

    ----------------

    ??:? _d_unittestp [0x456979]

    ??:? void tmputgtkqr2.__unittest_L42_C1() [0x441f11]

    ??:? void tmputgtkqr2.__modtest() [0x454488]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x45f97b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x455fa6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45b1bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45b24c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45b149]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x455f7d]

    ??:? runModuleUnitTests [0x45f751]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x457904]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164171
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(elem; lst)\n    {\n        if(elem < 0)\n        {\n  \
    \          if(largestNegative is null || largestNegative < elem)\n           \
    \ {\n                largestNegative = elem;\n            }\n        }\n     \
    \   else if(elem > 0)\n        {\n            if(smallestPositive is null || smallestPositive\
    \ > elem)\n            {\n                smallestPositive = elem;\n         \
    \   }\n        }\n    }\n    return tuple(largestNegative, smallestPositive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn9073d7a.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpn9073d7a.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpn9073d7a.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpn9073d7a.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    '
  stdout: ''
  timestamp: 1660164174
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largest is null || i > largest)\n            {\n                largest\
    \ = i;\n            }\n        }\n        else if(i > 0)\n        {\n        \
    \    if(smallest is null || i < smallest)\n            {\n                smallest\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp76md2bjk.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp76md2bjk.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp76md2bjk.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp76md2bjk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n \
    \       {\n            if(largest_negative is null)\n            {\n         \
    \       largest_negative = l;\n            }\n            else\n            {\n\
    \                largest_negative = max(largest_negative, l);\n            }\n\
    \        }\n        else if(l > 0)\n        {\n            if(smallest_positive\
    \ is null)\n            {\n                smallest_positive = l;\n          \
    \  }\n            else\n            {\n                smallest_positive = min(smallest_positive,\
    \ l);\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3sxf5rxr.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3sxf5rxr.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3sxf5rxr.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp3sxf5rxr.d(33): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp3sxf5rxr.d(38): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    /tmp/tmp3sxf5rxr.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3sxf5rxr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(l; lst) \n    {\n        if(l < 0) \n\
    \        {\n            if(largest_negative is null || l > largest_negative) \n\
    \            {\n                largest_negative = l;\n            }\n       \
    \ }\n        else if(l > 0) \n        {\n            if(smallest_positive is null\
    \ || l < smallest_positive) \n            {\n                smallest_positive\
    \ = l;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\n/*\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n  \
    \      auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcsf_1_fg.d(42): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcsf_1_fg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164173
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative.isNull || i > largestNegative.get)\n            {\n  \
    \              largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive.isNull || i < smallestPositive.get)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7xmu8f73.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp7xmu8f73.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7xmu8f73.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = Nullable!(long)();\n    Nullable!(long)\
    \ smallestPositive = Nullable!(long)();\n    foreach(i; lst)\n    {\n        if(i\
    \ < 0)\n        {\n            if(largestNegative.isNull || i > largestNegative.get)\n\
    \            {\n                largestNegative = Nullable!(long)(i);\n      \
    \      }\n        }\n        else if(i > 0)\n        {\n            if(smallestPositive.isNull\
    \ || i < smallestPositive.get)\n            {\n                smallestPositive\
    \ = Nullable!(long)(i);\n            }\n        }\n    }\n    return tuple(largestNegative,\
    \ smallestPositive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164173
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i > 0)\n \
    \       {\n            if(smallest_positive.isNull || i < smallest_positive)\n\
    \            {\n                smallest_positive = i;\n            }\n      \
    \  }\n        else if(i < 0)\n        {\n            if(largest_negative.isNull\
    \ || i > largest_negative)\n            {\n                largest_negative =\
    \ i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxgdoovy6.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpxgdoovy6.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxgdoovy6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164174
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(e; lst)\n    {\n        if(e < 0)\n        {\n        \
    \    if(largest is null || e > largest)\n            {\n                largest\
    \ = e;\n            }\n        }\n        else if(e > 0)\n        {\n        \
    \    if(smallest is null || e < smallest)\n            {\n                smallest\
    \ = e;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5oj4nytg.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5oj4nytg.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5oj4nytg.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp5oj4nytg.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5oj4nytg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative is null)\n            {\n         \
    \       largest_negative = i;\n            }\n            else\n            {\n\
    \                largest_negative = max(largest_negative, i);\n            }\n\
    \        }\n        else if(i > 0)\n        {\n            if(smallest_positive\
    \ is null)\n            {\n                smallest_positive = i;\n          \
    \  }\n            else\n            {\n                smallest_positive = min(smallest_positive,\
    \ i);\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5hcradp1.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5hcradp1.d(27): Error: incompatible types for `(largest_negative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(33): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp5hcradp1.d(38): Error: incompatible types for `(smallest_positive) is
    (null)`: `Nullable!long` and `typeof(null)`

    /tmp/tmp5hcradp1.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5hcradp1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(l; lst)\n    {\n        if(l < 0)\n        {\n        \
    \    if(largestNegative is null || l > largestNegative)\n            {\n     \
    \           largestNegative = l;\n            }\n        }\n        else if(l\
    \ > 0)\n        {\n            if(smallestPositive is null || l < smallestPositive)\n\
    \            {\n                smallestPositive = l;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3nd017rc.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp3nd017rc.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmp3nd017rc.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3nd017rc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164169
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = null;\n    Nullable!(long) smallestPositive\
    \ = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n        {\n        \
    \    if(largestNegative is null || i > largestNegative)\n            {\n     \
    \           largestNegative = i;\n            }\n        }\n        else if(i\
    \ > 0)\n        {\n            if(smallestPositive is null || i < smallestPositive)\n\
    \            {\n                smallestPositive = i;\n            }\n       \
    \ }\n    }\n    return tuple(largestNegative, smallestPositive);\n}\nunittest\n\
    {\n    alias candidate = largest_smallest_integers;\n\n{\n        auto result\
    \ = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyknjwhru.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpyknjwhru.d(27): Error: incompatible types for `(largestNegative) is (null)`:
    `Nullable!long` and `typeof(null)`

    /tmp/tmpyknjwhru.d(34): Error: incompatible types for `(smallestPositive) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyknjwhru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164168
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(num; lst)\n    {\n        if(num < 0)\n\
    \        {\n            if(largest_negative.isNull || num > largest_negative.get)\n\
    \            {\n                largest_negative = num;\n            }\n     \
    \   }\n        else if(num > 0)\n        {\n            if(smallest_positive.isNull\
    \ || num < smallest_positive.get)\n            {\n                smallest_positive\
    \ = num;\n            }\n        }\n    }\n    return tuple(largest_negative,\
    \ smallest_positive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk7pcnguo.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmpk7pcnguo.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk7pcnguo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164174
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = Nullable!(long)();\n    Nullable!(long)\
    \ smallest_positive = Nullable!(long)();\n    foreach(i; lst)\n    {\n       \
    \ if(i < 0)\n        {\n            if(largest_negative.isNull || i > largest_negative.get)\n\
    \            {\n                largest_negative = Nullable!(long)(i);\n     \
    \       }\n        }\n        else if(i > 0)\n        {\n            if(smallest_positive.isNull\
    \ || i < smallest_positive.get)\n            {\n                smallest_positive\
    \ = Nullable!(long)(i);\n            }\n        }\n    }\n    return tuple(largest_negative,\
    \ smallest_positive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164171
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = null;\n    Nullable!(long)\
    \ smallest_positive = null;\n    foreach(i; lst)\n    {\n        if(i < 0)\n \
    \       {\n            if(largest_negative.isNull || i > largest_negative.get)\n\
    \            {\n                largest_negative = i;\n            }\n       \
    \ }\n        else if(i > 0)\n        {\n            if(smallest_positive.isNull\
    \ || i < smallest_positive.get)\n            {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return tuple(largest_negative, smallest_positive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0v4bmdwv.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp0v4bmdwv.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0v4bmdwv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164170
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largestNegative = Nullable!(long)();\n    Nullable!(long)\
    \ smallestPositive = Nullable!(long)();\n    foreach(i; lst)\n    {\n        if(i\
    \ < 0)\n        {\n            if(largestNegative.isNull)\n            {\n   \
    \             largestNegative = Nullable!(long)(i);\n            }\n         \
    \   else\n            {\n                largestNegative = Nullable!(long)(max(largestNegative.get,\
    \ i));\n            }\n        }\n        else if(i > 0)\n        {\n        \
    \    if(smallestPositive.isNull)\n            {\n                smallestPositive\
    \ = Nullable!(long)(i);\n            }\n            else\n            {\n    \
    \            smallestPositive = Nullable!(long)(min(smallestPositive.get, i));\n\
    \            }\n        }\n    }\n    return tuple(largestNegative, smallestPositive);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpail30lt8.d(33): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmpail30lt8.d(44): Error: undefined identifier `min`, did you mean function
    `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpail30lt8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164174
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest = null;\n    Nullable!(long) smallest\
    \ = null;\n    foreach(e; lst)\n    {\n        if(e < 0)\n        {\n        \
    \    if(largest is null || e > largest)\n            {\n                largest\
    \ = e;\n            }\n        }\n        else if(e > 0)\n        {\n        \
    \    if(smallest is null || e < smallest)\n            {\n                smallest\
    \ = e;\n            }\n        }\n    }\n    return tuple(largest, smallest);\n\
    }\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\n{\n      \
    \  auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5oj4nytg.d(21): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5oj4nytg.d(22): Error: `inout` method `std.typecons.Nullable!long.Nullable.this`
    is not callable using a mutable object

    /tmp/tmp5oj4nytg.d(27): Error: incompatible types for `(largest) is (null)`: `Nullable!long`
    and `typeof(null)`

    /tmp/tmp5oj4nytg.d(34): Error: incompatible types for `(smallest) is (null)`:
    `Nullable!long` and `typeof(null)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5oj4nytg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164172
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
    \ returns a tuple (a, b), where 'a' is\n    the largest of negative integers,\
    \ and 'b' is the smallest\n    of positive integers in a list.\n    If there is\
    \ no negative or positive integers, return them as None.\n\n    Examples:\n  \
    \  >>> largest_smallest_integers([2L, 4L, 1L, 3L, 5L, 7L])\n    tuple(None, 1L)\n\
    \    >>> largest_smallest_integers([])\n    tuple(None, None)\n    >>> largest_smallest_integers([0L])\n\
    \    tuple(None, None)\n    \n*/\nTuple!(Nullable!(long), Nullable!(long)) largest_smallest_integers(long[]\
    \ lst) \n{\n    Nullable!(long) largest_negative = Nullable!(long)();\n    Nullable!(long)\
    \ smallest_positive = Nullable!(long)();\n    foreach(i; lst) \n    {\n      \
    \  if(i < 0) \n        {\n            if(largest_negative.isNull || i > largest_negative.get)\
    \ \n            {\n                largest_negative = Nullable!(long)(i);\n  \
    \          }\n        }\n        else if(i > 0) \n        {\n            if(smallest_positive.isNull\
    \ || i < smallest_positive.get) \n            {\n                smallest_positive\
    \ = Nullable!(long)(i);\n            }\n        }\n    }\n    return tuple(largest_negative,\
    \ smallest_positive);\n}\nunittest\n{\n    alias candidate = largest_smallest_integers;\n\
    \n{\n        auto result = candidate([2L, 4L, 1L, 3L, 5L, 7L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([2L, 4L, 1L, 3L, 5L, 7L, 0L]);\n        assert(result[0].isNull);\n\
    \        assert(!result[1].isNull && result[1].get == 1L);\n}\n\n{\n        auto\
    \ result = candidate([1L, 3L, 2L, 4L, 5L, 6L, -2L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -2L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([4L, 5L, 3L, 6L, 2L, 7L, -7L]);\n\
    \        assert(!result[0].isNull && result[0].get == -7L);\n        assert(!result[1].isNull\
    \ && result[1].get == 2L);\n}\n\n{\n        auto result = candidate([7L, 3L, 8L,\
    \ 4L, 9L, 2L, 5L, -9L]);\n        assert(!result[0].isNull && result[0].get ==\
    \ -9L);\n        assert(!result[1].isNull && result[1].get == 2L);\n}\n\n{\n \
    \       auto result = candidate([]);\n        assert(result[0].isNull);\n    \
    \    assert(result[1].isNull);\n}\n\n{\n        auto result = candidate([0L]);\n\
    \        assert(result[0].isNull);\n        assert(result[1].isNull);\n}\n\n{\n\
    \        auto result = candidate([-1L, -3L, -5L, -6L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-1L, -3L, -5L, -6L, 0L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -1L);\n        assert(result[1].isNull);\n}\n\n{\n     \
    \   auto result = candidate([-6L, -4L, -4L, -3L, 1L]);\n        assert(!result[0].isNull\
    \ && result[0].get == -3L);\n        assert(!result[1].isNull && result[1].get\
    \ == 1L);\n}\n\n{\n        auto result = candidate([-6L, -4L, -4L, -3L, -100L,\
    \ 1L]);\n        assert(!result[0].isNull && result[0].get == -3L);\n        assert(!result[1].isNull\
    \ && result[1].get == 1L);\n}\n\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164176
