{
  "name": "mbpp_247_lps",
  "language": "r",
  "prompt": "# Write a function to find the length of the longest palindromic subsequence in the given string.\nlps <- function(str) {",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_247_lps.py",
  "prompt_terminology": "verbatim",
  "tests": "test_humaneval <- function() {\ncandidate <- lps\n    if(!identical(candidate('TENS FOR TENS'), 5)){quit('no', 1)}\n    if(!identical(candidate('CARDIO FOR CARDS'), 7)){quit('no', 1)}\n    if(!identical(candidate('PART OF THE JOURNEY IS PART'), 9)){quit('no', 1)}\n}\ntest_humaneval()",
  "stop_tokens": [
    "\n#",
    "\n```"
  ],
  "completions": [
    "\n    n <- length(str)\n    # Create a table to store results of subproblems\n    L <- matrix(0, n, n)\n    # Strings of length 1 are palindrome of length 1\n    for (i in 1:n) {\n        L[i, i] <- 1\n    }\n    # Build the table. Note that the lower diagonal values of table are\n    # useless and not filled in the process. The values are filled in a\n    # manner similar to Matrix Chain Multiplication DP solution (See\n    # https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/).\n    # cl is length of substring\n    for (cl in 2:n) {\n        for (i in 1:n-cl+1) {\n            j <- i+cl-1\n            if (str[i] == str[j] && cl == 2) {\n                L[i, j] <- 2\n            } else if (str[i] == str[j]) {\n                L[i, j] <- L[i+1, j-1] + 2\n            } else {\n                L[i, j] <- max(L[i, j-1], L[i+1, j])\n            }\n        }\n    }\n    return(L[1, n])\n}\n",
    "\n  n <- nchar(str)\n  L <- matrix(0, nrow=n, ncol=n)\n  for (i in 1:n) {\n    L[i,i] <- 1\n  }\n  for (cl in 2:n) {\n    for (i in 1:(n-cl+1)) {\n      j <- i+cl-1\n      if (str[i] == str[j] && cl == 2) {\n        L[i,j] <- 2\n      } else if (str[i] == str[j]) {\n        L[i,j] <- L[i+1,j-1] + 2\n      } else {\n        L[i,j] <- max(L[i,j-1], L[i+1,j])\n      }\n    }\n  }\n  return(L[1,n])\n}\n\nlps(\"GEEKSFORGEEKS\")\n",
    "\n  n <- nchar(str)\n  L <- matrix(0, n, n)\n  for (i in 1:n) {\n    L[i, i] <- 1\n  }\n  for (cl in 2:n) {\n    for (i in 1:(n-cl+1)) {\n      j <- i+cl-1\n      if (str[i] == str[j] && cl == 2) {\n        L[i, j] <- 2\n      } else if (str[i] == str[j]) {\n        L[i, j] <- L[i+1, j-1] + 2\n      } else {\n        L[i, j] <- max(L[i, j-1], L[i+1, j])\n      }\n    }\n  }\n  return(L[1, n])\n}\n\nlps(\"BBABCBCAB\")\n",
    "\n    n <- nchar(str)\n    table <- matrix(0, n, n)\n    for (i in 1:n) {\n        table[i, i] <- 1\n    }\n    for (cl in 2:n) {\n        for (i in 1:(n - cl + 1)) {\n            j <- i + cl - 1\n            if (str[i] == str[j] && cl == 2) {\n                table[i, j] <- 2\n            } else if (str[i] == str[j]) {\n                table[i, j] <- table[i + 1, j - 1] + 2\n            } else {\n                table[i, j] <- max(table[i, j - 1], table[i + 1, j])\n            }\n        }\n    }\n    return(table[1, n])\n}\n\nlps(\"BBABCBCAB\")\n",
    "\n    n <- length(str)\n    L <- matrix(0, n, n)\n    for (i in 1:n) {\n        L[i, i] <- 1\n    }\n    for (cl in 2:n) {\n        for (i in 1:(n - cl + 1)) {\n            j <- i + cl - 1\n            if (str[i] == str[j] && cl == 2) {\n                L[i, j] <- 2\n            } else if (str[i] == str[j]) {\n                L[i, j] <- L[i + 1, j - 1] + 2\n            } else {\n                L[i, j] <- max(L[i, j - 1], L[i + 1, j])\n            }\n        }\n    }\n    return(L[1, n])\n}\nlps(\"BBABCBCAB\")\n",
    "\n    n <- length(str)\n    L <- matrix(0, n, n)\n    for (i in 1:n) {\n        L[i,i] <- 1\n    }\n    for (cl in 2:n) {\n        for (i in 1:(n-cl+1)) {\n            j <- i+cl-1\n            if (str[i] == str[j] && cl == 2) {\n                L[i,j] <- 2\n            } else if (str[i] == str[j]) {\n                L[i,j] <- L[i+1,j-1] + 2\n            } else {\n                L[i,j] <- max(L[i,j-1], L[i+1,j])\n            }\n        }\n    }\n    return(L[1,n])\n}\n\nlps(\"GEEKSFORGEEKS\")\n",
    "\n  n <- nchar(str)\n  L <- matrix(0, nrow = n, ncol = n)\n  for(i in 1:n) {\n    L[i,i] <- 1\n  }\n  for(cl in 2:n) {\n    for(i in 1:(n-cl+1)) {\n      j <- i+cl-1\n      if(str[i] == str[j] && cl == 2) {\n        L[i,j] <- 2\n      } else if(str[i] == str[j]) {\n        L[i,j] <- L[i+1,j-1] + 2\n      } else {\n        L[i,j] <- max(L[i,j-1], L[i+1,j])\n      }\n    }\n  }\n  return(L[1,n])\n}\n\nlps(\"BBABCBCAB\")\n",
    "\n  n <- nchar(str)\n  L <- matrix(0, n, n)\n  for (i in 1:n) {\n    L[i, i] <- 1\n  }\n  for (cl in 2:n) {\n    for (i in 1:(n-cl+1)) {\n      j <- i+cl-1\n      if (str[i] == str[j] && cl == 2) {\n        L[i, j] <- 2\n      } else if (str[i] == str[j]) {\n        L[i, j] <- L[i+1, j-1] + 2\n      } else {\n        L[i, j] <- max(L[i, j-1], L[i+1, j])\n      }\n    }\n  }\n  L[1, n]\n}\n\nlps(\"BBABCBCAB\")\n",
    "\n    n <- nchar(str)\n    L <- matrix(0, n, n)\n    for (i in 1:n) {\n        L[i, i] <- 1\n    }\n    for (cl in 2:n) {\n        for (i in 1:(n-cl+1)) {\n            j <- i+cl-1\n            if (str[i] == str[j] && cl == 2) {\n                L[i, j] <- 2\n            } else if (str[i] == str[j]) {\n                L[i, j] <- L[i+1, j-1] + 2\n            } else {\n                L[i, j] <- max(L[i, j-1], L[i+1, j])\n            }\n        }\n    }\n    L[1, n]\n}\n\nlps(\"BBABCBCAB\")\n",
    "\n  # Create a table to store results of subproblems\n  n <- nchar(str)\n  L <- matrix(0, n, n)\n  # Strings of length 1 are palindrome of length 1\n  for (i in 1:n) {\n    L[i, i] <- 1\n  }\n  # Build the table. Note that the lower diagonal values of table are\n  # useless and not filled in the process. The values are filled in a\n  # manner similar to Matrix Chain Multiplication DP solution (See\n  # http://www.geeksforgeeks.org/archives/15553). cl is length of\n  # substring\n  for (cl in 2:n) {\n    for (i in 1:(n-cl+1)) {\n      j <- i+cl-1\n      if (str[i] == str[j] && cl == 2) {\n        L[i, j] <- 2\n      } else if (str[i] == str[j]) {\n        L[i, j] <- L[i+1, j-1] + 2\n      } else {\n        L[i, j] <- max(L[i, j-1], L[i+1, j])\n      }\n    }\n  }\n  return(L[1, n])\n}\n",
    "\n  n <- nchar(str)\n  L <- matrix(0, n, n)\n  for (i in 1:n) {\n    L[i, i] <- 1\n  }\n  for (cl in 2:n) {\n    for (i in 1:(n - cl + 1)) {\n      j <- i + cl - 1\n      if (str[i] == str[j] && cl == 2) {\n        L[i, j] <- 2\n      } else if (str[i] == str[j]) {\n        L[i, j] <- L[i + 1, j - 1] + 2\n      } else {\n        L[i, j] <- max(L[i, j - 1], L[i + 1, j])\n      }\n    }\n  }\n  return(L[1, n])\n}\n\nlps(\"BBABCBCAB\")\n",
    "\n  n <- nchar(str)\n  L <- matrix(0, n, n)\n  for (i in 1:n) {\n    L[i, i] <- 1\n  }\n  for (cl in 2:n) {\n    for (i in 1:(n - cl + 1)) {\n      j <- i + cl - 1\n      if (str[i] == str[j] && cl == 2) {\n        L[i, j] <- 2\n      } else if (str[i] == str[j]) {\n        L[i, j] <- L[i + 1, j - 1] + 2\n      } else {\n        L[i, j] <- max(L[i, j - 1], L[i + 1, j])\n      }\n    }\n  }\n  L[1, n]\n}\n\nlps(\"BBABCBCAB\")\n",
    "\n    n <- nchar(str)\n    L <- matrix(0, n, n)\n    for (i in 1:n) {\n        L[i, i] <- 1\n    }\n    for (cl in 2:n) {\n        for (i in 1:(n - cl + 1)) {\n            j <- i + cl - 1\n            if (str[i] == str[j] && cl == 2) {\n                L[i, j] <- 2\n            } else if (str[i] == str[j]) {\n                L[i, j] <- L[i + 1, j - 1] + 2\n            } else {\n                L[i, j] <- max(L[i, j - 1], L[i + 1, j])\n            }\n        }\n    }\n    return(L[1, n])\n}\n",
    "\n  n <- nchar(str)\n  L <- matrix(0, n, n)\n  for (i in 1:n) {\n    L[i, i] <- 1\n  }\n  for (cl in 2:n) {\n    for (i in 1:(n - cl + 1)) {\n      j <- i + cl - 1\n      if (str[i] == str[j] && cl == 2) {\n        L[i, j] <- 2\n      } else if (str[i] == str[j]) {\n        L[i, j] <- L[i + 1, j - 1] + 2\n      } else {\n        L[i, j] <- max(L[i, j - 1], L[i + 1, j])\n      }\n    }\n  }\n  return(L[1, n])\n}\n\nlps(\"BBABCBCAB\")\n",
    "\n  n <- length(str)\n  # Create a table to store results of subproblems\n  L <- matrix(0, n, n)\n  # Strings of length 1 are palindrome of length 1\n  for (i in 1:n) {\n    L[i, i] <- 1\n  }\n  # Build the table. Note that the lower diagonal values of table are\n  # useless and not filled in the process. The values are filled in a\n  # manner similar to Matrix Chain Multiplication DP solution (See\n  # http://www.geeksforgeeks.org/archives/15553). cl is length of\n  # substring\n  for (cl in 2:n) {\n    for (i in 1:(n-cl+1)) {\n      j <- i+cl-1\n      if (str[i] == str[j] && cl == 2) {\n        L[i, j] <- 2\n      } else if (str[i] == str[j]) {\n        L[i, j] <- L[i+1, j-1] + 2\n      } else {\n        L[i, j] <- max(L[i, j-1], L[i+1, j])\n      }\n    }\n  }\n  return(L[1, n])\n}\n",
    "\n  n <- length(str)\n  L <- matrix(0, n, n)\n  for (i in 1:n) {\n    L[i, i] <- 1\n  }\n  for (cl in 2:n) {\n    for (i in 1:(n-cl+1)) {\n      j <- i + cl - 1\n      if (str[i] == str[j] && cl == 2) {\n        L[i, j] <- 2\n      } else if (str[i] == str[j]) {\n        L[i, j] <- L[i+1, j-1] + 2\n      } else {\n        L[i, j] <- max(L[i, j-1], L[i+1, j])\n      }\n    }\n  }\n  return(L[1, n])\n}\n",
    "\n  n <- nchar(str)\n  L <- matrix(0, n, n)\n  for (i in 1:n) {\n    L[i, i] <- 1\n  }\n  for (cl in 2:n) {\n    for (i in 1:(n - cl + 1)) {\n      j <- i + cl - 1\n      if (str[i] == str[j] && cl == 2) {\n        L[i, j] <- 2\n      } else if (str[i] == str[j]) {\n        L[i, j] <- L[i + 1, j - 1] + 2\n      } else {\n        L[i, j] <- max(L[i, j - 1], L[i + 1, j])\n      }\n    }\n  }\n  return(L[1, n])\n}\n\nlps(\"BBABCBCAB\")\n",
    "\n  n <- nchar(str)\n  L <- matrix(0, n, n)\n  for (i in 1:n) {\n    L[i, i] <- 1\n  }\n  for (cl in 2:n) {\n    for (i in 1:(n - cl + 1)) {\n      j <- i + cl - 1\n      if (str[i] == str[j] && cl == 2) {\n        L[i, j] <- 2\n      } else if (str[i] == str[j]) {\n        L[i, j] <- L[i + 1, j - 1] + 2\n      } else {\n        L[i, j] <- max(L[i, j - 1], L[i + 1, j])\n      }\n    }\n  }\n  return(L[1, n])\n}\n\nlps(\"BBABCBCAB\")\n",
    "\n  n <- nchar(str)\n  L <- matrix(0, nrow = n, ncol = n)\n  for (i in 1:n) {\n    L[i,i] <- 1\n  }\n  for (cl in 2:n) {\n    for (i in 1:(n-cl+1)) {\n      j <- i + cl - 1\n      if (str[i] == str[j] && cl == 2) {\n        L[i,j] <- 2\n      } else if (str[i] == str[j]) {\n        L[i,j] <- L[i+1,j-1] + 2\n      } else {\n        L[i,j] <- max(L[i,j-1], L[i+1,j])\n      }\n    }\n  }\n  return(L[1,n])\n}\n\nstr <- \"GEEKSFORGEEKS\"\nlps(str)\n",
    "\n  n <- nchar(str)\n  L <- matrix(0, n, n)\n  for (i in 1:n) {\n    L[i, i] <- 1\n  }\n  for (cl in 2:n) {\n    for (i in 1:(n - cl + 1)) {\n      j <- i + cl - 1\n      if (str[i] == str[j] && cl == 2) {\n        L[i, j] <- 2\n      } else if (str[i] == str[j]) {\n        L[i, j] <- L[i + 1, j - 1] + 2\n      } else {\n        L[i, j] <- max(L[i, j - 1], L[i + 1, j])\n      }\n    }\n  }\n  return(L[1, n])\n}\n\nlps(\"GEEKSFORGEEKS\")\n"
  ]
}