name: HumanEval_0_has_close_elements
language: lua
prompt: "-- Check if in given list of numbers, are any two numbers closer to each\
  \ other than\n-- given threshold.\nlocal function has_close_elements(numbers, threshold)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = has_close_elements\n\
  \    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), true)\n   \
  \ lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), false)\n    lu.assertEquals(candidate({1.0,\
  \ 2.0, 5.9, 4.0, 5.0}, 0.95), true)\n    lu.assertEquals(candidate({1.0, 2.0, 5.9,\
  \ 4.0, 5.0}, 0.8), false)\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.0}, 0.1), true)\n    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 1.0),\
  \ true)\n    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), false)\n\
  end\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local function close(a, b)\n    return math.abs(a - b) <= threshold\n\
    \  end\n  local size = #numbers\n  assert(size >= 2, 'should have at least two\
    \ numbers')\n  assert(size > 1, 'should have at least two numbers')\n  local closed\
    \ = false\n  local i = 0\n  while i < size do\n    local a = numbers[i]\n    local\
    \ j = i + 1\n    while j < size do\n      local b = numbers[j]\n      if close(a,\
    \ b) then\n        return true\n      end\n      j = j + 1\n    end\n    i = i\
    \ + 1\n  end\n  return false\nend", "  assert(type(numbers) == 'table', 'argument\
    \ numbers must be table')\n  local num_values = #numbers", "  local function is_close(a,\
    \ b) -- Checks if two numbers are closer than threshold.\n    return math.abs(a\
    \ - b) < threshold\n  end\n  for i, x in ipairs(numbers) do\n    for j, y in ipairs(numbers)\
    \ do\n      if i > j and is_close(x, y) and is_close(y, x) then\n        return\
    \ true\n      end\n    end\n  end\n  return false\nend", "  for i = 2, #numbers\
    \ - 1 do\n    for j = 1, #numbers do\n      if numbers[i] > numbers[j] then\n\
    \        -- Found two elements not equal\n        return false\n      end\n  \
    \  end\n  end", "    local first = numbers[1]\n    local last = numbers[#numbers]\n\
    \    for i = 1, #numbers do\n        local current = numbers[i]\n        if current\
    \ == first or current == last then\n            return false\n        else\n \
    \           local difference = current - first\n            if difference > threshold\
    \ then\n                return true\n            end\n        end\n    end\n \
    \   return false\nend", "  if #numbers == 0 then\n    return false\n  end\n  for\
    \ i = 1, #numbers do\n    for j = i + 1, #numbers do\n      if math.abs(numbers[i]\
    \ - numbers[j]) < threshold then\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "  -- Check if there are any two numbers in given list\
    \ which are closer to each other.\n  for _, v in pairs(numbers) do\n    for _,\
    \ v2 in pairs(numbers) do\n      -- If the two numbers are in given list, are\
    \ they closer than given threshold?\n      if v == v2 then\n        if v - threshold\
    \ < v2 - threshold then\n          return true\n        end\n      end\n    end\n\
    \  end\n  return false\nend", "    local found = {}\n    local max_diff = 0\n\
    \    for _, num in pairs(numbers) do\n        for _, num2 in pairs(numbers) do\n\
    \            local diff = num - num2\n            if diff < threshold then\n \
    \               max_diff = diff\n                found = {num = num, num2 = num2}\n\
    \            end\n        end\n    end\n    return found, max_diff\nend", "  for\
    \ _, num1 in pairs(numbers) do\n    for _, num2 in pairs(numbers) do\n      if\
    \ abs(num1 - num2) > threshold then\n        return true\n      end\n    end\n\
    \  end", "  local is_close = false\n  for _, el1 in ipairs(numbers) do\n    local\
    \ ok = false\n    for _, el2 in ipairs(numbers) do\n      if abs(el1 - el2) <\
    \ threshold then\n        ok = true\n        break\n      end\n    end\n    if\
    \ is_close then\n      return false\n    end\n    if not ok then\n      is_close\
    \ = true\n    end\n  end\n  return true\nend", "  local num_min = math.min(table.unpack(numbers))\n\
    \  local num_max = math.max(table.unpack(numbers))\n  local count = 0\n  for _,\
    \ el in pairs(numbers) do\n    local distance = abs(num_min - el)\n    count =\
    \ count + distance < threshold\n  end\n  return count\nend", "  for i, number\
    \ in ipairs(numbers) do\n    if numbers[i+1] - number > threshold then\n     \
    \ return true\n    end\n  end\n  return false\nend", "  local is_closed = {}\n\
    \  local min_index\n  local max_index", "  local close\n  for _, i in pairs(numbers)\
    \ do\n    close = false\n    for _, j in pairs(numbers) do\n      if i == j then\n\
    \        close = true\n        break\n      end\n      if math.abs(i - j) < threshold\
    \ then\n        close = true\n        break\n      end\n    end\n    if close\
    \ then return true end\n  end\n  return false\nend", "  -- Return false if no\
    \ numbers are given\n  if not numbers then return end", "  for i = 1, #numbers\
    \ do\n    for j = 1, #numbers do\n      if (numbers[i] > numbers[j]) then break\
    \ end\n      if (numbers[i] + threshold > numbers[j]) then\n        return true\n\
    \      end\n    end\n  end\n  return false\nend", "    for i = 1, #numbers do\n\
    \        for j = i+1, #numbers do\n            if distance_between_vectors(numbers[i],\
    \ numbers[j]) > threshold then\n                return true\n            end\n\
    \        end\n    end\n    return false\nend", "    for _, value in ipairs(numbers)\
    \ do\n        for _, value_2 in ipairs(numbers) do\n            if value == value_2\
    \ then\n                continue\n            end", "  local counts = {}\n  local\
    \ elements = {}\n  for _, value in ipairs(numbers) do\n    local count = counts[value]\n\
    \    if count == nil then\n      counts[value] = 1\n      elements[value] = true\n\
    \    else\n      counts[value] = count + 1\n    end\n  end\n  for key, value in\
    \ pairs(counts) do\n    if value < threshold then\n      return false\n    end\n\
    \  end\n  return true\nend", "  for i,v in ipairs(numbers) do\n    for j,w in\
    \ ipairs(numbers) do\n      if j>i and v+w < threshold then\n        return true\n\
    \      end\n    end\n  end\n  return false\nend", '   local min = nil', "   for\
    \ _, num in pairs(numbers) do\n      for _, other_num in pairs(numbers) do\n \
    \        if other_num ~= num and math.abs(num - other_num) <= threshold then\n\
    \            return true\n         end\n      end\n   end\n   return false\nend",
  "  if #numbers < 3 then\n    return false\n  end", "    local i = 0\n    local j\
    \ = 1\n    local closest = 0\n    local max_diff = threshold\n    local closest\
    \ = numbers[i]\n    if numbers[i] ~= numbers[1] then\n        while i < #numbers\
    \ and j < #numbers and numbers[i] > numbers[j] do\n            i = i + 1\n   \
    \         max_diff = (max_diff or numbers[i])\n        end\n        while j <\
    \ #numbers and i < #numbers and numbers[j] < numbers[i] do\n            j = j\
    \ + 1\n            max_diff = (max_diff or numbers[j])\n        end\n    end\n\
    \    while i < #numbers and numbers[i] < max_diff do\n        i = i + 1\n    end\n\
    \    while j < #numbers and numbers[j] > max_diff do\n        j = j + 1\n    end\n\
    \    if i >= #numbers then\n        return false\n    elseif j >= #numbers then\n\
    \        return true\n    else\n        return numbers[i] > numbers[j]\n    end\n\
    end", "    local close = 1\n    for i = 1, #numbers do\n        if numbers[i]\
    \ > threshold then\n            close = 0\n        elseif numbers[i] < threshold\
    \ then\n            close = 1\n        end\n    end\n    return close\nend", " \
    \ if #numbers < 2 then\n    return false\n  end\n  for i = 2, #numbers do\n  \
    \  for j = i + 1, #numbers do\n      if abs(numbers[i] - numbers[j]) < threshold\
    \ then\n        return true\n      end\n    end\n  end\n  return false\nend",
  "  local max_distance = math.max(...)\n  for _, a in pairs(numbers) do\n    for\
    \ _, b in pairs(numbers) do\n      if a == b then\n        -- Ignore the cases\
    \ where two numbers are equal.\n        continue\n      end\n      local distance\
    \ = math.sqrt(math.abs(a - b))\n      if distance > threshold then\n        return\
    \ true\n      end\n      local dist = math.sqrt(math.abs(math.max(...) - a))\n\
    \      if dist > threshold then\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "    local min1 = numbers[1]\n    local max1 = numbers[1]\n\
    \    local min2 = numbers[2]\n    local max2 = numbers[2]", "  for i, v1 in pairs(numbers)\
    \ do\n    for j, v2 in pairs(numbers) do\n      local distance = math.abs(v1 -\
    \ v2)\n      if distance <= threshold then\n        return true\n      end\n \
    \   end\n  end\n  return false\nend", "  if #numbers == 0 then return true end\n\
    \  if #numbers == 1 then return false end", "    local function distance(a, b)\n\
    \        return math.abs(a - b) -- Return distance in terms of absolute values\n\
    \    end", "  local distances = nil\n  for i = 0, #numbers - 1 do\n    local distance\
    \ = math.abs(numbers[i + 1] - numbers[i])\n    if distances == nil then\n    \
    \  distances = { distance }\n    else\n      table.insert(distances, distance)\n\
    \    end\n  end\n  return #distances > 1 and #distances ~= #numbers / 2\nend",
  "  if #numbers < 3 then return false end\n  if #numbers == 2 then\n    return numbers[1]\
    \ <= threshold and numbers[2] >= threshold\n  end\n  -- Get middle element\n \
    \ local middle_idx = ((#numbers - 1) / 2 + 1):floor()\n  local middle = numbers[middle_idx]\n\
    \  -- Iterate from middle to second last\n  local i1, i2 = middle_idx + 1, middle_idx\
    \ + 2\n  while i1 < #numbers and i2 < #numbers and numbers[i1] <= middle and numbers[i2]\
    \ >= middle do\n    i1, i2 = i1 + 1, i2 + 1\n  end\n  -- If middle element is\
    \ the one we want\n  if i1 == #numbers or i2 == #numbers then\n    return middle\
    \ <= threshold and middle >= threshold\n  end\n  -- If middle element is closer\
    \ to threshold\n  return numbers[i1] <= middle and middle <= numbers[i2]\nend",
  "   local min_diff = threshold\n   for _, number in ipairs(numbers) do\n      local\
    \ diff = math.abs(number - min_diff)\n      if diff < threshold then\n       \
    \  return true\n      elseif diff < min_diff then\n         min_diff = diff\n\
    \      end\n   end\n   return false\nend", "  local function has(n1, n2)\n   \
    \ for _, v in ipairs(numbers) do\n      local dist = math.abs(v - n1)\n      if\
    \ dist < threshold then\n        return true\n      end\n    end\n    return false\n\
    \  end\n  return has\nend", "  for _, value in ipairs(numbers) do\n    for _,\
    \ other_value in ipairs(numbers) do\n      if value < other_value and other_value\
    \ < threshold then\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "    assert(threshold:le(0))\n    local has_close_elements = false\n   \
    \ for _, number in ipairs(numbers) do\n        if math.abs(number - 1) < threshold\
    \ then\n            has_close_elements = true\n            break\n        end\n\
    \        if math.abs(number - 10) < threshold then\n            has_close_elements\
    \ = true\n            break\n        end\n    end\n    return has_close_elements\n\
    end", "  local close_list = setmetatable({}, {\n    __index = function(t, key)\n\
    \      local number1 = t[key]\n      for i, n in ipairs(numbers) do\n        local\
    \ number2 = numbers[i]\n        if number1 <= number2 then\n          if number1\
    \ - threshold <= number2 - threshold\n          or number1 - threshold >= number2\
    \ - threshold\n          or number1 - threshold > number2 - threshold then\n \
    \           return true\n          end\n        end\n      end\n      return false\n\
    \    end\n  })\n  return setmetatable(close_list, nil)\nend", "    local closest\n\
    \    for _,v in ipairs(numbers) do\n        local closest = v\n        for _,v2\
    \ in ipairs(numbers) do\n            if v < threshold then\n                break\n\
    \            end\n            if abs(v - v2) < threshold then\n              \
    \  closest = v2\n                break\n            end\n        end\n       \
    \ if closest then\n            return true\n        end\n    end\n    return false\n\
    end", "    for i = 1, #numbers - 1 do\n        local n = numbers[i]\n        for\
    \ j = i + 1, #numbers do\n            local m = numbers[j]\n            if abs(n\
    \ - m) < threshold then\n                return true\n            end\n      \
    \  end\n    end\n    return false\nend", "    local min_distance = math.inf\n\
    \    local min_element\n    for _, number in pairs(numbers) do\n        local\
    \ distance = math.abs((number - threshold))\n        if distance < min_distance\
    \ then\n            min_distance = distance\n            min_element = number\n\
    \        end\n    end\n    return min_element\nend", "  local counts = {}\n  for\
    \ i = 1, #numbers do\n    table.insert(counts, 0)\n  end\n  for i = 1, #numbers\
    \ do\n    table.insert(counts, 0)\n  end\n  for i = 1, #numbers do\n    local\
    \ n1 = numbers[i]\n    local n2 = numbers[i + 1]\n    counts[math.abs(n1 - n2)]\
    \ += 1\n  end", "  local function is_closer(a, b, threshold)\n    if #b == 1 then\n\
    \      return (b - a < threshold)\n    else\n      local d = b - a\n      return\
    \ (d / #b < threshold)\n    end\n  end\n  local found = false\n  for i = 1, #numbers\
    \ do\n    for j = 1, #numbers do\n      if j == i then\n        found = true\n\
    \      elseif is_closer(numbers[i], numbers[j], threshold) then\n        found\
    \ = true\n        break\n      end\n    end\n    if found then break end\n  end\n\
    \  return found\nend", "    local close = false\n    local close_number = 0\n\
    \    for i = 1, #numbers do\n        if numbers[i] < threshold then\n        \
    \    close = true\n            close_number = i\n        end\n    end\n    return\
    \ close and close_number\nend", "  local last_diff = threshold\n  for _, number\
    \ in pairs(numbers) do\n    local current_diff = math.abs(number - last_diff)\n\
    \    if current_diff > threshold then\n      return false\n    end\n    last_diff\
    \ = current_diff\n  end\n  return true\nend", "  for i = 1, #numbers do\n    if\
    \ numbers[i] ~= numbers[i - 1] + threshold then\n      return true\n    end\n\
    \  end\n  return false\nend", "    for _, v in pairs(numbers) do\n        for\
    \ _, v2 in pairs(numbers) do\n            if v == v2 or math.abs(v - v2) < threshold\
    \ then\n                return true\n            end\n        end\n    end\n \
    \   return false\nend", "    local min1 = math.min(numbers[#numbers])\n    local\
    \ max1 = math.max(numbers[#numbers])\n    for i = #numbers, 1, -1 do\n       \
    \ local min2, max2 = numbers[i], numbers[i]\n        for j = i + 1, #numbers do\n\
    \            local avg = (min1 + max2) / 2\n            local diff = avg - numbers[j]\n\
    \            if diff <= threshold then\n                return true\n        \
    \    end\n        end\n    end\n    return false\nend", "  if #numbers == 0 then\
    \ return false end\n  for _, a in pairs(numbers) do\n    for b in pairs(numbers)\
    \ do\n      local d = math.abs(a - b)\n      local closeness = math.abs(d - threshold)\n\
    \      if closeness > threshold then return true end\n    end\n  end\n  return\
    \ false\nend", "  for _, a in pairs(numbers) do\n    for _, b in pairs(numbers)\
    \ do\n      if a == b then return end\n      if a - b > threshold then return\
    \ end\n    end\n  end\n  return true\nend", "  for _, elem in pairs(numbers) do\n\
    \    for _, e in pairs(numbers) do\n      if elem == e then\n        -- Don't\
    \ bother comparing itself.\n        continue 2\n      end", "    -- Check for\
    \ at least one number in list\n    if next(numbers) ~= nil then\n        -- Iterate\
    \ through each number in list\n        for i = 1, #numbers do\n            --\
    \ Check if number is in list\n            if numbers[i] then\n               \
    \ -- Check if second number is in list\n                if numbers[i + 1] then\n\
    \                    -- Check if distance between both numbers is smaller than\
    \ threshold\n                    if math.sqrt(math.pow(numbers[i] - numbers[i\
    \ + 1], 2) + math.pow(threshold - numbers[i], 2)) < 0.5 then\n               \
    \         return true\n                    end\n                end\n        \
    \    end\n        end\n    end\n    return false\nend", "  for _, number in ipairs(numbers)\
    \ do\n    if threshold <= number then\n      return true\n    end\n  end\n  return\
    \ false\nend", "  local function is_close_element(element1, element2)\n    return\
    \ abs(element1 - element2) < threshold\n  end\n  return #numbers > 0 and #numbers\
    \ == #setmetatable(numbers, { __mode = \"kv\" })\n    and #setmetatable(numbers,\
    \ { __mode = \"set\", __len = setmetatable(#numbers, { __mode = \"kv\" }) }) ==\
    \ #numbers\n    and numbers[next(numbers)] ~= nil and next(numbers) ~= nil and\
    \ is_close_element(numbers[next(numbers)], numbers[next(numbers)])\nend", "\t\
    for _, element in ipairs(numbers) do\n\t\tlocal distances = nil\n\t\tlocal closest\
    \ = nil\n\t\tfor _, element in ipairs(numbers) do\n\t\t\tdistances = math.abs(element\
    \ - threshold)\n\t\t\tif closest == nil or distances < closest then\n\t\t\t\t\
    closest = distances\n\t\t\tend\n\t\tend\n\t\tif closest then\n\t\t\treturn true\n\
    \t\tend\n\tend\n\treturn false\nend", "  local closer = {}\n  for _, value in\
    \ pairs(numbers) do\n    local value2 = math.sqrt(math.abs(value))\n    local\
    \ minval = math.min(value2, threshold)\n    local maxval = math.max(value2, threshold)\n\
    \    local middle = (minval + maxval) / 2", '  if #numbers <= 1 then return false
    end', "    for _, value in ipairs(numbers) do\n        for _, value2 in ipairs(numbers)\
    \ do\n            if value ~= value2 and abs(value - value2) <= threshold then\n\
    \                return true\n            end\n        end\n    end\n    return\
    \ false\nend", "\tfor i,v in ipairs(numbers) do\n\t\tfor j,w in ipairs(numbers)\
    \ do\n\t\t\tif v == w then\n\t\t\t\tcontinue\n\t\t\tend", "    local num_1 = tonumber(numbers[1])\n\
    \    local num_2 = tonumber(numbers[2])\n    return (num_1 ~= num_2) or (abs(num_1\
    \ - num_2) < threshold)\nend", "  local distances = {}\n  for i, n in pairs(numbers)\
    \ do\n    distances[i] = {}\n    for _, j in pairs(numbers) do\n      distances[i][j]\
    \ = {}\n    end\n  end\n  for i, n1 in pairs(numbers) do\n    for j, n2 in pairs(numbers)\
    \ do\n      if i == j then\n        distances[i][j][n1] = 1\n      else\n    \
    \    distances[i][j][n1] = nn.abs(n1 - n2)\n        distances[i][j][n2] = 1\n\
    \      end\n    end\n  end\n  for _, i in pairs(numbers) do\n    for _, j in pairs(numbers)\
    \ do\n      for _, k in pairs(numbers) do\n        if distances[i][j][k] ~= distances[i][k][j]\
    \ then\n          return true\n        end\n      end\n    end\n  end\n  return\
    \ false\nend", "  local found = {}\n  for _, num in pairs(numbers) do\n    for\
    \ _, num2 in pairs(numbers) do\n      if num ~= num2 then\n        if abs(num\
    \ - num2) <= threshold then\n          found[#found + 1] = num2\n        end\n\
    \      end\n    end\n  end\n  return found\nend", "  local closed_elements = {}\n\
    \  for i,v in ipairs(numbers) do\n    for j,w in ipairs(numbers) do\n      --\
    \ If they are more than threshold.\n      if abs(v - w) > threshold then\n   \
    \     table.insert(closed_elements, v)\n      end\n    end\n  end\n  return closed_elements\n\
    end", "  -- First two elements to compare.\n  local index1 = 1\n  local index2\
    \ = 1", "  -- If threshold is zero, then return false immediately.\n  if threshold\
    \ == 0 then\n    return false\n  end", "  for _, number in pairs(numbers) do\n\
    \    for _, other_number in pairs(numbers) do\n      if number > other_number\
    \ then\n        -- Current is greater, so check if other number is\n        --\
    \ less than threshold\n        if other_number < threshold then\n          return\
    \ true\n        end\n      end\n    end\n  end\n  return false\nend", "  local\
    \ function is_close(a, b)\n    return math.abs(a - b) < threshold\n  end\n  local\
    \ function is_close_by_length(a, b)\n    return is_close(a, b) and math.abs(b\
    \ - a) < threshold\n  end\n  local function is_close_by_max_difference(a, b)\n\
    \    return is_close(a, b) and math.abs(b - a) > threshold\n  end", "  local n\
    \ = #numbers\n  local close = {}\n  local best = {}\n  local min_dist\n  local\
    \ best1\n  local best2", "    local function distance(x1,y1,x2,y2)\n        local\
    \ deltax = x2 - x1\n        local deltay = y2 - y1\n        return math.sqrt(deltax\
    \ * deltax + deltay * deltay)\n    end\n    for i = 1, #numbers - 1 do\n     \
    \   if distance(numbers[i], numbers[i+1], numbers[i+2], numbers[i+3]) > threshold\
    \ then\n            return true\n        end\n    end\n    return false\nend",
  "  local nn = #numbers - 1\n  local max = 0\n  local max_index", "  local max =\
    \ 0 \n  local min = 0\n  for _, num in pairs(numbers) do \n    max = math.max(max,\
    \ num)\n    min = math.min(min, num)\n  end\n  for _, num in pairs(numbers) do\
    \ \n    if num > threshold and num < max then\n      return true\n    else \n\
    \      if num < threshold and num > min then\n        return true\n      end\n\
    \    end\n  end\n  return false\nend", "    -- First check if there are any close\
    \ elements to each other in the list\n    -- of numbers\n    local closes = false\n\
    \    for i,v in ipairs(numbers) do\n        if numbers[i] <= threshold then\n\
    \            closes = true\n            break\n        end\n    end\n    -- If\
    \ not, just return false\n    if not closes then\n        return false\n    end\n\
    \    -- Now check if the threshold is too high and if the element before it is\
    \ not\n    -- too low (i.e. numbers[1] < threshold)\n    if threshold-numbers[1]\
    \ > threshold then\n        return false\n    end\n    -- Otherwise, check if\
    \ there are any close elements to each other in the list\n    -- of numbers after\
    \ the first element\n    closes = false\n    for i,v in ipairs(numbers) do\n \
    \       if numbers[i+1] <= threshold then\n            closes = true\n       \
    \     break\n        end\n    end\n    -- If not, just return false\n    if not\
    \ closes then\n        return false\n    end\n    -- Finally, check if there are\
    \ any close elements to each other in the list\n    -- of numbers after the first\
    \ element, but after the first element there is\n    -- no close element to the\
    \ given threshold\n    closes = false\n    for i,v in ipairs(numbers) do\n   \
    \     if numbers[i+1] <= threshold and numbers[i-1] > threshold then\n       \
    \     closes = true\n            break\n        end\n    end\n    -- If not, just\
    \ return false\n    if not closes then\n        return false\n    end\n    --\
    \ Otherwise, we have a good list to return true\n    return true\nend", "  if\
    \ #numbers == 0 then\n    return false\n  end", "    for _, number in pairs(numbers)\
    \ do\n        for _, other_number in pairs(numbers) do\n            if number\
    \ == other_number then\n                continue\n            end\n          \
    \  if abs(number - other_number) < threshold then\n                return true\n\
    \            end\n        end\n    end\n    return false\nend", "  assert(#numbers\
    \ > 0)\n  assert(#numbers == #threshold or #threshold == 0)\n  for _, val in ipairs(threshold)\
    \ do\n    local low = val\n    local high = val\n    local pos = #numbers\n  \
    \  while pos > 1 do\n      local mid = math.floor(pos/2)\n      local low = numbers[mid]\n\
    \      local high = numbers[mid+1]\n      if low > high and low > threshold[mid]\
    \ then\n        high = low\n      elseif low < high and high < threshold[mid]\
    \ then\n        low = high\n      elseif low == high and threshold[mid] then\n\
    \        -- Found a match, no need to go any farther.\n        return true\n \
    \     else\n        -- We found a number that doesn't match.\n        return false\n\
    \      end\n      pos = pos/2\n    end\n  end\n  return false\nend", "    local\
    \ function dist(a1, a2)\n        return math.abs(a1 - a2)\n    end\n    for i\
    \ = 1, #numbers, 2 do\n        for j = i+1, #numbers, 2 do\n            if dist(numbers[i],\
    \ numbers[j]) < threshold then\n                return true\n            end\n\
    \        end\n    end\n    return false\nend", "  for i = 1, #numbers do\n   \
    \ for j = i + 1, #numbers do\n      if math.abs(numbers[i] - numbers[j]) < threshold\
    \ then\n        return true\n      end\n    end\n  end", "    local index1 = 1\n\
    \    local index2 = 1", "  for _, v in ipairs(numbers) do\n    for _, vv in ipairs(numbers)\
    \ do\n      if v > threshold or vv < threshold then\n        -- This is not symmetric,\
    \ because values would be equal\n        -- only if v and vv are equal.\n    \
    \    if v == vv then\n          return false\n        elseif abs(v - vv) > threshold\
    \ then\n          return true\n        end\n      end\n    end\n  end\n  return\
    \ false\nend", "   for index, x in ipairs(numbers) do\n      for _, y in ipairs(numbers)\
    \ do\n         if x ~= y then\n            if math.abs(x - y) < threshold then\n\
    \               return true\n            end\n         end\n      end\n   end\n\
    \   return false\nend", "  assert(numbers, \"Must supply at least one number\"\
    )\n  assert(threshold >= 0, \"Must supply a non-negative threshold\")\n  for _,v\
    \ in ipairs(numbers) do\n    -- Check all numbers against the threshold\n    if\
    \ v < threshold then\n      return false\n    end\n  end\n  return true\nend",
  "   for _, a in pairs(numbers) do\n      for _, c in pairs(numbers) do\n       \
    \  if abs(a - c) < threshold then\n            return true\n         end\n   \
    \   end\n   end\n   return false\nend", "  for _, value in ipairs(numbers) do\n\
    \    local difference = value - threshold\n    if difference > 0 and difference\
    \ < threshold then\n      return true\n    end\n  end\n  return false\nend", " \
    \ local min_num = tonumber(numbers[1])\n  local max_num = tonumber(numbers[#numbers])\n\
    \  if min_num == max_num then return true end\n  local min = nil\n  local max\
    \ = nil\n  local min_distance = tonumber(threshold)\n  for _, number in ipairs(numbers)\
    \ do\n    local distance = tonumber(number) - min_num\n    if min == nil or distance\
    \ < min_distance then\n      min = number\n      min = distance\n    elseif distance\
    \ > min_distance then\n      min = distance\n      min = number\n    end\n  end\n\
    \  if min ~= nil then\n    local distance = tonumber(max) - min_num\n    if distance\
    \ < min_distance then\n      max = numbers[#numbers]\n      max = distance\n \
    \   elseif distance > min_distance then\n      max = distance\n      max = numbers[#numbers]\n\
    \    end\n  end\n  return min ~= nil and min < max_distance and max ~= nil and\
    \ max < min_distance\nend", "  -- The return value is true or false if the list\
    \ is empty or only one element\n  -- exists. If there is a second element, it\
    \ will be compared to threshold\n  -- and return true if they are closer.\n  return\
    \ #numbers > 0 and #numbers == 1 or (#numbers > 1 and threshold and abs(numbers[1]\
    \ - threshold) < abs(numbers[#numbers - 1] - threshold))\nend", "    for _, element\
    \ in ipairs(numbers) do\n        for _, other_element in ipairs(numbers) do\n\
    \            if element ~= other_element then\n                local distance\
    \ = (element - other_element)\n                if distance < threshold then\n\
    \                    return true\n                end\n            end\n     \
    \   end\n    end\n    return false\nend", "  for _, number in ipairs(numbers)\
    \ do\n    for _, next_number in ipairs(numbers) do\n      local relative_distance\
    \ = math.abs(next_number - number)\n      -- Check if the current number is too\
    \ close to previously seen one,\n      -- or if the previous number is too close\
    \ to current one. Take the\n      -- minimum of the two, so that we don't always\
    \ compare against\n      -- same number twice.\n      if relative_distance > threshold\
    \ or previous_number ~= nil then\n        return relative_distance\n      end\n\
    \    end\n  end\n  return nil\nend", "    for _, number in pairs(numbers) do\n\
    \        for _, other_number in pairs(numbers) do\n            if number > other_number\
    \ then\n                if abs(number - other_number) <= threshold then\n    \
    \                return true\n                end\n            elseif number <\
    \ other_number then\n                if abs(other_number - number) <= threshold\
    \ then\n                    return true\n                end\n            end\n\
    \        end\n    end\n    return false\nend", "    local function is_close(a,\
    \ b) -- Is one number closer than given threshold?\n        if b < 0 then\n  \
    \          return b > 0 and a * b <= threshold\n        elseif b > 0 then\n  \
    \          return a > 0 and a - b <= threshold\n        else\n            return\
    \ a == b\n        end\n    end\n    \n    for i=1,#numbers do\n        for j=i+1,#numbers\
    \ do\n            if is_close(numbers[i], numbers[j]) then\n                return\
    \ true\n            end\n        end\n    end\n    return false\nend", '    local
    close = {}', "  for _, value in ipairs(numbers) do\n    for _, value in ipairs(numbers)\
    \ do\n      if value - threshold < value - _threshold then\n        return true\n\
    \      end\n    end\n  end\n  return false\nend", "    local count = 0\n    for\
    \ _, v in pairs(numbers) do\n        if v < threshold then\n            count\
    \ = count + 1\n        else\n            count = 0\n        end\n    end\n   \
    \ return count > 1\nend", "    for _, num1 in pairs(numbers) do\n        for _,\
    \ num2 in pairs(numbers) do\n            if num1 + threshold < num2 then\n   \
    \             return true\n            end\n        end\n    end", "   for _,\
    \ x in pairs(numbers) do\n      local distance = 0\n      for _, y in pairs(numbers)\
    \ do\n         distance = distance + ((x-y) * (x-y))\n      end\n      if distance\
    \ < threshold then\n         return true\n      end\n   end\n   return false\n\
    end", "  for _, value in pairs(numbers) do\n    for _, value2 in pairs(numbers)\
    \ do\n      if value > value2 and value - value2 > threshold then\n        return\
    \ true\n      end\n    end\n  end\n  return false\nend", "  for _, value in pairs(numbers)\
    \ do\n    for _, value2 in pairs(numbers) do\n      if value < threshold then\n\
    \        if value2 < threshold then\n          return true\n        end\n    \
    \  end\n      if value > threshold then\n        if value2 > threshold then\n\
    \          return true\n        end\n      end\n    end\n  end\n  return false\n\
    end", "    for _, number in ipairs(numbers) do\n        if number < threshold\
    \ then\n            return true\n        end\n    end\nend", "  -- TODO: Optimize\
    \ this by sorting and comparing pairs.\n  for i = 1, #numbers - 1 do\n    for\
    \ j = i + 1, #numbers do\n      if abs(numbers[i] - numbers[j]) < threshold then\n\
    \        return true\n      end\n    end\n  end\n  return false\nend", "  for\
    \ _, num in pairs(numbers) do\n    for _, other_num in pairs(numbers) do\n   \
    \   if other_num == num then\n        continue\n      elseif abs(num - other_num)\
    \ < threshold then\n        return true\n      end\n    end\n  end", "    assert(#numbers\
    \ >= 2)\n    local last_number_index = #numbers - 1\n    local result = {}\n \
    \   for i = 1, last_number_index do\n        local current_number = numbers[i]\n\
    \        local next_number = numbers[i + 1]", "    for idx, number in ipairs(numbers)\
    \ do\n        for jdx, number2 in ipairs(numbers) do\n            if abs(number\
    \ - number2) <= threshold then\n                return true\n            end\n\
    \        end\n    end\n    return false\nend", "  for i, x in ipairs(numbers)\
    \ do\n    local other_numbers = numbers:gsub(x).filter(function(n)\n      return\
    \ n ~= x and n <= threshold and n ~= x + threshold\n    end)\n    if other_numbers\
    \ then\n      return true\n    end\n  end\n  return false\nend", "   for i = 1,\
    \ #numbers do\n      for j = 1, #numbers do\n         local distance = math.abs(numbers[i]\
    \ - numbers[j])\n         if distance <= threshold then\n            return true\n\
    \         end\n      end\n   end\n   return false\nend", "    local is_in_list\
    \ = {}\n    for _, number in ipairs(numbers) do\n        if is_in_list[number]\
    \ == nil then\n            is_in_list[number] = false\n        end\n    end",
  "    local distances = {}\n    for i,v in pairs(numbers) do\n        distances[i]\
    \ = {}\n        distances[i][1] = math.abs(i - threshold)\n        distances[i][2]\
    \ = math.abs(i + threshold)\n    end", "  -- Return true if any two numbers in\
    \ the list are within threshold of each other.\n  for _, v1 in pairs(numbers)\
    \ do\n    for _, v2 in pairs(numbers) do\n      if v1 ~= v2 and v1 - threshold\
    \ - v2 < threshold + v1 then\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "  -- First we make an \"array\" with all the distances\
    \ between the given numbers.\n  local distances\n  for i = 0, #numbers - 1 do\n\
    \    distances[i] = 0\n    for j = i + 1, #numbers do\n      local distance\n\
    \      if numbers[i] ~= numbers[j] then\n        distance = math.abs(numbers[i]\
    \ - numbers[j])\n      else\n        distance = 1\n      end\n      distances[i]\
    \ = distances[i] + distance\n    end\n  end", "    for _, number in pairs(numbers)\
    \ do\n        for i=1, #numbers do\n            local i2 = i + 1\n           \
    \ if number ~= numbers[i2] and abs(number - numbers[i2]) < threshold then\n  \
    \              return true\n            end\n        end\n    end\n    return\
    \ false\nend", "  -- We are going to remove all elements smaller then given threshold,\n\
    \  -- so we need to have all numbers as list.\n  assert(all(numbers))\n  assert(number\
    \ > threshold)\n  -- Find lowest element in list, that is still smaller then given\
    \ threshold.\n  local lowest = nil\n  for _, value in ipairs(numbers) do\n   \
    \ if lowest and value < threshold then\n      break -- We've found lowest element\
    \ that is still smaller then given threshold,\n      -- we are done here.\n  \
    \  end\n    lowest = value\n  end\n  -- Return true if given list contains only\
    \ one element, that is\n  -- smaller than given threshold\n  return #numbers ==\
    \ 1 and lowest < threshold\nend", "  for _, v in pairs(numbers) do\n    for _,\
    \ v2 in pairs(numbers) do\n      if v > threshold and v2 < threshold then\n  \
    \      return true\n      end\n    end\n  end\n  return false\nend", "    for\
    \ _, v in pairs(numbers) do\n        for _, v2 in pairs(numbers) do\n        \
    \    if v == v2 and v - threshold <= v2 and v - threshold >= -v then\n       \
    \         return true\n            end\n        end\n    end\n    return false\n\
    end", "    for _, num_1 in pairs(numbers) do\n        for _, num_2 in pairs(numbers)\
    \ do\n            if num_1 ~= num_2 then\n                if abs(num_1 - num_2)\
    \ > threshold then\n                    return true\n                end\n   \
    \         end\n        end\n    end\n    return false\nend", "    local index1\
    \ = 0\n    local index2 = 1\n    local result = 0\n    for i = 1, #numbers do\n\
    \        local currentDistance = math.pow(math.hypot(numbers[index1], numbers[index2]),\
    \ 2)\n        if currentDistance < threshold then\n            result = result\
    \ + 1\n        end\n        index1 = index1 + 1\n        index2 = index2 + 1\n\
    \    end\n    return result\nend", "    if numbers[1] > threshold then\n     \
    \   return true\n    end", "  -- If number of given list is not even or zero,\
    \ then there's no close\n  -- elements, so return false.\n  local num_elements\
    \ = #numbers\n  if num_elements <= 1 then\n    return false\n  end", "  local\
    \ num_ones = 0\n  local num_twos = 0\n  local num_threes = 0\n  local num_fours\
    \ = 0\n  local num_fives = 0\n  local num_sixes = 0\n  local num_sevens = 0\n\
    \  local num_eights = 0\n  local num_nines = 0\n  local nums_tens = 0\n  local\
    \ nums_hundreds = 0\n  for _, number in pairs(numbers) do\n    local digits =\
    \ number:gsub('(^0*)(.-)0', '%2'):gsub('(^0*)(.-)%', '%d'):reverse()\n    local\
    \ num_digits = tonumber(digits)\n    if num_digits >= threshold then\n      num_digits\
    \ = num_digits - threshold\n      num_ones = num_ones + 1\n      num_twos = num_twos\
    \ + 1\n      if num_digits >= 10 then\n        num_threes = num_threes + 1\n \
    \       if num_digits >= 100 then\n          num_fours = num_fours + 1\n     \
    \     if num_digits >= 1000 then\n            num_fives = num_fives + 1\n    \
    \        if num_digits >= 10000 then\n              num_sixes = num_sixes + 1\n\
    \              if num_digits >= 100000 then\n                num_sevens = num_sevens\
    \ + 1\n                if num_digits >= 1000000 then\n                  num_eights\
    \ = num_eights + 1\n                  if num_digits >= 10000000 then\n       \
    \             num_nines = num_nines + 1\n                    if num_digits >=\
    \ 1000000 then\n                      nums_tens = nums_tens + 1\n            \
    \          if num_digits >= 100000 then\n                        nums_hundreds\
    \ = nums_hundreds + 1\n                      end\n                    end\n  \
    \                end\n                end\n              end\n            end\n\
    \          end\n        end\n      end\n    end\n  end\n  return num_ones < 2\
    \ and\n         num_twos < 2 and\n         num_threes < 2 and\n         num_fours\
    \ < 2 and\n         num_fives < 2 and\n         num_sixes < 2 and\n         num_sevens\
    \ < 2 and\n         num_eights < 2 and\n         num_nines < 2 and\n         nums_tens\
    \ < 2 and\n         nums_hundreds < 2\nend", "   for _, elt in pairs(numbers)\
    \ do\n      for _, elt2 in pairs(numbers) do\n         if elt2[1] <= threshold\
    \ and elt <= elt2 then\n            return true\n         end\n      end\n   end\n\
    end", "  local result = true\n  for _, number1 in ipairs(numbers) do\n    for\
    \ _, number2 in ipairs(numbers) do\n      local dist = math.abs(number1 - number2)\n\
    \      if dist > threshold then\n        result = false\n        break\n     \
    \ end\n    end\n  end\n  return result\nend", "   for _, num in ipairs(numbers)\
    \ do\n      for _, num2 in ipairs(numbers) do\n         if num2 > num then break\
    \ end\n      end\n      if num2 > threshold then return true end\n   end\n   return\
    \ false\nend", "    local i = 1\n    while i < #numbers do\n        if numbers[i]\
    \ ~= numbers[i - 1] then\n            return true\n        end\n        i = i\
    \ + 1\n    end\n    return false\nend", "  for _, number1 in ipairs(numbers) do\n\
    \    for _, number2 in ipairs(numbers) do\n      if number1 < number2 then\n \
    \       if abs(number1 - number2) > threshold then\n          return true\n  \
    \      end\n      end\n    end\n  end\n  return false\nend", "  for i, n in ipairs(numbers)\
    \ do\n    if n < threshold then\n      return true\n    end\n  end", "  if #numbers\
    \ < 2 then return false end\n  local min_num = numbers[1]\n  local max_num = numbers[#numbers]",
  "  local num_pairs = 0\n  for _, num in pairs(numbers) do\n    for _, num2 in pairs(numbers)\
    \ do\n      local dist = math.sqrt(\n          math.pow(num2[0] - num, 2) + math.pow(num2[1]\
    \ - num, 2)\n      )\n      if dist < threshold then\n        num_pairs = num_pairs\
    \ + 1\n      end\n    end\n  end\n  return num_pairs > 0\nend", "  for _, number\
    \ in ipairs(numbers) do\n    for _, other_number in ipairs(numbers) do\n     \
    \ if number - other_number < threshold then\n        return true\n      end\n\
    \    end\n  end\n  return false\nend", "  -- Find minimum distance between numbers\
    \ and threshold.\n  local min_distance = (#numbers - 1) / 2\n  for _, element\
    \ in pairs(numbers) do\n    local distance\n    if element > threshold then\n\
    \      distance = math.abs(element - threshold)\n    elseif element < threshold\
    \ then\n      distance = math.abs(threshold - element)\n    else\n      distance\
    \ = 0\n    end\n    -- If two numbers are closer, take minimum.\n    if distance\
    \ < min_distance then\n      min_distance = distance\n    end\n  end\n  -- Check\
    \ if any two numbers meet threshold distance.\n  return min_distance > threshold\n\
    end", "    if #numbers == 1 then\n        return true\n    end", '   local distances
    = {}', "  -- Get distance between each two numbers, and return true iff any two\
    \ numbers are\n  -- closer to each other than the threshold.\n  -- We could do\
    \ an argmin here instead, but this avoids a call to math.abs.\n  for i, v1 in\
    \ ipairs(numbers) do\n    for j, v2 in ipairs(numbers) do\n      if i == j then\
    \ continue end", "  local n1 = numbers[1]\n  local n2 = numbers[2]\n  for i =\
    \ 2, #numbers do\n    -- If the current element is the first in the list, the\
    \ two numbers are equal and\n    -- we have found a match.\n    if n1 == numbers[i]\
    \ then\n      return true\n    end\n    -- If the current element is the second,\
    \ we found a closer pair.\n    if n2 == numbers[i] then\n      return true\n \
    \   end\n    -- Keep moving numbers ahead until we reach the one that isn't in\
    \ our list. This can\n    -- be done by looping through each element until we\
    \ find one that is not in the\n    -- list.\n    n1 = n1 .. numbers[i]\n    n2\
    \ = n2 .. numbers[i]\n  end\n  return false\nend", "  for i=1, #numbers do\n \
    \   local n = numbers[i]\n    for j=i+1, #numbers do\n      local m = numbers[j]\n\
    \      if math.abs(n - m) < threshold then\n        return true\n      end\n \
    \   end\n  end\n  return false\nend", "    -- Create a temporary table of pairs\
    \ with distance between elements\n    -- of given table as key, and list of elements\
    \ as value.\n    local pairs = {}\n    for i, v in pairs(numbers) do\n       \
    \ table.insert(pairs, {v, {}})\n    end", "    local count = 0\n    for _, value\
    \ in ipairs(numbers) do\n        for _, value_2 in ipairs(numbers) do\n      \
    \      if value == value_2 then\n                continue\n            end\n \
    \           if abs(value - value_2) > threshold then\n                count =\
    \ count + 1\n            end\n        end\n    end\n    return count > 0\nend",
  '    if threshold<=0 then return false end', "  for i, number in ipairs(numbers)\
    \ do\n    for j = i + 1, #numbers - 1 do\n      if number:dist(numbers[j]) ~=\
    \ threshold then\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "  -- If threshold is 0 or larger than the length of numbers, return false\n\
    \  if not threshold or threshold > #numbers then\n    return false\n  end\n  --\
    \ If the length of numbers is 2, then return true\n  if #numbers == 2 then\n \
    \   return true\n  end\n  -- Set minimum distance of difference between any two\
    \ numbers\n  local min_diff = threshold\n  -- Initialize distance of difference\
    \ of first two numbers\n  local diff_1\n  -- Initialize distance of difference\
    \ of second two numbers\n  local diff_2\n  -- Initialize number of consecutive\
    \ similar elements. Use a pair to store the indices\n  -- and the distance of\
    \ distance of similar elements.\n  local similar_elements\n  for i, number1 in\
    \ pairs(numbers) do\n    -- Initialize distance of difference of current and previous\
    \ two numbers\n    diff_1 = nil\n    diff_2 = nil\n    -- Initialize number of\
    \ consecutive similar elements\n    similar_elements = nil\n    -- Iterate through\
    \ all numbers to find consecutive similar elements\n    for _, number2 in pairs(numbers)\
    \ do\n      -- Check if difference between current and previous two numbers is\
    \ less than minimum\n      -- difference of difference of first two numbers\n\
    \      if diff_1 and diff_1 < min_diff then\n        -- Set minimum difference\
    \ of difference of first two numbers\n        min_diff = diff_1\n        -- Initialize\
    \ index of first similar element after current element\n        similar_elements\
    \ = i - 1\n      elseif diff_2 and diff_2 < min_diff then\n        -- Set minimum\
    \ difference of difference of second two numbers\n        min_diff = diff_2\n\
    \        -- Initialize index of second similar element after current element\n\
    \        similar_elements = i - 1\n      -- If difference between current and\
    \ previous two numbers is greater than minimum\n      -- difference of difference\
    \ of first two numbers, check if current is closer to previous\n      elseif diff_1\
    \ and diff_2 < min_diff then\n        -- Initialize index of first similar element\
    \ after current element\n        similar_elements = i - 1\n        -- Check if\
    \ current is closer to previous than previous similar element\n        if number1\
    \ ~= numbers[similar_elements] then\n          -- Check if current is closer to\
    \ previous\n          diff_2 = numbers[similar_elements] - number1\n        else\n\
    \          -- Check if current is closer to previous\n          diff_2 = numbers[similar_elements]\n\
    \        end\n      -- If difference between current and previous two numbers\
    \ is greater than minimum\n      -- difference of difference of first two numbers,\
    \ check if current is closer to previous\n      elseif diff_1 and diff_1 < min_diff\
    \ then\n        -- Initialize index of first similar element after current element\n\
    \        similar_elements = i - ", "  if #numbers == 0 then\n    return false\n\
    \  end\n  \n  local found = false\n  \n  for i = 1, #numbers do\n    local diff1\
    \ = numbers[i] - numbers[i - 1]\n    local diff2 = numbers[i + 1] - numbers[i]\n\
    \    \n    if diff2 > threshold or diff1 < -threshold then\n      return true\n\
    \    end\n    \n    if diff2 < threshold then\n      found = true\n    end\n \
    \ end\n  \n  return found\nend", "    local is_in_range = false\n    for _, value\
    \ in pairs(numbers) do\n        if math.abs(value - threshold) > threshold then\n\
    \            is_in_range = true\n            break\n        end\n    end\n   \
    \ return is_in_range\nend\n</code>\n<|/ a dscore=1 tags=lua |>\n<| a dscore=1\
    \ tags=lua |>\nI made this using only a couple of loops and two tables, one to\
    \ store values and another to store a range of values.\n<code>", "  -- Return\
    \ true if any two numbers are closer than threshold from each other.\n  -- Assumes\
    \ sorted input.\n  local i = 1\n  for _, next_element in ipairs(numbers) do\n\
    \    local prev_element = numbers[i - 1]\n    if abs(prev_element - next_element)\
    \ > threshold then\n      return true\n    end\n    i = i + 1\n  end\n  return\
    \ false\nend", "    local max_i = 1\n    local max_j = 1", "    local differences\
    \ = map(function(_,i)\n      return math.abs(numbers[i+1] - numbers[i])\n    end,\n\
    \    pairs(numbers)\n    )\n    return #differences > threshold\nend", "    if\
    \ #numbers <= 1 then\n        return false\n    end", "  for i = 1, #numbers do\n\
    \    for j = i + 1, #numbers do\n      if numbers[i] - numbers[j] >= threshold\
    \ then\n        return true\n      end\n    end\n  end\n  return false\nend",
  "    local i = 0\n    while i < #numbers - 1 do\n        -- Check if two elements\
    \ are \"close\" enough\n        if math.abs(numbers[i + 1] - numbers[i]) < threshold\
    \ then\n            return true\n        end\n        i = i + 1\n    end\n   \
    \ return false\nend", "  if #numbers == 0 then return false end\n  if #numbers\
    \ == 1 then return true end", "    local close = Vector()\n    for _, i in pairs(numbers)\
    \ do\n        local j = 1\n        while j < #numbers do\n            if i + j\
    \ < #numbers and abs(numbers[i] - numbers[j]) < (threshold * threshold) then\n\
    \                table.insert(close, j)\n            end\n            j = j +\
    \ 1\n        end\n    end\n    return #close > 0\nend", "  -- Iterate through\
    \ all numbers one by one.\n  for i = 1, #numbers do\n    local other_number_index\
    \ = #numbers - i - 1\n    local other_number = numbers[other_number_index]", " \
    \ for _, num in pairs(numbers) do\n    for _, num2 in pairs(numbers) do\n    \
    \  if not num2 then\n        threshold = threshold / 2\n      elseif not num then\n\
    \        threshold = threshold * 2\n      elseif not num2 and num2 > num + threshold\
    \ then\n        return true\n      end\n    end\n  end\n  return false\nend",
  "\tlocal closer_numbers = setmetatable({}, { __index = function(t, k) t.[k] = true\
    \ return t end})\n\tfor _,v in pairs(numbers) do\n\t\tfor _,v2 in pairs(numbers)\
    \ do\n\t\t\tif v ~= v2 and math.abs(v - v2) < threshold then\n\t\t\t\ttable.insert(closer_numbers,\
    \ v)\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\treturn closer_numbers\nend",
  "  -- Check if all elements are same distance.\n  if #numbers == 1 then\n    return\
    \ true\n  end\n  -- Check pairwise distances.\n  for i = 1, #numbers do\n    local\
    \ d1 = vector_distance(numbers[i], numbers[1])\n    local d2 = vector_distance(numbers[1],\
    \ numbers[i])\n    if d1 < threshold and d2 < threshold then\n      return true\n\
    \    end\n  end\n  return false\nend", "  for i, number1 in enumerate(numbers)\n\
    \  do\n    for j = i + 1, #numbers - 1\n    do\n      local number2 = numbers[j]\n\
    \      if number1 < number2 then\n        local difference = abs(number2 - number1)\n\
    \        if difference <= threshold then\n          return true\n        end\n\
    \      end\n    end\n  end\n  return false\nend", "    local min_element = tonumber(numbers[1])\n\
    \    for _, value in pairs(numbers) do\n        if min_element == tonumber(value)\
    \ then return true end\n        min_element = tonumber(value)\n    end\n    return\
    \ false\nend", "  -- Check if in given list of numbers.\n  if #numbers == 0 then\n\
    \    return false\n  end\n  -- Check whether two numbers are closer than given\
    \ threshold.\n  for _, _, _, value in ipairs(numbers) do\n    if math.abs(value\
    \ - threshold) > 1e-7 then\n      return true\n    end\n  end\n  return false\n\
    end", "  local i = 0\n  local j = 1\n  local flag = false\n  while i <= #numbers\
    \ and j <= #numbers and math.abs(numbers[i] - numbers[j]) ~= threshold do\n  \
    \  i = i + 1\n    j = j + 1\n  end\n  return i > j\nend", "  local min_distance\n\
    \  -- Iterate all numbers, calculate the distances and check if any of them is\
    \ closer\n  -- to threshold:\n  for _, num in pairs(numbers) do\n    local new_distance\n\
    \    -- Calculate distance between the two given numbers:\n    new_distance =\
    \ math.sqrt(\n      (numbers[#numbers]-num)^2 +\n      (numbers[1]-num)^2)\n \
    \   -- Check if distance is closer to given threshold:\n    if new_distance <\
    \ threshold then\n      -- If current distance is closer, return true and break:\n\
    \      min_distance = new_distance\n      break\n    end\n  end\n  return min_distance\
    \ ~= nil\nend", "    local min_distance = tonumber(threshold:sub(1,-1))\n    for\
    \ _,num in pairs(numbers) do\n        for _,othernum in pairs(numbers) do\n  \
    \          local distance = math.abs(num - othernum)\n            if distance\
    \ <= min_distance then\n                return false\n            end\n      \
    \  end\n    end\n    return true\nend\n</cell>\n<text>\nAs we can see, two numbers\
    \ are closer to each other than given threshold ($\\ell_{threshold}$) than another,\
    \ if they have the same absolute value.", "    if #numbers < 2 then\n        return\
    \ false\n    end", "  local pairs = {}\n  for _, value in pairs(numbers) do\n\
    \    for _, value in pairs(numbers) do\n      pairs[#pairs + 1] = value\n    end\n\
    \  end\n  pairs:sort(function(a, b) return math.abs(a - b) end)\n  for _, value\
    \ in pairs do\n    if math.abs(value - threshold) <= math.abs(pairs[#pairs] -\
    \ threshold) then\n      return true\n    end\n  end\n  return false\nend", " \
    \   local min_idx, max_idx = #numbers, 1\n    for i = 2, min_idx do\n        if\
    \ numbers[max_idx] - numbers[min_idx] > threshold then\n            return true\n\
    \        end\n        max_idx = i\n    end\n    return false\nend", "    -- Sort\
    \ all numbers by distance to origin.\n    table.sort(numbers)", "  local count\
    \ = 0\n  for _, value in ipairs(numbers) do\n    count = count + 1\n    if count\
    \ % 10 == 0 then\n      print(string.format(\"%d,\", value))\n    end\n    if\
    \ value - threshold < 0 then\n      break\n    end\n  end\n  if count < 2 then\n\
    \    return false\n  end\n  return true\nend", "  -- If the list is empty, return\
    \ false\n  if numbers[1] == nil then return false end\n  -- If the threshold is\
    \ 0, the list has only one element, so return true\n  if threshold == 0 then return\
    \ true end\n  -- If the threshold is greater than the length of the list, return\
    \ false\n  if threshold > #numbers then return false end", "  for _, number in\
    \ pairs(numbers) do\n    for _, other_number in pairs(numbers) do\n      if number\
    \ == other_number then\n        -- Do nothing.\n      elseif abs(number - other_number)\
    \ < threshold then\n        return true\n      elseif number > other_number then\n\
    \        -- Number is bigger than other, so we need to check if this one is bigger\
    \ than\n        -- threshold.\n        return false\n      else\n        -- Number\
    \ is smaller than other, so we need to check if this one is smaller than\n   \
    \     -- threshold.\n        return true\n      end\n    end\n  end\n  return\
    \ false\nend", "    local count = 0\n    local results = {}", "  -- For every\
    \ number in the list, check if it lies in given threshold range.\n  for i = 1,\
    \ #numbers do\n    local min_index, max_index = math.min(i, #numbers), math.max(i,\
    \ #numbers)\n    local number_value = numbers[i - 1]\n    -- Check if number is\
    \ closer to min or max number in current list.\n    local min = true\n    local\
    \ max = true\n    -- Check if current number is closer to min in current list.\n\
    \    if numbers[min_index] <= number_value then\n      min = false\n    end\n\
    \    -- Check if current number is closer to max in current list.\n    if numbers[max_index]\
    \ >= number_value then\n      max = false\n    end\n    -- Check if current number\
    \ is closer to two numbers in current list.\n    local close = min and max\n \
    \   if close and number_value - numbers[min_index] <= threshold\n      and number_value\
    \ - numbers[max_index] <= threshold then\n      close = false\n    end\n    --\
    \ If current number is closer than threshold, add it to close list.\n    if close\
    \ then\n      table.insert(close, number_value)\n    end\n  end\n  -- Return true\
    \ if we found any two numbers in given list, which are closer to each other than\n\
    \  -- the given threshold.\n  return #close == 2\nend", "    for _, number in\
    \ ipairs(numbers) do\n        for i = 1, #numbers - 1 do\n            if numbers[i]\
    \ > number and numbers[i] < numbers[i + 1] then\n                return true\n\
    \            end\n        end\n    end\n    return false\nend", "    local close\
    \ = {}\n    for i, num1 in enumerate(numbers) do\n        for j, num2 in enumerate(numbers)\
    \ do\n            if (i + j) ~= i then\n                local dist = distance(num1,\
    \ num2, threshold)\n                if dist <= threshold then\n              \
    \      table.insert(close, num)\n                end\n            end\n      \
    \  end\n    end\n    return #close ~= 0\nend", "    for _, value in ipairs(numbers)\
    \ do\n        local close = true\n        for _, other_value in ipairs(numbers)\
    \ do\n            if other_value == value then\n                close = false\n\
    \                break\n            end\n        end\n        if close then\n\
    \            return true\n        end\n    end\n    return false\nend", "    for\
    \ _, value in ipairs(numbers) do\n        for _, other_value in ipairs(numbers)\
    \ do\n            if other_value == value then\n                continue\n   \
    \         end\n            if abs(value - other_value) < threshold then\n    \
    \            return true\n            end\n        end\n    end\n    return false\n\
    end", "  -- Check length of given numbers\n  if #numbers == 0 then\n    return\
    \ false\n  end\n  -- Initialize variables\n  local close_to_first = math.abs(numbers[1]\
    \ - threshold)\n  local close_to_second = math.abs(numbers[2] - threshold)\n \
    \ -- Check if in given list of numbers, are any two numbers closer to each other\n\
    \  -- than given threshold.\n  for i = 1, #numbers - 1 do\n    local first = math.abs(numbers[i]\
    \ - threshold)\n    local second = math.abs(numbers[i+1] - threshold)\n    --\
    \ Check if in given list of numbers, are any two numbers closer to each other\n\
    \    -- than given threshold.\n    if second < first then\n      return false\n\
    \    end\n    -- Check if in given list of numbers, are any two numbers closer\
    \ to each other\n    -- than given threshold.\n    if close_to_first < second\
    \ then\n      close_to_first = first\n    end\n    -- Check if in given list of\
    \ numbers, are any two numbers closer to each other\n    -- than given threshold.\n\
    \    if close_to_second < first then\n      close_to_second = second\n    end\n\
    \  end\n  return true\nend", "  local function are_close(a, b, c) return math.abs(a\
    \ - b) < c end\n  for _, a in pairs(numbers) do\n    for _b, b in pairs(numbers)\
    \ do\n      if are_close(a, b, threshold) then\n        return true\n      end\n\
    \    end\n  end\n  return false\nend", "    local max_distance = 0\n    for _,\
    \ val in ipairs(numbers) do\n        if val < threshold then\n            return\
    \ true\n        end\n        if val > threshold then\n            max_distance\
    \ = max_distance + 1\n        end\n    end\n    return max_distance == #numbers\n\
    end", "  local function has_close(i1, i2)\n    if i1 ~= i2 then\n      return\
    \ numbers[i1] < numbers[i2] and\n             numbers[i1] > threshold\n    end\n\
    \    return false\n  end\n  local has_closes = {}\n  for i = 1, #numbers - 1 do\n\
    \    for j = 1, #numbers - 1 do\n      if not has_close(i, j) then\n        has_closes[i]\
    \ = has_closes[j] and has_close(i, j+1)\n      end\n    end\n  end\n  return has_closes\n\
    end", "  for i, number in ipairs(numbers) do\n    for j = i + 1, #numbers - 1\
    \ do\n      if math.abs(number - numbers[j]) ~= threshold then\n        return\
    \ true\n      end\n    end\n  end\n  return false\nend", "  local min_dist = threshold\n\
    \  for _, x in ipairs(numbers) do\n    for _, y in ipairs(numbers) do\n      local\
    \ d = math.abs(x - y)\n      if d < min_dist then\n        min_dist = d\n    \
    \  end\n    end\n  end\n  return min_dist <= threshold\nend", "    if #numbers\
    \ == 0 then\n        return false\n    end", "  -- If there are fewer elements\
    \ than threshold,\n  -- return false as we know that there is no close element.\n\
    \  if #numbers < threshold then\n    return false\n  end", "  for _, elem in ipairs(numbers)\
    \ do\n    for _, other_elem in ipairs(numbers) do\n      if other_elem == elem\
    \ then continue end\n      if abs(elem - other_elem) < threshold then\n      \
    \  return true\n      end\n    end\n  end\n  return false\nend\n</code>\nThen\
    \ to find all pairs, just iterate over the list:\n<code>\nfor _, elem in ipairs(numbers)\
    \ do\n  local found = false\n  for _, other_elem in ipairs(numbers) do\n    if\
    \ other_elem == elem then continue end\n    found = found or has_close_elements({elem,\
    \ other_elem}, threshold)\n    if found then break\n  end\n  if found then print(table.concat(elem,\
    \ \"-\")) end\nend\n</code>\nThis prints:\n<code>\n(0 0)\n(1 -1)\n(2 1)\n(3 1)\n\
    (4 3)\n(5 1)\n(6 2)\n(7 -1)\n(8 1)\n(9 3)\n(10 3)\n(11 3)\n(12 1)\n(13 2)\n(14\
    \ 3)\n(15 3)\n(16 1)\n(17 2)\n(18 3)\n(19 3)\n(20 3)\n(21 2)\n(22 2)\n(23 1)\n\
    (24 2)\n(25 3)\n(26 1)\n(27 1)\n(28 2)\n(29 1)\n(30 2)\n(31 1)\n(32 1)\n(33 1)\n\
    (34 2)\n(35 1)\n(36 2)\n(37 2)\n(38 1)\n(39 2)\n(40 2)\n(41 1)\n(42 1)\n(43 1)\n\
    (44 1)\n(45 2)\n(46 2)\n(47 2)\n(48 2)\n(49 3)\n(50 2)\n(51 3)\n(52 1)\n(53 2)\n\
    (54 3)\n(55 3)\n(56 2)\n(57 3)\n(58 1)\n(59 3)\n(60 1)\n(61 2)\n(62 1)\n(63 3)\n\
    (64 1)\n(65 2)\n(66 3)\n(67 3)\n(68 3)\n(69 1)\n(70 3)\n(71 3)\n(72 3)\n(73 3)\n\
    (74 3)\n(75 2)\n(76 2)\n(77 3)\n(78 3)\n(79 3)\n(80 3)\n(81 ", "  for _, x in\
    \ ipairs(numbers) do\n    for _, y in ipairs(numbers) do\n      if x + threshold\
    \ > y or y + threshold > x then\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "  local first_element = numbers[1]\n  local last_element\
    \ = numbers[#numbers]\n  return #numbers > 0 and #numbers >= 2 and\n    (last_element\
    \ - first_element) <= threshold and\n    (last_element - first_element) > -threshold\n\
    end", "  local close = { }\n  for _, element in pairs(numbers) do\n    if numbers[element]\
    \ < threshold then\n      close[element] = true\n    end\n  end\n  -- if there\
    \ are any elements left in the set, then the set is too large\n  for _, element\
    \ in pairs(numbers) do\n    if not close[element] then\n      return true\n  \
    \  end\n  end\n  return false\nend", "  for i, num in pairs(numbers) do\n    for\
    \ j = i + 1, #numbers do\n      if abs(num - numbers[j]) ~= threshold then\n \
    \       return true\n      end\n    end\n  end\n  return false\nend", "    --\
    \ Iterate backwards through the list.\n    for i = #numbers - 1, 1, -1 do\n  \
    \      -- Calculate the sum of each pair of adjacent numbers.\n        local sum\
    \ = 0\n        for j = 1, i - 1 do\n            sum = sum + numbers[j] + numbers[j\
    \ + 1]\n        end\n        -- Check if the sum is less than the threshold.\n\
    \        if sum < threshold then\n            return true\n        end\n    end\n\
    \    return false\nend", "    local max_distance = math.pow(10, math.floor(math.log10(threshold)))\n\
    \    for _, v in pairs(numbers) do\n        for _, v2 in pairs(numbers) do\n \
    \           local distance = math.abs(v - v2)\n            if distance < max_distance\
    \ then\n                return true\n            end\n        end\n    end\n \
    \   return false\nend", "    -- If any of them are NaN, return false\n    for\
    \ _, a in ipairs(numbers) do\n        if a == math.nan then\n            return\
    \ false\n        end\n    end", "    assert(type(numbers) == 'table', 'numbers\
    \ must be a table')\n    assert(type(threshold) == 'number', 'threshold must be\
    \ a number')\n    local num_elements = #numbers", "  -- TODO: vectorize this somehow\n\
    \  -- TODO: use more efficient structure than array\n  local pairs = {}\n  --\
    \ TODO: vectorize this somehow\n  for _, num in pairs(numbers) do\n    pairs[num]\
    \ = true\n  end", "  -- Find two numbers closest to each other.\n  local function\
    \ two_closest(numbers)\n    local result = {}\n    for _, v in ipairs(numbers)\
    \ do\n      local smallest = v\n      for i = 1, #numbers do\n        local dist\
    \ = math.abs(smallest - numbers[i])\n        if dist < threshold then\n      \
    \    smallest = numbers[i]\n        end\n      end\n      table.insert(result,\
    \ smallest)\n    end\n    return result\n  end\n  return two_closest(numbers)\n\
    end", "   if #numbers == 1 then\n      return true\n   end\n   if #numbers ==\
    \ 0 then\n      return false\n   end", "    local min_distance = nil\n    local\
    \ minimum = nil", "  for _, num1 in ipairs(numbers) do\n    for _, num2 in ipairs(numbers)\
    \ do\n      local d = math.abs(num1 - num2)\n      if d <= threshold then\n  \
    \      return true\n      end\n    end\n  end", "    local result\n    for _,\
    \ number in pairs(numbers) do\n        if number < threshold then\n          \
    \  if result == nil then\n                result = number\n            else\n\
    \                result = number < result and number or result\n            end\n\
    \        end\n    end\n    return result\nend", "    local is_close = false\n\
    \    for i = 1, #numbers do\n        local index = i\n        local close = false\n\
    \        for j = i + 1, #numbers do\n            local d = distance_between_vectors(numbers[index],\
    \ numbers[j])\n            if d < threshold then\n                close = true\n\
    \                index = j\n            end\n        end\n        if close then\n\
    \            is_close = true\n        end\n    end\n    return is_close\nend",
  "  for i = 1, #numbers do\n    for j = i + 1, #numbers do\n      if math.abs(numbers[i]\
    \ - numbers[j]) < threshold then\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "  local diff\n  for i = 1, #numbers - 1 do\n    diff =\
    \ math.abs(numbers[i] - numbers[i + 1])\n    if diff < threshold then\n      return\
    \ true\n    end\n  end\n  return false\nend", "  for i, x in ipairs(numbers) do\n\
    \    local j\n    for j = i + 1, #numbers do\n      if abs(x - numbers[j]) < threshold\
    \ then\n        return true\n      end\n    end\n  end\n  return false\nend",
  "  for _, value in ipairs(numbers) do\n    for _, value_2 in ipairs(numbers) do\n\
    \      if value - value_2 <= threshold then\n        return true\n      end\n\
    \    end\n  end", "    if #numbers == 0 then\n        return false\n    end\n\
    \    for i = 1, #numbers do\n        if numbers[i] > threshold then\n        \
    \    return true\n        end\n    end\n    return false\nend", "\t-- First check\
    \ if all numbers are within threshold\n\tif #numbers == 1 then\n\t\treturn false\n\
    \tend", "  -- First, compute all the elements and their distances.\n  -- If there\
    \ is one number in given set, distance is the sum of two distances.\n  local elements\
    \ = {}\n  local distances = {}\n  for _, number in ipairs(numbers) do\n    for\
    \ _, distance in pairs(numbers) do\n      local sum = 0\n      local distance_sum\
    \ = 0\n      for i, element in ipairs(elements) do\n        if element ~= nil\
    \ and element.number == number then\n          sum = sum + element.distance\n\
    \          distance_sum = distance_sum + distances[i]\n        end\n      end\n\
    \      if distance_sum < threshold then\n        table.insert(elements,\n    \
    \      {number = number, distance = sum})\n        distances[number] = sum\n \
    \     end\n    end\n  end\n  local count = 0\n  for _, element in ipairs(elements)\
    \ do\n    if #distances > 0 then\n      table.insert(distances, element.distance)\n\
    \    end\n    count = count + 1\n  end\n  return count\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
