name: HumanEval_10_make_palindrome
language: lua
prompt: "-- Find the shortest palindrome that begins with a supplied string.\n-- Algorithm\
  \ idea is simple:\n-- - Find the longest postfix of supplied string that is a palindrome.\n\
  -- - Append to the end of the string reverse of a string prefix that comes before\
  \ the palindromic suffix.\nlocal function make_palindrome(string)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
  \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
  \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
  \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local start = string\n    local len = string\n    local postfix\
    \ = string\n    local suffix", "   local prefix = string\n   local suffix = string\n\
    \   local length = #string\n   local result = ''", "\tlocal postfix = string.gsub(string,\
    \ \"$\", \"\")\n\tlocal suffix\n\tlocal palindrome = \"\"", "    local stringLength\
    \ = string.len()\n    if stringLength % 2 ~= 0 then\n        return nil\n    end",
  "   local suffix_length = string.len(string) - string.len(string.gsub(string, \"\
    ^\"))\n   local prefix = string.gsub(string, \"^\")\n   local reversed_prefix\
    \ = string.gsub(string.gsub(string, \"^\"), reverse(string), \"^\")\n   local\
    \ suffix = string.sub(reversed_prefix, 0, suffix_length)\n   local reversed_suffix\
    \ = string.sub(reversed_prefix, suffix_length)\n   return prefix .. suffix ..\
    \ reversed_suffix\nend", "    local max_len = -1\n    local max_len = -1\n   \
    \ for i=1, #string do\n        local s = string.sub(string, i, i)\n        if\
    \ string.len(s) < max_len then\n            max_len = string.len(s)\n        end\n\
    \    end\n    local s = \"\"\n    for i=0, max_len do\n        s = s .. string.sub(string,\
    \ i, i)\n    end\n    for i=#string, 1, -1 do\n        local s = string.sub(string,\
    \ 1, i) .. s\n        if s == s then\n            return s\n        end\n    end\n\
    end", "   -- Create a copy of supplied string.\n   local reverse = string\n  \
    \ local suffix = \"\"\n   -- Create a reversed suffix by appending all characters\
    \ to the suffix until we get\n   -- all characters from the original string that\
    \ are equal to the reversed\n   -- suffix.\n   for i = 1, #string do\n      local\
    \ character = string[i]\n      if character ~= suffix then\n         suffix =\
    \ suffix .. character\n      else\n         -- Reached the end of original string.\
    \ Append all characters from the\n         -- original string that equal the reversed\
    \ suffix.\n         reverse = reverse .. suffix\n         suffix = \"\"\n    \
    \  end\n   end\n   return reverse .. suffix\nend", "    local prefix_length =\
    \ #string + 2 -- +1 to account for final character being palindrome\n    local\
    \ suffix_length = #string - prefix_length\n    local prefix = string:sub(1, prefix_length)\n\
    \    local suffix = string:sub((prefix_length + 1), (prefix_length + suffix_length))\n\
    \    local reversed_prefix = prefix:reverse():gsub(\"^\", \"\")\n    return reversed_prefix\
    \ .. suffix\nend", "  local max_len = #string - 1\n  local prefix = ''\n  local\
    \ suffix = ''\n  for i = 1, #string do\n    local char = string.sub(i, i)\n  \
    \  -- Append prefix to prefix reverse of current character.\n    prefix = string.sub(prefix,\
    \ #prefix + 1):gsub(string.reverse(char), '')\n    -- Append suffix to suffix\
    \ (reverse) of the current character.\n    suffix = string.sub(suffix, #suffix\
    \ + 1):gsub(string.reverse(char), '')\n    -- If prefix or suffix are already\
    \ palindromes then stop searching.\n    if suffix == prefix or prefix == suffix\
    \ then break end\n    -- Append prefix to longest prefix of current string.\n\
    \    local max_len = #prefix + #suffix + 1\n    if max_len > max_len then max_len\
    \ = max_len end\n    -- Append suffix to longest suffix of current string.\n \
    \   local max_len = #prefix + #suffix + 1\n    if max_len > max_len then max_len\
    \ = max_len end\n    -- Append current character to prefix (reverse) of the current\
    \ string.\n    prefix = string.sub(prefix, #prefix + 1):gsub(char, '')\n    --\
    \ Append current character to suffix (reverse) of the current string.\n    suffix\
    \ = string.sub(suffix, #suffix + 1):gsub(char, '')\n  end\n  return prefix ..\
    \ string.reverse(suffix) .. suffix\nend", "    local prefix = 0\n    local suffix\
    \ = 0\n    local length = #string\n    while true do\n        local char = string.sub(string,prefix+1)\n\
    \        if char == string.sub(string, length) then\n            suffix = suffix\
    \ + 1\n        elseif char == string.sub(string, 1, suffix) then\n           \
    \ prefix = prefix + 1\n            suffix = suffix + 1\n        else\n       \
    \     return string.sub(string, prefix, suffix) .. string.sub(string, length-suffix-1,\
    \ length-prefix)\n        end\n    end\nend", "    local postfix = string.gsub(string,\
    \ \"%a+$\", \"\")\n    local reverse = string.gsub(string.gsub(string, \"^$\"\
    ), \"%a+\", \"\")\n    return string.reverse(string.sub(postfix, 1, -reverse))\n\
    end", "    -- Trim the string from spaces.\n    string = string.trim()\n    --\
    \ Split the string into an array of characters.\n    local postfix = string:gsub(\"\
    %W\", \"\")\n    -- Find the longest palindrome suffix that is a palindrome.\n\
    \    local palindrome = string.find(postfix, \"^([^.]+)\\.reverse(%W)$\") or {}\n\
    \    -- Reverse the string prefix before the suffix.\n    postfix = postfix:reverse()\n\
    \    -- Append to the end of the string.\n    postfix = postfix..\"^\".. palindrome\n\
    \    -- Make the palindrome and return it.\n    return postfix\nend", "   local\
    \ max_len\n   local max_len_pal\n   local max_len_pal_idx\n   for idx = 2, #string\
    \ do\n      local pal_str = string[idx:idx]\n      local pal_idx = idx:index(pal_str)\n\
    \      -- Find longest postfix of palindrome suffix\n      -- Example: 'abcdefg'\n\
    \      -- Palindrome: 'aeg', suffix: 'defg'\n      -- Longest postfix is 'def'\n\
    \      max_len_pal_idx = max_len or (pal_idx + ((pal_len - 1) .. pal_len))\n \
    \     -- If longest postfix is equal than max length then we can stop searching.\n\
    \      -- Example: max_len = 5, max_len_pal = 4, max_len_pal_idx = 4\n      --\
    \ We can't find any palindrome starting with 'abcdefg'.\n      if max_len_pal_idx\
    \ == max_len then\n         return nil\n      end\n      -- Find longest postfix\
    \ of palindrome prefix\n      -- Example: 'abcdefg'\n      -- Palindrome: 'abcdef',\
    \ prefix: 'acg'\n      -- Longest postfix is 'abc'\n      max_len_pal = max_len_pal_idx:sub(1,\
    \ max_len_pal_idx):sub(pal_len + 1)\n      -- If longest postfix is equal than\
    \ max length then we can stop searching.\n      -- Example: max_len = 5, max_len_pal\
    \ = 3, max_len_pal_idx = 3\n      -- We can't find any palindrome starting with\
    \ 'abcdefg'.\n      if max_len_pal == max_len then\n         return nil\n    \
    \  end\n   end\n   -- We found a palindrome.\n   return string[max_len .. max_len_pal_idx]\n\
    end", "\tlocal suffix   = string\n\tlocal postfix = string", "    local result\
    \ = string\n    for idx = 1, #string - 1 do\n        local str = string.sub(string,idx,idx+1)\n\
    \        if string.len(str) == 1 then\n            return string\n        elseif\
    \ string.len(str) > 1 then\n            local postfix = string.format(\"%s%s%s\"\
    ,str,str.reverse,str)\n            if string.find(result,postfix) == 1 then\n\
    \                result = result..postfix\n            end\n        end\n    end\n\
    \    return result\nend", "  -- Find the longest postfix of supplied string that\
    \ is a palindrome.\n  -- (This is done by appending the reverse of the string\
    \ prefix that comes before the palindromic suffix.)\n  local postfix = string\n\
    \  local palindromic_suffix = string\n  while #postfix > 0 and string[#postfix]\
    \ == string[#postfix] do\n    postfix = string[#postfix]\n  end\n  -- Append to\
    \ the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n  postfix = string\n  local reverse = string\n  repeat\n    if string[#reverse]\
    \ ~= string[#reverse] then\n      reverse = reverse .. string[#reverse]\n    end\n\
    \    string = string[#reverse]\n  until string\n  -- Make sure that the length\
    \ of the postfix is greater than or equal to the length of the palindromic suffix.\n\
    \  -- Otherwise the original string is not a palindrome.\n  if #postfix <= #palindromic_suffix\
    \ then\n    return \"#\" .. string\n  else\n    local reverse = string\n    repeat\n\
    \      if string[#reverse] ~= string[#reverse] then\n        reverse = reverse\
    \ .. string[#reverse]\n      end\n      string = string[#reverse]\n    until string\n\
    \    return \"#\" .. reverse\n  end\nend", '  local max_len = 0', "\tlocal postfix_len\
    \ = string.len() -- Finds longest postfix of string that is palindrome\n\tlocal\
    \ reverse = string.sub(string, 1, postfix_len) -- Finds reverse of postfix string\n\
    \tlocal postfix = string.reverse(reverse) -- Append reverse of postfix to postfix\n\
    \tlocal result = string.reverse(string.reverse(postfix)) -- Append the reversed\
    \ postfix to the postfix of the palindrome\n\treturn result\nend", "\tlocal reversed_postfix\
    \ = string\n\tfor i = #string - 1, 1, -1 do\n\t\treversed_postfix = reversed_postfix\
    \ .. string[i]\n\tend\n\treturn string .. reversed_postfix\nend", "  local longest,\
    \ palindrome = \"\", \"\"\n  for i = #string + 1, 2, -1 do\n    local prefix =\
    \ string[i - 1]\n    local suffix = string[#string]\n    local palindromic, longest\
    \ = longest_palindrome(prefix, suffix)\n    if not palindromic then\n      local\
    \ result = longest .. suffix\n      longest, palindrome = prefix, result\n   \
    \ end\n  end\n  assert(palindrome ~= \"\")\n  return longest, palindrome\nend",
  "\t-- Find longest postfix of string that is a palindrome.\n\tlocal longest_postfix\
    \ = 0\n\tfor i=1,#string do\n\t\tlocal char = string[i]\n\t\tif char == reverse\
    \ then\n\t\t\tlongest_postfix = i\n\t\telse\n\t\t\tlongest_postfix = longest_postfix\
    \ > i and longest_postfix or i\n\t\tend\n\tend", "    local result = ''\n    local\
    \ is_palindromic = true\n    local palindrome = string\n    local palindrome_lenght\
    \ = #palindrome", "\t-- Scan from first letter to last letter of supplied string.\n\
    \tlocal i = 0\n\tlocal length = string\n\t\t:gsub(\"^(.)\", \"%1\")\n\t\t:gsub(\"\
    (.$)\", \"%1\")\n\tlocal reverse = \"\"\n\twhile i <= #length do\n\t\tlocal char\
    \ = string.sub(string, i, i + 1)\n\t\tlocal reversed_char = string.sub(reverse,\
    \ #reverse, #reverse)\n\t\tif char == reversed_char then\n\t\t\ti = i + 1\n\t\t\
    else\n\t\t\tif #reverse == 0 then\n\t\t\t\treverse = char..reverse\n\t\t\t\tbreak\n\
    \t\t\telse\n\t\t\t\treverse = char..reverse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\
    \tend\n\treturn reverse\nend", "\t-- Find longest postfix that is a palindrome\
    \ and create reversed postfix of it.\n\t-- This will be the palindrome suffix.\n\
    \tlocal suffix\n\tfor i = 1, #string do\n\t\tsuffix = \"$(string%$i$i)\" .. suffix\n\
    \tend\n\t-- We will prepend reverse of the given prefix to it, so prepend it.\n\
    \tsuffix = \"$(string%%$suffix%%)\" .. suffix\n\t-- Now find prefix that comes\
    \ before palindrome suffix.\n\tlocal prefix = string\n\twhile not $(suffix ..\
    \ prefix .. $(palindrome)) == $(string) do\n\t\tprefix = prefix..$(prefix)\n\t\
    end\n\t-- Return both reversed prefix and suffix.\n\treturn \"$(string%%$prefix%%)\"\
    \ .. prefix .. suffix .. \"$(string%%$suffix%%)\"\nend", "    local length = string\n\
    \    local reverse = string\n    local i = length - 1\n    while i >= 0 do\n \
    \       reverse = reverse .. string[i]\n        i = i - 1\n    end\n    if length\
    \ == 0 then\n        return false\n    end\n    local is_palindrome = true --\
    \ To avoid undefined behavior.\n    if reverse:reverse() ~= string then\n    \
    \    return false\n    end\n    local substring = string.sub(reverse, 0, length)\n\
    \    -- Append the reverse of the substring.\n    reverse = reverse .. string.sub(reverse,\
    \ 0, length)\n    return substring .. reverse\nend", "  local reverse = string.gsub(string,\
    \ \"^\", function (m) return string.sub(m, 1, string.len(m)) end)\n  local palindrome\
    \ = string.gsub(string, function ()\n    local t = string.sub(reverse, 1, string.len(reverse))\n\
    \    return string.format(\"%s%s\", t, string.sub(reverse, string.len(reverse)))\n\
    \  end)\n  return palindrome\nend", "\t-- We don't care about anything that isn't\
    \ a palindrome.\n\tif string ~= '^' .. string .. '$' then\n\t\treturn string\n\
    \tend", "    local reverse, prefix = string\n    local i = 1\n    while i <= #string\
    \ do\n        local suffix = reverse[#reverse + i..-1]\n        if suffix ~= prefix\
    \ then\n            return prefix .. reverse\n        end\n        i = i + 1\n\
    \    end\n    return string\nend", "   local postfix = string\n   while string.len()\
    \ > 1 do\n      local palindrome = string.sub(postfix, 1, string.len(postfix)\
    \ - string.len(reverse(string)))\n      postfix = string.sub(postfix, string.len(reverse(palindrome))\
    \ + 1)\n      palindrome = reverse (palindrome)\n      if postfix ~= palindrome\
    \ then\n         return postfix .. palindrome\n      end\n   end\n   return postfix\n\
    end\n</code>\nAnd then, for example:\n<code>", "  -- Find longest postfix of string.\n\
    \  local suffix = string\n  local length = 0\n  for i = 1, #suffix do\n    length\
    \ = length + suffix:sub(i, i)\n  end", "    -- Find longest postfix of string\
    \ that is a palindrome.\n    local palindrome_postfix, palindrome_length = find_longest_palindrome_postfix(string)\n\
    \    if palindrome_postfix and palindrome_length then\n        -- Append reverse\
    \ of a string prefix that comes before the palindromic suffix.\n        local\
    \ reversed_prefix = string\n        for i = 0, palindrome_length do\n        \
    \    reversed_prefix = reversed_prefix:reverse()\n        end\n        -- Append\
    \ longest postfix of string that is a palindrome.\n        local palindrome_append\
    \ = palindrome_postfix\n        for i = 0, palindrome_length do\n            palindrome_append\
    \ = palindrome_append:reverse()\n        end\n        -- Build palindrome.\n \
    \       local palindrome = reversed_prefix:reverse() + palindrome_postfix\n  \
    \      return palindrome\n    else\n        return nil\n    end\nend", "    local\
    \ result = string.match(\"([^\" .. string .. \"]+)[\" .. string .. \"](\" .. string\
    \ .. \")\")\n    if result then\n        -- Remove palindrome suffix\n       \
    \ local suffix = string.sub(string, string.len(result) + 1, string.len(string))\n\
    \        local reversed = string.sub(suffix, 1, string.len(suffix))", "    local\
    \ palindrome = string\n    local suffix\n    for suffix in string.gmatch(\"%.-#\"\
    ):gmatch(\"%w+\") do\n        local prefix, suffix = string.sub(palindrome, 1,\
    \ -#suffix), string.sub(palindrome, -1)\n        local prefix_reverse = prefix:reverse()\n\
    \        palindrome = palindrome .. prefix_reverse .. suffix\n    end\n    return\
    \ palindrome\nend", "    -- Handle empty string\n    if not string then\n    \
    \    return ''", "    local index = #string\n    while index > 0 do\n        if\
    \ string.sub(string, 1, index) == make_palindrome_prefix(string) then\n      \
    \      return string..make_palindrome_suffix(string:sub(index, index))\n     \
    \   end\n        index = index - 1\n    end\nend", "\tlocal suffix\n\tlocal longest\
    \ = 0", "  local suffix\n  local suffix = string\n  local length = #string", " \
    \ local postfix = string.gsub(string.gsub(string, \"[%(^)]+$\"), \"[%(^)]+\",\
    \ \"%1\") -- Strip trailing punctuation.\n  -- Add palindrome suffix.\n  postfix\
    \ = string.reverse(postfix) .. postfix\n  -- Find longest palindrome that starts\
    \ with a prefix of the postfix.\n  local longest = string.gsub(postfix, \"%-([^%)]+)%\"\
    , function(_, suffix)\n    local postfix = string.gsub(string, \"[%(^)]+\", suffix\
    \ .. \"%1\")\n    local longest_palindrome = string.gsub(postfix, \"%-([^%)]+)%\"\
    , function(_, suffix)\n      return string.reverse(suffix)\n    end)\n    -- Remove\
    \ palindrome suffix from longest palindrome string.\n    longest = longest:gsub(\"\
    %-([^%)]+)%\", function(_, suffix)\n      return suffix\n    end)\n    longest\
    \ = string.reverse(longest)\n    return longest .. suffix\n  end)\n  return longest:gsub(\"\
    %-([^%)]+)%\", function(_, suffix)\n    return suffix\n  end)\nend", "    -- Create\
    \ an empty string to store the reverse of the string.\n    local reverse_string\
    \ = \"\"\n    -- For each character in the supplied string.\n    for character\
    \ in string:gmatch(\"[^ ]+\") do\n    -- Reverse the character\n    reverse_string\
    \ = reverse_string .. string.char(reverse(character))\n    end", "    if not string\
    \ then\n        return nil\n    end", "    local reversed_string = \"\"\n    local\
    \ string_prefix = get_string_prefix_at_index(string, 1, true)", "    local palindrome\
    \ = string\n    local longest_postfix = string.gsub(string, \" \", \"\")\n   \
    \ local prefix_length = string.len(longest_postfix)\n    local prefix_string =\
    \ string.sub(longest_postfix, 0, prefix_length)\n    local reversed_prefix = prefix_string\
    \ .. string.sub(prefix_string, -1, prefix_length)\n    local reversed_suffix =\
    \ string.gsub(longest_postfix, \"^\", reversed_prefix)\n    palindrome = palindrome\
    \ .. \" \" .. reversed_suffix\n    return palindrome\nend", "   local prefix =\
    \ ''\n   for i = #string do\n      if string.sub(i, i + 1) ~= string.sub(string:reverse():find(),\
    \ string:reverse():find()) then\n         prefix = prefix .. string.sub(i, i +\
    \ 1)\n      end\n   end\n   if prefix:len() >= string.len(string) then\n     \
    \ return prefix .. string.sub(string:reverse():find(), string:reverse():find())\n\
    \   end\n   return string\nend", "\tlocal longest, prefix, suffix = palindrome(string)\n\
    \tlocal postfix, palindrome = longest:reverse():gsub(\"%s+$\", \"\"), string\n\
    \treturn string.reverse(prefix:sub(1, longest)) .. postfix .. string.reverse(palindrome)\n\
    end", "  -- Find longest postfix that is palindrome\n  local postfix = string\n\
    \  local palindrome = string\n  local maxLength = 0\n  while palindrome ~= postfix\
    \ do\n    if palindrome == postfix:reverse() then\n      maxLength = maxLength\
    \ + 1\n    end\n    local newPostfix = postfix:sub(1, maxLength)\n    postfix\
    \ = postfix:sub(maxLength + 1)\n    postfix = postfix:reverse()\n    postfix =\
    \ postfix .. newPostfix\n    palindrome = palindrome:reverse()\n  end\n  -- Add\
    \ postfix to string and return\n  return string .. postfix\nend", "    local postfix\
    \ = string\n    for i=1,string.len do\n        postfix = string.reverse(postfix)\
    \ .. string.reverse(string:sub(string.len - i))\n    end\n    return postfix\n\
    end", "    local start = 0\n    local len\n    local postfix_to_test = string\n\
    \    while start < #postfix_to_test do\n        len = #postfix_to_test\n     \
    \   local palindrome\n        for i = start, len-1 do\n            if string[i]\
    \ ~= string[len-i] then\n                len = i\n                palindrome =\
    \ string.sub(string,start,len-1)\n                break\n            end\n   \
    \     end\n        if palindrome ~= nil then\n            postfix_to_test = string.sub(postfix_to_test,len+1)\n\
    \            return palindrome\n        end\n        start = len + 1\n    end\n\
    \    return nil\nend", "    local suffix = get_suffix(string)\n    local palindrome\
    \ = string\n    local prefix = ''", "    local length = string.len()\n    if length\
    \ == 0 then return nil end\n    local reversed = string\n    local prefix", " \
    \ local longest_postfix = _find_longest_postfix(string)\n  local postfix_reversed\
    \ = _find_longest_prefix_reverse(string,\n    longest_postfix.length)\n  return\
    \ string .. postfix_reversed\nend", "  local longest = string.match(string, \"\
    (.*%a+)%a?\")\n  if longest and longest:len() > string.len(string) then\n    --\
    \ This is not Palindrome\n    return false\n  end\n  local reversed_prefix = reverse(string:sub(1,\
    \ string.len(string)-1))\n  local palindrome = reversed_prefix .. string\n  return\
    \ palindrome\nend", "    -- Find longest palindrome in string that is prefixed\
    \ by given string.\n    local max_prefix = 0\n    for i = 1, #string do\n    \
    \    local prefix = string[max_prefix]\n        local length = #prefix + 1\n \
    \       local postfix = string:sub(max_prefix + 1, length)\n        local palindrome\
    \ = prefix + postfix:reverse()\n        if palindrome == string then\n       \
    \     return prefix\n        end\n        if palindrome:find(string) == 1 then\n\
    \            max_prefix = i\n        end\n    end\nend", '  local rev_string',
  "  -- Build prefix to palindrome reverse string\n  local prefix = ''\n  for i =\
    \ 1, #string do\n    prefix = prefix .. string.sub(i, i)\n  end", "    local suffix\n\
    \    for i = #string + 1, 1, -1 do\n        local reverse = string.sub(reverse(string,\
    \ 1, i-1), 1, i)\n        if reverse == string then\n            suffix = i\n\
    \        end\n    end\n    return string.sub(string, 1, suffix-1..suffix) + string.sub(reverse(string,\
    \ 1, suffix-1), suffix+1, #string)\nend", "    local palindrome = \"\"\n    local\
    \ max_char\n    local min_char\n    -- Find longest postfix of string that is\
    \ a palindrome\n    for i = 1, #string do\n        max_char = string[max_char_pos(string)]\n\
    \        min_char = string[min_char_pos(string)]\n        -- Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        palindrome = palindrome .. string[max_char_pos(string) - min_char_pos(string)]\n\
    \    end\n    return palindrome\nend", "  if string == '' then return '' end\n\
    \  local suffix = ''\n  while true do\n    local prefix = ''\n    while true do\n\
    \      prefix = prefix .. string\n      if palindromes[prefix] ~= palindromes[prefix]\
    \ then\n        prefix = prefix .. suffix\n        break\n      end\n      string\
    \ = suffix\n    end\n    if prefix == suffix then\n      break\n    end\n    if\
    \ #suffix > 0 then\n      suffix = string\n    else\n      suffix = ''\n    end\n\
    \  end\n  local palindrome = prefix .. suffix\n  palindromes[palindrome] = palindrome\n\
    \  return palindrome\nend", "  local length = #string\n  local palindrome\n  local\
    \ postfix = {}", "  local is_palindrome = false\n  local longest_postfix_string\
    \ = \"\"\n  local longest_postfix_string_index = 1\n  for i = 1, #string do\n\
    \    if string.sub(i, i) == string.sub(string, #string) then\n      longest_postfix_string\
    \ = longest_postfix_string .. string.sub(string,\n        longest_postfix_string_index,\
    \ i)\n      longest_postfix_string_index = i\n    end\n  end\n  if longest_postfix_string\
    \ ~= \"\" then\n    for i = longest_postfix_string_index, #string do\n      if\
    \ string.sub(i, i) == string.sub(string, #string) then\n        is_palindrome\
    \ = true\n        break\n      end\n    end\n  end\n  return longest_postfix_string,\
    \ is_palindrome\nend", "    if string == nil then\n        return nil\n    end\n\
    \    local length = #string\n    local prefix\n    local suffix\n    local reverse",
  "  -- A single character prefix of the longest postfix of the string is palindrome\n\
    \  if string.len == 1 or string.len == string.sub(string, string.len-1) == ''\
    \ then\n    return string.sub(string, 1, string.len-1)\n  end\n  -- A sequence\
    \ of characters can form a palindrome\n  if string.len == string.sub(string, string.len-2).len\
    \ then\n    return string.sub(string, 1, string.len-1) + make_palindrome(string.sub(string,\
    \ string.len-2))\n  end\n  -- Find the longest postfix of supplied string that\
    \ is a palindrome.\n  local postfix_len = string.len\n  while string.len > 1 and\
    \ string.sub(string, string.len-1, string.len) == string.sub(string, string.len-2,\
    \ string.len) do\n    postfix_len = string.len\n    string = string.sub(string,\
    \ 1, string.len-1)\n  end\n  -- Return concatenation of reverse of a string prefix\
    \ that comes before the longest postfix of supplied string.\n  return string.sub(string,\
    \ 1, string.len-1) + make_palindrome(string.sub(string, string.len-2))\nend",
  "    if string == nil then return end\n    local postfix_palindromes = {}\n    for\
    \ i = 1, #string do\n        local postfix = string\n        postfix = string.reverse(postfix,\
    \ i)\n        postfix_palindromes[#postfix_palindromes + 1] = postfix\n    end\n\
    \    if #postfix_palindromes == 0 then\n        return nil\n    end\n    local\
    \ smallest_postfix = #postfix_palindromes[1]\n    for i = 2, #postfix_palindromes\
    \ do\n        if smallest_postfix > #postfix_palindromes[i] then\n           \
    \ smallest_postfix = #postfix_palindromes[i]\n        end\n    end\n    local\
    \ palindrome = string\n    palindrome = palindrome:sub(1, smallest_postfix)\n\
    \    palindrome = palindrome:reverse()\n    palindrome = palindrome:sub(1, #string)\n\
    \    if #palindrome  == 0 then\n        return nil\n    end\n    return palindrome\n\
    end", "   local longest_postfix, longest_prefix_len\n   for _,v in ipairs(string.gmatch(\"\
    (%a+)\")) do\n      longest_postfix = v .. reverse(string.sub(v,1,string.len(v)))\n\
    \      longest_prefix_len = string.len(longest_postfix)\n   end\n   return longest_postfix\
    \ .. string.sub(string, longest_prefix_len)\nend", "  if string == nil then\n\
    \    return \"nil\"\n  elseif string.sub(string, 1, string.len(string)) == string\
    \ then\n    return string\n  else\n    local start, end = string.find(string,\
    \ \"^\")\n    if start > end then\n      start = string.len(string)\n    end\n\
    \    local length = string.len(string)\n    if start < end then\n      length\
    \ = start - 1\n    end\n    local reverse = string.sub(string, string.len(string)\
    \ - length - 1, string.len(string))\n    local prefix = string.sub(string, 0,\
    \ string.len(string) - length - 1)\n    return prefix .. reverse .. string\n \
    \ end\nend", "  if string == \"\" then\n    return nil\n  end\n  local prefix\
    \ = reverse(string:sub(1, #string))\n  local suffix = reverse(string:sub(#string,\
    \ #string))\n  if prefix and suffix then\n    return string..suffix..prefix\n\
    \  end\n  return nil\nend", "    -- Remove spaces and carriage returns from start\
    \ and end\n    string = string.gsub('\\r', '');\n    string = string.gsub('\\\
    n', '');\n    \n    -- Find longest palindrome prefix\n    local prefix_len =\
    \ string.gsub(string:match('^([^%s]+)%s$'), '%d+', 1);\n    \n    -- Make palindrome\
    \ with suffix from longest palindrome prefix\n    local palindrome = string..string.sub(string:sub(prefix_len+1,\
    \ -prefix_len));\n    \n    return palindrome;\nend", "  local postfix = string:reverse()\n\
    \  local reverse = postfix:sub(1, -string.len(postfix))\n  local palindrome =\
    \ string .. reverse\n  return palindrome\nend", "    local pal = string.match(\"\
    ^(.-)..(.*)$\", \"$2\") -- Get longest postfix of given string.\n    if pal then\n\
    \        local reversed_string = string.gsub(pal, \"(.*)$\", \"$1:..\") -- Reverse\
    \ the given prefix before the suffix.\n        return string.reverse(reversed_string)\
    \ -- Reverse the whole string.\n    else\n        return string\n    end\nend\n\
    </code>\nAnd now the main function...\n<code>", "\tlocal postfix = string.gsub(string,\
    \ \"^.\", \"^.\")\n\tpostfix = string.gsub(postfix, \"$\", \"$.\")\n\tpostfix\
    \ = string.gsub(postfix, \"^\", \"^.\")\n\tpostfix = string.gsub(postfix, \"$\"\
    , \"$.\")\n\treturn string\n\t\t.. \"^\"\n\t\t.. postfix .. \"$\"\nend", "  --\
    \ TODO: Refactor: We could probably avoid making the temporary string if we used\
    \ a stack\n  -- to perform the postfix finding - this would require more refactoring,\
    \ though.\n  local reverse = string\n  local postfix = \"\"\n  for i = #string,\
    \ 1, -1 do\n    local current = string[i]\n    local next = \"\"\n    for j =\
    \ 1, #string do\n      if string[j] == current then\n        next = string[j]\n\
    \        break\n      end\n    end\n    if next == current then\n      break\n\
    \    end\n    postfix = reverse .. next -- We reverse it because we need the longest\
    \ postfix that ends with it.\n    reverse = postfix -- Reverse it.\n  end\n  return\
    \ postfix .. reverse\nend", "    local longest_postfix = get_longest_postfix_string(string)\n\
    \    local postfix = string\n    local reverse = ''\n    -- Keep adding the longest\
    \ postfix until there is no longer any postfix.\n    while postfix ~= '' do\n\
    \        reverse = reverse .. postfix\n        postfix = longest_postfix\n   \
    \     longest_postfix = get_longest_postfix_string(postfix, longest_postfix)\n\
    \    end\n    return reverse .. postfix\nend", "   assert(type(string) == 'string')\n\
    \   local palindrome = ''\n   local suffix_len = 0\n   for i = 1, #string do\n\
    \      local char = string.sub(i, i)\n      if char == char:reverse() then\n \
    \        suffix_len = suffix_len + 1\n      else\n         suffix_len = suffix_len\
    \ + 1\n         palindrome = palindrome .. char\n      end\n   end\n   \n   palindrome\
    \ = palindrome:reverse()\n   \n   return palindrome .. string.sub(suffix_len,\
    \ #string)\nend", "    if string.match then\n        -- Lua 5.2\n        local\
    \ function palindrome1(string)\n            return string.gsub(string, string.match,\
    \ \"%W\"):reverse():gsub(\"%W\", \"%%%d\"):reverse())\n        end", "    -- Handle\
    \ edge cases where string length is 0\n    if not string or string.lenght == 0\
    \ then return string end", "    if string == nil then return nil end\n    local\
    \ length\n    local maxLength = 0\n    local maxLength = string.len(string) /\
    \ 2\n    for i = 1, maxLength do\n        local char = string.sub(string, i -\
    \ 1, i)\n        local revChar = string.sub(string, string.len(string) - i - 1,\
    \ string.len(string) - i)\n        if char == revChar then\n            length\
    \ = i\n        else\n            length = maxLength\n        end\n    end\n  \
    \  local palindrome = string\n    for i = 1, length do\n        palindrome = palindrome\
    \ .. string.reverse(string:sub(i, i))\n    end\n    return palindrome\nend", " \
    \   local suffix\n    local index\n    local max_length = 0\n    for index = 1,\
    \ #string do\n        suffix = string.sub(string, (index - 1) * 2)\n        if\
    \ suffix == suffix then\n            max_length = max_length + 1\n        else\n\
    \            max_length = max_length\n            break\n        end\n    end\n\
    \    for index = 1, max_length do\n        string = string .. string.reverse(string,\
    \ (index + 1) * 2)\n    end\n    return string\nend", "   local start = string.find(string,\
    \ \"%^%\")\n   if start == nil then return string end\n   local stop = string.find(string,\
    \ \"%-%$\", start+3)\n   if stop == nil then return string end\n   local reverse\
    \ = string.reverse(string.sub(string, start, stop-1))\n   return\n      string.sub(string,\
    \ \"%^%\", start) ..\n      reverse ..\n      string.sub(string, \"%-%$\", stop+1)\n\
    end\n</code>\n<|/ a tags=lua-patterns,lua |>\n<| c |>\nThis was a great solution!\
    \ Very helpful!\n<|/ c |>\n<| a dscore=2 tags=lua-patterns,lua |>\n<code>", "\t\
    local prefix = ''\n\tlocal longest = 0\n\tfor i = #string, 1, -1 do\n\t\tif string.sub(string,i,i)\
    \ == string.sub(string,i,i) then\n\t\t\tprefix = prefix .. string.sub(string,i,i)\n\
    \t\telse\n\t\t\tif prefix ~= '' then\n\t\t\t\tlongest = #prefix + 1\n\t\t\t\t\
    break\n\t\t\telse\n\t\t\t\tprefix = ''\n\t\t\tend\n\t\tend\n\tend\n\tprefix =\
    \ prefix .. string.sub(string,longest)\n\treturn prefix .. string.reverse(string.sub(string,\
    \ 1,-longest))\nend", "    -- Find the length of the prefix that must come before\
    \ a palindrome suffix to make it a palindrome.\n    local prefix_length = string.find(string,\
    \ \"^[^\\n]\", 1, 1)", "    local palindrome = nil\n    local max_prefix = 1\n\
    \    local prefix\n    local suffix", "    local reverse = \"\"\n    for i = 1,\
    \ string.lenght do\n        reverse = reverse..string.sub(i, string.lenght)\n\
    \    end\n    return string..reverse\nend", "   local postfix = string\n   while\
    \ true do\n      postfix = string .. postfix:reverse()\n      if postfix ~= string\
    \ then\n         return postfix\n      end\n   end\nend", '    local postfix,
    suffix', "  local palindrome = string.gsub(string, \"(.-)(.+)$\", \"\\\\2\\\\\
    1\")\n  string = string .. string.rep(palindrome, #palindrome + 2)\n  local prefix\n\
    \  if string.sub(string, 1, #palindrome) ~= palindrome then\n    prefix = string.sub(string,\
    \ 1, #palindrome)\n  else\n    prefix = string\n  end\n  return prefix, string,\
    \ palindrome\nend", "    local lens = string:len()\n    local longest = ''\n \
    \   local suffix = ''\n    local reversed = ''\n    for i = 1, lens do\n     \
    \   if suffix == '' then\n            suffix = string:sub(i,i)\n        elseif\
    \ suffix:sub(1,1) == string:sub(i,i) then\n            suffix = suffix:sub(2)\n\
    \        else\n            suffix = suffix .. string:sub(i,i)\n        end\n \
    \       if suffix:sub(1,1) == string:sub(lens-i,lens-i) then\n            longest\
    \ = suffix .. longest:sub(longest:len()-1)\n            reversed = string(reversed)\
    \ .. suffix:sub(1,1) .. reversed:sub(#reversed-1)\n        end\n    end\n    return\
    \ longest .. reversed\nend", "\tlocal max_len, prefix, suffix", "  local max_size\
    \ = string.len(string) + 1\n  local start = 0\n  local end = 0\n  while start\
    \ < max_size do\n    local start = string.len(string) + 1\n    while start > 0\
    \ do\n      -- Find longest postfix of string that is a palindrome.\n      local\
    \ max_size = start\n      for i = start, 1, -1 do\n        local last_letter =\
    \ string.sub(string,i,i)\n        if string.len(last_letter) == 1 then\n     \
    \     break\n        else\n          max_size = max_size - 1\n        end\n  \
    \    end\n      max_size = max_size + 1\n      start = start - 1\n      local\
    \ postfix_to_add = string.rep(\"*\", max_size)\n      postfix_to_add = string.sub(postfix_to_add,0,start)\n\
    \      postfix_to_add = string.sub(postfix_to_add,-1,max_size)\n      postfix_to_add\
    \ = string.sub(postfix_to_add,0,max_size)", "\tlocal longest = string.gsub(string,\
    \ \"(%.?)(%.?)(%.?)\", \"%2$3\") -- longest palindromic suffix of string.\n\t\
    local prefix = string.gsub(string, \"(%.?)%2$3\", \"%2$3\") -- prefix of a string\
    \ that is palindrome\n\t-- Create reversed suffix\n\tlocal suffix_reversed = string.sub(longest,\
    \ 1, #longest - 1)\n\t-- Reverse reversed suffix.\n\tsuffix_reversed = string.gsub(suffix_reversed,\
    \ \"(%.?)(%.?)\", \"%1$2\") -- Reverse reversed suffix.\n\t-- Append reversed\
    \ suffix to longest postfix to create the palindrome\n\treturn string .. prefix\
    \ .. string.sub(suffix_reversed, 1, #suffix_reversed - 1) .. suffix\nend", " \
    \   local max_length = 0\n    local length = 1\n    for i = 1, #string do\n  \
    \      if string[i] ~= string[length - 1] then\n            length = length +\
    \ 1\n        end\n        if i > max_length then\n            max_length = i\n\
    \        end\n    end", "    -- First reverse the string and then find the longest\
    \ palindrome.\n    local suffix_length = len(string)\n    while suffix_length\
    \ > 0 do\n        local start = suffix_length\n        local stop = suffix_length\
    \ - 1\n        suffix_length = suffix_length - 1\n        local reverse = string.reverse(string:sub(start,\
    \ stop))\n        if reverse == string then\n            return string\n     \
    \   end\n    end\nend", "  -- Find longest palindrome in string.\n  local longest\
    \ = find_longest(string)\n  -- Find longest palindrome in reverse of the string.\n\
    \  local reverse = reverse(string)\n  -- Remove longest from front of string.\n\
    \  -- Remove longest from end of string.\n  local shortest = string.sub(string,\
    \ 1, longest-2)\n  local longest_reverse = reverse.sub(longest-2, longest)\n \
    \ -- Append to the end of the string.\n  local output = string.sub(string, 1,\
    \ longest+2)\n  -- Append the shortest postfix to the end of the string.\n  output\
    \ = output .. shortest\n  -- Append the longest postfix to the end of the string.\n\
    \  output = output .. longest_reverse\n  -- Return the string.\n  return output\n\
    end", "    if string == nil or string == \"\" or string == \"0\" or string ==\
    \ \"1\" then\n        return string\n    end", "  local longest_palindrome = \"\
    \"\n  local longest_postfix_index = 0\n  local longest_postfix_length = 0", "\t\
    local result", "  local longest, palindrome = string.match(string, \"(.)(%a+)$\"\
    )\n  string = palindrome\n  local index = string.find(\"#{\")\n  while index do\n\
    \    string.gsub(string, \"%a{\" .. index, \"\")\n    local pal = string.match(string,\
    \ \"(.)(%a+)$\")\n    if pal then\n      if string.sub(pal[2], 1, string.len(palindrome))\
    \ ~= palindrome then\n        string.gsub(string, \"#\", palindrome)\n      end\n\
    \      string = pal[1]\n    end\n    index = string.find(\"#{\")\n  end\n  return\
    \ string.gsub(string, \"%a{\", \"\")\nend", "    local palindrome = string\n \
    \   local longest_postfix_size = string_to_prefixes(string).reduce(function(max_len,\
    \ prefix)\n        return max_len > #prefix and max_len or #prefix\n    end)\n\
    \    local prefix_size = string_to_prefixes(string).reduce(function(prefix_len,\
    \ prefix)\n        return prefix_len > #prefix and prefix_len or #prefix\n   \
    \ end)\n    -- Add longest postfix to beginning of string.\n    -- Since we are\
    \ adding to the beginning of the string, we reverse the string\n    -- prefix\
    \ that comes before it before we append the postfix to the end.\n    local suffix\
    \ = string_to_prefixes(string).reduce(function(suffix, prefix)\n        return\
    \ #suffix > #prefix and suffix or #suffix\n    end)\n    local prefix_reversed\
    \ = prefix_size < #suffix\n    local longest_postfix = string_to_prefixes(string).reduce(function(postfix,\
    \ prefix)\n        return #postfix > #prefix and postfix or #postfix\n    end)\n\
    \    local longest_postfix_start = longest_postfix_size + prefix_reversed\n  \
    \  -- Add longest postfix to end of string.\n    local longest_postfix_end = suffix\
    \ - longest_postfix_size\n    if longest_postfix_start > #longest_postfix then\n\
    \        longest_postfix_start = #longest_postfix\n    end\n    if longest_postfix_end\
    \ > #longest_postfix then\n        longest_postfix_end = #longest_postfix\n  \
    \  end\n    palindrome = palindrome .. string_to_suffixes(string).reduce(function(suffix,\
    \ prefix)\n        return #suffix > #prefix and suffix or #suffix\n    end)\n\
    \    palindrome = palindrome .. longest_postfix\n    -- We are adding from the\
    \ end, so reverse the postfix if required.\n    if prefix_reversed then\n    \
    \    palindrome = palindrome .. string_to_suffixes(string).reduce(function(suffix,\
    \ prefix)\n            return #suffix > #prefix and suffix or #suffix\n      \
    \  end)\n    end\n    return palindrome\nend", "    local postfix = string\n \
    \   local length = #string\n    while length > 1 do\n        local middle = math.floor((length\
    \ + 1) * ((length + 1) / 2))\n        middle = math.min(middle, length - 1)\n\
    \        postfix = string..middle..middle\n        length = length - middle\n\
    \    end\n    return postfix, string..(string.sub(string, 1, end-1)):reverse()\n\
    end", "    local longest = string.gmatch(string, \"(^|[^A-Za-z0-9])([A-Za-z0-9]+)([^A-Za-z0-9])\"\
    )\n    if longest then\n        local prefix\n        local suffix\n        local\
    \ longest_palindrome", "  local index = 1\n  while true do\n    -- Find longest\
    \ postfix of string that is a palindrome.\n    local suffix = string[index:index]\n\
    \    local palindrome = string\n    for i = index, #string do\n      palindrome\
    \ = string..string.sub(palindrome, i, i)\n    end\n    local reversed = string..string.sub(palindrome,\
    \ #palindrome, #palindrome)", "\tlocal palindrome_prefix = ''\n\tlocal palindrome_suffix\
    \ = ''\n\tlocal longest_palindrome_length = 0\n\tlocal longest_palindrome_length_index\
    \ = 0\n\tlocal longest_palindrome_prefix = ''\n\tlocal longest_palindrome_suffix\
    \ = ''\n\tlocal longest_palindrome_suffix_index = 0\n\tfor i = 1, #string do\n\
    \t\tlocal character = string.sub(string,i,i)\n\t\tif character == character then\n\
    \t\t\tlongest_palindrome_length_index = i\n\t\t\tlongest_palindrome_length = longest_palindrome_length\
    \ + (i - longest_palindrome_length_index)\n\t\telse\n\t\t\tif longest_palindrome_length_index\
    \ > 0 then\n\t\t\t\tlongest_palindrome_length = longest_palindrome_length + (i\
    \ - longest_palindrome_length_index)\n\t\t\t\tlongest_palindrome_suffix = string.sub(string,longest_palindrome_length_index,longest_palindrome_length_index)\n\
    \t\t\t\tlongest_palindrome_prefix = string.sub(string,0,longest_palindrome_length_index)\n\
    \t\t\t\tif longest_palindrome_length < longest_palindrome_length then\n\t\t\t\t\
    \tlongest_palindrome_suffix = string.sub(string.sub(string,longest_palindrome_length_index,longest_palindrome_length_index\
    \ + longest_palindrome_length - 1),0,longest_palindrome_length)\n\t\t\t\tend\n\
    \t\t\tend\n\t\t\tlongest_palindrome_length_index = 0\n\t\t\tlongest_palindrome_length\
    \ = 0\n\t\t\tlongest_palindrome_prefix = ''\n\t\t\tlongest_palindrome_suffix =\
    \ ''\n\t\tend\n\tend\n\tif longest_palindrome_length_index > 0 then\n\t\tlongest_palindrome_length\
    \ = longest_palindrome_length + (i - longest_palindrome_length_index)\n\t\tlongest_palindrome_suffix\
    \ = string.sub(string,longest_palindrome_length_index,longest_palindrome_length_index)\n\
    \t\tlongest_palindrome_prefix = string.sub(string,0,longest_palindrome_length_index)\n\
    \t\tif longest_palindrome_length < longest_palindrome_length then\n\t\t\tlongest_palindrome_suffix\
    \ = string.sub(string.sub(string,longest_palindrome_length_index,longest_palindrome_length_index\
    \ + longest_palindrome_length - 1),0,longest_palindrome_length)\n\t\tend\n\t",
  "  -- Find longest palindromic suffix.\n  local max_postfix_length = -1\n  for i\
    \ = 1, string.lenth do\n    if string.sub(i, i, i) ~= string.rev(string.sub(i,\
    \ i, i)) then\n      max_postfix_length = i\n    end\n  end\n  assert(string.len(string)\
    \ >= max_postfix_length)\n  -- Construct palindrome from longest suffix.\n  local\
    \ postfix_reverse = string.rev(string.sub(string.length, max_postfix_length))\n\
    \  return string.sub(string, 0, max_postfix_length..postfix_reverse)\nend", " \
    \  local suffix\n   local palindrome = \"\"\n   local prefix\n   for suffix in\
    \ string.gmatch(string, \"(.)%.*$\") do\n      local reversed_prefix = reverse(string:sub(#prefix))\n\
    \      if palindrome:sub(1, #reversed_prefix) ~= reversed_prefix then\n      \
    \   palindrome = palindrome .. reversed_prefix\n         palindrome = palindrome\
    \ .. suffix\n      else\n         palindrome = palindrome .. suffix\n      end\n\
    \   end\n   return palindrome\nend", "\tlocal longest_postfix = string.gsub(string,\
    \ '.') -- longest postfix of supplied string.\n\tlocal palindrome = string.sub(longest_postfix,\
    \ 1, string.len(longest_postfix) - 1) -- String prefix that comes before the palindromic\
    \ suffix.\n\tpalindrome = string.reverse(palindrome) -- Reverse of string prefix.\n\
    \treturn longest_postfix.. palindrome\nend", "    local postfix = string.sub(string,\
    \ 1, string.len(string))\n    local prefix_reverse = string.sub(string.gsub(postfix,\
    \ '(.)%b', string.char(1, string.reverse)), 1, string.len(postfix))\n    return\
    \ string.gsub(string.gsub(string.gsub(prefix_reverse, '(.)%b', '%1%b'), '(.)%b',\
    \ '%1%b'), '(.)%b', '%1%b') .. postfix\nend", "    local suffix = ''\n    for\
    \ i = 1, string.lenght do\n        suffix = suffix .. string[string.lenght - i]\n\
    \        if suffix == string then\n            return string\n        end\n  \
    \  end\n    return nil\nend", "  local index = 0\n  local max_length = #string\
    \ + 1\n  local result = \"\"\n  while index <= max_length do\n    local substring\
    \ = string.sub(string, index, index)\n    index = index + 1\n    if string.sub(string,\
    \ index, index) == substring then\n      result = result .. substring .. \"-\"\
    \n      index = index + 1\n      max_length = max_length - 1\n    end\n  end\n\
    \  return result\nend", "    local length\n    -- Find longest postfix that is\
    \ a palindrome from the string itself.\n    repeat\n        -- Find longest postfix\
    \ of string that is also a palindrome\n        -- by appending its reverse to\
    \ the string itself\n        -- Example: Lanterna -> LanternaLanterna -> LanternaLanternaLanterna\
    \ -> LanternaLanternaLanternaLanterna -> LanternaLanternaLanternaLanternaLanterna\
    \ -> LanternaLanternaLanternaLanternaLanterna\n        --           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
  "\t-- Find longest postfix that is a palindrome\n\tlocal longest_postfix\n\tlocal\
    \ longest_suffix_length\n\tlocal longest_prefix_length\n\tlocal longest_length\n\
    \tlocal longest_postfix_length\n\tlocal longest_prefix_length_length\n\tfor longest_postfix_length\
    \ = 1, #string do\n\t\tlocal postfix = string[longest_postfix_length]\n\t\tlocal\
    \ prefix_length = longest_postfix_length - 1\n\t\tlocal prefix_string\n\t\tif\
    \ prefix_length == 0 then\n\t\t\tprefix_string = string\n\t\telse\n\t\t\tprefix_string\
    \ = string[prefix_length]\n\t\tend\n\t\t-- Make sure that this is a palindrome\n\
    \t\tlocal result = check_palindrome(prefix_string, postfix)\n\t\tif result then\n\
    \t\t\tlongest_postfix_length = longest_postfix_length\n\t\t\tlongest_suffix =\
    \ postfix\n\t\t\tlongest_suffix_length = prefix_length\n\t\t\tlongest_prefix_length\
    \ = prefix_length\n\t\t\tlongest_prefix_length_length = prefix_length\n\t\t\t\
    longest_length = prefix_length\n\t\t\tbreak\n\t\tend\n\tend\n\tlocal palindrome_length\
    \ = longest_prefix_length\n\tif longest_postfix_length == #string then\n\t\tlongest_postfix_length\
    \ = longest_prefix_length\n\tend\n\t-- Construct the new string\n\tlocal new_string\n\
    \tif longest_prefix_length == 1 then\n\t\tnew_string = string\n\t\tnew_string[longest_prefix_length]\
    \ = longest_suffix\n\telse\n\t\tnew_string = string\n\t\tnew_string[longest_prefix_length]\
    \ = longest_suffix\n\t\tnew_string[longest_postfix_length] = string[#string-1\
    \ - longest_suffix_length]\n\tend\n\treturn new_string\nend", "    -- Initialize\
    \ variables.\n    local prefix_length = 0\n    local suffix_length = 0", "   \
    \ local suffix    = string\n    local length    = #string\n    local palindrome\
    \ = string", "    local palindrome = nil\n    local palindrome_start = -1\n  \
    \  local palindrome_end = -1\n    for i = 1, #string do\n        local len = string:lenght()\n\
    \        local palindrome_len = len / 2\n        if palindrome_start < 0 then\n\
    \            palindrome_start = i\n        end\n        if palindrome_end < 0\
    \ then\n            palindrome_end = palindrome_start + palindrome_len - 1\n \
    \       end\n        if string:sub(i, palindrome_start + 1):reverse() == string[i\
    \ + 1 - palindrome_len]:reverse() then\n            palindrome = string\n    \
    \        palindrome_start = -1\n            palindrome_end = -1\n        end\n\
    \    end\n    return palindrome\nend", "    -- Base case. No palindromic suffix\
    \ found.\n    -- This can happen if string is an empty string.\n    if #string\
    \ == 0 then\n        return string\n    end", "  local palindrome = \"\"\n  local\
    \ longest = \"\"\n  local longest_postfix = \"\"\n  for i = 1, #string do\n  \
    \  -- Find longest postfix of string that is a palindrome\n    longest = string.sub(string,\
    \ 1, i)\n    for j = 1, #string do\n      if j > 1 then\n        local substring\
    \ = string.sub(string, j, j)\n        longest = string.sub(longest, #longest,\
    \ #longest + string.len(substring))\n      end\n      if longest == string.sub(string,\
    \ i, i) then\n        longest_postfix = string.sub(string, 1, i - 1)\n       \
    \ break\n      end\n    end\n    palindrome = palindrome .. longest_postfix\n\
    \  end\n  return palindrome\nend", "    local max_postfix = string\n    for i\
    \ = 1, #string do\n        local postfix = string\n        postfix = string.sub(postfix,\
    \ 1, i - 1)\n        if suffix(postfix, string.sub(string, i - 1, i), #string)\
    \ == 0 then\n            max_postfix = max_postfix..postfix..string\n        end\n\
    \    end", "\tlocal postfix = string.match( string, \"%a([^a]*)a\" ) -- longest\
    \ palindromic suffix\n\tlocal reverse_prefix = string.match( string, \"%a([^a]*)a\"\
    \ ) -- prefix with longest palindromic suffix\n\t\n\t-- Append reverse of reverse\
    \ of string prefix to postfix to make a palindrome.\n\tlocal palindrome = postfix\
    \ .. reverse_prefix\n\t\n\treturn palindrome\nend\n</textarea></form>", "\tlocal\
    \ suffix\n\tlocal middle", "  local palindrome = string\n  local reverse_postfix\
    \ = \"\"\n  local postfix = string.match(palindrome, \"(^.*%S+)\")\n  if postfix\
    \ ~= nil then\n    reverse_postfix = reverse(string.rep(\"%.\", string.len(postfix)))..postfix\n\
    \  end\n  local index = string.find(palindrome, \"(^%S+)\")\n  if index == nil\
    \ then\n    return nil\n  end\n  local suffix = string.sub(palindrome, index+1)\n\
    \  while suffix ~= \"\" do\n    local index = string.find(suffix, \"(%.*)\")\n\
    \    if index == nil then\n      break\n    end\n    suffix = string.sub(suffix,\
    \ index+1)\n    local prefix = string.rep(\"%.\", string.len(suffix))..suffix\n\
    \    palindrome = prefix..reverse_postfix\n  end\n  return palindrome\nend", " \
    \ local reversed = string\n  local prefix_length = string.len(string) - string.len(reversed)\n\
    \  reversed = reversed:gsub('(.)(.)', function(m)\n    return string.sub(reversed,\
    \ 1, string.len(reversed)-string.len(m.gsub('(.)(.)','\\2')))\n  end)\n  return\
    \ string..reversed\nend", "   -- Find the longest postfix that is palindrome and\
    \ append to string.\n   local found_palindrome = nil\n   for i = 1, #string do\n\
    \      local prefix_start = i - 1\n      local prefix_end = i\n      -- Check\
    \ if the string is a palindrome.\n      local prefix_string = string\n      if\
    \ prefix_start > 1 then\n         -- The string is not a palindrome if its first\
    \ character is not\n         -- a palindrome itself.\n         local first_char\
    \ = string.sub(string, 1, prefix_start)\n         local second_char = string.sub(string,\
    \ 1, prefix_end)\n         if first_char == second_char then\n            -- The\
    \ first character is a palindrome itself.\n            prefix_string = string.sub(string,\
    \ 1, prefix_start - 1)\n         elseif prefix_start <= prefix_end then\n    \
    \        prefix_string = string.sub(string, 1, prefix_end - 1)\n         else\n\
    \            prefix_string = string.sub(string, 1, prefix_start)\n         end\n\
    \      end\n      local suffix_start = string.len(prefix_string) + 1\n      local\
    \ suffix_end = string.len(prefix_string)\n      -- Find the suffix that is palindrome\
    \ and append to string.\n      local suffix_string = string\n      if suffix_start\
    \ <= suffix_end then\n         -- The string is not a palindrome if its last character\
    \ is not\n         -- a palindrome itself.\n         local last_char = string.sub(string,\
    \ 1, suffix_end)\n         local first_char = string.sub(string, 1, suffix_start\
    \ - 1)\n         if last_char == first_char then\n            -- The last character\
    \ is a palindrome itself.\n            suffix_string = string.sub(string, 1, suffix_start)\n\
    \         elseif suffix_start <= suffix_end then\n            suffix_string =\
    \ string.sub(string, 1, suffix_start)\n         end\n      end\n      -- Check\
    \ if the palindrome suffix is palindrome of the prefix.\n      local suffix_string_palindrome\
    \ = prefix_string\n      if suffix_start > 1 then\n         suffix_string_palindrome\
    \ = string.sub(prefix_string, 1, prefix_start)\n      end\n      suffix_string_palindrome\
    \ = suffix_string_palindrome .. suffix_string\n      local suffix_string_palindrome_reversed\
    \ = suffix.reverse(suffix_string_palindrome)\n      if suffix_string_palindrome_reversed\
    \ == suffix_string then\n         -- The suffix is a palindrome of the prefix.\n\
    \         found_palindrome = prefix_string\n         break\n      end\n   end\n\
    \   if not found_palindro", "    local start = string.find(\"-\", string) + 1\n\
    \    local end = string.find(string.sub(string, start, string), string.reverse(string.sub(string,\
    \ start, string))) + 1\n    local palindrome = string.sub(string, start, end)",
  "    local postfix_length = 0 -- Length of longest postfix of string.\n    local\
    \ postfix_string = string -- Postfix string of original string.\n    local prefix\
    \ = string -- Prefix of original string.\n    while true do\n        if postfix_length\
    \ == 0 then\n            postfix_length = #postfix_string\n        end\n     \
    \   postfix_length = postfix_length - 1\n        postfix_string = postfix_string..reverse_string(reverse_string(prefix,\
    \ postfix_length))\n        prefix = prefix..postfix_string\n        if postfix_length\
    \ == 0 then\n            return postfix_string\n        end\n    end\nend", '    local
    result = "("', "   local length\n   local palindrome", "    --local max_len =\
    \ 0\n    --local max_len_palindrome = 0\n    --local prefix_len = 1\n    --local\
    \ suffix_len = 1\n    --local suffix_reverse_len = 1\n    --local max_suffix_len\
    \ = 1\n    --local min_suffix_len = 1\n    --local min_palindrome_len = 1\n  \
    \  --local max_len_palindrome = 1\n    --local max_suffix_reverse_len = 1\n  \
    \  --local min_suffix_reverse_len = 1\n    --local min_palindrome_len = 1\n  \
    \  --local max_len_palindrome = 1\n    --local max_len_palindrome_len = 1\n  \
    \  local string_reverse = ''", "  local palindrome = string\n  local start, i\
    \ = 1, 1\n  while i <= #string do\n    if palindrome:sub(i, #palindrome) == palindrome:sub(i:len())\
    \ then\n      start = i\n      i = i + #palindrome\n    else\n      i = start\
    \ + #palindrome\n      palindrome = palindrome:sub(start, #palindrome)\n    end\n\
    \  end\n  return palindrome\nend", "  -- find longest palindrome\n  local max_len\
    \ = 1\n  local max_len_palindrome = nil\n  local suffix_palindrome = \"\"\n  for\
    \ i = 1, #string do\n    local t = string[max_len]\n    local is_palindrome =\
    \ true\n    for j = 1, #t do\n      -- skip over spaces\n      if t[j] == \" \"\
    \ then\n        j = j + 1\n      end\n      if t[j] ~= string[i] then\n      \
    \  is_palindrome = false\n        break\n      end\n    end\n    -- if palindrome\
    \ is found, then save it for later.\n    if is_palindrome then\n      -- add reverse\
    \ of the prefix to the suffix\n      suffix_palindrome = string[#string]\n   \
    \   string[#string] = string[max_len]\n      --  and update max length\n     \
    \ max_len = max_len + 1\n      -- break early if we have found longest palindrome\n\
    \      if max_len_palindrome == nil then\n        max_len_palindrome = max_len\n\
    \        break\n      end\n    end\n  end\n  if max_len_palindrome == nil then\n\
    \    -- no palindromes found. just return original string\n    return string\n\
    \  end\n  -- add reversed suffix to the original string\n  string = string ..\
    \ suffix_palindrome\n  -- remove trailing spaces from the string\n  string = string.gsub(\"\
    \  \", \"\")\n  return string\nend", "  assert(string ~= nil, \"Input string must\
    \ not be nil\")\n  local result = string\n  local prefix = string\n  local suffix\
    \ = string\n  while true do\n    local postfix = suffix:sub(1, -#suffix)\n   \
    \ suffix = suffix:sub(2)\n    if suffix:palindrome() == true then\n      result\
    \ = result .. suffix .. prefix\n      break\n    end\n    prefix = prefix .. suffix\n\
    \  end\n  assert(result ~= nil, \"Input string is too short\")\n  return result\n\
    end", "    local palindrome = string\n    local length = #palindrome\n    for\
    \ i = 1, length/2, 1 do\n        if string[i:i+length] == palindrome:reverse()\
    \ then\n            palindrome = palindrome .. string[i]\n            break\n\
    \        end\n    end\n    return palindrome\nend", "    -- Get the prefix and\
    \ suffix\n    local prefix_length = string.len(string) - string.reverse(string.sub(string,1,string.len(string)))\n\
    \    local suffix = string.reverse(string.sub(string,string.len(string),string))",
  "  local max_len = string.len(string) / 2\n  local palindrome = string\n  -- Find\
    \ the longest postfix palindrome.\n  for i = 1, max_len, 2 do\n    local prefix_len\
    \ = string.len(string) - i\n    local is_palindrome = palindrome == palindrome:reverse()\n\
    \    if is_palindrome then\n      -- Add the length of the longest postfix to\
    \ the palindrome.\n      palindrome = palindrome .. string.sub(string, 1, prefix_len)\n\
    \      break\n    end\n  end\n  return palindrome\nend", "    -- Find the longest\
    \ palindrome that begins with a supplied string.\n    local longest = 0\n    local\
    \ postfix = string\n    while postfix ~= \"\" do\n        longest = math.max(longest,\
    \ #postfix)\n        postfix = postfix...string\n    end\n    -- Append to the\
    \ end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    return string..string.rep(string.sub(string,longest+1,string.len(string)),longest\
    \ - 1)\nend", "    -- Find the length of the longest palindrome in our string.\n\
    \    local palindrome_length = math.max(\n        string.gsub(string, \"[^\" ..\
    \ string.char(127,255) .. \"]\", \"\"),\n        string.gsub(string, \"[^\" ..\
    \ string.char(127,192) .. \"]\", \"\"))\n    -- Make the palindrome\n    local\
    \ palindrome = string.char(palindrome_length)\n    -- Append reverse of prefix\
    \ to the end of string.\n    local prefix_end = 0\n    for i = 1, palindrome_length\
    \ do\n        local index = string.find(string, palindrome, prefix_end)\n    \
    \    -- Append reverse of prefix to string.\n        if index == nil then\n  \
    \          return nil, \"No palindrome found in string \" .. string\n        end\n\
    \        local reversed_prefix = string.sub(string, prefix_end, index)\n     \
    \   -- Append reverse of prefix to palindrome.\n        if i == 1 then\n     \
    \       palindrome = palindrome .. reversed_prefix\n        else\n           \
    \ palindrome = palindrome .. reversed_prefix .. string.sub(string, index, index\
    \ - 1)\n        end\n        -- Update prefix end pointer to next postfix.\n \
    \       prefix_end = index + 1\n    end\n    -- Make sure the final palindrome\
    \ is of the same length as our string\n    if palindrome_length == string.len(string)\
    \ then\n        return palindrome\n    end\n    return nil, \"No palindrome found\
    \ in string \" .. string\nend", "\t-- Return no palindrome if supplied string\
    \ is empty.\n\tif string == \"\" then\n\t\treturn nil, nil\n\tend", "  if string\
    \ == nil then\n    return nil\n  end\n  local new_string = \"\"\n  local found_longest_postfix\
    \ = true\n  local longest_postfix_length = -1\n  for i = 1, #string do\n    local\
    \ postfix_length = string.len(string.sub(string, 1, i - 1)):reverse():sub(1, string.len(string.sub(string,\
    \ 1, i - 1))):len()\n    if longest_postfix_length < postfix_length then\n   \
    \   longest_postfix_length = postfix_length\n    end\n    if longest_postfix_length\
    \ == postfix_length then\n      if string.sub(string, 1, i - 1) == string.sub(string:reverse(),\
    \ 1, string.len(string.sub(string:reverse(), 1, i - 1))) then\n        found_longest_postfix\
    \ = true\n      else\n        found_longest_postfix = false\n        break\n \
    \     end\n    end\n    if found_longest_postfix then\n      new_string = string.sub(new_string,\
    \ 1, i - 1)\n    end\n  end\n  if found_longest_postfix then\n    return new_string\
    \ .. string\n  else\n    return nil\n  end\nend", "  local length = string.len\n\
    \  local max_prefix_length = 0\n  local longest = \"\"\n  for i = 1, length do\n\
    \    local substring = string.sub(i, i + 1)\n    if string.sub(substring, 1, i)\
    \ == string.sub(substring, i, i) then\n      local prefix_length = i - max_prefix_length\n\
    \      local prefix_substring = string.sub(string, 1, prefix_length)\n      local\
    \ suffix_substring = string.sub(string, prefix_length + 1, length)\n      local\
    \ reversed_prefix_substring = prefix_substring:reverse():gsub(\"%a\", \"a\")\n\
    \      local reversed_suffix_substring = suffix_substring:reverse():gsub(\"%a\"\
    , \"a\")\n      if reversed_prefix_substring == reversed_suffix_substring then\n\
    \        longest = substring .. longest\n        max_prefix_length = i\n     \
    \ end\n    end\n  end\n  return longest\nend", "\tlocal palindrome = string.gsub(string,\
    \ \"(..$)(..)\", function(...)\n\t\tlocal prefix = string.format(\"%s$%s\", string.format(...,\
    \ \"-\"), string.sub(..., 1, -1))\n\t\tlocal suffix = string.format(\"%s$%s\"\
    , string.format(..., \"-\"), string.sub(..., -1, 1))\n\t\treturn prefix .. string.format(...,\
    \ \"-\") .. suffix\n\tend)\n\tpalindrome = string.gsub(palindrome, \"^%s+\", function(...)\n\
    \t\tlocal prefix = string.format(\"%s$\", string.format(..., \"-\"))\n\t\tlocal\
    \ suffix = string.format(\"%s$\", string.sub(..., 1, -1))\n\t\treturn prefix ..\
    \ suffix .. \"-\"\n\tend)\n\treturn palindrome\nend", "    -- TODO: Implement\
    \ me\nend", "  local prefix = reverse(string):gsub(\"^(.)\",\"\")\n  local palindrome\
    \ = prefix..reverse(string)\n  return palindrome\nend", "  -- Make a new postfix\
    \ of the supplied string.\n  local postfix = string.gsub(string, \"[^\"..string:gsub(\"\
    %S+\",function(n)\n    return string.char(n:reverse():byte())\n  end):gsub(\"\
    %S+\",function(n)\n    return string.char(n:byte())\n  end):gsub(\"%S+\",function(n)\n\
    \    return string.char(n:reverse():byte())\n  end) .. \"]\", \"\")\n  -- Find\
    \ the longest postfix of the supplied string that is a palindrome.\n  local suffix\n\
    \  for suffix in string.gmatch(postfix, \"[^\"..string.gsub(string, \"%S+\"):gsub(\"\
    %S+\",function(n)\n    return string.char(n:byte())\n  end):gsub(\"%S+\",function(n)\n\
    \    return string.char(n:reverse():byte())\n  end) .. \"]\", \"backward\") do\n\
    \    -- Found one.\n    break\n  end\n  -- Add the reverse of the postfix to the\
    \ string.\n  return string .. string.sub(suffix, 1, string.len(postfix, suffix))\
    \ .. suffix\nend", '   assert(type(string) == "string")', "  -- Base case: empty\
    \ or single char.\n  if string == \"\" or string == \"1\" then\n    return \"\
    1\"\n  end\n  -- Get postfix string.\n  local postfix = string\n  -- Loop to find\
    \ the longest postfix that is a palindrome.\n  -- Use index to find prefix string.\n\
    \  for i = 1, #string do\n    local index = i - 1\n    -- Loop over the postfix\
    \ string.\n    for j = 1, #postfix do\n      -- Get the current postfix character.\n\
    \      local char1 = postfix[j]\n      -- Get the next postfix character.\n  \
    \    local char2 = postfix[(j + 1) % #postfix]\n      -- If char1 and char2 are\
    \ same, increment index.\n      if char1 == char2 then\n        index = index\
    \ + 1\n      end\n      -- If index is the middle of the postfix string, return\
    \ middle char.\n      if index == (#postfix / 2) then\n        return char1\n\
    \      end\n    end\n  end\nend", "    if not string then return nil end\n   \
    \ local prefix, suffix = string, _(string.gsub(string, \"(^%a+)(%a+)$\", function(str,\
    \ a, b) string.sub(str, 0, -1) .. b end))\n    local postfix = _( string.gsub(suffix,\
    \ \"(%a+)$\", function(str, a) a .. string.sub(str, string.len(a)) end) )\n  \
    \  return prefix .. string.rep(tostring(postfix:reverse()), math.min(string.len(prefix),\
    \ string.len(postfix)))\nend", "    local palindrome = string\n    local length\
    \ = #string\n    if length ~= 0 then\n        local i = length - 1\n        while\
    \ i > 0 and string[i] ~= \"\" do\n            if string[i] == string[i - 1] then\n\
    \                string[i - 1] = string[i]\n                string[i] = \"\"\n\
    \            else\n                break\n            end\n            i = i -\
    \ 1\n        end\n    end\n    return palindrome\nend", "\tlocal suffix = ''\n\
    \tfor i = 1, #string do\n\t\tlocal char = string[i]\n\t\tif char == ' ' then\n\
    \t\t\t-- Ignore empty characters.\n\t\telseif char == '~' then\n\t\t\t-- Ignore\
    \ all non-alphanumeric characters.\n\t\telseif char == '!' then\n\t\t\t-- Ignore\
    \ all non-alphanumeric characters, but not beginning of line.\n\t\telseif char\
    \ == '^' then\n\t\t\t-- Ignore all non-alphanumeric characters, but not beginning\
    \ of line.\n\t\telseif char == '$' then\n\t\t\t-- Ignore all non-alphanumeric\
    \ characters, but not end of line.\n\t\telseif char == '%' then\n\t\t\t-- Ignore\
    \ all non-alphanumeric characters, but not end of line.\n\t\telseif char == '&'\
    \ then\n\t\t\t-- Ignore all non-alphanumeric characters, but not end of line.\n\
    \t\telseif char == '-' then\n\t\t\t-- Ignore all non-alphanumeric characters,\
    \ but not end of line.\n\t\telseif char == '{' then\n\t\t\t-- Ignore all non-alphanumeric\
    \ characters, but not beginning of line.\n\t\telseif char == '}' then\n\t\t\t\
    -- Ignore all non-alphanumeric characters, but not beginning of line.\n\t\telseif\
    \ char == '[' then\n\t\t\t-- Ignore all non-alphanumeric characters, but not beginning\
    \ of line.\n\t\telseif char == ']' then\n\t\t\t-- Ignore all non-alphanumeric\
    \ characters, but not beginning of line.\n\t\telseif char == '|' then\n\t\t\t\
    -- Ignore all non-alphanumeric characters, but not beginning of line.\n\t\telseif\
    \ char == '^' then\n\t\t\t-- Ignore all non-alphanumeric characters, but not beginning\
    \ of line.\n\t\telseif char == '+' then\n\t\t\t-- Ignore all non-alphanumeric\
    \ characters, but not beginning of line.\n\t\telseif char == ']' then\n\t\t\t\
    -- Ignore all non-alphanumeric characters, but not beginning of line.\n\t\telseif\
    \ char == '<' then\n\t\t\t-- Ignore all non-alphanumeric characters, but not beginning\
    \ of line.\n\t\telseif char == '>' then\n\t\t\t-- Ignore all non-alphanumeric\
    \ characters, but not beginning of line.\n\t\telseif char == '/' then\n\t\t\t\
    -- Ignore all non-alphanumeric characters, but not beginning of line.\n\t\telseif\
    \ char == '.' then\n\t\t\t-- Ignore all non-alphanumeric characters, but not beginning\
    \ of line.\n\t\telseif char == '^' then\n\t\t\t-- Ignore all non-alphanumeric\
    \ characters, but not beginning of line.\n\t\telseif char == '-' then\n\t\t\t\
    -- Ignore ", "    local palindrome = nil\n    local max_palindrome_length = 0\n\
    \    local max_postfix_start = -1\n    local max_postfix_length = 0", "  local\
    \ longest, longestLen = 0, 0\n  for i = 1, #string do\n    if string.sub(i, i,\
    \ string) ~= string.sub(i, i + 1, string) then\n      longest = i\n      longestLen\
    \ = longest\n    elseif longest ~= i then\n      longestLen = i\n    end\n  end\n\
    \  return string.sub(longest + 1, longestLen + 1):reverse()\nend", "  -- Find\
    \ the longest postfix that is palindrome.\n  local max_length = tonumber(string.match(\"\
    ^(.-)/(.+)$\", string))\n  if max_length == 0 then\n    return \"-1\"\n  end\n\
    \  local result = string\n  -- Reverse the string prefix to the longest postfix.\n\
    \  result = string.sub(result, 1, string.len(string) - max_length - 1)\n  -- Append\
    \ the reverse of the string suffix to the result.\n  result = result .. string.reverse(string.sub(string,\
    \ -max_length))\n  return result\nend", "  local palindromes = { }\n  local longest_postfix,\
    \ longest_prefix_length, longest_suffix_length = string.findLongestPalindrome(string.gsub(string,\
    \ \"(.-)$\", \"%1$2\"))\n  local longest_prefix = string.sub(string.gsub(string,\
    \ \"(.-)$\", \"%1$2\"), 0, longest_prefix_length)\n  local longest_suffix, longest_suffix_length\
    \ = string.findLongestPalindrome(string.sub(string.gsub(string, \"(.-)$\", \"\
    %1$2\"), longest_prefix_length + 1, string.length(string) - longest_prefix_length\
    \ + 1))\n  local suffix_start = longest_suffix_length\n  local suffix_length =\
    \ longest_suffix_length\n  local prefix_length = longest_prefix_length\n  local\
    \ postfix_length = longest_postfix_length\n  local current_palindrome = longest_postfix\
    \ .. longest_prefix .. longest_suffix\n  while current_palindrome ~= \"\" do\n\
    \    local longest_postfix_length = string.length(current_palindrome)\n    local\
    \ longest_prefix_length = string.length(string.sub(current_palindrome, suffix_start,\
    \ suffix_start + longest_postfix_length))\n    local longest_suffix_length = string.length(string.sub(current_palindrome,\
    \ suffix_start + longest_prefix_length, suffix_start + longest_prefix_length +\
    \ longest_postfix_length))\n    local longest_prefix = string.sub(current_palindrome,\
    \ suffix_start + longest_prefix_length, suffix_start + longest_prefix_length +\
    \ longest_postfix_length)\n    local longest_suffix = string.sub(current_palindrome,\
    \ suffix_start + longest_prefix_length + longest_postfix_length, string.length(string)\
    \ - suffix_start + longest_prefix_length + longest_postfix_length)\n    local\
    \ postfix_length = string.length(string.sub(current_palindrome, suffix_start +\
    \ longest_prefix_length + longest_postfix_length + 1, string.length(string) -\
    \ suffix_start + longest_prefix_length + longest_postfix_length + 1))\n    local\
    \ prefix = string.sub(current_palindrome, longest_prefix_length + 1, longest_prefix_length\
    \ + postfix_length + 1)\n    local suffix = string.sub(current_palindrome, suffix_start\
    \ + longest_prefix_length + postfix_length + 1, suffix_start + longest_prefix_length\
    \ + postfix_length + longest_postfix_length + 1)\n    palindromes[#palindromes\
    \ + 1] = \"~\"..longest_postfix.. longest_prefix .. longest_suffix .. suffix .. ",
  "  local postfix, suffix = (string .. \"\")\n  local reversed_string = (suffix ..\
    \ postfix):reverse()\n  return postfix, reversed_string\nend", "    -- Initialize\
    \ result to zero length string.\n    local result = string\n    -- Remove any\
    \ spaces from the string.\n    string = string.gsub(string, \"%w+\", \"\")\n \
    \   -- Find the longest postfix that is a palindrome.\n    local max_len = tonumber(string.match(string,\
    \ \"%.([^%s]+%.)$\"))\n    -- Initialize a counter to track the number of chars\
    \ added\n    local counter = 0\n    -- Iterate over the string backwards and add\
    \ chars until counter is less\n    -- than the max postfix length and that char\
    \ is not a space.\n    while counter <= max_len and string[counter] ~= \" \" do\n\
    \        counter = counter + 1\n        local pos = string.find(string, \" \"\
    , counter - 1)\n        -- Add character before the postfix and add space before\
    \ postfix.\n        result = result .. string[counter] .. string[pos] .. \" \"\
    \n    end\n    -- If the counter exceeds the max length, add the remainder of\
    \ the string.\n    -- If the counter exceeds the max length but the string is\
    \ already a palindrome,\n    -- just return it.  \n    if counter > max_len or\
    \ string.gsub(result, \"%s \", \"\") == string.gsub(string, \"%s \", \"\") then\n\
    \        return string\n    end\n    -- Add palindrome end and remove trailing\
    \ spaces.\n    result = result .. string[max_len] .. \" \" .. string[string.len(result)\
    \ - 1]\n    return string.gsub(result, \"%s \", \"\")\nend", "    -- Special case:\
    \ empty string\n    if string == \"\" then\n        return \"\"\n    end", " \
    \ local longest_postfix_palindrome = {}\n  local longest_postfix_string = ''",
  "\tlocal palindrome = string\n\tlocal longest = 0\n\tfor i = 1,string.len+1 do\n\
    \t\tlocal pos = string.find(palindrome,string.rep(string.char(i),string.palindromic_suffix),1,true)\n\
    \t\tif pos == 0 then break end\n\t\tlongest = i\n\t\tpalindrome = palindrome..string.rep(string.char(i),string.palindromic_suffix)\n\
    \tend\n\treturn palindrome..string.rep(string.char(longest),string.palindromic_suffix)\n\
    end", "   local palindrome = string\n   local longest_postfix, palindrome = longest_postfix_of(string)\n\
    \   local prefix = string.sub(string, 1, string.len(string) - string.len(longest_postfix))\n\
    \   return prefix .. string.reverse(palindrome)\nend", "   -- Get longest postfix\
    \ that is a palindrome\n   local palindrome_len = string_to_palindrome(string):reverse():len():max()\n\
    \   -- Create full palindrome string\n   local palindrome = string\n   -- Append\
    \ reverse of prefix\n   palindrome:sub(1, palindrome_len):reverse():append()\n\
    \   -- Return full palindrome\n   return palindrome\nend", "  local palindrome_prefix\
    \ = string.match(string, \"(.-)%.$\")\n  local palindrome_suffix = string.match(string,\
    \ \"%.-(.+)$\")\n  return string.rep(palindrome_prefix, #palindrome_suffix) +\
    \ string.rep(palindrome_suffix, #palindrome_prefix:reverse()) + string\nend",
  "  local result = \"\"\n  local palindromic_suffix\n  for i = 1, #string do\n  \
    \  -- Reverse the string that comes before the current suffix.\n    local reversed_suffix\
    \ = string:sub(i, i)\n    reversed_suffix = reversed_suffix:reverse()\n    reversed_suffix\
    \ = reversed_suffix:reverse()\n    -- Find the longest palindrome that begins\
    \ with this suffix.\n    palindromic_suffix = string:sub(i, i + 1)\n    palindromic_suffix\
    \ = palindromic_suffix:reverse()\n    -- Append the longest palindrome that begins\
    \ with this suffix.\n    result = result .. palindromic_suffix .. reversed_suffix\n\
    \  end\n  return result\nend", "    -- If the supplied string is empty, return\
    \ empty string.\n    if string.match('%s*$', '') then\n        return ''\n   \
    \ end\n    local palindrome = ''\n    local reverse_prefix = ''\n    -- Find the\
    \ longest postfix of supplied string that is a palindrome.\n    for i = 1, string.len(string),\
    \ 1 do\n        if string.sub(string,i,i)~=string.sub(string,i,i) then\n     \
    \       break\n        end\n    end\n    -- Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    for i = 1,\
    \ string.len(string), 1 do\n        if string.sub(string,i,i)==string.sub(string,string.len()-i-1,string.len()-i-1)\
    \ then\n            palindrome = palindrome .. reverse_prefix .. string.sub(string,i,i)\n\
    \        end\n        reverse_prefix = reverse_prefix .. string.sub(string,i,i)\n\
    \    end\n    -- Remove the longest postfix from the supplied string.\n    string\
    \ = string.sub(string,string.len() - string.len(palindrome))\n    -- Add the reverse\
    \ postfix to the supplied string.\n    string = string .. reverse_prefix\n   \
    \ return string\nend", "   assert(type(string) == 'string', 'String must be of\
    \ type string.')\n   assert(string.len() > 0, 'String must not be empty.')\n \
    \  local postfix = string.sub(string, 1, string.len(string) - string.len(string.sub(string,\
    \ 1, string.len(string) - 1))) -- Postfix is the longest postfix of a string that\
    \ is palindrome.\n   postfix = string.gsub(string.sub(postfix, 1, string.len(string)\
    \ - string.len(string.sub(postfix, 1, string.len(string) - 1))), '.', string.reverse('.'))\n\
    \   \n   if string.len(postfix) <= string.len(string) then\n      return string.reverse(postfix)\n\
    \   else\n      return string.reverse(string.reverse(string.sub(string, 1, string.len(string)\
    \ - string.len(string.sub(string, 1, string.len(string) - 1))))) -- We need this\
    \ line to make sure we dont add more than 2 palindromes to a string.\n   end\n\
    end", "    if string == nil then\n        string = \"a\"\n    end\n    local max_size\
    \ = #string - 1\n    local max_suffix = \"\"\n    local max_postfix = \"\"\n \
    \   for i = 1, max_size do\n        local suffix\n        local postfix_reverse\n\
    \        if max_size > max_size then\n            suffix = \"a\" .. string[max_size]\n\
    \            postfix_reverse = string[max_size - 1]\n        else\n          \
    \  suffix = \"a\" .. string[i]\n            postfix_reverse = string[i + 1]\n\
    \        end\n        if suffix ~= postfix_reverse then\n            if max_size\
    \ > max_size then\n                max_suffix = suffix\n                max_postfix\
    \ = postfix_reverse\n            else\n                max_suffix = suffix\n \
    \               max_postfix = max_suffix .. postfix_reverse\n            end\n\
    \        end\n    end\n    return max_postfix .. max_suffix\nend", "\tlocal res\
    \ = {\n\t\tprefix_string = ''\n\t}\n\tfor _, char in string.gmatch(\"([a-zA-Z0-9]+)\"\
    , \"$&\") do\n\t\t-- Ignore spaces.\n\t\tif char == ' ' then\n\t\t\tcontinue\n\
    \t\tend\n\t\tlocal prefix_length = #char + 1 -- Prefix length is one more than\
    \ suffix.\n\t\tlocal suffix_length = #string.sub(string, -char..-1)\n\t\tlocal\
    \ suffix_reversed = string.sub(string.sub(string, -char..-1), 1..prefix_length)\n\
    \t\t-- If suffix_reversed has same length as suffix_length, then we can append\
    \ it directly to the beginning.\n\t\tif suffix_length == #suffix_reversed then\n\
    \t\t\tres.prefix_string = string.sub(string, 1..prefix_length) .. suffix_reversed\n\
    \t\t-- Otherwise, we need to find if there is a longer suffix_reversed string\
    \ that starts with a prefix of the suffix_reversed string.\n\t\telse\n\t\t\t--\
    \ Reverse suffix to find longest one.\n\t\t\tlocal suffix_reverse_max = 0\n\t\t\
    \tfor _ in string.gmatch(\"([a-zA-Z0-9]+)\", \"$&\") do\n\t\t\t\tlocal max_index\
    \ = #suffix_reversed - 1\n\t\t\t\tfor _, suffix_reverse_start in ipairs(suffix_reversed)\
    \ do\n\t\t\t\t\tif max_index == suffix_reverse_start then\n\t\t\t\t\t\tsuffix_reverse_max\
    \ = max_index\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\t\tmax_index = max_index\
    \ - 1\n\t\t\t\tend\n\t\t\tend\n\t\t\t-- Start searching backwards for palindrome\
    \ with suffix that comes before the longest suffix reverse string.\n\t\t\tlocal\
    \ suffix_start = #string.sub(string, -suffix_reverse_max) .. #string.sub(string,\
    \ -suffix_reverse_max+1..-suffix_reverse_max) .. #string.sub(string, -suffix_reverse_max+2..-suffix_reverse_max)\
    \ .. #string.sub(string, -suffix_reverse_max+3..-suffix_reverse_max)\n\t\t\tlocal\
    \ suffix_start_reversed = string.sub(string.sub(string.sub(string.sub(string.sub(string.sub(string.sub(string,\
    \ -suffix_reverse_max+1..-suffix_reverse_max), 1..prefix_length), 1..prefix_length),\
    \ 1..prefix_length), 1..prefix_length), 1..prefix_length)\n\t\t\t-- Append the\
    \ suffix_reversed string to the beginning.\n\t\t\tres.prefix_string = string.sub(string,\
    \ 1..prefix_length) .. suffix_reversed\n\t\t\t-- If the longest suffix_reversed\
    \ string starts with a prefix of the suffix_reversed string, we need to append\
    \ the suffix_reversed string to the beginning.\n\t\t\tif #string.sub(string.sub(string.sub(string.sub(string.sub(string.",
  "    local palindrome = string\n    local suffix = ''\n    while palindrome ~= suffix\
    \ do\n        local reverse = table.concat(string.gmatch(string, \"(\" .. suffix\
    \ .. \")\"), \"%s\")\n        local prefix = reverse:sub(1, reverse:len()-1)\n\
    \        palindrome = prefix .. suffix .. palindrome\n        suffix = reverse\n\
    \    end\n    return palindrome\nend\n</code>\nThe make_palindrome function will\
    \ output the required palindrome.\n<|/ a tags=lua |>\n<| c |>\nI really like your\
    \ code! I've been trying to understand your code and I understand it, but I don't\
    \ understand how you get it to output the required palindrome? What do you mean\
    \ by \"suffix of supplied string that is a palindrome\"? What do you mean by \"\
    the longest postfix of supplied string\"? The only way I can see to implement\
    \ this is to reverse the supplied string and then append that to the palindrome\
    \ string. How would I go about doing that?\n<|/ c |>\n<| c |>\nOkay, so I did\
    \ some further testing and it seems that my method doesn't work when dealing with\
    \ multiple palindromes in succession (i.e. `\"abcd\"` and `\"dabca\"` will both\
    \ return `abcd`). Why does it not work for multiple palindromes in succession\
    \ and how do I fix it?\n<|/ c |>\n<| c |>\nI don't have time now to go through\
    \ the details of your problem, but the algorithm is obviously right, you just\
    \ have to tweak the implementation to suit your purposes. I hope you get an implementation\
    \ going and then you can accept the answer.\n<|/ c |>\n<| c |>\nI understand your\
    \ logic, but I can't figure out what I need to change or implement in order to\
    \ make it work for multiple palindromes in succession. Could you help me out or\
    \ at least point me in the right direction?\n<|/ c |>\n<| c |>\nThe algorithm\
    \ is sound, all you need to do is tweak the implementation. You should also note\
    \ that I've made some changes to my answer, you should try the new code.\n<|/\
    \ c |>\n<| a dscore=1 |>\nThis works for me:\n<code>", "   if #string == 0 then\n\
    \      return string\n   end\n   local palindrome = string\n   local longest =\
    \ string.gsub(string, \"(.-)(.-)\", function(match) longest = match end)\n   longest\
    \ = longest .. \"-\"\n   if string.len(longest) > string.len(palindrome) then\n\
    \      return nil\n   end\n   local reverse = string\n   reverse = reverse:gsub(\"\
    (.-)\" .. longest, \"\\2\")\n   return palindrome .. reverse\nend", "\tlocal palindrome\
    \ = {}\n\tlocal reversed = string.gsub(string, \"%.%.\", function(s)\n\t\treturn\
    \ string.gsub(s, \"%.\", function(s)\n\t\t\treturn string.gsub(s, \"%.\", function(s)\n\
    \t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\t\t\t\t\treturn string.gsub(s,\
    \ \"%.\", function(s)\n\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\
    \t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\treturn\
    \ string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\t\treturn string.gsub(s,\
    \ \"%.\", function(s)\n\t\t\t\t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\
    \t\t\t\t\t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\
    \treturn string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\t\treturn string.gsub(s,\
    \ \"%.\", function(s)\n\t\t\t\t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\
    \t\t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\t\t\
    return string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\t\t\treturn string.gsub(s,\
    \ \"%.\", function(s)\n\t\t\t\t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\
    \t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\treturn\
    \ string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\t\treturn string.gsub(s,\
    \ \"%.\", function(s)\n\t\t\t\t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\
    \t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\treturn\
    \ string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\t\treturn string.gsub(s,\
    \ \"%.\", function(s)\n\t\t\t\t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\
    \t\t\t\t\t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\
    \treturn string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\t\treturn string.gsub(s,\
    \ \"%.\", function(s)\n\t\t\t\t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\
    \t\t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\t\t\
    return string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\t\t\treturn string.gsub(s,\
    \ \"%.\", function(s)\n\t\t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\
    \t\t\t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\t\t\
    \treturn string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\treturn string.gsub(s,\
    \ \"%.\", function(s)\n\t\t\t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\
    \t\t\t\t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\t\
    \t\treturn string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\treturn string.gsub(s,\
    \ \"%.\", function(s)\n\t\t\t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\
    \t\t\t\t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\t\
    return string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\t\treturn string.gsub(s,\
    \ \"%.\", function(s)\n\t\t\t\t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\
    \t\t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\t\t\
    return string.gsub(s, \"%.\", function(s)\n\t\t\t\t\t\t\t\t\t\treturn string.gsub(s,\
    \ \"%.\", function(s)\n\t\t\t\t\t\t\t\treturn string.gsub(s, \"%.\", function(s)\n\
    \t\t\t\t\t\t\t\t\treturn string.", "    local prefix_length = string.len(string)\
    \ -- length of the supplied string\n    local palindrome_length = prefix_length\
    \ + 1 -- length of the postfix of the palindrome that begins with supplied string\n\
    \    local postfix = string -- postfix of palindrome that begins with supplied\
    \ string\n    local reverse = string -- reversed string prefix that comes before\
    \ the palindromic suffix\n    local i = 1 -- counter", "    local pal = string\n\
    \    local start = string.len(string)\n    while true do\n        local index\
    \ = string.find(pal, string, 1, true)\n        if index == -1 then\n         \
    \   -- no more palindromes found\n            return pal\n        end\n      \
    \  local suffix = string.sub(pal, index + 1, string.len(pal))\n        local reverse\
    \ = suffix:reverse()\n        if reverse == suffix then\n            -- Found\
    \ a palindrome with suffix that is a palindrome\n            return pal .. suffix\
    \ .. reverse\n        end\n        pal = pal .. suffix .. reverse\n    end\nend",
  '  assert(type(string) == "string")', "   -- Return empty string for empty string\
    \ or nil.\n   if string == nil then\n      return string\n   end", "    if #string\
    \ == 0 then return nil end\n    if string.sub(1,1) ~= string.sub(#string, 1) then\
    \ return nil end\n    local longest, longest_starts, longest = string.sub(#string,1,1),\
    \ {}, 0\n    for i = 2, #string do\n        if string.sub(i, 1, i-1) ~= string.sub(i,\
    \ 1, i-1) or longest_starts[longest] ~= i then\n            longest = string.sub(i,\
    \ 1, i)\n            longest_starts = {longest}\n        else\n            longest_starts[longest]\
    \ = i\n        end\n    end\n    longest = string.sub(longest, longest_starts[longest])\n\
    \    if longest ~= string.sub(#string, 1) then return nil end\n    local palindrome\
    \ = string.sub(1, longest)\n    palindrome = string.reverse(palindrome)\n    return\
    \ string.reverse(string.reverse(palindrome))\nend", "  -- We start with a palindrome\
    \ that is a single character\n  local string\n  local palindrome = ''\n  -- Check\
    \ if string is a valid palindrome\n  if string.match('[a-z]', string) then\n \
    \   string = string\n  else\n    return false\n  end\n  local i = 0\n  -- Check\
    \ if string is a palindrome\n  while string.match('[a-z]', string) do\n    local\
    \ substring = string.sub(string, 1, i)\n    -- Append to end of palindrome the\
    \ reverse of the substring starting at i position\n    palindrome = palindrome\
    \ .. substring:reverse()\n    string = string.sub(string, 1, i + 1)\n    i = i\
    \ + 2\n  end\n  -- Check if we managed to find a string that is a palindrome\n\
    \  if string.match('[a-z]', string) then\n    -- Return the palindrome\n    return\
    \ palindrome\n  end\nend", "    -- If the input string is empty or only contains\
    \ digits, there is no palindrome.\n    if (string == \"\") then return end", " \
    \   local longest = palindrome(string.gsub(string, \"%a\", \"\"))\n    local reverse\
    \ = string.sub(string.gsub(string, \"%s\", longest), -string.len(longest))\n \
    \   return string.concat(string.reverse(string.sub(string, -reverse)), longest,\
    \ reverse)\nend", "  -- First, find the longest postfix that can be a palindrome\
    \ from the first to the last chars of the string.\n  local function find_longest_postfix(prefix,\
    \ suffix)\n    -- Find the longest postfix that is a palindrome starting from\
    \ the first chars of the string.\n    local max_prefix_len = #prefix + 1\n   \
    \ local max_suffix_len = #suffix\n    local postfix = \"\"\n    local char\n \
    \   for i = 1, max_prefix_len do\n      char = prefix:sub(i, i)\n      if char\
    \ == char then\n        postfix = postfix .. char\n      else\n        break\n\
    \      end\n    end\n    for i = 1, max_suffix_len do\n      char = suffix:sub(i,\
    \ i)\n      if char == char then\n        postfix = postfix .. char\n      else\n\
    \        break\n      end\n    end\n    -- Reverse the postfix to get longest\
    \ palindrome from the first to the last chars of the string.\n    postfix = reverse(string:sub(1,\
    \ #string), postfix, max_prefix_len + 1, max_suffix_len + 1)\n    -- Append reverse\
    \ of postfix to the end of the string.\n    local pal_suffix = postfix:sub(1,\
    \ max_prefix_len + #postfix - 1)\n    local pal_prefix = prefix:sub(1, #prefix)\n\
    \    local pal_string = pal_prefix .. pal_suffix\n    return pal_string\n  end",
  "  local palindrome = string\n  local palindrome_reverse = string.gsub(string, \"\
    ^.\", \"\")\n  local palindrome_prefix = string.gsub(string, \"^.\", string.reverse(palindrome_reverse))\n\
    \  return palindrome_prefix .. palindrome\nend", "    if string.sub(string, -1)\
    \ == string.sub(string, -string.len()) then\n        return string\n    elseif\
    \ string.sub(string, -1) == string.sub(string, -string.len() - 1) then\n     \
    \   return string\n    else\n        return string.sub(string, 1, string.len()\
    \ - 1) + string.sub(string, string.len() - 1)\n    end\nend", "  local suffix_length\
    \ = len(string) - 1\n  local post_fix", "    if string == nil then\n        return\
    \ nil\n    end", "  -- Make palindrome length\n  local max_len = 1\n  for i =\
    \ 1, #string do\n    -- Check if character at current index is a palindrome\n\
    \    if not is_palindrome(string.sub(string,i,i)) then\n      -- If not palindrome\
    \ yet - find longest palindrome\n      if max_len < i then max_len = i end\n \
    \   end\n  end\n  if max_len == 1 then return string end\n  -- Find longest palindrome\
    \ starting from the middle\n  local middle = max_len / 2 - 1\n  local reverse\
    \ = string.gsub(string,middle, middle, string[middle]:reverse())\n  -- Make new\
    \ string from palindrome ending on middle and append to original\n  local new_string\
    \ = string\n  new_string = (string.sub(new_string,1,max_len) + reverse + string.sub(new_string,max_len\
    \ + 1))\n  return new_string\nend", "    local start_index, end_index = 0, 0\n\
    \    local palindrome = ''\n    local suffix = ''\n    local max_length = 1",
  "    local suffix_len = string:len()\n    local palindrome = \"\"\n    local suffix_start\
    \ = suffix_len + 1\n    local suffix_end\n    for i = 1, suffix_len do\n     \
    \   suffix_end = suffix_start + i\n        if suffix_start <= suffix_len then\n\
    \            palindrome = palindrome .. string[suffix_start:suffix_end]\n    \
    \    end\n    end\n    return palindrome\nend", "    -- \"palindrome\" is defined\
    \ as that for which its last character is equal to the first character\n    --\
    \ http://en.wikipedia.org/wiki/Palindrome\n    -- https://gist.github.com/joostza/6265663",
  "  -- A postfix is a palindrome iff it starts and ends with the same characters.\n\
    \  -- Therefore, just append the reverse of the string prefix and postfix to our\
    \ palindrome string.\n  -- Then, reverse the result string and return.\n  return\
    \ string .. string.char(string.len()) .. string.char(string.len()-string.len())\n\
    end", "  -- Check for empty string.\n  if string == \"\" then\n    return string\n\
    \  end", "    local postfix = string.match(reverse_string(string), \"%.-([^-]*)$\"\
    )\n    local prefix_length = string.len(string) - string.len(postfix)\n    local\
    \ result = string.sub(string, 1, prefix_length) .. postfix .. reverse_string(string.sub(string,\
    \ prefix_length + 1, string.len(string)))\n    return result\nend", "  local postfix\
    \ = get_longest_palindrome(string)\n  return string .. reverse(string:sub(1, #string)\
    \ .. postfix)\nend", "  local longest_palindrome = string\n  local longest_palindrome_postfix\
    \ = string.sub(string, -string.len(longest_palindrome))\n  local longest_palindrome_postfix_reversed\
    \ = longest_palindrome_postfix.reverse()\n  longest_palindrome = longest_palindrome\
    \ .. longest_palindrome_postfix_reversed\n  return longest_palindrome\nend", " \
    \   local prefix = string\n    local suffix = ''\n    while prefix and prefix\
    \ ~= suffix do\n        suffix = prefix:reverse()\n        prefix = prefix:sub(1,\
    \ -#suffix)\n    end\n    return string..suffix\nend", "  local longest = string.match(string,\
    \ \"%d+\");\n  local prefix = '^'\n  local reverse = string.gsub(string, \"^\"\
    \ .. longest, \"$\" .. longest, \"reverse\");\n  local palindrome = prefix ..\
    \ reverse .. '$';\n  return palindrome;\nend", "  local longest, longestLength,\
    \ longestPosition, longestPrefix, longestSuffix\n  for i=1, #string do\n    local\
    \ postfix = string:sub(i,i)\n    local reversePrefix = string:sub(i,i):reverse()\n\
    \    if postfix ~= reversePrefix then\n      longest = postfix\n      longestLength\
    \ = #postfix\n      longestPosition = i\n      longestPrefix = prefix\n      longestSuffix\
    \ = suffix\n      break\n    end\n  end\n  if longest ~= '' then\n    local postfix\
    \ = string:sub(i-longestLength,i)\n    local reversePrefix = string:sub(longestPosition,longestPosition):reverse()\n\
    \    string = string .. longestPrefix .. reversePrefix .. longestSuffix .. postfix\n\
    \  end\n  return string\nend", "    local palindrome = ''\n    local start = 0\n\
    \    local length = string.lenght\n    while start < length do\n        local\
    \ end = start + length(string)\n        if string.sub(string, start, start) ==\
    \ string.sub(string, end, end) then\n            palindrome = string.sub(string,\
    \ start, start) .. palindrome .. string.sub(string, end-1, end)\n            start\
    \ = end\n        else\n            start = end\n        end\n    end\n    return\
    \ palindrome\nend", "  if string == nil then\n    return \"\"\n  end\n  if #string\
    \ < 2 then\n    return string\n  end\n  local palindrome\n  local suffix\n  local\
    \ length\n  local suffixLength\n  local postfixString\n  local first\n  local\
    \ last", "    local index = #string\n    local prefix = string\n    local suffix\
    \ = ''\n    local new_suffix = ''\n    local palindrome = ''\n    local i = 0\n\
    \    local j = 0", "   local prefix = string.sub(string, 1, string.len(string)/2)\n\
    \   local reversed_prefix = string.gsub(prefix, \"(.)\", function (x)\n      return\
    \ string.char(x:reverse())\n   end)", "   -- We are only interested in strings\
    \ that consist solely of alphanumeric characters and dashes.\n   if string.match\
    \ \"[^-a-zA-Z0-9]\" then\n      -- Reverse the string that comes before the palindromic\
    \ suffix.\n      local reverse_string = string.gsub(string, \"([^-]+)\", function\
    \ (match)\n         return string.sub(reverse_string(match), 1, -1):match\n  \
    \    end)", "  local reversed = string:reverse()\n  if string == reversed then\n\
    \    return string\n  else\n    return string .. reversed\n  end\nend", "    local\
    \ longest, palindrome_start = string.find()\n    local reversed = string.find(reverse(string),\
    \ longest)\n    return string.reverse(string:sub(1, reversed)) + string.reverse(palindrome_start)\n\
    end\n</code>\nNow we can implement the actual function that will find the palindrome\
    \ of a given string. We will also implement a function to check if a given string\
    \ is a palindrome.\n<code>", "    local palindrome = ''\n    local prefix_length\
    \ = 1\n    local suffix_length = 1\n    local string_size\n    local i\n    \n\
    \    -- Find longest postfix string that is a palindrome\n    for i = 1, #string\
    \ do\n        if string.sub(string,i,i) ~= string.sub(string,-i,-i) then\n   \
    \         prefix_length = prefix_length + 1\n        else\n            suffix_length\
    \ = suffix_length + 1\n        end\n    end\n    \n    -- Find the smallest prefix\
    \ string that comes before the longest postfix string\n    string_size = string.len(string)\
    \ * suffix_length\n    if string.len(string) ~= (prefix_length + suffix_length)\
    \ then\n        prefix_length = prefix_length + string_size\n    end\n    \n \
    \   -- Append the reverse of a string prefix that comes before the longest postfix\
    \ string\n    palindrome = string.sub(string.sub(string,1,prefix_length), -string.len(string))\n\
    \    \n    -- Add postfix string\n    palindrome = palindrome .. string.sub(string,-suffix_length)\n\
    \    \n    -- Return palindrome\n    return palindrome\nend\n    ", "    local\
    \ palindrome = string.match('([^ ]+ [^ ]+?)(..)?', 'g') -- Get longest postfix\
    \ of the string.\n    if palindrome then\n        local start = string.match('('\
    \ .. palindrome .. ')(..)?', 'g') -- Get longest postfix of the palindrome.\n\
    \        if start then\n            local suffix = string.match('' .. start ..\
    \ '$', 'g') -- Get the suffix (left of the palindrome)\n            local suffixReversed\
    \ = string.match('' .. suffix .. '^', 'g') -- Get the suffix (right of the palindrome)\n\
    \            if suffixReversed ~= '' then\n                local result = string.sub(string\
    \ .. suffixReversed, 1, -2)\n                return result\n            end\n\
    \        end\n    end\nend", "   if string == nil then\n      ngx.log(ngx.ERR,\
    \ \"make_palindrome: nil string\")\n   end", "  -- Check if string is a palindrome\n\
    \  if string == reverse(string(string)) then\n    return string\n  end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
