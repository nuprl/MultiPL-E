name: HumanEval_11_string_xor
language: lua
prompt: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
  \ binary XOR on these inputs and return result also as a string.\nlocal function\
  \ string_xor(a, b)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
  \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
  \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local output = \"\";\n    for i = 1, string.len(a) do\n       \
    \ output = (output .. tostring(a[i .. 1]) .. tostring(b[i .. 1]))\n    end\n \
    \   return output\nend", "  if type(a) ~= 'string' then\n    error('first argument\
    \ not a string')\n  end\n  if type(b) ~= 'string' then\n    error('second argument\
    \ not a string')\n  end\n  local xor = ''\n  for i = 1, #a do\n    if a[i] ~=\
    \ b[i] then\n      xor = xor .. '1'\n    else\n      xor = xor .. '0'\n    end\n\
    \  end\n  return xor\nend", "    return a:gsub(\"[^01]\"):gsub(\"%1+\", function\
    \ (x)\n                return x:byte() ^ b[x:byte()]\n            end)\nend",
  "  local n = #a + 1\n  local result = \"\"\n  for i = 1, n do\n    local carry =\
    \ a[i]\n    a[i] = b[i]\n    b[i] = carry\n    result = string.format(\"%s%s%s\"\
    , result, carry and \"1\" or \"0\", b[i] and \"1\" or \"0\")\n  end\n  assert(n\
    \ == #b, \"Input strings must have same length\")\n  return result\nend", "  local\
    \ ret\n  local l1, l2 = #a, #b\n  if l1 ~= l2 then\n    return nil\n  end\n  --\
    \ l1 must be even, otherwise we would have got an error.\n  if l1 % 2 == 0 then\n\
    \    -- The XOR of the whole strings is also the XOR of the bit strings.\n   \
    \ ret = a:sub(1, l1 + 1):byte(1, l1 % 2):byte(l1 % 2 + 1):concat(b:sub(1, l2 +\
    \ 1):byte(1, l1 % 2):byte(l1 % 2 + 1))\n  else\n    -- XOR is performed on each\
    \ bit individually.\n    ret = a:sub(1, l1 + 1):concat(b:sub(1, l2 + 1))\n  end\n\
    \  return ret\nend", "  local xor_table = {\n    [\"0\"] = \"0\",\n    [\"1\"\
    ] = \"1\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n\
    \    [\"0\"] = \"0\",\n    [\"1\"] = \"0\",\n    [\"1\"] = \"0\",\n    [\"1\"\
    ] = \"0\",\n    [\"1\"] = \"0\",\n    [\"0\"] = \"0\",\n    [\"1\"] = \"1\",\n\
    \    [\"1\"] = \"0\",\n    [\"1\"] = \"0\",\n    [\"1\"] = \"0\",\n    [\"1\"\
    ] = \"1\",\n    [\"0\"] = \"0\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n\
    \    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n    [\"0\"] = \"0\",\n    [\"1\"\
    ] = \"1\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n\
    \    [\"0\"] = \"0\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n    [\"1\"\
    ] = \"1\",\n    [\"1\"] = \"1\",\n    [\"0\"] = \"0\",\n    [\"1\"] = \"1\",\n\
    \    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n    [\"0\"\
    ] = \"0\",\n    [\"1\"] = \"0\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"0\",\n\
    \    [\"1\"] = \"0\",\n    [\"1\"] = \"0\",\n    [\"1\"] = \"1\",\n    [\"0\"\
    ] = \"0\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n\
    \    [\"1\"] = \"1\",\n    [\"0\"] = \"0\",\n    [\"1\"] = \"1\",\n    [\"1\"\
    ] = \"1\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n    [\"0\"] = \"0\",\n\
    \    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n    [\"1\"\
    ] = \"1\",\n    [\"0\"] = \"0\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n\
    \    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n    [\"0\"] = \"0\",\n    [\"1\"\
    ] = \"1\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n\
    \    [\"0\"] = \"0\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n    [\"1\"\
    ] = \"1\",\n    [\"1\"] = \"1\",\n    [\"0\"] = \"0\",\n    [\"1\"] = \"1\",\n\
    \    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n    [\"0\"\
    ] = \"0\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n\
    \    [\"1\"] = \"1\",\n    [\"0\"] = \"0\",\n    [\"1\"] = \"1\",\n    [\"1\"\
    ] = \"1\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n    [\"0\"] = \"0\",\n\
    \    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n    [\"1\"\
    ] = \"1\",\n    [\"0\"] = \"0\",\n    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n\
    \    [\"1\"] = \"1\",\n    [\"1\"] = \"1\",\n    [\"0\"] = \"0\",\n    [\"1\"\
    ] = \"1\",\n    [\"1\"] = \"1\",\n", "    assert(type(a) == 'string' and type(b)\
    \ == 'string')\n    assert(a ~= '' and b ~= '' and a ~= b, 'a and b must be equal\
    \ length')", "\tlocal result = \"\"\n\tfor i = 1, #a do\n\t\tresult = result ..\
    \ string.char(a.byte[i] ^ b.byte[i])\n\tend\n\treturn result\nend", "   assert(a,\
    \ \"Argument 'a' is nil\")\n   assert(b, \"Argument 'b' is nil\")\n   return string.format(\"\
    %s%s%s\", a:byte(), b:byte(), a:byte() ^ b:byte())\nend", "  assert(type(a) ==\
    \ 'string' and type(b) == 'string')\n  local r = {}\n  for i = 1, #a do\n    table.insert(r,\
    \ math.floor((math.floor(#a) - i) * math.floor((math.floor(#a) - i) / 2)) + math.floor(i))\n\
    \  end\n  for i = 1, #b do\n    table.insert(r, math.floor((math.floor(#b) - i)\
    \ * math.floor((math.floor(#b) - i) / 2)) + math.floor(i))\n  end\n  for i = 1,\
    \ #r do\n    r[i] = math.floor((math.floor(#a) - math.floor((math.floor(#a) -\
    \ i) * math.floor((math.floor(#a) - i) / 2)) + math.floor(i)) ^ (math.floor(#b)\
    \ - math.floor((math.floor(#b) - i) * math.floor((math.floor(#b) - i) / 2)) +\
    \ math.floor(i))\n  end\n  return table.concat(r)\nend", "  local result = ''\n\
    \  local x = 0\n  for i = 1, #a do\n    x = x + tonumber(a[i]) ^ tonumber(b[i])\n\
    \  end\n  result = string.format('%x%x', x % 256, x >> 8)\n  return result\nend",
  "\t-- If either input is empty then result is empty\n\tif a == \"\" or b == \"\"\
    \ then\n\t\treturn \"\"\n\tend", "    local output = {}\n    for i, c in ipairs(a)\
    \ do\n        output[i] = math.abs(c - b[i])\n    end\n    return table.concat(output,\
    \ \"|\")\nend", "  local binA = tostring(a:byte())\n  local binB = tostring(b:byte())\n\
    \  return tostring(binA:gsub(\"1\", \"0\")..binB:gsub(\"1\", \"0\"))\nend", " \
    \ local binary = string.format(\"%b\", a)\n  binary = string.gsub(binary, \"1\"\
    , \"0\")\n  binary = string.gsub(binary, \"0\", \"1\")\n  binary = string.gsub(binary,\
    \ \" \", \"\")\n  binary = string.gsub(string.rep(\"0\", 8), \" \", \"1\")\n \
    \ binary = string.gsub(string.rep(\"1\", 8), \" \", \"0\")\n  return string.format(\"\
    %b\", binary, b)\nend", "   local bin_a  = string.format(\"%08b%s\", tonumber(a),\
    \ \"\")\n   local bin_b  = string.format(\"%08b%s\", tonumber(b), \"\")\n   local\
    \ result = bin_a xor bin_b\n   return string.format(\"%08b%s\", tonumber(result),\
    \ \"\")\nend", "    local c = ''\n    for i=1, #a do\n        c = (c + a[i]) ^\
    \ b[i]\n    end\n    return c\nend", "    -- This will be done in one call.\n\
    \    -- return string_xor_byte(a.val, b.val)\n    -- This is how this would be\
    \ done in multiple calls.\n    local res = \"\"\n    local carry = false\n   \
    \ for i,v in ipairs(a) do\n        res..= string.format(\"%0\" .. (8 - #b) ..\
    \ \"d\", v.val ^ b.val[#b])\n        if carry then res = \"1\" + res else res\
    \ = res end\n        carry = true\n    end\n    return res\nend", "    return\
    \ a:gsub(\".\", function(x)\n        return (\"000\" + x:byte()).sub(\"0\" ..\
    \ \"11\")\n    end)..b:gsub(\".\", function(x)\n        return (\"000\" + x:byte()).sub(\"\
    0\" .. \"11\")\n    end)\nend", "    local tmp = {}\n    for i = 1, #a do\n  \
    \      tmp[i] = a[i] ^ b[i]\n    end\n    return table.concat(tmp)\nend", "  \
    \  assert(type(a) == 'string' and type(b) == 'string')\n    local size = #a\n\
    \    local binary = {[size] = '\\0'}\n    for j = 1, size do\n        binary[j]\
    \ = a[j] xor b[j]\n    end\n    return table.concat(binary)\nend", "   return\
    \ (\n      a..b\n      .. #a .. #b\n      .. #a:sub(1, 1) .. #b:sub(1, 1)\n  \
    \ )\nend", "    assert(type(a) == \"string\" and type(b) == \"string\")\n    if\
    \ a then\n        local a_len = #a\n        local b_len = #b\n        assert(a_len\
    \ + b_len == #a)\n        local result = \"\"\n        for i = 1, a_len do\n \
    \           local ai = tonumber(a:sub(1, a_len - i))\n            local bi = tonumber(b:sub(1,\
    \ b_len - i))\n            if ai and bi then\n                result = result\
    \ .. string.char(tonumber(tostring(ai) ^ tostring(bi)))\n            else\n  \
    \              result = result .. string.char(0)\n            end\n        end\n\
    \        return result\n    else\n        return \"\"\n    end\nend", '    return
    a:gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d",
    "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d",
    "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d",
    "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d",
    "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d",
    "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d",
    "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d",
    "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d",
    "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d",
    "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d",
    "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d",
    "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d",
    "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d",
    "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d", "%d%d"):gsub("%d%d",
    "%d%d"):gsub("%d%d", "', "  local result = \"\"\n  for i = 1, string.len(a) do\n\
    \    local carry = a[i]\n    if a[i + 2] ~= 0 then\n      carry = carry ^ a[i\
    \ + 2]\n    end\n    if a[i + 1] ~= 0 then\n      carry = carry ^ a[i + 1]\n \
    \   end\n    local new_char = string.char(string.byte('0', carry) + string.byte('1',\
    \ a[i + 1]) + string.byte('0', a[i + 2]) + string.byte('1', carry))\n    result\
    \ = result .. new_char\n  end\n  return result\nend\n</cell>\n<cell>", "\tlocal\
    \ function bin2dec(c)\n\t\treturn string.byte(c) - (string.byte(b) and 128 or\
    \ 0)\n\tend", "  -- Compute a binary XOR by treating the input as a number.\n\
    \  local xor_num = tonumber(a) XOR tonumber(b)", "   return string.format(\"%x\"\
    , (a ^ b))\nend", "  assert(type(a) == \"string\" and type(b) == \"string\")\n\
    \  local a_binary = string.rep(\"1\", #a)\n  local b_binary = string.rep(\"1\"\
    , #b)\n  for i = 1, #a do\n    a_binary[i] = a[i] ~= b[i]\n  end\n  return string.reverse(a_binary)\n\
    end", "  local t = {bit.bor(a.[1], b.[1])}\n  table.insert(t, bit.band(a.[2],\
    \ b.[2]))\n  table.insert(t, bit.band(a.[3], b.[3]))\n  table.insert(t, bit.band(a.[4],\
    \ b.[4]))\n  table.insert(t, bit.band(a.[5], b.[5]))\n  table.insert(t, bit.band(a.[6],\
    \ b.[6]))\n  table.insert(t, bit.band(a.[7], b.[7]))\n  return table.concat(t,\
    \ \"\")\nend", "    -- perform binary xor on 2 strings a and b consisting only\
    \ of 1s and 0s\n    -- (string length must be the same or we will have an error)\n\
    \    local xor_string = string.format(\"%x\", string.byte(a) ^ string.byte(b))\n\
    \    return xor_string\nend", "    local xor = ''\n    for i = 1, #a, 1 do\n \
    \       xor = xor .. tostring(a[i]) .. tostring(b[i])\n    end\n    return xor\n\
    end", "  local l = #a\n  local r = #b", "    local b_bytes, a_bytes = binary_encode_string(a),\
    \ binary_encode_string(b)\n    return binary_encode_string(binary_xor(tostring(b_bytes),\
    \ tostring(a_bytes)))\nend", "   local bits = unpack(a:gsub('%b', function(x)\
    \ return #x end):gsub('%d%d', function(x, y) return (x == y) end))\n   return\
    \ table.concat(b:gsub('%b', function(x) return #x end):gsub('%d%d', function(x,\
    \ y) return (x == y) end):gsub('%d', function(t) bits[t] end))\nend", "  local\
    \ bin = {}\n  for i = 1, 8 do\n    bin[i] = a[i] xor b[i]\n  end\n  return table.concat(bin,\
    \ \"\")\nend", "  -- Write your code here\nend", "  local bs = table.remove(b,\
    \ 0)\n  local ans = table.remove(a, 0)\n  for i=1, #b do\n    ans = ans .. string.format(tostring(bs\
    \ ^ ans))\n  end\n  return ans\nend", "  local bs = unpack(b) or 0\n  local as\
    \ = unpack(a) or 0\n  local ret = ''\n  for i = 1, (#as + #bs) - 1 do\n    ret\
    \ = (ret ~= '') and (ret .. tostring(not tostring(as[i])) .. tostring(bs[i]) or\n\
    \                        tostring(as[i]) .. tostring(bs[i]) )\n  end\n  return\
    \ ret\nend", "  local result = \"\"\n  for i = 1, #a do\n    result = result ..\
    \ string.char(tonumber(a[i]) XOR tonumber(b[i]))\n  end\n  return result\nend",
  "    local ret\n    if a and b then\n        ret = ''\n        for i=1, #a do\n\
    \            ret = ret .. string.char(a[i] ^ b[i])\n        end\n    end\n   \
    \ return ret\nend\n</cell>\n<cell>", "   local function binaryXOR(a,b)\n     \
    \ local bstr = unpack(b, \"*byte\")\n      local astr = unpack(a, \"*byte\")\n\
    \      local result = {}\n      for i=1, 8 do\n         local r1 = bstr[i] XOR\
    \ astr[i]\n         local r2 = r1^r1\n         if r2 ~= 0 then\n            result[i]\
    \ = r2\n         else\n            result[i] = 0\n         end\n      end\n  \
    \    table.insert(result,-1)\n      table.insert(result,-1)\n      return table.concat(result,\
    \ \"\")\n   end\n   return binaryXOR(a,b)\nend", "   local result = \"\"\n   for\
    \ i = 1, #a do\n      result = (result .. tostring(a[i]) .. tostring(b[i]))\n\
    \   end\n   return result\nend", "  if a ~= b then return \"0\" end\n  return\
    \ a\nend\n</cell>\n<code language=julia-1.6>\nusing Test\n@testset \"string xor\"\
    \ begin\n  test_equality(string_xor(\"11\", \"01\"), \"01\")\n  test_equality(string_xor(\"\
    01\", \"11\"), \"01\")\n  test_equality(string_xor(\"00\", \"11\"), \"11\")\n\
    \  test_equality(string_xor(\"11\", \"10\"), \"11\")\n  test_equality(string_xor(\"\
    01\", \"10\"), \"01\")\n  test_equality(string_xor(\"10\", \"01\"), \"10\")\n\
    \  test_equality(string_xor(\"01\", \"00\"), \"00\")\n  test_equality(string_xor(\"\
    00\", \"01\"), \"01\")\n  test_equality(string_xor(\"10\", \"00\"), \"10\")\n\
    \  test_equality(string_xor(\"00\", \"10\"), \"00\")\n  test_equality(string_xor(\"\
    11\", \"01\"), \"10\")\n  test_equality(string_xor(\"01\", \"11\"), \"10\")\n\
    \  test_equality(string_xor(\"10\", \"01\"), \"01\")\n  test_equality(string_xor(\"\
    01\", \"10\"), \"01\")\n  test_equality(string_xor(\"00\", \"11\"), \"11\")\n\
    \  test_equality(string_xor(\"11\", \"10\"), \"11\")\n  test_equality(string_xor(\"\
    01\", \"10\"), \"01\")\n  test_equality(string_xor(\"10\", \"01\"), \"10\")\n\
    \  test_equality(string_xor(\"01\", \"00\"), \"10\")\n  test_equality(string_xor(\"\
    00\", \"01\"), \"01\")\n  test_equality(string_xor(\"10\", \"00\"), \"01\")\n\
    end\n</cell>\n<text>\nExercise 3", "   assert(type(a) == 'string' and type(b)\
    \ == 'string')", "  -- If length(a) is not equal to length(b), return empty string.\n\
    \  -- If length(a) = length(b), then XOR bit-by-bit, from LSB to MSB.\n  local\
    \ bit_length = 0\n  for i = 1, #a do\n    bit_length = bit_length + math.abs(a[i]\
    \ - b[i])\n  end\n  if bit_length ~= #a then return '' end\n  local xor = \"\"\
    \n  for i = 1, bit_length do\n    xor = xor .. tostring(math.abs(a[i] ^ b[i]))\n\
    \  end\n  return xor\nend", "  local result = ''\n  for i = 0, #a do\n    local\
    \ bit = string.byte(a)^string.byte(b)\n    bit = string.char(bit)\n    result\
    \ = result .. bit\n    b = string.sub(b, 1, #b - 1)\n    a = string.sub(a, 1,\
    \ #a - 1)\n  end\n  return result\nend", "  if type(a) ~= 'string' or type(b)\
    \ ~= 'string' then return 'nil' end\n  local ret = 'nil'\n  for a in string.gmatch(a,\
    \ '%d*') do\n    for b in string.gmatch(b, '%d*') do\n      ret = ret .. string.sub(a,\
    \ b, 1) ^ string.sub(b, a, 1)\n    end\n  end\n  return ret\nend", "  a = tostring(a)\n\
    \  b = tostring(b)\n  local ret = \"00\"\n  for i = 0, 3 do\n    -- Concatenate\
    \ all 4 bits together as string for one bit.\n    ret = (tostring(ret) .. tostring(a[i]))\n\
    \  end", "   local a_in = bin.unpack(a, 1, true)\n   local b_in = bin.unpack(b,\
    \ 1, true)\n   local out = bin.pack(nil, a_in[1]) -- Reset the output to empty.\n\
    \   for i = 2, #a_in do\n      out = bin.pack(out, a_in[i] ^ b_in[i])\n   end\n\
    \   return out\nend", "\tlocal binA = string.format(\"%b\", a)\n\tlocal binB =\
    \ string.format(\"%b\", b)\n\tlocal result\n\tlocal i = 0\n\twhile i < #binA do\n\
    \t\tlocal x = binA[i]\n\t\tlocal y = binB[i]\n\t\t\n\t\tif x < y then\n\t\t\t\
    result = result .. \"0\"\n\t\telse\n\t\t\tresult = result .. \"1\"\n\t\tend\n\t\
    \t\n\t\ti = i + 1\n\tend\n\t\n\treturn result\nend", "    local result = a\n \
    \   for _, char in b:gmatch(\"%c\") do\n        result = result .. char\n    end\n\
    \    return result\nend", "   -- We will use XOR operation only when the first\
    \ bit of both input strings\n   -- are '1' otherwise output will be zero (i.e\
    \ '0').\n   -- Hence perform XOR operation only if all bits of both input strings\
    \ are\n   -- equal to '1'.\n   if a:byte()&0x80 ~= 0 and\n      b:byte()&0x80\
    \ ~= 0 then\n      return tostring(a:byte()^b:byte())\n   else\n      return \"\
    0\"\n   end\nend", "   local xor_a = a:byte()\n   local xor_b = b:byte()\n   local\
    \ result = ''\n   for i = 1, 8 do\n      result = result .. xor_a xor xor_b\n\
    \      xor_a = xor_a >> 1\n      xor_b = xor_b >> 1\n   end\n   return result\n\
    end", "  return string.format('%x', string.format(\"%x\" .. b) .. string.format(\"\
    %x\" .. a)) -- The final result is a string.\nend", "   local result\n   if #a\
    \ ~= #b then\n      print(\"XOR on strings with different lengths aborted\")\n\
    \      return nil\n   end\n   if #a == 0 then\n      result = \"\"\n   elseif\
    \ #b == 0 then\n      result = a\n   else\n      result = '\"' .. string.gsub(a,\
    \ \"1\", \"X\") .. string.gsub(b, \"1\", \"X\") .. '\"' -- convert strings to\
    \ numbers and perform binary XOR\n   end\n   return result\nend", "    if a ==\
    \ '' then a = '1' end\n    if b == '' then b = '1' end", "    local result = \"\
    \"\n    for i = 1, #a do\n        local xor = string.format(\"%x\", a ^ b)\n \
    \       result = result .. xor .. \" \"\n    end\n    return result\nend\n</cell>\n\
    <cell>\nprint(string_xor(\"0011001\", \"1111111\"))\nprint(string_xor(\"1101101\"\
    , \"11111111\"))\n</cell>\n<text>\nA good practice is to convert string numbers\
    \ to binary numbers before performing any operations.", "  if a~=b and b~=a then\
    \ return nil end\n  local a_len = #a\n  local b_len = #b\n  local c = ''\n  for\
    \ i=0,a_len,1 do\n    local c = c .. string.rep(a[i], math.min(b_len, a_len-i-1))\n\
    \  end\n  return c\nend", "   local bs = byte(a)\n   local rs = byte(b)\n   local\
    \ xs = \"\"\n   for i = 1, #a do\n      xs = xs .. string.format(\"%02x\", bs\
    \ ^ byte(a:sub(i, i)))\n   end\n   return xs\nend", "   -- Return empty string\
    \ if either input string is empty.\n   if (string.len(a) == 0 or string.len(b)\
    \ == 0) then\n      return \"\"\n   end\n   -- Return empty string if both input\
    \ strings have the same length.\n   if (string.len(a) == string.len(b)) then\n\
    \      return \"\"\n   end\n   -- Convert the binary strings to a binary integer\
    \ array and XOR the\n   -- arrays. Return the resulting binary integer array.\n\
    \   return array_to_string(xor(to_binaryarray(a), to_binaryarray(b)))\nend", "\t\
    local result = \"\"\n\tlocal i, j = 1, 1\n\twhile i <= #a and j <= #b do\n\t\t\
    local c = a[i]\n\t\tlocal d = b[j]\n\t\tif c then\n\t\t\tresult = result .. c\n\
    \t\tend\n\t\tif d then\n\t\t\tresult = result .. d\n\t\tend\n\t\ti = i + 2\n\t\
    \tj = j + 2\n\tend\n\treturn result\nend", "    local xor_out = ''\n    local\
    \ xor_in1, xor_in2 = unpack(a), unpack(b)\n    for i=1, #xor_in1 do\n        xor_out\
    \ = xor_out .. tostring(xor_in1[i] ^ xor_in2[i])\n    end\n    return xor_out\n\
    end", "    local result = '{}'\n    for i = 1, #a do\n        local temp = tostring(a[i])\
    \ ^ tostring(b[i])\n        if temp == '0' then\n            result = result ..\
    \ '0'\n        elseif temp == '1' then\n            result = result .. '1'\n \
    \       end\n    end\n    return result .. '0'\nend", "    local result = \"\"\
    \n    for i = 1, #a, 1 do\n        result = result .. string.rep(a[i], #b[i])\n\
    \    end\n    return result\nend", "    -- Return the result as binary number\
    \ with size 32.\n    if a == '00000000' or b == '00000000' then\n        return\
    \ a\n    end", "    local xor = ''\n    for i = 1, #a do\n        xor = xor ..\
    \ tostring(a:byte(i) ^ b:byte(i))\n    end\n    return xor\nend", "    -- XORing\
    \ strings is a special case\n    if #b == 0 and #a == 0 then\n        return ''\n\
    \    end\n    \n    local b_bin = assert(io.write(b))\n    local a_bin = assert(io.write(a))\n\
    \    \n    local xor = ''\n    \n    local i = -1\n    while true do\n       \
    \ i = i + 1\n        local a = string.byte(unpack(a_bin))\n        local b = string.byte(unpack(b_bin))\n\
    \        xor = string.char(a) ^ xor\n        if b == 0 and a ~= 0 then\n     \
    \       return xor\n        end\n        if a == 0 and b != 0 then\n         \
    \   return xor\n        end\n    end\nend", "   local xor = \"\"\n   for i=1,\
    \ #a do\n      local p = a\n      local q = b\n      local p = p:sub(i+1, #p)\n\
    \      local q = q:sub(i+1, #q)\n      if p:len() > 0 and q:len() > 0 then\n \
    \        xor = xor .. p:sub(1, 1):reverse():sub(1, 1) .. q:sub(1, 1):reverse():sub(1,\
    \ 1)\n      end\n   end\n   return xor\nend\n</cell>\n<text>\nThe second function\
    \ takes a string as an argument and outputs the number of times that string appears\
    \ in a given string.", "   local res = \"\"\n   for i = 1, #a do\n      local\
    \ carry = a[i - 1]\n      res   = (carry == \"1\" and b[i - 1] == \"0\") or\n\
    \              (carry == \"0\" and b[i - 1] == \"1\") or\n              (carry\
    \ == \"1\" and b[i - 1] == \"1\")\n      if not res then\n         break -- Only\
    \ happens when one of the strings is empty.\n      end\n   end\n   return res\n\
    end", "  local xor_output = ''\n  for i = 1, #a, 1 do\n    xor_output = xor_output\
    \ .. tostring(a[i]) .. tostring(b[i])\n  end\n  return xor_output\nend", "  return\
    \ a..b\nend", "    local r = \"\"\n    for i,c in ipairs(a) do\n        if tostring(c)\
    \ ~= tostring(b[i]) then\n            r=r..tostring(b[i])..\"1\"\n        else\n\
    \            r=r..tostring(b[i])..\"0\"\n        end\n    end\n    return r\n\
    end", "    local res = \"%x\"\n    for i = 0, #a do res = res .. \"%c%x\" end\n\
    \    for i = 0, #b do res = res .. \"%c%x\" end\n    return res\nend", "   a =\
    \ string.format(\"%0\" .. #a .. \"b\", a)\n   b = string.format(\"%0\" .. #b ..\
    \ \"b\", b)\n   local ans = a:sub(1, #a-1) .. b:sub(1, #b-1)\n   return ans ..\
    \ string.rep(\"0\", #ans-1)\nend\n</cell>\n<cell>", "  local xor_table = {\n \
    \   [0] = \"0000\",\n    [1] = \"0001\",\n    [2] = \"0010\",\n    [3] = \"0011\"\
    ,\n    [4] = \"0100\",\n    [5] = \"0101\",\n    [6] = \"0110\",\n    [7] = \"\
    0111\",\n    [8] = \"1000\",\n    [9] = \"1001\",\n    [10] = \"1010\",\n    [11]\
    \ = \"1011\",\n    [12] = \"1100\",\n    [13] = \"1101\",\n    [14] = \"1110\"\
    ,\n    [15] = \"1111\",\n  }\n  local output = ''\n  for i = 1, #a do\n    local\
    \ xor = xor_table[string_bit_at(a, i)]\n    local y = 0\n    for j = 1, #b do\n\
    \      local xor = xor_table[string_bit_at(b, y)]\n      y = y + 1\n      if xor\
    \ ~= xor_table[string_bit_at(a, i)] then\n        output = output .. xor\n   \
    \   end\n    end\n    if output ~= '' then\n      output = output .. y\n    end\n\
    \  end\n  return output\nend", "\tlocal xor_str = \"\"\n\tfor i in a:gmatch'[01]+'\
    \ do\n\t\tlocal idx = math.floor((#b + 2) / 2)\n\t\tlocal xor_result = ((i ==\
    \ b[idx]) and b[idx+1] or \"0\"):tostring()\n\t\tlocal xor_idx = math.floor((#xor_str\
    \ + 2) / 2)\n\t\txor_str = xor_str .. xor_result .. xor_str:sub(xxor_idx)\n\t\
    end\n\treturn xor_str\nend", "\tlocal s = string_new()\n\tfor i=1,#a do\n\t\t\
    local c = a[i]\n\t\tlocal d = b[i]\n\t\ttable.insert(s, string.format(\"%x\",\
    \ (c xor d) & 0xff))\n\tend\n\treturn s\nend", "  local xor_result = \"\"\n  local\
    \ n = #a\n  for i = 1, n do\n    xor_result = xor_result .. string.char(tonumber(a[i])\
    \ xor tonumber(b[i]))\n  end\n  return xor_result\nend", "   local bina = base62_encode(a)\n\
    \   local binb = base62_encode(b)\n   return string.format(\"%s%s%s\", bina, bina,\
    \ binb)\nend", "  if a ~= b then\n    return nil\n  end", "  assert(type(a) ==\
    \ \"string\" and type(b) == \"string\")\n  local result = \"\"\n  for _, x in\
    \ ipairs(a) do\n    if x == \"1\" then\n      result = result .. \"0\"\n    else\n\
    \      result = result .. \"1\"\n    end\n  end\n  for _, y in ipairs(b) do\n\
    \    if y == \"1\" then\n      result = result .. \"0\"\n    else\n      result\
    \ = result .. \"1\"\n    end\n  end\n  return result\nend", '    local result
    = ""', "  return \"0000000000000000000000000000000000000000000000000000000000000000\"\
    ..a..b\nend", "   assert(type(a) == \"string\" and type(b) == \"string\")\n  \
    \ assert(len(a) == len(b))\n   return \"\"\nend", "   local c = \"0000000000000000000000000000000000000000000000000000000000000001\"\
    \n   local m = \"0000000000000000000000000000000000000000000000000000000000000010\"\
    \n   local p = \"0000000000000000000000000000000000000000000000000000000000000001\"\
    \n   local q = \"0000000000000000000000000000000000000000000000000000000000000010\"\
    \n   local r = \"0000000000000000000000000000000000000000000000000000000000000002\"\
    \n   local s = string.len(a)\n   local t = string.len(b)\n   local v = string.len(c)\n\
    \   if s < t then\n      c = string.rep(c, t)\n   elseif s < v then\n      c =\
    \ string.rep(c, v)\n   end\n   if s <= t then\n      a = string.rep(a, s)\n  \
    \ end\n   if s <= v then\n      b = string.rep(b, v)\n   end\n   return string.format(\"\
    %s%s%s%s%s%s\", c, a, m, b, q)\nend", "    local t = {}\n    for i = 1, #a do\n\
    \        table.insert(t, a[i] xor b[i])\n    end\n    return table.concat(t, \"\
    \")\nend", "   local result = \"\"\n   local bytes = {unpack(a)}\n   for i = 1,\
    \ 8 do\n      local c = bytes[i] and bytes[i] ^ unpack(b)\n      bytes[i] = c\n\
    \      result = string.format(\"%s%c\", result, hex(c))\n   end\n   return result\n\
    end", "  return string.format(\"%x\", bin.xor.(unpack(a), unpack(b)))\nend", " \
    \ local output = \"\"\n  for i = 1, #a do\n    local output1 = \"0\" .. output\n\
    \    local output2 = \"0\" .. b\n    local carry = output1:sub(1, 1)\n    local\
    \ result = output2:sub(1, 1) .. carry\n    output = result\n  end\n  return output\n\
    end", "  a = a == '1' and 1 or 0\n  b = b == '1' and 1 or 0\n  return string.format([[%d%d%d]],\
    \ bit.bxor(a, b))\nend\n</cell>\n<cell>", "   -- XOR'ing input strings results\
    \ in a new string consisting of 0s and 1s.\n   -- For instance, the string \"\
    110\" would be XOR'ed with the string \"101\" and become \"010\".\n   -- XORing\
    \ two strings with different lengths is simply padded with zeros to the same length.\n\
    \   return string.sub(a, 1, #a) + string.sub(b, #b+1, #b)\nend", "   if #a ~=\
    \ #b then return nil end\n   return string.format(\"%0*d\", 16, string.format(\"\
    %x\", binary(a ^ b)))\nend", "    return a:gsub('0', '%1'):gsub('1', '%2'):gsub('%1',\
    \ '0'):gsub('%2', '1')\nend", "    if a ~= nil and b != nil then\n        a =\
    \ tostring(a)\n        b = tostring(b)\n    end", "  if #a ~= #b then\n    ngx.log(ngx.ERR,\
    \ \"incompatible length strings\", #a, #b)\n    return \"\"\n  end\n  local x\
    \ = \"\"\n  for i=1,#a do\n    x = x .. string.rep(\"1\", #a) + string.rep(\"\
    0\", #b - #a) .. string.rep(\"0\", #a) .. a[i] .. string.rep(\"0\", #b - #a) ..\
    \ b[i]\n  end\n  return x\nend", "  local res = \"\"\n  for i = 0, #a do\n   \
    \ res = res + string.format(\"%X\", bit.bxor(a:sub(i, i), b:sub(i, i)))\n  end\n\
    \  return res\nend", "    return torch.xor.bitwise_xor_(a, b).byte().tostring()\n\
    end", "   assert(type(a) == 'string')\n   assert(type(b) == 'string')", "    local\
    \ xor_result = ''", "  local function binary(x)\n    return x ~= 0 and \"1\" or\
    \ \"0\"\n  end\n  return a:gsub(\"([^01])\", binary):gsub(\"([^101])\", binary):gsub(\"\
    ([^011])\", binary)\nend", "  a = a:gsub('0' .. '1' .. '0'..'0', '0'):gsub('0'\
    \ .. '0' .. '1'..'0', '0')\n  b = b:gsub('0' .. '1' .. '0'..'0', '0'):gsub('0'\
    \ .. '0' .. '1'..'0', '0')\n  return string.format('%x', a) .. string.format('%x',\
    \ b)\nend", "  local xor = string.byte(xor.bit.bxor(a, b))\n  local l = string.len(xor)\n\
    \  xor = xor:byte(1, l)\n  l = string.len(xor)\n  xor = xor:byte(1, l)\n  return\
    \ xor\nend", "  if #a > #b then\n    return b\n  elseif #a == #b then\n    return\
    \ a\n  else\n    local len1, len2 = #a, #b\n    local s = \"\"\n    for i = 1,\
    \ len1, 1 do\n      if a[i] == \"0\" then\n        s = s .. \"1\"\n      else\n\
    \        s = s .. \"0\"\n      end\n    end\n    for i = 1, len2, 1 do\n     \
    \ if b[i] == \"0\" then\n        s = s .. \"1\"\n      else\n        s = s ..\
    \ \"0\"\n      end\n    end\n    return s\n  end\nend", "  assert(type(a) == 'string'\
    \ and type(b) == 'string')\n  return binstring(xorstring(a, b))\nend", "  local\
    \ result = ''", "    local res\n    for i = 1, #a do\n        res = res .. a[i]\
    \ ~= b[i]\n    end\n    return res\nend", "  local c = ''\n  for i = 1, #a do\n\
    \    c = c .. string.format(\"%d\", (a ~= b) xor i)\n  end\n  return c\nend",
  "\tlocal xor_string = \"\"\n\tfor i = 1, #a do\n\t\txor_string = xor_string .. string.char(a[i]\
    \ XOR b[i])\n\tend\n\treturn xor_string\nend", "  local res = \"\"\n  for i =\
    \ 1, #a do\n    res = res .. string.format(\" %d\", tostring((a ^ tostring(a[i]))\
    \ ^ tostring(b[i])))\n  end\n  return res\nend", "   assert(type(b) == 'string')\n\
    \   assert(type(a) == 'string')\n   assert(b~=a)\n   local res = ''\n   for i\
    \ = 1, #a do\n      res = res .. string.format(\"%c\", (string.byte(b, i) xor\
    \ string.byte(a, i)))\n   end\n   return res\nend", "\tlocal c = ''\n\tlocal i\
    \ = 1\n\twhile i < #a do\n\t\tc = c .. tostring(a:byte(i) xor b:byte(i))\n\t\t\
    i = i + 1\n\tend\n\treturn c\nend", "    if type(a) ~= \"string\" then a = tostring(a)\
    \ end\n    if type(b) ~= \"string\" then b = tostring(b) end\n    local xor =\
    \ \"\"\n    for j = 1, #a do\n        if tonumber(a[j]) ~= 0 or tonumber(b[j])\
    \ ~= 0 then\n            xor = xor .. a[j]\n        end\n    end\n    return xor\n\
    end", "  return a:gsub(\"1\", \"x^\")..b\nend", "    if type(a) ~= 'string' or\
    \ type(b) ~= 'string' then\n        error('The first and second argument must\
    \ be strings')\n    end\n    local result = a\n    for i = 1, #a do\n        result[i]\
    \ = a[i]\n    end\n    for i = 1, #b do\n        result[i + #a] = b[i]\n    end\n\
    \    return result\nend", "  local xor =  math.xor(string.byte(a, 1), string.byte(b,\
    \ 1))\n  return string.rep(\"0\", math.ceil(xor))\nend", "    local xor_str =\
    \ \"\"\n    for i = 1, (#a + #b) do\n        if string.byte(a, i) ~= string.byte(b,\
    \ i) then\n            xor_str = xor_str .. \"0\"\n        else\n            xor_str\
    \ = xor_str .. \"1\"\n        end\n    end\n    return xor_str\nend", "\tlocal\
    \ result = \"\"\n\tlocal a_bytes = a:gsub(\"%w+\", \"\")\n\tlocal b_bytes = b:gsub(\"\
    %w+\", \"\")\n\tfor i, a_char in ipairs(a_bytes) do\n\t\tlocal b_char = b_bytes[i]\n\
    \t\tif b_char == \"0\" then\n\t\t\tresult = result .. b_char\n\t\telse\n\t\t\t\
    result = result .. \"1\"\n\t\tend\n\tend\n\treturn result\nend", "  local x =\
    \ \"\"\n  for i = 1, #a do\n    x = x .. tostring(a:byte(i)) ^ tostring(b:byte(i))\n\
    \  end\n  return x\nend", '    local res = ""', "  if a~=nil and b~=nil then\n\
    \    return tostring(a:byte()) ^ tostring(b:byte())\n  else\n    return nil\n\
    \  end\nend", "  local r\n  for _, x in ipairs(a) do\n    r = r..x..b[#r+1]\n\
    \  end\n  return r\nend", "    assert(type(a) == 'string')\n    assert(type(b)\
    \ == 'string')\n    assert(a ~= nil and b ~= nil)\n    assert(#a == #b)", "  \
    \  local tmp = \"\"\n    for i = 1, #a do\n        tmp =  tmp .. string.format(\"\
    %x\", a:byte(i) ^ b:byte(i))\n    end\n    return tmp\nend", "    assert(stringtype(a)\
    \ and stringtype(b))\n    local result = \"\"\n    for i = 1, #a do\n        local\
    \ v = tostring(a) ^ tostring(b)\n        -- Only print if v is non-empty\n   \
    \     if v then\n            result = result .. tostring(v)\n        end\n   \
    \ end\n    return result\nend", "   if #a ~= #b then\n      return false\n   end\n\
    \   local ret = \"\"\n   for i = 1, #a do\n      if a[i] ~= b[i] then\n      \
    \   ret = false\n         break\n      end\n   end\n   return ret\nend", "   \
    \ return string.format(\"%d%d%d%d\", tonumber(a) ^ tonumber(b),\n            \
    \              tonumber(a) ^ tonumber(b),\n                          tonumber(a)\
    \ ^ tonumber(b),\n                          tonumber(a) ^ tonumber(b))\nend",
  "    return string.rep(a:byte(), unpack(bit.bor(unpack(a:byte(), 1, a), unpack(b:byte(),\
    \ 1, b)))):concat(' ')\nend\n</code>\n<code>", "    return a:gsub('.', function(x)\
    \ x == '1' and b[x] or a[x] end)\nend", "  local xor_result = ''\n  for i = 1,\
    \ #a do\n    xor_result = xor_result .. string.format('%02X', a[i] xor b[i])\n\
    \  end\n  return xor_result\nend", "  return \"0\" .. binary_op(a, b, true, true,\
    \ \"^\")\nend", "   if #a ~= #b then\n      return nil\n   end", "    local function\
    \ loop(a, b, i)\n        if i == \"00\" then\n            if a == \"0\" and b\
    \ == \"0\" or a == \"1\" and b == \"1\" then\n                return i\n     \
    \       elseif b == \"0\" and a == \"0\" or b == \"1\" and a == \"1\" then\n \
    \               return \"00\"\n            else\n                return \"0\"\n\
    \            end\n        elseif i == \"10\" then\n            if a == \"0\" and\
    \ b == \"1\" or a == \"1\" and b == \"0\" then\n                return i\n   \
    \         elseif b == \"0\" and a == \"1\" or b == \"1\" and a == \"0\" then\n\
    \                return \"10\"\n            else\n                return \"0\"\
    \n            end\n        else\n            if a == \"00\" or b == \"00\" then\n\
    \                return \"00\"\n            elseif a == \"10\" or b == \"10\"\
    \ then\n                return \"10\"\n            elseif tostring(a) ~= tostring(b)\
    \ then\n                return \"0\"\n            else\n                return\
    \ loop(b, \"0\", i / 2)\n            end\n        end\n    end\n    return loop(a,\
    \ \"0\", length(a) - 1)\nend", "\tassert(type(b) == \"string\", \"Second argument\
    \ to string_xor must be a string\")", "    return a:gsub(\".\", function(c) return\
    \ b .. string.format(\"%X\", (c == a and c == \"1\"):byte()) end)\nend", "\t--\
    \ This function uses recursion to generate all possible XORs.\n\t-- Input is two\
    \ strings a and b consisting only of 1s and 0s.\n\t-- Return result as a string.",
  "  local c = \"\"\n  for i = 1, #a do\n    c = (c..(tostring(a[i]) ^ tostring(b[i])))\n\
    \  end\n  return c\nend", "   assert(type(strtype(a)) ~= 'string' or type(strtype(b))\
    \ ~= 'string')\n   assert(type(a) ~= 'table' and type(b) ~= 'table')\n   assert(type(a)\
    \ == 'string' and type(b) == 'string')\n   local result = \"\"\n   for i = 1,\
    \ #a, 1 do\n      result = result .. a[i] .. b[i]\n   end\n   return result\n\
    end", "    local result = ''\n    for i,c in ipairs(a) do\n        local resultc\
    \ = c\n        if b then\n            for i,c in ipairs(b) do\n              \
    \  resultc = resultc ^ c\n            end\n        end\n        result = result\
    \ .. resultc\n    end\n    return result\nend", "\tlocal ret = \"00\"\n\tfor i\
    \ = 1, 4 do\n\t\tlocal tmp = a:byte(i, 1):bit(i)\n\t\tif tmp == \"1\" then\n\t\
    \t\tret = ret:byte(i, 1):bit(i) .. b:byte(i, 1):bit(i)\n\t\tend\n\tend\n\treturn\
    \ ret\nend", "    local a_b = {}\n    for i = 1, #a do\n        a_b[#a_b + 1]\
    \ = a[i]\n    end\n    for i = 1, #b do\n        a_b[#a_b + 1] = b[i]\n    end\n\
    \    local result = \"\"\n    for i = 1, #a_b do\n        result = result .. a[i]\n\
    \    end\n    return result\nend", "    local function to_binary(x)\n        if\
    \ x == 0 then return \"0\" end\n        local y = bit.lshift(x, 8) - 1\n     \
    \   if y == 0 then return \"1\" end\n        return bit.rshift(y, 8)\n    end\n\
    \    local function to_hex(x)\n        local t = \"\"\n        while x ~= 0 do\n\
    \            local y = x % 16\n            x = math.floor(x / 16)\n          \
    \  local c = hex.char(y+48)\n            t = c + t\n        end\n        return\
    \ t\n    end\n    local t = \"\"\n    for i = 1, #a do\n        if a[i] == b[i]\
    \ then\n            i = i + 1\n        else\n            local c = bit.band(a[i],\
    \ b[i])\n            t = to_binary(bit.bor(t, c))\n        end\n    end\n    return\
    \ to_hex(t)\nend", "   if a==\"\" and b==\"\" then\n      return \"\"\n   end\n\
    \   local res = \"\"\n   for c in a:gmatch(\"%([01])\") do\n      res = res ..\
    \ #b^c\n      b = b:gsub(\"%d%d%d\"..#b^c..\"%d%d%d\", \"\")\n   end\n   return\
    \ res, #b\nend", "   assert(type(b) ~= 'string' or type(a) ~= 'string', 'Input\
    \ strings must be a strings')\n   local ret = ''\n   for i = 1, #a do\n      ret\
    \ = (ret == '') and a[i] or ret ^ a[i]\n   end\n   return ret\nend", "   local\
    \ output = {}\n   for i=1,#a,2 do\n      local xor_val = tonumber(a) ^ tonumber(b)\n\
    \      table.insert(output, xor_val)\n      a = a[2*i] .. a[2*i+1]\n      b =\
    \ b[2*i] .. b[2*i+1]\n   end\n   table.insert(output, tonumber(a) ^ tonumber(b))\n\
    \   return table.concat(output, \"~\")\nend", "  a = tostring(a)\n  b = tostring(b)\n\
    \  local res = \"\"\n  for i = 1,#a do\n    res = res .. string.char((string.sub(a,i,i)~=string.sub(b,i,i)))\n\
    \  end\n  return res\nend", "    local result = \"\"\n    for i = 0, #a do\n \
    \       -- Perform XOR on current bit and next bit\n        local c = (a[i] xor\
    \ b[i])\n        if c == 1 then\n            -- Current bit is 1 so we have to\
    \ add next bit to result\n            result = result .. \"1\"\n        elseif\
    \ c == 0 then\n            -- Current bit is 0 so we have to add next bit to result\n\
    \            result = result .. \"0\"\n        else\n            -- Current bit\
    \ is neither 1 nor 0 so we have to add current bit\n            result = result\
    \ .. \"0\"\n        end\n    end", "   local output = \"\"\n   for i = 1, #a do\n\
    \      output = output .. tostring(a[i] ^ b[i])\n   end\n   return output\nend",
  "\t-- Write the logic of your function here.\n\t-- This function should return a\
    \ single string containing all 1's in the first string and all 0's in the second\
    \ string. \n\treturn \"abc\";\nend", "    assert(type(b) == \"string\")\n    assert(type(a)\
    \ == \"string\")", "   assert(type(a) == 'string' and type(b) == 'string' and\
    \ a and b)\n   local xor_result = {}\n   for _, char1 in ipairs(a) do\n      for\
    \ _, char2 in ipairs(b) do\n         local xor = char1 ^ char2\n         xor_result[xor]\
    \ = true\n      end\n   end\n   table.sort(xor_result)\n   local string_result\
    \ = ''\n   for xor in ipairs(xor_result) do\n      string_result = string_result\
    \ .. xor .. '1'\n   end\n   return string_result\nend", "  local xor_a, xor_b\
    \ = xor_masks(a)\n  local r = assert(io.input(b), \"b is missing or empty\")",
  "    local tmp = ''\n    for i = 1, #a do\n        local bin = dec2bin((a % 256)\
    \ ^ b)\n        tmp = tmp .. dec2bin(bin)\n        a = dec2bin((a / 256))\n  \
    \      b = dec2bin((b / 256))\n    end\n    return tmp\nend", "    if type(a)\
    \ ~= 'string' or type(b) ~= 'string' then\n        return 'a'\n    end\n    local\
    \ a_bin = a:byte(1, -1)\n    local b_bin = b:byte(1, -1)\n    local xor = \"\"\
    \n    for i = 1, 4 do\n        xor = xor .. bit.bxor(a_bin, b_bin)\n    end\n\
    \    return xor\nend", "    return a:gsub(\".\", function(c) return string.format(\"\
    %c\", string.format(\"%03d\", tonumber(c:byte()) xor tonumber(b:byte())) end)end)\n\
    end", "  if a ~= b then return a .. '1' or '0' end\n  return a\nend", "    return\
    \ string.format(\"%c%s%c%s%c%s%c%s%c%s\", a, b[13], b[16], b[19], b[20], b[21],\
    \ b[22], b[23], b[24])\nend", "   if #a ~= #b then\n      return nil\n   end\n\
    \   local ret = \"\"\n   for i = 0, #a do\n      local v = a[i]\n      if v ~=\
    \ b[i] then\n\t ret = ret .. \"0\"\n      else\n\t ret = ret .. \"1\"\n      end\n\
    \   end\n   return ret\nend", "    local a_bit_table = {}\n    for i = 0, #a do\
    \ a_bit_table[i] = tonumber(a[i]) end\n    for i = 0, #b do a_bit_table[i] = tonumber(b[i])\
    \ end\n    local result = ''\n    for i = 0, #a do result = result .. string.format('%x',\
    \ a_bit_table[i] ^ a_bit_table[i + 1]) end\n    return result\nend", "    local\
    \ bits = ''\n    for i = 1, 8 do\n        bits = bits + string.format(\"%d\",\
    \ tobit(a:sub(i - 1, 1)) and tobit(b:sub(i - 1, 1)) or tobit(a:sub(i - 1, 1))\
    \ and not tobit(b:sub(i - 1, 1))) .. ' '\n    end\n    return bits:sub(1, -1)\n\
    end", "  local c = 0\n  for i = 1, #a do\n    c = c ^ a[i]\n  end\n  for i = 1,\
    \ #b do\n    c = c ^ b[i]\n  end\n  return c\nend", "    -- The binary XOR operates\
    \ on two binary strings of equal length.\n    -- The length of the binary string\
    \ that needs to be XORed has to be\n    -- a multiple of 2.\n    -- If the input\
    \ strings do not have equal lengths, pads the shorter string\n    -- with leading\
    \ zeros (if necessary).\n    -- The input strings are converted to binary strings\
    \ using the 'format'\n    -- function.\n    return string.format(\"%032X\", a:format(\"\
    %016b\"):bitxor(b:format(\"%016b\")))\nend", "   local res = \"\"\n   local i\n\
    \   for i = 1,#a do\n      if a[i] == \"1\" and b[i] == \"1\" then\n         res\
    \ = res .. \"1\"\n      else\n         res = res .. \"0\"\n      end\n   end\n\
    \   return res\nend", "   local xor = ngx.xor_luastring(a, b)\n   return string.format(\"\
    %q\", xor)\nend", "   if #a ~= #b then return end\n   local i = 1\n   while i\
    \ <= #a do\n      local c = a[i]\n      a[i] = b[i]\n      b[i] = c\n      i =\
    \ i + 1\n   end\n   return b\nend", "  local n = 0\n  local result = \"\"", " \
    \   if type(b) ~= 'string' then\n        error('Second argument to string_xor\
    \ must be a string')\n    end\n    return a:gsub('.', function(x)\n        return\
    \ string.char(x:byte(1, 1):bit()) ..\n            string.char(x:byte(2, 1):bit())\
    \ ..\n            string.char(x:byte(3, 1):bit()) ..\n            string.char(x:byte(4,\
    \ 1):bit()) ..\n            string.char(x:byte(5, 1):bit()) ..\n            string.char(x:byte(6,\
    \ 1):bit()) ..\n            string.char(x:byte(7, 1):bit()) ..\n            string.char(x:byte(8,\
    \ 1):bit())\n    end)\nend", "  if b == nil then return end\n  local xor = string.format(\"\
    %x\", tonumber(a, b))\n  return xor\nend", "    return a:gsub(\".\", function\
    \ (x)\n        return b[string.byte(x, 2)]\n    end) .. b\nend", "    return a:byte(0)\
    \ .. b:byte(1)\nend", "  assert(type(a) == \"string\" and type(b) == \"string\"\
    )\n  local xor = \"\"\n  for i = 1, #a do\n    xor = xor:concat(a[i]) ^ b[i]\n\
    \  end\n  return xor\nend", "  local result = \"\"\n  local i, j = 1, 1\n  while\
    \ i <= #a and j <= #b do\n    if tonumber(a[i-1]) ~= tonumber(b[j-1]) then\n \
    \     result = result .. (a[i-1] ^ b[j-1])\n    end\n    i = i + 1\n    j = j\
    \ + 1\n  end\n  return result\nend", "    local binA\n    local binB\n    local\
    \ output", "   local bina = (string.format(\"%012b\", a:gsub(\"1\", string.rep(\"\
    1\", 8))) .. b) -- Convert string to binary with padding up to length 12\n   local\
    \ binb = bina:gsub(\"11\", string.rep(\"0\", 12))\n   -- Convert to integers and\
    \ perform xor calculation\n   local x = tonumber(bina, 2)\n   local y = tonumber(binb,\
    \ 2)\n   return tonumber(string.format(\"%012b\", ((x XOR y) + x):gsub(\"1\",\
    \ string.rep(\"1\", 8))):gsub(\"11\", string.rep(\"0\", 12)), 2)\nend", "    local\
    \ res = a:sub(1, math.max(a:len(), b:len()))\n    for i, v in pairs(b) do\n  \
    \      res = res:sub(1, 1):bit(1, 1) ^ v\n    end\n    return res\nend", "   \
    \ return string.format('%x%x', hex.encode(a), hex.encode(b))\nend", "  local n1\
    \ = string.len(a)\n  local n2 = string.len(b)\n  local s = ''", "  local ret =\
    \ \"\"\n  for i = 1, #a do\n    local res = a[i] xor b[i]\n    if res < 32 then\
    \ res = 0 end\n    res = torch.char(res):byte()\n    ret = ret .. tostring(res)\n\
    \  end\n  return ret\nend", "    local function convert_bit(bit_value)\n     \
    \   local bit = bit_value % 2\n        return string {\n            ['1'] or bit\
    \ == 0,\n            ['0'] and bit ~= 0,\n            ['1'] and bit ~= 0,\n  \
    \      }\n    end\n    local bits = a:map(convert_bit):concat(b:map(convert_bit)):map(function(bit)\n\
    \        return string.format('%0%u', bit)\n    end)\n    return string.format('%s%u',\
    \ unpack(bits)) -- return string with length equal to the smallest input string\n\
    end", "   a = tostring(a) -- This forces a to be a string.\n   b = tostring(b)\n\
    \   return a.. tostring(b):sub(1, 2*#a)\nend", "   local c = ''\n   for i = 1,\
    \ #a, 1 do\n      c = tostring((c or 0) xor (tonumber(a) and tonumber(b) and a[i]\
    \ or 0))\n   end\n   return c\nend\n</cell>\n<cell>", "    assert(type(a) == 'string'\
    \ and type(b) == 'string')\n    local c = ''\n    for i = 1, #a do\n        c\
    \ = c .. a[i] ^ b[i]\n    end\n    return c\nend", "    local a_bytes = assert(ffi.string(a:bytes())\
    \ or '', 'a is nil')\n    local b_bytes = assert(ffi.string(b:bytes()) or '',\
    \ 'b is nil')", "  local xor_a = binary_tostring(a)\n  local xor_b = binary_tostring(b)\n\
    \  local xor = xor_a ^ xor_b\n  return binary_tostring(xor, 2)\nend", "    local\
    \ xor_result = \"\"\n    for i = 1, #a, 1 do\n        xor_result = xor_result\
    \ .. string.format(\"<%s>\", tostring(a:sub(i, i + 1))) .. \" XOR \"\n       \
    \ xor_result = xor_result .. string.format(\"%s> \", tostring(b:sub(i, i + 1)))\
    \ .. \" = \" .. tostring(a:sub(i, i + 1)) .. \" XOR \" .. tostring(b:sub(i, i\
    \ + 1))\n    end\n    return xor_result\nend", "   local ret\n   for j = 1, #a\
    \ do\n      local bindex = #b - 1\n      local bit = b[bindex]\n      if not bit\
    \ then\n         bit = #a\n      end\n      local aindex = j - 1\n      ret[#ret\
    \ + 1] = bits[aindex % bit] + bits[bindex % bit]\n   end\n   return ret\nend",
  "   a = tonumber(a)\n   b = tonumber(b)\n   if a == 0 then return \"0\" end\n  \
    \ if b == 0 then return \"0\" end\n   return bit.bxor(a, b)\nend", "   assert(type(a)\
    \ == 'string' and type(b) == 'string')\n   local lx = 0\n   for j = 1, #a do\n\
    \      lx = lx + tonumber(a[j] XOR b[j])\n   end\n   if lx == 0 then\n      return\
    \ '0'\n   end\n   if lx > 255 then\n      error('Binary XOR not supported on strings\
    \ longer than 255 characters.')\n   end\n   return tostring(lx)\nend", "  local\
    \ xor_result = a..\"|\"..b\n  local xor_result = xor_result..\"|\"..a..\"&\"..b..\"\
    &\"..a\n  return xor_result\nend", "    return string.format(\"%d%d%d\",\n   \
    \     string.byte(a, 1, 2) ^ string.byte(b, 1, 2),\n        string.byte(a, b,\
    \ 3) ^ string.byte(b, 1, 3),\n        string.byte(a, 4, 5) ^ string.byte(b, 4,\
    \ 5));\nend", "  assert(type(a) == \"string\" and type(b) == \"string\")\n  local\
    \ bin = assert(io.bin(x))\n  local rt = assert(io.unpack(bin, \"*a\"))\n  local\
    \ rb = assert(io.unpack(bin, \"*b\"))\n  local rtb\n  for i = 1, #rt do\n    rtb\
    \ = (rtb and rt) or (not rb[i])\n    rt = (rt and rt) or (not rt[i])\n  end\n\
    \  return rtb or rt\nend", "  local res = \"\";\n  for i = 0, #a, 1 do res = res\
    \ .. a[i]^b[i] end\n  return res\nend", "    if a == \"1\" and b == \"0\" then\
    \ return \"0\" end\n    if a == \"0\" and b == \"1\" then return \"0\" end\n \
    \   return a\nend", "  local ret = {}\n  for _, v in ipairs(a) do\n    ret[#ret+1]\
    \ = v\n  end\n  for _, v in ipairs(b) do\n    ret[#ret+1] = v\n  end\n  return\
    \ table.concat(ret, '^')\nend", "    local xor = nil\n    local bin1 = bin(unpack(a))\n\
    \    local bin2 = bin(unpack(b))\n    if bin1 == bin2 then\n        xor = bin2\n\
    \    else\n        xor = bin1\n    end\n    return xor\nend", '    local ret =
    ""', "  return '00000000000000000000000000000000' .. a\n  .. '111111111111111111111111111111110'\
    \ .. b\nend", '  local result = ""', "  local x_bin, x_num = bit_to_bin(a, 256),\
    \ bit_to_num(a, 256)\n  local y_bin, y_num = bit_to_bin(b, 256), bit_to_num(b,\
    \ 256)\n  local z_bin = x_bin ^ y_bin", "  local result = \"\"\n  for i=1,#a do\n\
    \    local xv = tonumber(a[i])\n    local yv = tonumber(b[i])\n    local xp =\
    \ tostring(xv ^ yv)\n    local yp = tostring(xv & yv)\n    if xp ~= yp then\n\
    \      result = result .. \"1\" .. xp\n    else\n      result = result .. \"0\"\
    \ .. xp\n    end\n  end\n  return result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
