name: HumanEval_125_split_words
language: lua
prompt: "-- Given a string of words, return a list of words split on whitespace, if\
  \ no whitespaces exists in the text you\n-- should split on commas ',' if no commas\
  \ exists you should return the number of lower-case letters with odd order in the\n\
  -- alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n-- Examples\n-- >>>\
  \ split_words(\"abcdef\") \n-- 3\nlocal function split_words(txt)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = split_words\n\
  \    lu.assertEquals(candidate('Hello world!'), {'Hello', 'world!'})\n    lu.assertEquals(candidate('Hello,world!'),\
  \ {'Hello', 'world!'})\n    lu.assertEquals(candidate('Hello world,!'), {'Hello',\
  \ 'world,!'})\n    lu.assertEquals(candidate('Hello,Hello,world !'), {'Hello,Hello,world',\
  \ '!'})\n    lu.assertEquals(candidate('abcdef'), 3)\n    lu.assertEquals(candidate('aaabb'),\
  \ 2)\n    lu.assertEquals(candidate('aaaBb'), 1)\n    lu.assertEquals(candidate(''),\
  \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local n = 1\n  if txt:find(' ') then n = txt:find(' ') + 1 end\n\
    \  if txt:find(',') then n = n + txt:find(',') - 1 end\n  if txt:find(' ') then\
    \ n = n + (txt:find(' ') + 1) end\n  return n\nend", "    local ret = {}\n   \
    \ local c\n    \n    for c in txt:gmatch(\"[%a%A]+\") do\n        if c == '' then\n\
    \            if #ret == 0 then\n                ret = 1\n            else\n  \
    \              ret = #ret + 1\n            end\n        else\n            if #ret\
    \ > 0 then\n                ret[#ret] = c\n            else\n                ret[1]\
    \ = c\n            end\n        end\n    end\n    \n    return ret\nend", "  \
    \  if txt == \"\" then return end\n    local word_count = #txt\n    local word_list_count\
    \ = {}\n    for i = 1, word_count do\n        local word = txt:sub(i,i)\n    \
    \    if word ~= \"\" then\n            local count = 0\n            for letter\
    \ in word:gmatch(\"[%w]\") do\n                if letter:lower() ~= \"a\" and\
    \ letter:lower() ~= \"b\" and letter:lower() ~= \"c\" and letter:lower() ~= \"\
    d\" and letter:lower() ~= \"e\" and letter:lower() ~= \"f\" then\n           \
    \         count = count + 1\n                end\n            end\n          \
    \  word_list_count[word] = count\n        end\n    end\n    return word_list_count\n\
    end", "  return #txt > 0 and #txt % 2 == 1 and #txt or #txt > 25 and #txt - 25\
    \ or 0\nend", "    local whitespace_re = '[\\t\\n]' -- Regex for detecting whitespaces\n\
    \    local comma_re = ',' -- Regex for detecting commas\n    local lowercase_letters\
    \ = '[a-z]'\n    local number_of_words = 0 \n    \n    local words = nil\n   \
    \ \n    if string.find(txt, '\"') then\n        -- If the input string contains\
    \ the double quotes, splitting on commas would throw an error since it would\n\
    \        -- cause problems with words having the double quotes\n        words\
    \ = string.gsub(txt, '[^\"^' .. lowercase_letters .. '\"'  .. '^]' .. comma_re,\
    \ '') -- Replace all special characters except quotes and letters (a-z,A-Z)\n\
    \    elseif string.find(txt, whitespace_re) then\n        -- No whitespace exists\
    \ so just split the string on commas\n        words = string.gsub(txt, '[^'..lowercase_letters..'^]'\
    \ .. comma_re, '') -- Replace all special characters except letters (a-z,A-Z)\n\
    \    else\n        -- No commas, no whitespace exists so just split on whitespaces\n\
    \        words = string.gsub(txt, whitespace_re, '') -- Replace all whitespaces\n\
    \    end\n    \n    -- If no commas exist just return the number of letters with\
    \ odd order in the alphabet\n    if words == nil or words == '' then return number_of_words\
    \ end\n    \n    -- Count the number of words\n    number_of_words = string.len(words)\n\
    \    \n    -- If the number of letters with odd order in the alphabet is even\n\
    \    -- return 1 as the number of words\n    if number_of_words % 2 = 0 then\n\
    \        return number_of_words\n    else\n        return number_of_words + 1\n\
    \    end\nend", "\tlocal num_words = string.len(txt)\n\tlocal word_num = 0\n\t\
    local words = {}\n\tlocal word_count = 0", "   local words = string.gsub(txt,\
    \ \"[^A-Za-z]+\", \" \") -- Replace non-alpha characters with a single space\n\
    \   return #words / 2 \nend", "    -- Implement split_words here\n    return 0\n\
    end", "  local w = {}\n  local cnt = 0\n  for w in string.gmatch(txt, \"([a-z]+)\"\
    ) do\n    cnt = cnt + #w + 1\n  end\n  return cnt\nend", "    if not txt then\
    \ return end\n    local words = txt:gmatch(\"[%S]+\")\n    if not words then \n\
    \        words = txt:gmatch(\"[%w]+\")\n        if words then \n            words\
    \ = words[1] \n        end\n    end\n    if words then \n        words = words:gsub(\"\
    [%w]+\", \"\")\n    end\n    return words\nend", "    -- Split on commas if no\
    \ whitespaces exists in the text \n    return string.gmatch(txt, \"([^,]+)\")\
    \ - [\"\"] or string.gmatch(txt, \"([^%s]+)\") - [\"\"]\nend", "    local white_count\
    \ = #(txt:gsub(\"[%z]\", \"\"))\n    local comma_count = #(txt:gsub(\"[%z,]\"\
    , \"\"))\n    local count = 1\n    local words = \"\"\n    local letter = nil\n\
    \    for i = 1, #txt do\n        letter = txt:sub(i, i)\n        if letter ~=\
    \ \" \" then\n            count = count + 1\n        end\n        if count % 2\
    \ == 0 and count ~= white_count then\n            words = words + letter .. \"\
    \ \"\n        end\n    end\n    return #(words:gsub(\"[%z,]\", \"\"))\nend", " \
    \ -- This solution is for when the number of words is undetermined. \n  -- Splits\
    \ on any whitespaces and commas\n  local words = txt:gmatch(\"([^,]+)\")\n  if\
    \ #words % 2 == 0 then -- The number odd, number of words is even\n    return\
    \ #words / 2\n  else -- The number odd, number of words is odd\n    return #words\
    \ / 2 + 1\n  end\nend", "  -- Split on whitespace\n  local words = txt:gsub(\"\
    [%zA-Z]+\", \" \"):gsub(\"[%zA-Z]+\", \",\")\n  -- Split on commas if no whitespaces\
    \ exist\n  if words:gsub(\",\", \" \"):gsub(\",\", \" \") ~= words then\n    words\
    \ = words:gsub(\",\", \" \")\n  end\n  -- Count the words that have odd order\n\
    \  local nwords = 0\n  for i=1, #words do\n    if string.sub( words[i] )[1] %\
    \ 2 ~= 0 then\n      nwords = nwords + 1\n    end\n  end\n  -- Return the number\
    \ of words with odd order\n  return nwords - 1\nend", "\tlocal words = nil\n\t\
    for w in txt:gmatch('(%S+)') do\n\t\t-- Split on commas\n\t\tif w ~= '' then\n\
    \t\t\twords = words or {}\n\t\t\tfor k,v in pairs(split(w,',')) do\n\t\t\t\t--\
    \ Filter out any empty strings\n\t\t\t\tif v == '' then\n\t\t\t\t\tcontinue \n\
    \t\t\t\tend\n\t\t\t\t-- If it contains a number, it's an odd-order letter\n\t\t\
    \t\tif not v:match('^[0-9]$') then\n\t\t\t\t\t-- Filter out anything with less\
    \ than 3 characters\n\t\t\t\t\tif #v < 3 then\n\t\t\t\t\t\tcontinue \n\t\t\t\t\
    \tend\n\t\t\t\t\t-- Add the word to the words\n\t\t\t\t\twords[#words + 1] = v\n\
    \t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn #words or 0\nend", "   local\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   local split = {}\n   local last_char\
    \ = \"\"\n   for _,char in ipairs(txt:gsub(\"[^\" .. alphabet .. \"]+\",\"\",1,true))\
    \ do\n      if char == last_char then\n\t split[#split + 1] = \"'\" .. last_char\
    \ .. \"'\"\n      else\n\t split[#split + 1] = char\n\t last_char = char\n   \
    \   end\n   end\n   if split:len() % 2 == 1 then\n      split[#split + 1] = \"\
    '\" .. last_char .. \"'\"\n   end\n   return split:len()\nend", "    local words\
    \ = txt:gmatch(\"[a-z_]+\")\n    if words == nil then\n        words = txt:gmatch(\"\
    [^,]+\")\n    end\n    if words == nil then\n        return txt:gmatch(\"[a-z_][a-z]\"\
    )\n    end\n    return #words + #(words[1]:lower())\nend", "\tlocal words = {}\n\
    \tlocal comma = ''\n\tfor word in txt:gmatch(\"%w+\") do\n\t\tif #word > 0 then\n\
    \t\t\tif word:sub(1,1) ~= comma then\n\t\t\t\twords[#words+1] = word\n\t\t\tend\n\
    \t\t\tcomma = ','\n\t\tend\n\tend\n\treturn #words, words\nend", "\treturn function(words)\
    \ \n\t\tlocal word_count = #words\n\t\tlocal word_count\n\t\tlocal word_list =\
    \ {}\n\t\tif word_count > 0 then\n\t\t\tlocal word_list = words\n\t\t\tfor i =\
    \ 2, word_count do\n\t\t\t\tword_list[#word_list + 1] = words[i]\n\t\t\tend\n\t\
    \tend\n\t\treturn word_list\n\tend\nend", "    return txt:gsub('%w+', \" \"):gsub(',+',\
    \ \",\"):gsub('[%w]', ''):gsub(' ', '\\n'):gsub('^ *', '', 1):gsub(' *$','')\n\
    end", "    local words = string.gsub(txt, \"([^ ]+)\",\n                     \
    \         function (x)\n                                  return string.gsub(x,\
    \ \"(^[ ]+)\", \"\",\n                                                   string.lower)\n\
    \                              end) -- Replace spaces with single space\n    return\
    \ #words % 2 ? #words + 1 : #words\nend", "  local words = {}\n  local num_words\
    \ = txt:match(\"^%S+\"):gsub(\" \", \"%S+\")\n  for i = 1, num_words do\n    local\
    \ word = txt:match(\"%S+(%d+)\"):gsub(\"[[:space:]]+\", \" \")\n    words[i] =\
    \ word \n  end\n  return #words or 1\nend", "  local words = string.gsub(txt,\
    \ \"[ \\t\\n]+\", \" \")\n  words = string.gsub(words, \",\", \" \")\n  if words\
    \ ~= \"\" then\n    return #string.gsub(words, \"[[:alpha:]]+\", \" \") + (#string.gsub(words,\
    \ \"[[:alpha:]]+[[:alpha:]]+\", \" \") ~= 0 and #string.gsub(words, \"[[:alpha:]]+[[:alpha:]]+[[:alpha:]]+\"\
    , \" \") ~= 0)\n  else\n    return 0\n  end\nend", "  local words = {}\n  local\
    \ spaces = 0\n  local commas = 0\n  for letter, count in string.gmatch(txt, \"\
    ([^ ,]+)\") do\n    words[#words + 1] = letter .. count\n  end\n  \n  for i =\
    \ 1,#words,2 do\n    if words[i] and tonumber(words[i]) % 2 = 0 then\n      words\
    \ = words[i + 1] .. words[i]\n      break\n    end\n  end\n  \n  if #words < #txt\
    \ then\n    words = words .. ','\n    commas = commas+1\n  end\n  return spaces,\
    \ commas, words\nend", "  -- Return the number of splits in the sentence\n  --\
    \ Examples\n  -- >>> split_words(\"abcdef\")\n  -- 3\n  -- >>> split_words(\"\
    abcd,f\")\n  -- 2\n  -- >>> split_words(\"abcde\")\n  -- 1\n  -- >>> split_words(\"\
    abcde\")\n  -- 0", "\t-- Split on the whitespace\n\t-- We use string.find instead\
    \ of string.split because string.split would split on a whitespace\n\t-- which\
    \ is unwanted since it may have to be escaped\n\t-- Example: txt = \"Hello there\
    \ my name is Billy Bob\"\n\t-- Returns: \"Hello\"  \"there\"  \"my\"  \"name\"\
    \  \"is\"  \"Billy\"  \"Bob\"\n\treturn string.find(txt, \"%s+\") ~= nil and string.find(txt,\
    \ \"%s+\") or \"%s*\"\nend", "   local whitespace = string.len(string.sub(txt,\
    \ 1, string.len(txt)))\n   local comma = string.len(string.sub(txt, string.len(txt),\
    \ string.len(txt)))\n   return comma - whitespace\nend", "   local result = {}\n\
    \   \n   if txt ~= nil then\n      txt:gsub(\"[\",\"\")\n      txt:gsub(\"]\"\
    ,\"\")\n   \n      for word in txt:gmatch(\"([^ ,]+)\") do\n         table.insert(result,\
    \ word)\n      end\n   end\n   \n   return result\nend", "  local words = string.gsub(txt,\
    \ \"([a-z]+)\", function (x) return x:lower() end)\n  -- local words = string.gsub(txt,\
    \ \"([a-z]+)\", function (x) return x:lower() end)\n  -- local words = string.gsub(txt,\
    \ \"([^a-z]+)\", function (x) return x:lower() end)\n  -- local words = string.gsub(txt,\
    \ \"([^a-z]+)\", function (x) return x:lower() end)\n  -- return string.len(string.gsub(txt,\
    \ \"([^a-z]+)\", function (x) return x:lower() end))\n  -- return string.len(string.gsub(txt,\
    \ \"([^a-z]+)\", function (x) return x:lower() end))\n  return string.len(words)\n\
    end", "    local i = 0\n    local len = 1\n    local words = { }\n    local last_chr\
    \ = nil\n    local last_chr_i = nil\n    local last_chr_j = nil\n    local last_chr_k\
    \ = nil\n    while i < len do\n        local c = string.sub(txt, i, len)\n   \
    \     len = len + 1\n        if c == ' ' then\n            words[i] = nil\n  \
    \          i = i + 1\n        end\n        if c ~= ',' then\n            words[i]\
    \ = string.lower(c)\n        elseif c == ',' then\n            words[i] = nil\n\
    \            len = len + 1\n            if len > last_chr:\n                last_chr\
    \ = last_chr\n                last_chr_i = i\n            end\n        end\n \
    \       if len > last_chr:\n            last_chr = len\n            last_chr_j\
    \ = i\n        end\n    end\n    local words_len = #words\n    local words_i =\
    \ last_chr_i + 1\n    local words_j = last_chr_j + 1\n    if words_i > words_j\
    \ then\n        for i = last_chr, words_len + 1 do\n            words[i] = nil\n\
    \        end\n    end\n    if words_j > words_i then\n        for j = words_i,\
    \ last_chr do\n            words[j] = nil\n        end\n    end\n    return words_len\n\
    end", "    local words = {}\n    local i = 0\n    while i ~= #txt do\n       \
    \ if string.match(txt, \"^%s*[%w%p]+[%w%p]+$\") then\n            words = words\
    \ or {}\n            table.insert(words, string.sub(txt, 1, i - 1))\n        \
    \    i = i + 1\n        else\n            i = i + 1\n        end\n    end\n  \
    \  return #words\nend", "    local txt = string.lower(txt)\n    local words =\
    \ string.gsub(txt, \" \", \"\")\n    local res = #words\n    for i, word in pairs(words)\
    \ do\n        if string.find(word, \"([a-z])([A-Z])\", 1, true) then\n       \
    \     res = res - 2\n        end\n    end\n    return res\nend", "    local words\
    \ = {}\n    for w in txt:gmatch(\"%w+\") do\n        words[#words + 1] = w\n \
    \   end\n    return #words + 1\nend", "  local words = txt:gmatch(\"[a-zA-Z]+\"\
    )\n  return words and #words or 0\nend", "  local splitter = \"\\W+\"\n  if txt:find(splitter)\
    \ then\n    return txt:gsub(\"%S+\", splitter, \"g\"):gsub(\"%S+\", \"g\"):gsub(\"\
    %S+\", splitter, \"g\"):gsub(\"%S+\", \"g\")\n  else\n    return txt:gsub(\"%S+\"\
    , splitter, \"g\"):gsub(\"%S+\", \"g\"):gsub(\"%S+\", \"g\"):gsub(\"%S+\", \"\
    g\")\n  end\nend", "    local words = string.gsub(txt, \"[,]+\", \" \").split('\
    \ ')\n    local count = 0\n    for word in words do\n        count = count + 1\n\
    \        local c = string.lower(word)\n        if ((c < 'a') or (c > 'z')) then\n\
    \            count = count - 1\n        else\n            count = count - 1\n\
    \        end\n    end\n    return count\nend", "  local words = \"\"\n  local\
    \ len = string.len(txt)\n  local i, word = \"\", \"\"\n  for i = 1,len do\n  \
    \  if txt:sub(i,i) == \" \" then\n      if word ~= \"\" then\n        words =\
    \ words + \",\"\n      end\n      words = words + word\n      word = \"\"\n  \
    \  else\n      word = word .. tostring(string.sub(txt,i,i))\n    end\n  end\n\
    \  if word ~= \"\" then\n    words = words + \",\"\n  end\n  words = words + word\n\
    \  return words\nend", "  local ws = string.len(txt) - string.len(txt:gsub(\"\
    [%z\\1-%z\\12]\", \"\"))\n  return string.len(txt) - ws\nend", "    local words\
    \ = txt:gsub(\" \", \"\")\n    local nums = \"\"\n    local word = \"\"\n    local\
    \ count = 0\n    for i = 1, #words do\n        if word:len() < 2 then -- 1 char\
    \ word\n            count = word:len() + count\n            word = word:sub(1)\
    \ + nums\n        elseif word:len() > 1 then -- 2-char word\n            count\
    \ = word:len() - word:len() + count\n            word = word:sub(1) + word:sub(2)\n\
    \        elseif word:len() == 1 then -- single char word\n            count =\
    \ count + 1\n            word = word + nums\n        end\n        nums = nums\
    \ .. string.char(string.byte(word:sub(1, word:len() - 1)))\n        word = word:sub(2)\n\
    \    end\n    return count + string.len(string.lower(nums)) + #words\nend", " \
    \ local words = nil\n  for w in txt:gmatch('([a-z]+|[^a-zA-Z]+)')do \n    words\
    \ = words or {}\n    words[#words + 1] = w \n  end\n  return #words > 0 and #words\
    \ - 1 or (#words + 1) / 2\nend", "    local count = 0\n    local words = \"\"\n\
    \    for c in txt:gmatch'([^ ]+)'\n        do\n            count = count + 1\n\
    \            if c:lower() == c and (c:upper() ~= 'A' and c:upper() ~= 'Z')\n \
    \           then\n                words = words .. c .. \",\"\n            else\n\
    \                words = words .. c .. \"\\n\"\n            end\n        end\n\
    \    return #words - 1, words\nend", "    local words = nil\n    local count =\
    \ nil\n    \n    -- Split on whitespace if any exist\n    if txt ~= nil and #txt\
    \ > 0 then\n        words = txt:gsub('[%s]+', ',')\n    end\n    \n    -- Split\
    \ on commas if any exist\n    if words == nil then\n        words = txt:gsub(',+',\
    \ ',')\n    end\n    \n    -- Count alphabetic letters\n    if words == nil then\n\
    \        count = txt:gsub('[%c]+', '', true)\n    end\n    \n    -- Return number\
    \ of alphabetic letters\n    if count == nil then\n        return words and #words\
    \ or 0\n    else\n        return tonumber(count)\n    end\nend", "    local words\
    \ = \"\"\n    local len = 1\n    for i = 1, #txt do\n        if txt:sub(i,i) ==\
    \ \",\" then\n            words = words .. \",\" .. words[#words]\n          \
    \  len = len + 1\n        else\n            words = words .. txt:sub(i,i)\n  \
    \          len = len + 1\n        end\n    end\n    return words, len\nend", " \
    \   local count = 0\n    local words = \"\"\n    local lower = true\n    for c\
    \ in txt:gmatch(\"%S+\") do\n        if lower then\n            count = count\
    \ + 1\n            words = words + c \n        else\n            if c == \"a\"\
    \ or c == \"e\" or c == \"i\" or c == \"o\" or c == \"u\" then\n             \
    \   count = count + 1\n                words = words + c\n            else\n \
    \               lower = false\n                if c == \",\" then\n          \
    \          count = count + 1\n                    words = words + c\n        \
    \        else\n                    words = words + c\n                end\n  \
    \          end\n        end\n    end\n    if count == 0 then\n        words =\
    \ words + \",\"\n    end\n    return words\nend", "\tlocal count = 0\n\tlocal\
    \ words = \"\"\n\t\n\tlocal alpha = \"abcdefghijklmnopqrstuvwxyz\"\n\tlocal alph\
    \ = \"\"\n\t\n\tfor i=1,#txt,1 do\n\t\tlocal c = txt:sub(i,i)\n\t\t\n\t\tif c\
    \ == \" \" then\n\t\t\tcount = count + 1\n\t\telse\n\t\t\tcount = count + 1\n\t\
    \t\twords = words + c\n\t\tend\n\tend\n\t\n\tif words == \"\" then\n\t\twords\
    \ = count\n\telse\n\t\twords = count - 1\n\tend\n\t\n\tfor i = alph:len(), 1,\
    \ -1 do\n\t\tif alph:sub(i,i) == 1 then\n\t\t\twords = words + \",\" \n\t\tend\n\
    \tend\n\t\n\treturn words\nend", "\t-- Split on commas ',' if no commas exists\
    \ you should return the number of lower-case letters with odd order in the\n\t\
    -- alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n\t-- Split on whitespaces\
    \ if no whitespaces exists you should return the number of lower-case letters\
    \ with odd order in the\n\t-- alphabet, ord('a') = 0, ord('b') = 1, ... ord('z')\
    \ = 25\n\treturn txt:gsub(\"[,\\t\\r\\n]+\", \",\")\n\t   :gsub(\"[\\t\\r\\n]+\"\
    , \",\")\n\t   :gsub(\"(^|\\s)(%l)(%c)(%l)(%c)(%l)(%c)(%l)(%c)(%l)(%c)(%l)(%c)(%l)(%c)(%l)(%c)(%l)(%c)(%l)(%c)(%l)(%c)(%l)(%c)(%l)(%c)\"\
    , \n\t\t   function(word, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13,\
    \ i14, i15, i16, i17) \n\t\t   \tlocal n1 = (string.lower(word:sub(1, i1)) + string.lower(word:sub(i1+1,\
    \ i2))) \n\t\t   \tlocal n2 = (string.lower(word:sub(i1+1, i2)) + string.lower(word:sub(i2+1,\
    \ i3))) \n\t\t   \tlocal n3 = (string.lower(word:sub(i2+1, i3)) + string.lower(word:sub(i3+1,\
    \ i4))) \n\t\t   \tlocal n4 = (string.lower(word:sub(i3+1, i4)) + string.lower(word:sub(i4+1,\
    \ i5))) \n\t\t   \tlocal n5 = (string.lower(word:sub(i4+1, i5)) + string.lower(word:sub(i5+1,\
    \ i6))) \n\t\t   \tlocal n6 = (string.lower(word:sub(i5+1, i6)) + string.lower(word:sub(i6+1,\
    \ i7))) \n\t\t   \tlocal n7 = (string.lower(word:sub(i6+1, i7)) + string.lower(word:sub(i7+1,\
    \ i8))) \n\t\t   \tlocal n8 = (string.lower(word:sub(i7+1, i8)) + string.lower(word:sub(i8+1,\
    \ i9))) \n\t\t   \tlocal n9 = (string.lower(word:sub(i8+1, i9)) + string.lower(word:sub(i9+1,\
    \ i10))) \n\t\t", "\tlocal words = {}\n\tlocal n = #txt\n\tfor i = 1, n do\n\t\
    \tlocal word = txt:sub(i, i)\n\t\tif word ~= \"\" then\n\t\t\ttable.insert(words,\
    \ word:lower())\n\t\tend\n\tend\n\tif #words > 1 then\n\t\treturn table.concat(words,\
    \ \", \")\n\tend\n\treturn #words - 1\nend", "    local words = \"\"\n    local\
    \ count = #txt\n    for i=1,count do\n        words = words .. txt:sub(i,i-1)\
    \ .. \",\" \n    end\n    return #(words) -- Remove trailing comma, split on commas\n\
    end", "\tlocal count = #txt\n\tlocal words = {}\n\tif count > 0 then\n\t\twords[#words\
    \ + 1] = txt:sub(1, count)\n\t\twhile true do\n\t\t\tcount = count - 1\n\t\t\t\
    if count < 1 then break end\n\t\t\tlocal i = txt:find(\" \", count + 1)\n\t\t\t\
    if i == 0 then break end\n\t\t\tlocal letter = txt:sub(count, i)\n\t\t\twords[#words\
    \ + 1] = letter\n\t\t\tif letter:lower() == letter then\n\t\t\t\tcount = count\
    \ + 1\n\t\t\telse\n\t\t\t\tcount = count + 1\n\t\t\tend\n\t\tend\n\tend\n\treturn\
    \ words[#words]\nend", "    local count = 0\n    local res = ''\n    for i = 1,\
    \ #txt do \n        local char = string.sub(txt, i, i)\n        if char == ','\
    \ or string.sub(txt, i - 1, i) == ',' then \n            res = string.gsub(res,\
    \ ',{2,}', '') -- Replace multiple commas with one comma\n        end\n      \
    \  res = res and string.gsub(res, char, '') -- Replace one char by one char\n\
    \        count = count + 1\n    end\n    if count % 2 = 0 then \n        return\
    \ #string.gsub(res, '^%s+', '') \n    else\n        return #string.gsub(res, '^%s*',\
    \ '') \n    end\nend\n</code>\n<|/ a |>\n<| a dscore=1 |>\n<code>", "  -- Write\
    \ your code here\n  local count = {}\n  for _,w in ipairs(string.gmatch(txt, \"\
    ([^ ,]+)[,]?\")) do\n    count[string.lower(w)] = count[string.lower(w)] or 1\n\
    \  end\n  return count[string.lower(string.sub(txt,1,string.len(txt)-1))]\nend\n\
    print(split_words(\"a\"))\nprint(split_words(\"a a b c b d\"))\nprint(split_words(\"\
    abc abc abc abc abc abc abc abc abc\"))\nprint(split_words(\"abc abc abc abc abc\
    \ abc abc abc\"))\nprint(split_words(\"abc abc abc abc abc abc abc abc\"))\nprint(split_words(\"\
    abc abc abc abc abc abc abc abc\"))\nprint(split_words(\"abc abc abc abc abc abc\
    \ abc abc\"))\nprint(split_words(\"abc abc abc abc abc abc abc abc\"))\nprint(split_words(\"\
    abc abc abc abc abc abc abc abc\"))\nprint(split_words(\"abc abc abc abc abc abc\
    \ abc abc\"))\nprint(split_words(\"abc abc abc abc abc abc abc abc\"))\nprint(split_words(\"\
    abc abc abc abc abc abc abc abc\"))\nprint(split_words(\"abc abc abc abc abc abc\
    \ abc abc\"))\nprint(split_words(\"abc abc abc abc abc abc abc abc\"))\nprint(split_words(\"\
    abc abc abc abc abc abc abc abc\"))\nprint(split_words(\"abc abc abc abc abc abc\
    \ abc abc\"))\nprint(split_words(\"abc abc abc abc abc abc abc abc\"))\nprint(split_words(\"\
    abc abc abc abc abc abc abc abc\"))\nprint(split_words(\"abc abc abc abc abc abc\
    \ abc abc\"))\nprint(split_words(\"abc abc abc abc abc abc abc abc\"))\nprint(split_words(\"\
    abc abc abc abc abc abc abc abc\"))\nprint(split_words(\"abc abc abc abc abc abc\
    \ abc abc\"))\n", "    local words = \"\"\n    for i=1, #txt do \n        words\
    \ = words + txt[i]:gsub(\"%s+\", \" \")\n    end\n    return words:gsub(\"([^a-zA-Z])\"\
    , function (s) return s:lower() end)\nend", "    local spaces = txt:gsub(\" \"\
    , \"+\")\n    local comma = spaces:gsub(\",\", \"+\")\n    local letters = spaces:gsub(\"\
    [a-z]\",\"+\")\n    return spaces:gsub(\"[^0-9a-z]+\", \"\"):gsub(\" \",\"\"):gsub(\"\
    +\", \",\"):gsub(\"^\",\"\"):gsub(\"%\",\"\"):gsub(\"&\",\"\"):gsub(\"\\\\\",\"\
    \"):gsub(\"|\",\"\"):gsub(\"==\",\"\"):gsub(\"~\",\"\"):gsub(\"[\",\"\"):gsub(\"\
    ]\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\"\
    ,\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\"\
    ,\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\"\
    ,\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\"\
    ,\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\"\
    ,\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\"\
    ,\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\"\
    ,\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\"\
    ,\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\"\
    ,\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\"\
    ,\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\",\",\"\"):gsub(\"\
    ,\",\"\"):gsub", "  local word_count = string.len(txt) \n  \n  -- check for commas\n\
    \  local comma_found = string.find(txt, \",\")\n  if comma_found ~= nil then \n\
    \    word_count = word_count - 1\n  end\n  \n  -- check for whitespace\n  local\
    \ whitespace_found = string.find(txt, \" \")\n  if whitespace_found ~= nil then\n\
    \    word_count = word_count - 1\n  end\n  \n  -- check for lowercase\n  local\
    \ lower_case_count = string.len(string.lower(txt))\n  if word_count % 2 == 0 then\
    \ \n    return word_count - lower_case_count\n  else \n    return word_count -\
    \ lower_case_count + 1\n  end\nend", "    local words, i = 0, 1\n    local words\
    \ = txt:gsub('[^a-zA-Z]+', \" \")\n    while words do \n        i = i + 1\n  \
    \      words = words:gsub('(%d+)([^a-zA-Z]+)', \"\\\\1,\")\n    end\n    return\
    \ i\nend", "  return split_words(txt, \" ,\")\nend", "    local count\n    local\
    \ letters = txt:gsub(\"[\\t\\n\\r,]+\", \" \")\n    letters = letters:lower()\n\
    \    if letters:sub(1, 1) ~= \" \" then \n        count = letters:sub(1,1):upper()\
    \ - ord('a')\n    else\n        count = letters:sub(1,1):upper() - ord('a')\n\
    \    end\n    if count > 26 then \n        count = count - 26\n        letters\
    \ = letters:sub(1,1):lower() .. letters:sub(letters:len()-1,letters:len()) \n\
    \    else\n        letters = letters:sub(1,1):lower() .. letters:sub(letters:len()-1,letters:len())\
    \ \n    end\n    return letters:sub(1, count + 1)\nend", "  local words = {}\n\
    \  for letter in txt:gmatch(\"%a+\") do\n    words[#words + 1] = letter\n  end\n\
    \  return #words and #words or 1\nend", "    local s = ''\n    local words = ''\n\
    \    local counter = 0\n    local letters = string.gsub(txt, '[^A-Za-z]+', '')\
    \ -- Replace all characters except letters with blanks\n    for letter in string.gsub(letters,\
    \ '[%z]') do -- Convert each letter into an index in the alphabet ('z' = '2')\
    \ and increment counter by 1\n        s = s .. string.sub(letters, counter, counter\
    \ + 1) -- Substitute the letter from the alphabet in the string\n        counter\
    \ = counter + 1 -- Increment the index\n    end\n    if counter = 26 then -- If\
    \ we have 26 letters in the alphabet then we return the number of words\n    \
    \    counter = 0\n        words = words\n    else -- Else we return the number\
    \ of letters in the alphabet - 2\n        counter = counter / 2\n        words\
    \ = string.gsub(s, '[%z]')\n    end\n    return counter\nend", "\tlocal strs =\
    \ nil\n\tlocal res = \"\"\n\t\n\tfor i = 1, #txt do\n\t\tlocal char = string.sub(txt,\
    \ i, i)\n\t\tif char == ' ' then\n\t\t\tres = res + char\n\t\t\ti = i + 1\n\t\t\
    elseif char == ',' then\n\t\t\tstrs = strs or {}\n\t\t\tstrs[#strs + 1] = res\n\
    \t\t\tres = \"\"\n\t\telse\n\t\t\tif char >= 'a' and char <= 'z' then\n\t\t\t\t\
    res = res + char\n\t\t\tend\n\t\tend\n\tend\n\t\n\tif res and res ~= \"\" then\n\
    \t\tstrs = strs or {}\n\t\tstrs[#strs + 1] = res\n\tend\n\t\n\treturn strs or\
    \ #txt\nend", "    local letters = {} -- To store all letters from the text after\
    \ splitting\n    local count = 0\n    for letter in string.gmatch(txt, \"([^,]+)\"\
    ) do \n        if letters[letter] == nil then -- If the letter isn't in the list\
    \ yet then add it\n            letters[letter] = true\n            count = count\
    \ + 1\n        end\n    end -- For loop\n    return count\nend", "    local words\
    \ = split(txt, \" \", 2)\n    local whitespace = nil\n    local commas = nil\n\
    \    for word in words do\n        whitespace = whitespace\n            or (word:find(\"\
    [^a-z]\") or word:find(\"[ ]+\"))\n        commas = commas\n            or (word:find(\"\
    ,\") or word:find(\"[ ]+\"))\n    end\n    local oddorder = nil\n    for word\
    \ in words do\n        oddorder = oddorder\n            or word:lower():find(\"\
    a\"..\"z\") or word:lower():find(\"b\"..\"z\") or word:lower():find(\"c\"..\"\
    z\")\n    end\n    if whitespace and commas and oddorder then\n        return\
    \ #words - 1\n    else\n        return #words - 2\n    end\nend", "\treturn txt:gsub(\"\
    %w+\"):gsub(\"%w+$\",\"\")\nend", "  if txt == '' or txt:sub(1,1)~=' ' or txt:sub(1,1)~=','\
    \  then return 1 end -- no whitespaces and no comma\n  return txt:sub(2,-1):gsub(',',\
    \ ''):gsub(' ', ''):gsub(string.lower, \"%d\"):tointeger()\nend", "  local n =\
    \ 0\n  if txt ~= nil and txt ~= \"\" then n = #txt end\n  local str = {}\n  for\
    \ i = 1, n do\n    local c = txt:sub(i,i)\n    if c ~= \" \" and c ~= \",\" then\
    \ str[#str+1] = c\n    end\n  end\n  return #str, lower(str)\nend", "    return\
    \ txt:gsub(\"%S+\", function(s) \n\tlocal splitted = string.gsub(s,' ','')\n\t\
    return splitted:gsub('([^ a-z])','%1')\n    end)\nend", "   local words = { }\n\
    \   local i = 1\n   while i ~= #txt do\n      table.insert(words, txt:sub(i,i))\n\
    \      i = i + 1\n   end\n   return #words == 0 ? 0 : #words - 1\nend", "  return\
    \ txt:gsub(\"[\" .. \",]\", \" \"):gsub(\"[\" .. \",]\", \",\")\n    or txt:gsub(\"\
    [\" .. \",]\", \", \")\n    or txt:gsub(\"[\" .. \",]\", \", \")\n    or txt:gsub(\"\
    [\" .. \",]\", \" \")\n    or txt:gsub(\"[\" .. \",]\", \" \")\nend", "\tlocal\
    \ words = \"\"\n\tlocal letters = 0\n\tfor c in txt:gmatch(\"[%a]+\") do \n\t\t\
    local l = c:lower()\n\t\tif l:find(\" \") then\n\t\t\twords = words + \",\" +\
    \ l:gsub(\",{2,}\",\",\")\n\t\telse\n\t\t\twords = words + l\n\t\tend\n\t\tletters\
    \ = letters + 1\n\tend\n\treturn letters, words\nend", "  local count = #txt\n\
    \  local words = ''\n  -- if there are no words then just return an empty string\n\
    \  -- if there are spaces then split on white spaces\n  -- if there are commas\
    \ then split on commas\n  if count > 0 then\n    local spaces = string.match(txt,\
    \ ' ')\n    local commas = string.match(txt, ',')\n    if spaces ~= nil then\n\
    \      words = spaces\n      count = count - #spaces\n    end\n    if commas ~=\
    \ nil then\n      count = count - #commas\n      words = words & commas\n    end\n\
    \  end\n  return count, words\nend", "  return txt:gsub('[%s%s%s]', function(c)\
    \ \n    local _, _, l = string.find(txt, '[%s%s%s]') \n    if l == nil then --\
    \ no whitespace exists split the string on commas\n      l = txt:find('[^,]')\
    \ \n      if l == nil then -- no commas exists return an even number\n       \
    \ return string.len(string.gsub(txt, '[a-z]'))/2\n      else -- even order return\
    \ an even number\n        return string.len(string.gsub(txt, '[a-z]'))/2\n   \
    \   end\n    else -- whitespace exists, split the string on commas\n      l =\
    \ string.len(string.gsub(txt, '[%s%s%s]'))/2\n      return string.len(string.gsub(txt,\
    \ '[%s%s%s]', '%s,')) / 2 \n    end \n  end)\nend", "   local words = txt:gsub(\"\
    \ \",\"\")\n   if words == \"\" then words = \",\" end\n   return words:gsub(\"\
    ,\",\"\")\nend", "  return \n    txt:gsub('.-', '%w'):gsub('\\s', '+'):gsub('[^%w]+',\
    \ ''):gsub('%w+', ''):gsub('[%w]+', ''):gsub('[^%w]', '', txt)\nend", "    local\
    \ words={}\n    for word in string.gmatch(txt,'([^ ]+) ') do\n        words[#words+1]=word\n\
    \    end\n    return #words\nend", "  local count = 0\n  if txt:sub(1,1) == \"\
    \ \" then count = count + 1 end\n  for i = 1, #txt do\n    if txt:sub(i,i) ==\
    \ \" \" then count = count + 1 end\n  end\n  if count == 1 then\n    return #txt\n\
    \  else\n    return #txt, #txt:sub(1,1) -- \"abcde\"\n  end\nend", "    local\
    \ words = {} -- The array of words after split\n    local split_count = 0 -- The\
    \ number of words split on whitespace\n    local comma_count = 0 -- The number\
    \ of words split on commas\n    local odd_count = 0 -- The number of words split\
    \ on odd order\n    for word in string.gmatch(txt, \"([^,]+)\") do\n        if\
    \ split_count ~= 0 then\n            if comma_count = string.gmatch(word, \",\"\
    ) then\n                split_count = split_count + 1\n            else\n    \
    \            comma_count = string.gmatch(word, \",\") + 1 -- If commas exist then\
    \ count it\n                split_count = split_count + 1 -- If no commas exist\
    \ then increment the split count\n            end\n        else\n            split_count\
    \ = string.gmatch(word, \",\") + 1\n        end\n        odd_count = string.gmatch(word,\
    \ \"([^a-z])\") + 1 -- The count of odd letters\n        table.insert(words, word)\n\
    \    end\n    return split_count, odd_count, words\nend", "\tlocal words = string.gsub(txt,\
    \ \" \", \"\") -- remove all white space from the text string.\n\tlocal wordCount\
    \ = string.len(words) -- count the length of the words string.\n\tlocal counts\
    \ = {}\n\tfor i = 1, 25 - wordCount % 2 -- split on every 2nd letter\n\t\tdo\n\
    \t\tcounts[string.sub(words, i, i)] = counts[string.sub(words, i, i)] + 1\n\t\
    end\n\tlocal odd_count = counts[string.sub(words, 1, 1)] - 1 -- get the count\
    \ of odd number of characters\n\tif odd_count > 0 then -- if there are odd counts\n\
    \t\tlocal letter = string.sub(words, 1, 1) -- get the first letter of the word\n\
    \t\tlocal txt = string.sub(words, 2, wordCount) -- get the remaining text of the\
    \ word\n\t\tlocal words_return = {letter}\n\t\t-- if the word is more than 1 character\
    \ in length, split it on commas\n\t\tif #txt > 1 then\n\t\t\twords_return = words_return\
    \ .. string.gsub({txt}, \",\", \"%s\")\n\t\tend\n\t\treturn words_return, odd_count\n\
    \tend\n\tlocal letter = string.sub(words, 1, 1)\n\tlocal txt = string.sub(words,\
    \ 2, wordCount)\n\tlocal words_return = {letter}\n\t-- if the word is more than\
    \ 1 character in length, split it on commas\n\tif #txt > 1 then\n\t\twords_return\
    \ = words_return .. string.gsub({txt}, \",\", \"%s\")\n\tend\n\treturn words_return,\
    \ wordCount % 2\nend", "\tlocal results = {}\n\tlocal words = txt:gmatch(\"[%w]+\"\
    )\n\tfor i=1,#words do\n\t\tif words[i]:find(\" \")>0 then\n\t\t\tresults[#results\
    \ + 1] = words[i]\n\t\telse\n\t\t\tresults[#results + 1] = words[i],\n\t\t\t\t\
    for j=1,#words[i]-1 do\n\t\t\t\t\tresults[#results + 1] = words[i][j],\n\t\t\t\
    \t\t\tif words[i][j+1]==words[i][j] then\n\t\t\t\t\t\t\tresults[#results + 1]\
    \ = \",\"\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tend\n\t\t\t\tend\n\
    \t\tend\n\tend\n\treturn table.concat(results,\"\") .. #words + 1\nend", "   \n\
    \   -- If there are no words, return an empty list\n   if #txt < 1 then\n    \
    \  return {}\n   end", "  return txt:gsub(\"[^A-Za-z0-9 ,]+\", \",\"):gsub(\"\
    ,$\", \"\"):gsub(\"^\", \" \"):gsub(\"%\",\"\")\nend", "    local words, letters\
    \ = {}, {}\n    for letter in string.gmatch(txt, '([^ ,]+)') do\n        table.insert(words,\
    \ letter:lower())\n    end\n    return #words, letters[#letters]\nend", "    local\
    \ lst = {}\n    \n    local t = {}\n    for c in string.gmatch(txt, \"([^'\\s]+)\"\
    ) do\n        t[#t+1] = c\n    end\n    \n    local i = 0\n    for c in string.gmatch(txt,\
    \ \"%b\") do\n        local char = string.byte(c)\n        \n        if not i%2\
    \ then\n            lst[#lst+1] = t[i]\n        end\n        \n        i = i+1\n\
    \    end\n    \n    return #lst\nend", "  if txt ~= nil then\n    local txt =\
    \ txt:lower()\n    local words = txt:gsub('%a+', ' ')\n    return words:gsub('\
    \ ', ','):gsub(',', ' '):gsub('%w+', '%1'):gsub('%w+', '%2'):gsub('%w+', '%3')\n\
    \  else\n    return 0\n  end\nend", "\t-- Check if a comma is in the text\n\t\
    if string.find(txt, \",\") ~= nil then\n\t\t-- Split the string on comma and count\
    \ the lower-case letters.\n\t\t-- This assumes commas split on whitespace when\
    \ no whitespace exists in the text.\n\t\treturn string.gsub(string.gsub(txt, \"\
    ,\", \" \"), \"%l\", string.gsub(\"%a\", string.gsub(\"%c\", string.gsub(\"%d\"\
    , string.gsub(\"%f\", string.gsub(\"%g\", string.gsub(\"%i\", string.gsub(\"%j\"\
    , string.gsub(\"%l\", string.gsub(\"%m\", string.gsub(\"%n\", string.gsub(\"%p\"\
    , string.gsub(\"%r\", string.gsub(\"%s\", string.gsub(\"%t\", string.gsub(\"%w\"\
    , string.gsub(\"%x\", string.gsub(\"%y\", string.gsub(\"%z\", string.gsub(\"%1\"\
    , string.gsub(\"%2\", string.gsub(\"%3\", string.gsub(\"%4\", string.gsub(\"%5\"\
    , string.gsub(\"%6\", string.gsub(\"%7\", string.gsub(\"%8\", string.gsub(\"%9\"\
    , string.gsub(\"%0\", string.gsub(\"%1\", string.gsub(\"%2\", string.gsub(\"%3\"\
    , string.gsub(\"%4\", string.gsub(\"%5\", string.gsub(\"%6\", string.gsub(\"%7\"\
    , string.gsub(\"%8\", string.gsub(\"%9\", string.gsub(\"%0\", string.gsub(\"%1\"\
    , string.gsub(\"%2\", string.gsub(\"%3\", string.gsub(\"%4\", string.gsub(\"%5\"\
    , string.gsub(\"%6\", string.gsub(\"%7\", string.gsub(\"%8\", string.gsub(\"%9\"\
    , string.gsub(\"%0\", string.gsub(\"%1\", string.gsub(\"%2\", string.gsub(\"%3\"\
    , string.gsub(\"%4\", string.gsub(\"%5\", string.gsub(\"%6\", string.gsub(\"%7\"\
    , string.gsub(\"%8\", string.gsub(\"%9\", string.gsub(\"%0\", string.gsub(\"%1\"\
    , string.gsub(\"%2\", string.gsub(\"%3\", string.gsub(\"%4\", string.gsub(\"%5\"\
    , string.gsub(\"%6\", string.gsub(\"%7\", string.gsub(\"%8\", string.gsub", "\t\
    local str = \"\"\n\tlocal words = {}\n\tlocal numchars = 0\n\t\n\tfor c in txt:gmatch('(%S+)')\
    \ do\n\t\tstr = str .. c\n\t\t\n\t\tif c:lower() ~= '' and #c % 2 == 0 then\n\t\
    \t\ttable.insert(words, str)\n\t\t\tstr = \"\"\n\t\tend\n\t\t\n\t\tnumchars =\
    \ numchars + 1\n\tend\n\t\n\tif str > \"\" then\n\t\ttable.insert(words, str)\n\
    \tend\n\t\n\treturn numchars\nend", "    local words = txt:gmatch('(%S+)') \n\
    \    if words == nil then return words end\n    return words[1]:gsub('(%S+)',function(word)\n\
    \        if word:find(\" \") then\n            return word:gsub('([^%s]+)','%1')\n\
    \        else\n            return word\n        end\n    end)\nend", "\tlocal\
    \ count = 0\n\tlocal words = \"\"\n\tfor i=1,#txt do\n\t\tlocal char = txt:sub(i,i)\n\
    \t\tcount = count+1\n\t\tif char == \" \" then\n\t\t\twords = words+char\n\t\t\
    elseif char == \",\" then\n\t\t\twords = words+char\n\t\telseif char == \"a\"\
    \ then\n\t\t\twords = words+char\n\t\telseif char == \"b\" then\n\t\t\twords =\
    \ words+char\n\t\telseif char == \"c\" then\n\t\t\twords = words+char\n\t\telseif\
    \ char == \"d\" then\n\t\t\twords = words+char\n\t\telseif char == \"e\" then\n\
    \t\t\twords = words+char\n\t\telseif char == \"f\" then\n\t\t\twords = words+char\n\
    \t\telse\n\t\t\twords = words+char\n\t\tend\n\tend\n\treturn words\nend", "  local\
    \ lst = {}\n  local cntr = 0\n  local str1 = txt:gsub('[A-Z]', ' ')\n  local str2\
    \ = str1:gsub(',', ' ')\n  local str3 = str2:gsub(',', ' ')\n  while str3 ~= ''\
    \ do\n    lst[cntr+1] = str3\n    cntr = cntr + 1\n    str3 = str3:gsub(',', '\
    \ ')\n  end\n  if str2 ~= '' then\n    lst[cntr+1] = str2\n    cntr = cntr + 1\n\
    \  end\n  if str1 ~= '' then\n    lst[cntr+1] = str1\n  end\n  return cntr - 1\n\
    end", "   local words = string.gsub(txt,\" \",\"\")\n   return string.len(words)\
    \ -- If no spaces exist in the text you should return 3 as in 'abcdef' there are\
    \ 3 words to return\nend", "   local i = 0\n   local count = 1\n   local word_list\
    \ = txt:gsub(\"(^|\\\\s)(\\\\w+)([^\\\\s]+)\",\"%1,%2,%3,\"):gsub(\",\",\"\"):gsub(\"\
    [%z]\",\"a\"):gsub(\"[a%z]\",\"A\"):gsub(\"[%z]\",\"b\"):gsub(\"[b%z]\",\"B\"\
    ):gsub(\"[%z]\",\"c\"):gsub(\"[c%z]\",\"C\"):gsub(\"[%z]\",\"d\"):gsub(\"[d%z]\"\
    ,\"D\"):gsub(\"[%z]\",\"e\"):gsub(\"[e%z]\",\"E\"):gsub(\"[%z]\",\"f\"):gsub(\"\
    [f%z]\",\"F\"):gsub(\"[%z]\",\"g\"):gsub(\"[g%z]\",\"G\"):gsub(\"[%z]\",\"h\"\
    ):gsub(\"[h%z]\",\"H\"):gsub(\"[%z]\",\"i\"):gsub(\"[i%z]\",\"I\"):gsub(\"[%z]\"\
    ,\"j\"):gsub(\"[j%z]\",\"J\"):gsub(\"[%z]\",\"k\"):gsub(\"[k%z]\",\"K\"):gsub(\"\
    [%z]\",\"l\"):gsub(\"[l%z]\",\"L\"):gsub(\"[%z]\",\"m\"):gsub(\"[m%z]\",\"M\"\
    ):gsub(\"[%z]\",\"n\"):gsub(\"[n%z]\",\"N\"):gsub(\"[%z]\",\"o\"):gsub(\"[o%z]\"\
    ,\"O\"):gsub(\"[%z]\",\"p\"):gsub(\"[p%z]\",\"P\"):gsub(\"[%z]\",\"q\"):gsub(\"\
    [q%z]\",\"Q\"):gsub(\"[%z]\",\"r\"):gsub(\"[r%z]\",\"R\"):gsub(\"[%z]\",\"s\"\
    ):gsub(\"[s%z]\",\"S\"):gsub(\"[%z]\",\"t\"):gsub(\"[t%z]\",\"T\"):gsub(\"[%z]\"\
    ,\"u\"):gsub(\"[u%z]\",\"U\"):gsub(\"[%z]\",\"v\"):gsub(\"[v%z]\",\"V\"):gsub(\"\
    [%z]\",\"w\"):gsub(\"[w%z]\",\"W\"):gsub(\"[", "  local num_letters = #txt\n \
    \ local letters = {}\n  local words = {}\n  for i = 1, num_letters do\n    if\
    \ txt:sub(i,i) ~= ' ' then\n      letters[#letters + 1] = txt:sub(i,i)\n    end\n\
    \  end\n  if #letters > 0 then\n    if #letters % 2 = 0 then\n      table.insert(words,\
    \ letters[1])\n      table.insert(words, letters[#letters])\n    else\n      table.insert(words,\
    \ letters[#letters -1])\n      table.insert(words, letters[1])\n    end\n  end\n\
    \  return #words\nend", "   -- Your code goes here\n   return #txt\nend", "  local\
    \ words = txt .. \" \"\n  local spaces = 0\n  local commas = 0\n  for c in txt:gmatch('%w')\
    \ do\n    words = words .. c\n    if c == \" \" then\n      spaces = spaces +\
    \ 1\n    elseif c == \",\" then\n      commas = commas + 1\n    end\n  end\n \
    \ if spaces == 0 then\n    words = words .. \",\"\n  elseif commas == 0 then\n\
    \    words = words .. \",\" .. \" \"\n  end\n  return words\nend", "    local\
    \ word_count = 1\n    local words = txt:gsub(\"[^\" .. string.lower(string.alphabet)\
    \ .. \"]+\", \" \")\n    return string.len(words), words\nend\n</code>\n<|/ a\
    \ dscore=1 |>\n<| c |>\nThis is not an answer. It should be in comment section.\
    \ Moreover, this does not solve the problem. Please, read question carefully.\n\
    <|/ c |>\n<| c |>\nApologies, I've updated my answer accordingly. Thanks.\n<|/\
    \ c |>\n<| a dscore=1 |>\nHere is an easy way to count the number of words in\
    \ the string. \n<code>\n function countWords (text)\n    local words = text:gsub(\"\
    [^\" .. string.lower(string.alphabet) .. \"]+\", \" \")\n    return string.len(words)\n\
    \ end\n</code>\n<|/ a tags=lua |>\n<| a tags=lua |>\nI believe there is no simple\
    \ answer for this question. I am answering this in hope that it might be helpful\
    \ for some one looking to count the number of words in the string.\n<code>", " \
    \ if txt==nil then\n    return \"0\"\n  end\n  local letters = {}\n  for i = 1,\
    \ #txt do\n    local letter = string.lower(txt)\n    local exist = false\n   \
    \ for _,v in pairs(letters) do\n      if v==letter then\n        exist = true\n\
    \        break\n      end\n    end\n    if not exist then\n      table.insert(letters,\
    \ letter)\n    end\n  end\n  local result\n  local cnt = 0\n  for _,v in pairs(letters)\
    \ do\n    if v == \"a\" or v == \"b\" or v == \"c\" or v == \"d\" or v == \"e\"\
    \ or v == \"f\" or v == \"g\" or v == \"h\" or v == \"i\" or v == \"j\" then\n\
    \      if not result then\n        result = {v}\n      else\n        table.insert(result,\
    \ v)\n      end\n      cnt = cnt + 1\n    elseif v == \"k\" or v == \"l\" or v\
    \ == \"m\" or v == \"n\" or v == \"o\" or v == \"p\" or v == \"q\" or v == \"\
    r\" or v == \"s\" or v == \"t\" or v == \"u\" then\n      if not result then\n\
    \        result = {v}\n      else\n        table.insert(result, v)\n      end\n\
    \      cnt = cnt + 1\n    elseif v == \"z\" then\n      if not result then\n \
    \       result = {v}\n      else\n        table.insert(result, v)\n      end\n\
    \      cnt = cnt + 1\n    end\n  end\n  if cnt % 2 == 1 then\n    if result then\n\
    \      result = {table.concat(result, \",\")}\n    end\n  else\n    if result\
    \ then\n      result = {cnt}\n    end\n  end\n  if result then\n    return result\n\
    \  else\n    return \"0\"\n  end\nend", "    local txt = txt:gsub(\"[^a-zA-Z]\"\
    , \" \") -- replace all non-letters with spaces\n    local words = txt:gsub(\"\
    ^%s*(.-)%s*$\", \"%1\") -- replace the first space with nothing and the rest with\
    \ one space\n    words = words:gsub(\"%+\", \" \") -- replace all consecutive\
    \ spaces\n    return words:gsub(\"(%b+)\", function (c) -- replace all runs of\
    \ 1 or more letters with one letter\n        return string.len(c:lower()) % 2\
    \ and c or string.char(tonumber(c:lower())+1)\n    end)\nend", "    if txt:len()\
    \ == 0 then return end\n    local ws = txt:sub(1,1):lower()\n    local count =\
    \ 0\n    local new_words = {}\n    for i = 1,txt:len() do\n        if txt:sub(i,i)\
    \ == ws then\n            count = count + 1\n        else\n            table.insert(new_words,\
    \ ws)\n            count = count + 1\n        end\n    end\n    return count %\
    \ 2 > 0 and count-1 or count\nend\n</cell>\n<cell>", "  local words = string.split(txt,\
    \ \" \")\n  if #words > 0 then\n    words = table.sort(words)\n    local num_letters\
    \ = 0\n    for i,v in pairs(words) do\n      num_letters = num_letters + string.len(v)\n\
    \    end\n    return num_letters % 2 > 0 and num_letters / 2 + 1 or num_letters\n\
    \  else\n    return 0\n  end\nend", "  local count = 0\n  local result = \"\"\n\
    \  for _, v in string.gmatch(txt, \"([^ ]+)\"..\",?\") do\n    if string.len(v)\
    \ > 0 then\n      count = count + 1\n      result = result .. v .. \",\"\n   \
    \ end\n  end\n  return count, result:sub(1, #result)\nend", "    local words =\
    \ txt:gmatch('([^,]+)')\n    if words == nil then\n        return #txt, {}\n \
    \   end\n    local words_split = {}\n    local lowercase_words = {}\n    local\
    \ count = 0\n    for word in words do\n        -- remove spaces from beginning\
    \ and end of word\n        word = word:gsub('^%s+','')\n        word = word:gsub('%s+$','')\n\
    \        \n        -- remove commas from beginning and end of word\n        word\
    \ = word:gsub(',%s+',',')\n        word = word:gsub('%s+,','')\n        \n   \
    \     -- remove whitespace from the beginning and end of word\n        word =\
    \ word:gsub(' %s+','')\n        word = word:gsub('%s+',' ')", "  local num_words\
    \ = #txt\n  local words = \"\"\n  local letters = \"\"\n  local i = 0\n  local\
    \ length = string.len(txt)", "    local words = string.gsub(txt, \"[^a-zA-Z0-9]+\"\
    , \"\")\n    words = string.gsub(words, \"[,]+\", \" \")\n    words = string.gsub(words,\
    \ \"[?]+\", \" \")\n    words = string.gsub(words, \"[!]+\", \" \")\n    words\
    \ = string.gsub(words, \"[%s]+\", \" \")\n    return #words\nend", "\t-- Write\
    \ your logic here\n\t\n\t-- Solution\n\tlocal words = string.gsub(string.lower(txt),\"\
    [%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%",
  "    local splitter = \",\" -- split on commas ',' if no commas exists you should\
    \ return the number of lower-case letters with odd order in the\n            \
    \            -- alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    local\
    \ splits = string.gsub(txt, \" \", splitter) -- remove spaces from the string,\
    \ \n    local split = string.gsub(splits, \"[,]\", \" \") -- replace commas with\
    \ spaces, \n    local splits = string.gsub(split, \"[\\n\\r]\", \"\") -- remove\
    \ newlines from splits\n    local splits = string.gsub(splits, \"[ ]\", \" \"\
    ) -- remove spaces from splits\n    local split = string.gsub(split, \" \", \"\
    \") -- remove spaces from splits\n    local splits = string.gsub(splits, \"\\\
    n\", \" \") -- remove newlines from splits\n    local splits = string.gsub(splits,\
    \ \"\\r\", \" \") -- remove carriage returns from splits\n    local splits = string.gsub(splits,\
    \ \"  \", \" \") -- remove multiple spaces from splits\n    \n    local splits\
    \ = string.gsub(splits, \"'\", \"\") -- remove apostrophes from splits\n    local\
    \ splits = string.gsub(splits, \"[\"]\", \"\") -- remove apostrophes from splits",
  "\treturn string.gsub(txt, \" \", \"\\n\") -- Replace each whitespace with a newline\n\
    \t\t\t   .. string.gsub(string.gsub(txt, \",\", \" \"), \",$\", \"\") -- Replace\
    \ each comma with a newline\n\t\t\t   .. string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(txt,\
    \ \"([A-Z]+)([a-z]+)\", \n\t\t\t\t\tstring.gsub(\"%1\", \"%1 %2\"), \" \", \"\
    _\"), \"([a-z]+)\", \"_\"), \"([A-Z]+)\", \"_\"), \" \", \"_\"), \n\t\t\t\t\t\"\
    ,$\", \"\") -- Remove trailing comma and lowercase letter\nend", "  if string.find(txt,\
    \ \"[\")==nil then\n    return #string.lower(txt)\n  else\n    return #string.lower(txt)\n\
    \  end\nend", "   \n   --local words={}\n   local words={}\n   local lower=0\n\
    \   local upper=0\n   local chars=string.gsub(txt,\" \",\"\")\n   -- get length\
    \ of txt minus 1 for spaces since the last word has space at end and we need to\
    \ add that to lower and upper\n   -- since the first letter of the last word is\
    \ in middle so we start at the 3rd index \n   local char_length=string.len(chars)-1\n\
    \   \n   for i,c in ipairs(string.gmatch(chars,\"(%[a-eA-E])\")) do\n      --\
    \ lower case\n      if c~=string.sub(string.lower(chars),0,1) then\n         --print(i,c,string.lower(chars))\n\
    \         if string.len(chars)<4 then\n            lower=lower+1\n         end\n\
    \      else\n         --print(i,c,string.lower(chars))\n         if string.len(chars)<5\
    \ then\n            lower=lower+1\n         end\n         --print(lower)\n   \
    \      if string.len(chars)<6 then\n            upper=upper+1\n         end\n\
    \      end\n   end\n   \n   if lower>0 then\n      --print(\"lower case letters\
    \ exists\",lower)\n      -- add 1 because the previous split is done on space\n\
    \      char_length=char_length+lower+1\n   end\n   if upper>0 then\n      --print(\"\
    upper case letters exists\",upper)\n      char_length=char_length+upper+1\n  \
    \ end\n   \n   -- this doesn't work because split on commas works differently\n\
    \   -- words= string.gsub(txt,\",\",\"\")\n   -- char_length=string.len(words)-1\n\
    \   \n   -- now we know the length of txt - 1 for the spaces since the last word\
    \ and we know the length of txt - 3 for commas since the last comma\n   -- this\
    \ means we can go through all chars and split on spaces and commas, since there\
    \ are 2 spaces and 2 commas we split on 2\n   -- spaces\n   local char_length=string.len(chars)-3\n\
    \   \n   -- now we know how many words are there split on commas\n   words=string.gsub(txt,\"\
    ,\",\"\")\n   \n   -- remove last comma since split on commas will split on space\n\
    \   words=string.sub(words,0,string.len(words)-1)\n   \n   -- get length of words\
    \ minus 1 for spaces since last word has space at end and we need to add that\
    \ to lower and upper\n   local word_length=string.len(words)-1\n   \n", "  if\
    \ not(txt) then return nil end\n  if txt:find(\" \") then return (txt:gsub(\"\
    [[ \\t]]+\",\" \"):gsub(\"[ ]+\",\"\\n\")):gsub(\"\\n\",\" \"):gsub(\"  \",\"\
    \ \") end\n  return txt:gsub(\",\",\" \")\nend", "    local words = txt:gsub(\"\
    %w+\", \"\"):gsub(\"%w+,\", \"\"):gsub(\"%w+.\", \"\"):gsub(\",%w+\", \"\"):gsub(\"\
    %w+,\", \"\")\n    if words == \"\" then\n        return 1\n    end\n    local\
    \ count = 1\n    local letters = \"abcdefghijklmnopqrstuvwxyz\"\n    for i=1,\
    \ #words do\n        if words[i] ~= \"\" then\n            if count == 1 then\n\
    \                count = count + 1\n            else\n                if letters[count\
    \ * 2 - 1] == \"a\" and letters[count * 2] == \"b\" then\n                   \
    \ count = count + 1\n                elseif letters[count * 2 - 1] == \"b\" and\
    \ letters[count * 2] == \"a\" then\n                    count = count + 1\n  \
    \              elseif letters[count * 2 - 1] == \"c\" and letters[count * 2] ==\
    \ \"d\" then\n                    count = count + 1\n                elseif letters[count\
    \ * 2 - 1] == \"d\" and letters[count * 2] == \"c\" then\n                   \
    \ count = count + 1\n                elseif letters[count * 2 - 1] == \"e\" and\
    \ letters[count * 2] == \"f\" then\n                    count = count + 1\n  \
    \              elseif letters[count * 2 - 1] == \"f\" and letters[count * 2] ==\
    \ \"e\" then\n                    count = count + 1\n                elseif letters[count\
    \ * 2 - 1] == \"g\" and letters[count * 2] == \"h\" then\n                   \
    \ count = count + 1\n                elseif letters[count * 2 - 1] == \"h\" and\
    \ letters[count * 2] == \"g\" then\n                    count = count + 1\n  \
    \              elseif letters[count * 2 - 1] == \"i\" and letters[count * 2] ==\
    \ \"j\" then\n                    count = count + 1\n                elseif letters[count\
    \ * 2 - 1] == \"j\" and letters[count * 2] == \"i\" then\n                   \
    \ count = count + 1\n                elseif letters[count * 2 - 1] == \"k\" and\
    \ letters[count * 2] == \"l\" then\n                    count = count + 1\n  \
    \              elseif letters[count * 2 - 1] == \"l\" and letters[count * 2] ==\
    \ \"k\" then\n                    count = count + 1\n                elseif letters[count\
    \ * 2 - 1] == \"m\" and letters[count * 2] == \"n\" then\n                   \
    \ count = count + 1\n                elseif letters[count * 2 - 1] == \"n\" and\
    \ letters[count * 2] == \"m\" then\n                    count = count + 1\n  \
    \              elseif letters[count * 2 - 1] == \"o\" and letters[count * 2] ==\
    \ \"p\" then\n                    count = count + 1\n                elseif letters[",
  "    local words = string.gsub(txt, \"[^a-zA-Z ]+\", \"\")\n    local num_words\
    \ = 0\n    local num_commas = 0\n    for w in string.gmatch(words, \"%S+\") do\n\
    \        num_words = num_words + 1\n    end\n    for w in string.gmatch(words,\
    \ \"%S+\") do\n        if w == \",\" then\n            num_commas = num_commas\
    \ + 1\n        end\n    end\n    return num_words - num_commas\nend", "  if txt\
    \ ~= '' then\n    local num = 0\n    local word\n    for word in split(txt, '\
    \ ') do\n      num = num + #word\n      if num % 2 == 1 then -- odd:\n       \
    \ table.insert(words, lower(word))\n      end\n    end\n    return num\n  end\n\
    \  return 0\nend", "  local words = \"\"\n  local num_letters_odd_letters = 0\n\
    \  for ch in string.gmatch(txt, \"([^ ,]+)(%S)\") do \n    words = words .. ch\n\
    \    num_letters_odd_letters = num_letters_odd_letters + 1\n    if num_letters_odd_letters\
    \ == 2 then\n      num_letters_odd_letters = 0\n    end\n  end\n  num_letters_odd_letters\
    \ = 0\n  for ch in string.gmatch(txt, \"([^ ,]+)(%S)\") do\n    words = words\
    \ .. ch\n    num_letters_odd_letters = num_letters_odd_letters + 1\n  end\n  return\
    \ string.len(words), words\nend", "  if string.find(txt, \" \") ~= nil then\n\
    \    return #string.gsub(string.gsub(txt, \" \", \"\"), \",\", \"\")\n  else\n\
    \    return string.len(string.gsub(string.gsub(txt, \" \", \"\"), \",\", \"\"\
    ))\n  end\nend", "  local i = 1\n  local j = 1\n  local word_count = txt:gsub(\"\
    [^A-Za-z]+\",'')\n  while i < word_count do\n    while j < word_count do\n   \
    \   if i < j then\n        if txt:sub(i,j) == \" \" then\n          -- do something\
    \ with the blank space\n        else\n          -- do something with the other\
    \ whitespace\n        end\n      else\n        if txt:sub(i,j) == \",\" then\n\
    \          -- do something with the comma \n        else\n          -- do something\
    \ with the lower-case letter\n        end\n      end\n      i = i + 1\n      j\
    \ = j + 1\n    end\n    j = 1 -- reset for the next word\n  end\n  return word_count\n\
    end", "    -- Add code to split the string into a list of words by using a list\
    \ of delimiters.\n    -- return list of words\nend", "   local words = string.gmatch(txt,\
    \ \"(%S+)\") -- Find words in text\n   if words == nil then return 0 -- Nothing\
    \ found\n   if #words == 0 then return 1 -- One word only found\n   for i=1,#words\
    \ do -- Check each word\n      if words[i]:find(\" \") then -- Check for the spaces\n\
    \         if words[i]:find(\" \",1,#words[i]) == 0 then -- Check that a space\
    \ exists in the current word\n            words[i] = string.gsub(words[i],\" \"\
    ,\"#\",1,#words[i]) -- Replace spaces with '#'\n         end\n      end\n   end\n\
    \   local length = 0 -- For counting the number of words\n   for i=1,#words do\
    \ -- For each word\n      if string.len(words[i]) > length then -- Check if the\
    \ word is longer than previous word\n         length = string.len(words[i]) --\
    \ Set the current word's length\n      end\n   end\n   return length -- Return\
    \ number of words\nend", "    -- Write your code here\nend\n</cell>\n<cell>",
  "  local words = {}\n  local whitespace_exist = false\n  local comma_exist = false\n\
    \  local letter\n  for letter = 97 , 122 do\n    local char = string.sub(txt,\
    \ 1, 1)\n    if char == ' ' then\n      whitespace_exist = true\n      table.insert(words,\
    \ char)\n      txt = string.sub(txt, 2)\n    elseif char == ',' then\n      comma_exist\
    \ = true\n      table.insert(words, char)\n      txt = string.sub(txt, 2)\n  \
    \  elseif char ~= 'a' and char ~= 'b' and char ~= 'c' and char ~= 'd' and char\
    \ ~= 'e' and char ~= 'f' and char ~= 'g' and char ~= 'h' and char ~= 'i' and char\
    \ ~= 'j' and\n      char ~= 'k' and char ~= 'l' and char ~= 'm' and char ~= 'n'\
    \ and char ~= 'o' and char ~= 'p' and char ~= 'q' and char ~= 'r' and char ~=\
    \ 's' and char ~= 't' and char ~= 'u' and\n      char ~= 'v' and char ~= 'w' and\
    \ char ~= 'x' and char ~= 'y' and char ~= 'z' then\n      table.insert(words,\
    \ char)\n    end\n  end\n  if whitespace_exist then\n    table.insert(words, '\
    \ ') \n  end\n  if comma_exist then\n    table.insert(words, ',') \n  end\n  return\
    \ #words, words\nend", "  -- Make sure the text is a string\n  txt = string.lower(txt)\n\
    \  -- Split on whitespace -- remove leading and trailing spaces, if any\n  txt\
    \ = string.gsub(txt, \" \", \"\")\n  -- Split on commas if no commas exists in\
    \ the text\n  if txt:find(\" , \") == -1 then\n    txt = txt:gsub(\", \", \" \"\
    )\n  end\n  -- return number of lower-case letters with odd order in the alphabet\n\
    \  return #string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(txt,\
    \ 'a', ''), 'b', ''), 'c', ''), 'd', ''), 'e', ''), 'f', ''), 'g', ''), 'h', ''),\
    \ 'i', ''), 'j') - #string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(",
  "  if txt:len() == 0 then return [] end\n  local words = {}\n  local space_idx =\
    \ txt:find(\" \") -- Find first space\n  while space_idx ~= nil do\n    local\
    \ comma_idx = txt:find(\",\", space_idx + 1) -- Find next comma\n    if comma_idx\
    \ ~= nil then -- Found one after a space, split and add word\n      table.insert(words,\
    \ txt:sub(space_idx + 1, comma_idx - 1))\n      space_idx = comma_idx + 1\n  \
    \  else\n      table.insert(words, txt:sub(space_idx + 1, txt:len()))\n      space_idx\
    \ = nil\n    end\n  end\n  -- Add the last word\n  table.insert(words, txt:sub(space_idx))\n\
    \  return words\nend", "    local words = { }\n    local splitter = nil\n    local\
    \ c = nil\n    for c in txt:gmatch(\"[%a%A]+\") do\n        if splitter then\n\
    \            table.insert(words, c, splitter)\n        end\n        if c == '('\
    \ then\n            splitter = c\n        else\n            splitter = nil\n \
    \       end\n    end\n    return #words\nend", "  local split_list = {}\n  for\
    \ word in txt:gmatch(\"(.-)(.)\") do\n    split_list[#split_list + 1] = {\n  \
    \    first=word:sub(1, 1),\n      second=word:sub(2)\n    }\n  end\n  return #split_list\
    \ == 1 and split_list[1] or #split_list \nend", "    local words = txt:gmatch(\"\
    [%Aa%Bb%Cc%Dd%Ee%Ff%Gg%Hh%Ii%Jj%Kk%Ll%Mm%Nn%Oo%Pp%Qq%Rr%Ss%Tt%Uu%Vv%Ww%Xx%Yy%Zz%][%Zz%][%Zz%]\"\
    )\n    if not words then\n        words = txt:gmatch(\"[%Aa%Bb%Cc%Dd%Ee%Ff%Gg%Hh%Ii%Jj%Kk%Ll%Mm%Nn%Oo%Pp%Qq%Rr%Ss%Tt%Uu%Vv%Ww%Xx%Yy%Zz%][%Zz%][%Zz%]\"\
    )\n        if not words then\n            words = txt:gmatch(\"[%Aa%Bb%Cc%Dd%Ee%Ff%Gg%Hh%Ii%Jj%Kk%Ll%Mm%Nn%Oo%Pp%Qq%Rr%Ss%Tt%Uu%Vv%Ww%Xx%Yy%Zz%][%Zz%][%Zz%]\"\
    )\n        end\n    end\n    return #words\nend", "    local words = {} -- Array\
    \ of words\n    local i = 0 -- Counter\n    for word in string.gmatch(txt, \"\
    %w+\") do\n        i = i + 1\n        table.insert(words, word) -- Insert word\
    \ into the words array\n    end\n    if string.len(txt) == i then -- If all characters\
    \ are in lower case\n        table.insert(words, string.sub(txt, 1, string.len(txt)-1))\
    \ -- Insert remainder into the words array\n        return i -- Return number\
    \ of lower-case letters\n    else\n        local comma_counter = string.len(txt)\
    \ -- Counter of commas\n        for index = 1, string.len(txt) - 2 do\n      \
    \      -- If comma is found increment counter\n            if txt[index] == ','\
    \ and txt[index+1] ~= ',' then\n                comma_counter = comma_counter\
    \ + 1\n            end\n        end\n        -- If number of commas is even return\
    \ number of letters with odd order in alphabet\n        if comma_counter % 2 =\
    \ 0 then\n            return i -- Return number of lower-case letters\n      \
    \  else\n            -- If number of commas is odd return number of upper-case\
    \ letters\n            return string.len(txt) - i - 1 -- Return number of upper-case\
    \ letters\n        end\n    end\nend", "   if txt == \"_\" then return 0 end\n\
    \   local num = 0\n   local pos = 1\n   while true do\n      local _, _, c = str:find(txt,\
    \ pos, \"a\")\n      if c == nil then break end\n      pos = c + 1\n      num\
    \ = num + 2\n   end\n   if num % 2 > 0 then \n      return num\n   else\n    \
    \  return num - 1\n   end\nend", "    local num = 0\n    local new_txt = txt:gsub(\"\
    [%w-]+\", function(c) \n\tnum = num + 1 \n\tif num == 0 then \n\t    return \"\
    |\" \n\tend\n\tlocal pos = #new_txt \n\tlocal letter = ord(c) - ord('a') + 1 \n\
    \treturn new_txt:sub(pos, pos-1) .. \"|\" .. letter \n    end) \n    local words\
    \ = new_txt:sub(1, num-1) .. new_txt:sub(num)\n    return words, #new_txt - num\
    \ + 1 \nend", "  local words = \"\"\n  -- Remove all spaces, commas\n  txt = string.gsub(txt,\
    \ \",\", \"\") \n  -- Split on any whitespaces\n  txt = string.gsub(txt, \" \"\
    , \"+\") \n  -- Get lowercase letters and remove odd order and capital letters\n\
    \  local lowercase = string.gsub(txt, \"[a-z]\", \"\")\n  local result = {}\n\
    \  for i = 1, #lowercase do\n    local lowercaseLetter = lowercase:sub(i,i)\n\
    \    -- Check if letter is uppercase, if not append it to the words\n    if lowercaseLetter\
    \ ~= lowercaseLetter:upper() then\n      words = words .. lowercaseLetter\n  \
    \  end\n    -- Append letter to result\n    table.insert(result, lowercaseLetter)\n\
    \  end\n  return #result, words\nend", "  return txt:gsub('([^ ]*)', ',\\0'):gsub(',$',\
    \ ''):gsub(',+', ',')\nend", "  -- split on whitespace and comma\n  local words\
    \ = txt:gsub('[,\\\\s]+', ','):gsub('[^A-Za-z]+', '')\n  -- return number of lower-case\
    \ letters with odd order\n  return #words - #words:gsub('[a-z]+$', '')\nend",
  "    local count = 1\n    local words = \"\"\n    for letter in txt:gmatch(\"[%a%b%c%l%p%x%z%w]\"\
    ) do\n        count = count + letter:lower():byte() + 1\n    end\n    for letter\
    \ in txt:gmatch(\"[%a%b%c%l%p%x%z%w]\") do\n        if letter:lower() ~= letter:upper()\
    \ then\n            words = words .. letter:lower() .. \",\"\n        end\n  \
    \  end\n    words = words .. count\n    return tonumber(words):byte()\nend", " \
    \ local words = txt:gsub(\"%S+\", function(str)\n    local w = str:lower() --\
    \ lower case all letters\n    if w == \"\" then return \"\" end\n    local count\
    \ = #w + 1\n    local res = \"\"\n    while #res < count do\n      res = w + \"\
    ,\" + res\n    end\n    return res\n  end)\n  return words:gsub(\",+\", function(str)\
    \ -- remove all commas from the input string\n    local word = str:lower()\n \
    \   if word == \"\" then return \"\" end\n    local count = #word + 1\n    local\
    \ res = \"\"\n    while #res < count do\n      res = word + \",\" + res\n    end\n\
    \    return res\n  end):gsub(\"^,\", \"\") -- remove all leading commas\nend",
  "    local words = string.gmatch(txt, \"([^%s]+)\") -- Split on spaces not contained\
    \ within quotes\n    local num_words = string.len(words)", "  local words = {}\n\
    \  for w in txt:gmatch('[^%w*]+') do table.insert(words, w) end\n  return #words\
    \ + #(txt:gsub('([a-z])(%A+)', '\\2'):gsub('%A+([a-z])', '\\1'):gsub('%A+$', ''))\n\
    end", "  local words = string.gsub(txt, \"[%c]\", \" \").   -- Replace all non-whitespace\
    \ chars with spaces\n  local splitted = {}\n  local letters = {}\n  for i = 1,\
    \ string.len(words) do\n    local letter = string.sub(words, i, i)\n    if not\
    \ letters[letter] then\n      table.insert(splitted, letter)\n      letters[letter]\
    \ = true\n    end\n  end\n  return #splitted, #letters - 1\nend", "    local words\
    \ = ''\n    for i = 1, string.len(txt) do\n        if string.sub(txt,i,i) == '\
    \ ' then\n            words = words + ','\n        else\n            words = words\
    \ + string.sub(txt,i,i)\n        end\n    end\n    if words == ',' then\n    \
    \    return string.len(txt)\n    else\n        return #words + 1\n    end\nend",
  "   local ws = 0\n   local wd = {}\n   local wc = 0\n   for w, _ in pairs(txt:gmatch(\"\
    %w+\")) do\n      if ws ~= 1 then\n         wd = { wd, wc }\n         ws = 1\n\
    \      end\n      wc = wc + #w\n   end\n   return wc, wd\nend", "\tlocal words\
    \ = txt:gmatch(\"[\\\\w-]+\")\n\tlocal spaces = txt:gmatch(\"%w+\")\n\t\n\treturn\
    \ #words or #spaces\nend", "   if txt == nil then\n      return\n   end\n   \n\
    \   local words = \"\"\n   local count = 0\n   \n   for letter in txt:gmatch(\"\
    %w+\") do\n      count = count + 1\n      if count % 2 == 1 then\n         words\
    \ = words .. letter\n      else\n         words = words .. \",\" .. letter\n \
    \     end\n   end\n   \n   return words\nend", "   if txt ~= nil then\n      local\
    \ res = \"\"\n      local count = 1\n      for i = 1, #txt do \n         res =\
    \ res or count\n         local char = txt:sub(i,i)\n         if char == \",\"\
    \ then\n            res = res or \",,\"\n            count = count + 1\n     \
    \    elseif char == \"\" then\n            res = res or char\n         else\n\
    \            res = res or char:lower()\n         end\n      end\n      return\
    \ res\n   else\n      return \"nil\"\n   end\nend", "  local words = {}\n  for\
    \ w in txt:gmatch('[A-Za-z]+') do\n    words[#words + 1] = {\n      w = w,\n \
    \     ord = w:lower():byte()\n    }\n  end\n  return table.sort(words, function(a,\
    \ b) return a.ord < b.ord end)\nend", "    local count=0\n    local words={}\n\
    \    for w in string.gmatch(txt, \"%S+\") do\n        words[count]=w\n       \
    \ count = count + 1\n    end\n    return count\nend", "    -- Check input for\
    \ whitespace\n    if txt ~= '' then \n        -- Return all words separated by\
    \ whitespace\n        return txt:gmatch('[%S]+')\n    end\n    -- Return 0, since\
    \ there is no whitespace in the input\n    return 0\nend", "    if txt ~= nil\
    \ then\n        return string.gmatch(string.lower(txt), \",+\") ~= nil\n    else\n\
    \        return 0\n    end\nend", "\tlocal words = txt:match(\"[^,]+\")\n\treturn\
    \ #words\nend", "    local words = string.gsub(txt, \"([^A-Za-z ])\", \" \")\n\
    \    words = string.gsub(words, \"([^A-Za-z])\", \",\")\n    words = string.gsub(words,\
    \ \"([^A-Za-z ])\", \" \")\n    words = string.gsub(words, \"([^A-Za-z])\", \"\
    ,\")\n    words = string.gsub(words, \"([^A-Za-z ])\", \" \")\n    return string.len(words)\
    \ + (string.len(string.sub(words, 1, 1)) / 2)\nend", "    local words = \"\"\n\
    \    local whitespaces = \"\"\n    local comma = \"\"\n    local letters = 0\n\
    \    for char in txt:gmatch(\"[%w-]+\") do\n        if char == whitespace then\n\
    \            whitespaces = whitespaces + char\n        elseif char == comma then\n\
    \            if comma and letters % 2 == 1 then\n                words = words\
    \ + comma\n            end\n            comma = char\n            letters = 0\n\
    \        else\n            letters = letters + 1\n            words = words +\
    \ char\n        end\n    end\n    if comma and letters % 2 == 1 then\n       \
    \ words = words + comma\n    end\n    return words\nend", "   local words = {}\n\
    \   local word_length = 0\n   for w in string.gmatch(txt, \"[^ ]+\") do\n    \
    \  word_length = word_length + #w\n      table.insert(words, w)\n   end\n   if\
    \ word_length > 0 then\n      table.insert(words, nil)\n   end\n   return word_length,\
    \ words\nend", "  local words = {}\n  local letters = {}\n  for letter, word in\
    \ pairs(txt:gsub(\"(%b+)\", \"\"):gsub(\"(%[a-z])\", \"%1, \")) do\n    letters[letter]\
    \ = true\n    table.insert(words, word)\n  end\n  for i=25,1,-1 do\n    if not\
    \ letters[i] then return #words + 1 end\n  end\n  return #words + 1\nend", " \
    \   local words = {}\n    for word in string.gmatch(txt, \"[^A-Za-z0-9]+\") do\n\
    \        table.insert(words, word)\n    end\n    local words_count = #words\n\
    \    if words_count > 0 then\n        if words_count % 2 == 1 then\n         \
    \   local first_word = words[1]\n            table.insert(words, first_word)\n\
    \        end\n    end\n    \n    return words_count\nend\n</cell>\n<text>\nProblem\
    \ 2.2 - count_letter\nImplement the function count_letter in the cell below.",
  "   if txt:find(\"^%s+$\") then\n       local words = str:gsub(\"[,%w]+\",\" \"\
    ):gsub(\"^ +\",\"\"):gsub(\"( +)\",\"\"):gsub(\"^%s+\",\"\")\n       return words\n\
    \   else\n       return str:gsub(\"[%w_.]+\",\" \"):gsub(\"^ +\",\"\"):gsub(\"\
    ( +)\",\"\"):gsub(\"^%s+\",\"\")\n   end\nend\n</code>\n<|/ a |>\n<| c |>\nthank\
    \ you for pointing it out and showing the example. This is a good example of using\
    \ regex in Lua, very useful, cheers.\n<|/ c |>\n<| a |>\n<code>", "   local letters\
    \ = {}\n   for w in string.gmatch(string.lower(txt),\".-,()+\") do letters[#letters+1]=w\
    \ end\n   return (#letters)/2 -- This assumes that each letter has exactly two\
    \ appearances.\nend", "    local words = { }\n    for w in txt:gmatch(\"(%S+)\"\
    ) do words[#words + 1] = w end\n    return words[#words]\nend", "   local numWords,\
    \ word, letterCount, letters = {}, {}, {}, {}\n   for char in string.gmatch(txt,\
    \ \"%a\") do -- %a is equivalent to [a-z]+\n      if letterCount[char] then\n\
    \         letterCount[char] = letterCount[char] + 1\n      else\n         letterCount[char]\
    \ = 1\n         if word[char] then\n            numWords = numWords + 1\n    \
    \     end\n         word[char] = true\n         table.insert(letters, char)\n\
    \      end\n   end\n   return numWords, letters, letterCount, word\nend", "  return\
    \ txt:gsub(\"[^a-zA-Z,]+\", \" \"):gsub(\"[,]+\", \" \")\nend", "  local split_list\
    \ = txt:gsub(\"[[:space:]]+\", \" \"):gsub(\"[,]+\", \" \")\n  return split_list:gsub(\"\
    [[:alpha:]]+\", function(x)\n    return #x + 1\n  end)\nend\n</code>\n<|/ a |>\n\
    <| c |>\n`split_words` does not work for me\n<|/ c |>\n<| c |>\n: I added an implementation\
    \ of `split_words` which works for me.\n<|/ c |>\n<| c |>\nthank you very much\
    \ for your answer\n<|/ c |>\n<| c |>\n: You're welcome!\n<|/ c |>\n<| c |>\n,\
    \ how did you come up with the solution `local function split_words(txt)\n  local\
    \ split_list = txt:gsub(\"[[:space:]]+\", \" \"):gsub(\"[,]+\", \" \")\n  return\
    \ split_list:gsub(\"[[:alpha:]]+\", function(x)\n    return #x + 1\n  end)\nend`?\
    \ I really don't understand how it works.\n<|/ c |>\n<| a |>\nIf you don't want\
    \ a recursive solution but a iterative one, here it is:\n<code>", "    local words\
    \ = {}\n    for w in string.gmatch(txt, \"([^ ]+)\") do\n        words[#words\
    \ + 1] = w\n    end\n    return #words - 1\nend", "  local word_counts = {}\n\
    \  local words = \"\"\n  for _,w in ipairs(txt:gmatch(\"%S+\")) do\n    if word_counts[w]\
    \ == nil then\n      word_counts[w] = 0\n    end\n    word_counts[w] = word_counts[w]\
    \ + 1\n    words = words .. w .. ','\n  end\n  return #word_counts\nend", "  local\
    \ splits = { }\n  for _,word in ipairs(txt:gmatch('%w+')) do \n    table.insert(splits,\
    \ word)\n  end \n  return #splits\nend", "   local words= {}\n   local i= 1 \n\
    \   for w in txt:gmatch(\"[^A-Za-z ]\") do \n      words[#words + 1]= w\n    \
    \  i = i + 1\n   end\n   return i, words\nend", "    local words = nil\n    local\
    \ counter = 0\n    local is_digit = false\n    local num_letters = 0\n    for\
    \ letter in string.gmatch(txt, \"%S\") do \n        if is_digit then \n      \
    \      if string.byte(letter) == 0 then \n                counter = counter -\
    \ 1\n            else\n                num_letters = num_letters + 1\n       \
    \     end\n        else\n            if string.byte(letter) == 0 and letter ~=\
    \ \"'\" then\n                num_letters = num_letters + 1\n            end\n\
    \        end\n        is_digit = string.byte(letter) == 0 \n        if letter\
    \ ~= \"'\" then \n            counter = counter + 1\n        end\n    end\n  \
    \  if counter > 0 then \n        words = num_letters - 1\n    else\n        words\
    \ = string.gmatch(txt, \",\")\n    end\n    return words\nend\n</cell>\n<text>\n\
    And a function to convert the lower-case letters to upper-case letters, and back.\
    \ Useful for converting to and from the English alphabet. \nNote -- This only\
    \ works with letters, not numbers.", "    local words = txt .. \"\"\n    local\
    \ last = -1\n    local cnt = 0\n    for i = 1, #words do\n        if #words[i]\
    \ > 1 then\n            last = i\n            break\n        end\n    end", " \
    \ if string.len(txt) > 1 then\n    local num_commas = string.len(txt) - string.len(string.gsub(txt,\
    \ \",\", \"\")) \n    local num_commas_odd = num_commas - string.len(string.gsub(txt,\
    \ \",\", \"\"))\n    local num_lowers = string.len(string.gsub(txt, \"[a-z]\"\
    , \"\"))\n    return num_commas_odd + (num_commas_odd < num_lowers)\n  else\n\
    \    return 1\n  end\nend\n</cell>\n<cell>", "    local words  = {}\n    local\
    \ spaces = false\n    local commas = false\n    for ch in string.gmatch(txt, \"\
    ([^ ]+) \") do\n        -- If space exists, push it into the words list\n    \
    \    if spaces then\n            table.insert(words, ch)\n        else\n     \
    \       -- If commas exist, push the current letter to the words list, then set\
    \ commas to false\n            if commas then\n                table.insert(words,\
    \ ch)\n                commas = false\n            -- If commas don't exist, set\
    \ commas to true, and push the current letter to the words list\n            else\n\
    \                commas = true\n                table.insert(words, ch)\n    \
    \        end\n        end\n        -- If it's the first character of the word,\
    \ push the current letter to the words list\n        if string.byte(ch) == string.byte(string.sub(txt,\
    \ 1, 1)) then\n            table.insert(words, ch)\n        end\n        -- If\
    \ it's the last character of the word, push the current letter to the words list\n\
    \        if string.byte(ch) == string.byte(string.sub(txt, -1, 1)) then\n    \
    \        table.insert(words, ch)\n        end\n        -- If there's a whitespace\
    \ between characters\n        if string.byte(ch) == string.byte(\" \") then\n\
    \            spaces = true\n        end\n    end\n    -- return the number of\
    \ lower-case letters with odd order in the alphabet, ord('a') = 0, ord('b') =\
    \ 1, ... ord('z') = 25\n    return #words\nend", "    local s = \"\"\n    for\
    \ i, c in ipairs(txt) do\n        if (c == \" \" or c == \",\") then\n       \
    \     s = s .. c\n        else\n            s = s .. tostring(c) .. \" \"\n  \
    \      end\n    end\n    if s == \"\" then\n        return 1\n    else\n     \
    \   local len = #s\n        local i = 0\n        local out = {}\n        for i\
    \ = 1, len do\n            local c = s[i]\n            local lower = tostring(c)\n\
    \            if lower == c then\n                lower = tostring((i - 1) / 2)\n\
    \            end\n            if lower > \"z\" and lower < \"a\" then\n      \
    \          if lower % 2 == 1 then\n                    table.insert(out, tostring(i))\n\
    \                end\n            end\n        end\n        return #out\n    end\n\
    end", "\t-- Your code here\n\tlocal words = txt:gsub('[\\W_]+','%w'):gsub('[%s]','%'):gsub('\\\
    W+','%w'):gsub('[%s]','%'):gsub('%s+',' '):gsub('%s+','%')\n\t-- return words\n\
    \treturn words:gsub('%w %w %w','%w'):gsub('%s %s %s','%w'):gsub('%w %s','%w'):gsub('%s\
    \ %w','%w'):gsub('%s %s','%w'):gsub('%w %w','%w'):gsub('%s %w','%w'):gsub('%w\
    \ %s','%w'):gsub('%w %s','%w'):gsub('%w','%w'):gsub('%s','%'):gsub('%s %w','%w'):gsub('%s\
    \ %w','%w'):gsub('%s %s','%w'):gsub('%s %s','%w'):gsub('%w %w','%w'):gsub('%s\
    \ %w','%w'):gsub('%s %s','%w'):gsub('%s %s','%w'):gsub('%w %w','%w'):gsub('%s\
    \ %w','%w'):gsub('%s %s','%w'):gsub('%s %s','%w')\nend", "  -- We split the input\
    \ on whitespace first and then do some sanity checks\n  -- Then we split the output\
    \ on commas if no commas exist\n  return txt:gsub(\"([a-z]+)\", function(x) \n\
    \    local n = 1\n    for i = 1, #x do\n      n = n + x:sub(i, i) == \"\" and\
    \ 1 or tonumber(x:sub(i, i))\n    end\n    return n\n  end)\nend", "   local words\
    \ = txt:gsub(\"[^A-Za-z]+\", \" \")\n   words = words:gsub(\"[,]+\", \" \")\n\
    \   words = words:gsub(\"[^a-z]+\", \"\")\n   return words:gsub(\"%a\", function(a)\
    \ return ord(a) - ord('a') + 1 end) \nend", "   -- Remove whitespaces at start\
    \ and end\n   local txt = txt:gsub(\"^%s*\", \"\"):gsub(\"%s*$\", \"\")\n   --\
    \ Return the number of non-whitespace characters\n   return txt:gsub(\"[%S]+\"\
    ):gsub(\"[^%S]\"):gsub(\" \"):gsub(\"^%s*\", \"\"):gsub(\"%s*$\", \"\")\nend",
  "  if txt == '' or txt == '\\n' then return 0 end\n  local i = 0\n  local j = 0\n\
    \  local words = {}\n  local word = ''\n  local last_space = false\n  local prev_space\
    \ = false\n  while true do\n    if i >= #txt then\n      if word ~= '' then\n\
    \        words[#words + 1] = word\n      end\n      break\n    end\n    local\
    \ c = toupper(txt[i])\n    if c == ' ' then\n      last_space = true\n      if\
    \ prev_space then\n        words[#words + 1] = word\n        word = ''\n     \
    \ else\n        prev_space = true\n      end\n    elseif c == ',' then\n     \
    \ if word ~= '' then\n        words[#words + 1] = word\n      end\n      word\
    \ = ''\n      last_space = false\n      prev_space = false\n    elseif c ~= '\\\
    n' then\n      word = word .. c\n    end\n    i = i + 1\n  end\n  if word ~= ''\
    \ then\n    words[#words + 1] = word\n  end\n  return #words + 1\nend", "  return\
    \ txt:gsub(\"[%z]\", function(c) \n    -- count lowercase letter characters and\
    \ odd order characters with 'a' = 0, 'b' = 1, ... 'z' = 25\n    if c == \"a\"\
    \ then return \"0\" end\n    if c == \"b\" then return \"1\" end\n    if c ==\
    \ \"c\" then return \"2\" end\n    if c == \"d\" then return \"3\" end\n    if\
    \ c == \"e\" then return \"4\" end\n    if c == \"f\" then return \"5\" end\n\
    \    if c == \"g\" then return \"6\" end\n    if c == \"h\" then return \"7\"\
    \ end\n    if c == \"i\" then return \"8\" end\n    if c == \"j\" then return\
    \ \"9\" end\n    if c == \"k\" then return \"10\" end\n    if c == \"l\" then\
    \ return \"11\" end\n    if c == \"m\" then return \"12\" end\n    if c == \"\
    n\" then return \"13\" end\n    if c == \"o\" then return \"14\" end\n    if c\
    \ == \"p\" then return \"15\" end\n    if c == \"q\" then return \"16\" end\n\
    \    if c == \"r\" then return \"17\" end\n    if c == \"s\" then return \"18\"\
    \ end\n    if c == \"t\" then return \"19\" end\n    if c == \"u\" then return\
    \ \"20\" end\n    if c == \"v\" then return \"21\" end\n    if c == \"w\" then\
    \ return \"22\" end\n    if c == \"x\" then return \"23\" end\n    if c == \"\
    y\" then return \"24\" end\n    if c == \"z\" then return \"25\" end\n  end)\n\
    end\n</cell>\n<text>\nExercise 9\nWrite a function called count_letters that counts\
    \ the number of letters in the text provided, given that the text only contains\
    \ lowercase letters. You can use a\ndictionary", "   local count = 0\n   for word\
    \ in string.gmatch(txt, \"([^,]+)\") do\n      count = count + 1\n   end\n   return\
    \ count\nend", "  local words = {}\n  local count = 0", "  local num_words = 0\n\
    \  local words = txt:gsub(\",\",\"\\\\n\") -- turn single words into a list\n\
    \  for i = 1, #words do\n    local letters = {}\n    local word = words[i]\n \
    \   local count = 1\n    while word ~= \"\" do\n      if word:sub(1, 1) == \"\
    s\" then\n        word = word:sub(2)\n        count = count + 1\n      elseif\
    \ word:sub(1, 1) == \"e\" then\n        word = word:sub(2)\n      elseif word:sub(1,\
    \ 1) == \"t\" then\n        word = word:sub(2)\n      elseif word:sub(1, 1) ==\
    \ \"y\" then\n        word = word:sub(2)\n      elseif word:sub(1, 1) == \"l\"\
    \ then\n        word = word:sub(2)\n      elseif word:sub(1, 1) == \"a\" then\n\
    \        word = word:sub(2)\n      elseif word:sub(1, 1) == \"e\" then\n     \
    \   word = word:sub(2)\n      elseif word:sub(1, 1) == \"n\" then\n        word\
    \ = word:sub(2)\n      elseif word:sub(1, 1) == \"d\" then\n        word = word:sub(2)\n\
    \      elseif word:sub(1, 1) == \"r\" then\n        word = word:sub(2)\n     \
    \ elseif word:sub(1, 1) == \"a\" then\n        word = word:sub(2)\n      elseif\
    \ word:sub(1, 1) == \"t\" then\n        word = word:sub(2)\n      elseif word:sub(1,\
    \ 1) == \"h\" then\n        word = word:sub(2)\n      elseif word:sub(1, 1) ==\
    \ \"c\" then\n        word = word:sub(2)\n      elseif word:sub(1, 1) == \"a\"\
    \ then\n        word = word:sub(2)\n      elseif word:sub(1, 1) == \"d\" then\n\
    \        word = word:sub(2)\n      elseif word:sub(1, 1) == \"e\" then\n     \
    \   word = word:sub(2)\n      elseif word:sub(1, 1) == \"i\" then\n        word\
    \ = word:sub(2)\n      elseif word:sub(1, 1) == \"o\" then\n        word = word:sub(2)\n\
    \      elseif word:sub(1, 1) == \"n\" then\n        word = word:sub(2)\n     \
    \ elseif word:sub(1, 1) == \"f\" then\n        word = word:sub(2)\n      else\n\
    \        word = word:sub(2)\n      end\n      table.insert(letters, word)\n  \
    \    count = count + 1\n      num_words = num_words + 1\n    end", "    local\
    \ words = #txt > 0 and split(txt, \" \") or ''\n    local num_words = #words\n\
    \    if num_words > 0 then\n        local num_letters = 0\n        local has_commas\
    \ = false\n        local has_whitespace = false\n        for i = 1, #words do\n\
    \            local char = words[i]\n            local lower = tolower(char)\n\
    \            if char == ',' then has_commas = true end\n            if char ==\
    \ '.' or char == ' ' then has_whitespace = true end\n            if has_commas\
    \ and has_whitespace and lower < #lower+1 then break end\n            if has_commas\
    \ and has_whitespace and lower > #lower+1 then break end\n            has_letter\
    \ = has_letter and (lower < 65 or lower > 122)\n            num_letters = num_letters\
    \ + 1\n        end\n        if has_whitespace and not has_commas and num_letters\
    \ == 1 then\n            return 1\n        else\n            return num_letters\n\
    \        end\n    else\n        return 0\n    end\nend", "\tlocal words = txt:match(\"\
    [^A-Za-z]+\")\n\treturn words:gsub(\",\",\"\"):gsub(\"\\n\",\"\"):gsub(\"\\r\"\
    ,\"\"):gsub(\"\\t\",\"\"):gsub(\":\",\"\"):gsub(\"(\",\"\"):gsub(\")\",\"\"):gsub(\"\
    <\",\"\"):gsub(\">\",\"\"):gsub(\":=\",\"\")\nend", "   -- get number of non-whitespace\
    \ characters in txt \n   local nChars = #(txt:gsub('%S',' '))\n   \n   -- if there\
    \ are no whitespace characters\n   if nChars == 0 then\n      -- split on commas\
    \ if no commas exists in txt\n      if #(txt:gsub(',',' ')) == 0 then\n      \
    \   -- split on lowercase letters if no commas exists in txt\n         if #(txt:gsub(string.lower(string.letters),'\
    \ '))/2 ~= 1 then\n            nChars = #(txt:gsub(string.lower(string.letters),'\
    \ '))\n         end\n      end\n   end\n   \n   return nChars\nend", "   -- Your\
    \ code goes here\nend", "    local words = {}\n    local len = #txt\n    for idx\
    \ = 1, len do\n        if txt[idx] ~= ' ' and txt[idx] ~= ',' then \n        \
    \    table.insert(words, tostring(txt[idx:len]))\n        end\n    end\n    return\
    \ table.concat(words, '')\nend", "    local words = {}\n    local count = 0\n\
    \    local last_index = 0\n    local len = string.len(txt)\n    local character\n\
    \    for index=1,len do\n        character = string.sub(txt,index,index)\n   \
    \     if character ~= \" \" then\n            count = count + 1\n        else\n\
    \            words[last_index] = words[last_index] .. string.sub(txt,last_index,index)\n\
    \            last_index = index\n            count = 0\n        end\n    end\n\
    \    return count, words[last_index]\nend", "    local words, cwords = txt:gsub('%s+',\
    \ ',', 'g'), #txt\n    local i = 0\n    \n    while i < cwords do\n        if\
    \ words[i] == \"\" then\n            words[i] = words[i+1]\n            words[i+1]\
    \ = nil\n        end\n        i = i + 2\n    end\n    \n    return #words - 1\n\
    end", "\t-- No need for special casing\n\tif not txt then return 0 end\n\treturn\
    \ txt:match('([^,]+)') and (txt:match('([^,]+)')):gsub('%w', function(c) return\
    \ string.gsub(c:lower(), \"([a-z])([a-z])\", \"%1 %2\") end)\nend", "    local\
    \ words = \"\"\n    local count = 0\n    for i = 1, #txt do\n        if tostring(txt[i])\
    \ ~= '-' and tostring(txt[i]) ~= ' ' then\n            words = words + tostring(txt[i])\n\
    \        else\n            count = count + 1\n        end\n    end\n    return\
    \ count, words\nend", "    if txt ~= nil then\n        local words = {}\n    \
    \    local i, cnt", "\tlocal words = ''\n\t\n\t-- split on commas and whitespace\n\
    \tlocal split1 = txt:gsub(\"[^a-zA-Z]\", \",\")\n\t-- split on whitespace and\
    \ comma\n\tlocal split2 = split1:gsub(\",[ ]+\", \" \")\n\t-- split on whitespace\
    \ and hyphens\n\tlocal split3 = split2:gsub(\"[- ]+\", \" \")\n\t\n\t-- append\
    \ words and return count\n\twords = words .. split3:gsub(\"[- ]+\", \"\")\n\t\
    return (words:gsub(\"^,\", \"\"):gsub(\",$\", \"\"):gsub(\"[- ]\", \"\"):gsub(\"\
    \ \", \"\"))\nend", "   local words = {}\n   local pos = 1\n   while pos <= #txt\
    \ do\n      if string.sub(txt, pos, pos) = \" \" then\n         table.insert(words,\
    \ string.sub(txt, pos, pos + 1))\n      elseif string.sub(txt, pos, pos) = \"\
    ,\" then\n         table.insert(words, string.sub(txt, pos, pos + 1))\n      else\n\
    \         pos = pos + 1\n      end\n   end\n   return (#words + 1) % 2\nend",
  "  local words = txt:gsub('([^ ,]+)') -- Split on anything not space or comma\n\
    \  words = words:gsub('%w') -- Split on letters A-Z\n  words = words:gsub('%W')\
    \ -- Split on letters a-z\n  words = words:gsub(',',',') -- If spaces exist in\
    \ the text split on commas\n  words = words:gsub('%w[ao]','') -- If words starting\
    \ with 'a' or 'o' split on letters a-z\n  words = words:gsub('%W[ao]','') -- If\
    \ words starting with 'a' or 'o' split on letters A-Z\n  return tonumber(words)\n\
    end", "  local num = 0\n  local words = ''\n  local alphabet = string.letters('a')\n\
    \  for w in txt:gmatch(\"[^' ,]\") do\n    if w ~= '' then\n      num = num +\
    \ 1\n      if not words:sub(#words, #words) ~= '' and words:sub(#words, #words)\
    \ ~= ',' then\n        words = words & ' ' .. alphabet .. '_' .. w\n      else\n\
    \        words = words & ' ' .. alphabet .. '_' .. '_'\n      end\n    end\n \
    \ end\n  return num -- num has the number of splitted words\nend", "\t-- check\
    \ for no whitespaces\n\tif txt:match('^%s*$') then \n\t\treturn #txt, #tolower(txt)\n\
    \tend", "  local words  = {}\n  local numWords = 0\n  for word in txt:gmatch(\"\
    (%S+)\") do\n    table.insert(words, word)\n    numWords  = numWords + 1\n  end\n\
    \  return numWords\nend", "   local l1, l2, l3 = 0, 0, 0\n   for w in string.gmatch(txt,\
    \ \"([^%s]+)\") do l1 = l1 + #w; l2 = l2 + #w / 2; l3 = l3 + #w / 2 end\n   return\
    \ l1 + l2 + l3\nend", "   local i, j, s = 0, #txt, {}\n   while i < j do\n   \
    \   table.insert(s, string.sub(txt, i, j))\n      i = i + 1 \n   end\n   if string.sub(txt,\
    \ i, j) == \"\" then\n      return #s\n   else\n      return #s + 1 -- add 1 because\
    \ there should always be a space after a comma in the CSV format\n   end\nend",
  "  if txt ~= '' then\n    local split = {}\n    for x in string.gmatch(txt, '([^\
    \ ,]+)')do table.insert(split, x) end\n    return #split, split\n  else\n    return\
    \ 0, {}\n  end\nend", "  return txt:gsub(\"([^,]+)\", function (c) return split(c)\
    \ end)\nend", "    local words = string.gsub(txt, \" \", \",\")\n    local count\
    \ = #words\n    local results = {}\n    for i=1,count do \n        results[#results+1]\
    \ = words[i]\n    end \n    return results\nend", "   -- your code goes here\n\
    \   -- return words\nend", "    -- This implementation uses a single array and\
    \ two stacks to keep track of where we are in the string and what characters have\n\
    \    -- been seen in the string. This avoids allocating the array every time a\
    \ word is encountered and reduces the number of function calls\n    -- when splitting\
    \ strings where there are multiple words found in a string.\n    local word_count\
    \ = {}\n    local stack = {}\n    local word = {}\n    local char_count = 0\n\
    \    local word_length = 0\n    local i = 0\n    while i < #txt do\n        --\
    \ if the string contains anything besides letters, split on whitespace\n     \
    \   if string.sub(txt, i, i) ~= '' then\n            word_length = string.len(string.sub(txt,\
    \ i, i))\n        elseif word_length == 0 then\n            word_length = string.len(string.sub(txt,\
    \ i, i))\n            table.insert(stack, string.sub(txt, i, i))\n        else\n\
    \            -- if the string only contains letters, split on commas\n       \
    \     if string.sub(txt, i, i) ~= ',' then\n                word_count = word_count\
    \ + 1\n                table.insert(word, string.sub(txt, i, i))\n           \
    \     char_count = char_count + 1\n                table.insert(stack, string.sub(txt,\
    \ i, i))\n            -- if the string only contains numbers, split on commas\n\
    \            elseif string.sub(txt, i, i) ~= '-' then\n                word_count\
    \ = word_count + 1\n                table.insert(word, string.sub(txt, i, i))\n\
    \                char_count = char_count + 1\n                table.insert(stack,\
    \ string.sub(txt, i, i))\n            -- if the string contains letters and numbers,\
    \ split on whitespace\n            elseif string.sub(txt, i, i) ~= '-' and string.sub(txt,\
    \ i, i) ~= ',' then\n                word_count = word_count + 1\n           \
    \     table.insert(word, string.sub(txt, i, i))\n                char_count =\
    \ char_count + 1\n                table.insert(stack, string.sub(txt, i, i))\n\
    \            else\n                table.insert(word, string.sub(txt, i, i))\n\
    \            end\n        end\n        i = i + 1\n    end\n    return word_count\n\
    end", "   local words = {}\n   for word in string.gmatch(txt, \"[^,]+\") do\n\
    \      if word:len() ~= 0 then\n         table.insert(words, word)\n      end\n\
    \   end\n   return table.count(words, \"<word>\") or 0\nend", "  -- Split on whitespaces\n\
    \  return txt:gsub('%s+', function(s) \n    local split = \"\"\n    for c in s:gmatch(\"\
    [%z][%z%]\") do\n      split = split .. c\n    end\n    return split\n  end)\n\
    end", "\tlocal words = string.gsub(txt, \"[^ ,]+\", \"\")\n\treturn #words / 2\n\
    end", "    local words = {}\n    for _,word in gmatch(txt, \"([^ ,]+)\") do\n\
    \        if word:sub(#word, 1, 1):lower() == word:sub(#word, 1, 1):lower() then\n\
    \            table.insert(words, word)\n        elseif #word % 2 == 1 then\n \
    \           table.insert(words, word:sub(#word, 1))\n        else\n          \
    \  table.insert(words, word:sub(#word, 2, #word))\n        end\n    end\n    return\
    \ table.concat(words, \" \")\nend\n</code>\n<|/ a tags=lua-patterns,lua |>\n<|\
    \ c |>\nThanks for the help! I actually have already figured it out myself and\
    \ forgot to post the answer but I will post it now so that others won't have to\
    \ do what I did. Your solution works great, thanks again!\n<|/ c |>\n<| a dscore=2\
    \ |>\nA more idiomatic Lua solution would be:\n<code>\ns=\"abcdef\"\ntable.concat({\n\
    \    table.concat({\n        table.concat({s:sub(1, 2):lower()}, 1, -1)\n    },\
    \ 2, -1),\n    table.concat({\n        table.concat({s:sub(3)}, 1, -1)\n    },\
    \ 2, -1),\n}, 1, -1)\n</code>\nThe idea is to split each word into two halves,\
    \ with the last half in one column and the second half in another, and then concatenate\
    \ them back together with one column. Lua tables behave very much like lists.\n\
    <|/ a tags=lua-patterns,lua |>\n<| a tags=lua-patterns,lua dscore=1 |>\nThe easiest\
    \ thing to do would be to replace each space with a comma, and strip the commas\
    \ from the beginning and end so you're left with the words themselves.\n<code>"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
