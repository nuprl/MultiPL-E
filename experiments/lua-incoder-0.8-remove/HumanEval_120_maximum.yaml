name: HumanEval_120_maximum
language: lua
prompt: "-- Given an array arr of integers and a positive integer k, return a sorted\
  \ list \n-- of length k with the maximum k numbers in arr.\n-- Example 1:\n-- Example\
  \ 2:\n-- Example 3:\n-- Note:\n-- 1. The length of the array will be in the range\
  \ of [1, 1000].\n-- 2. The elements in the array will be in the range of [-1000,\
  \ 1000].\n-- 3. 0 <= k <= len(arr)\nlocal function maximum(arr, k)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = maximum\n\
  \    lu.assertEquals(candidate({-3, -4, 5}, 3), {-4, -3, 5})\n    lu.assertEquals(candidate({4,\
  \ -4, 4}, 2), {4, 4})\n    lu.assertEquals(candidate({-3, 2, 1, 2, -1, -2, 1}, 1),\
  \ {2})\n    lu.assertEquals(candidate({123, -123, 20, 0, 1, 2, -3}, 3), {2, 20,\
  \ 123})\n    lu.assertEquals(candidate({-123, 20, 0, 1, 2, -3}, 4), {0, 1, 2, 20})\n\
  \    lu.assertEquals(candidate({5, 15, 0, 3, -13, -8, 0}, 7), {-13, -8, 0, 0, 3,\
  \ 5, 15})\n    lu.assertEquals(candidate({-1, 0, 2, 5, 3, -10}, 2), {3, 5})\n  \
  \  lu.assertEquals(candidate({1, 0, 5, -7}, 1), {5})\n    lu.assertEquals(candidate({4,\
  \ -4}, 2), {-4, 4})\n    lu.assertEquals(candidate({-10, 10}, 2), {-10, 10})\n \
  \   lu.assertEquals(candidate({1, 2, 3, -23, 243, -400, 0}, 0), {})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local max_val = 0\n    local max_num = 0\n    for i = 1, k do\n\
    \        if arr[i] > arr[max_num] then\n            max_num = i\n        else\n\
    \            max_val = arr[i]\n        end\n    end\n    return max_val\nend",
  "    local n = #arr\n    local sorted_list = {}\n    if n < k then\n        return\
    \ sorted_list\n    end\n    for i = 1, k - 1 do\n        local max_element = arr[1]\n\
    \        for j = 2, n do\n            if arr[j] > max_element then\n         \
    \       max_element = arr[j]\n            end\n        end\n        sorted_list[i\
    \ + 1] = max_element\n    end\n    return sorted_list\nend", "  if k == 0 then\
    \ return arr end\n  if k <= #arr then\n    return maximum(maximum(arr, k-1), k)\n\
    \  end\n  \n  local max1 = arr[1]\n  local max2 = arr[2]\n  \n  for i = 2, #arr\
    \ do\n    local cur_max = max1\n    \n    if max2 > max1 then\n      cur_max =\
    \ max2\n    end\n    \n    max2 = max1\n    max1 = arr[i]\n    \n    arr[i] =\
    \ cur_max\n  end\n  \n  return arr\nend", "\tassert(k > 0, \"k cannot be negative\
    \ or 0.\")\n\tassert(k<=#arr, \"k cannot be larger than the length of the input\
    \ array.\")\n\tif k == 1 then\n\t\treturn arr\n\tend\n\tlocal pivot = arr[1]\n\
    \tlocal arr = {}\n\tfor i = 2, k do\n\t\tarr[i] = arr[i-1]\n\tend\n\tarr[k] =\
    \ pivot\n\tlocal max_arr = {}\n\tlocal index = 1\n\twhile index<k do\n\t\tif pivot\
    \ > arr[index] then\n\t\t\tarr[index] = pivot\n\t\tend\n\t\tindex = index + 1\n\
    \tend\n\tmax_arr = arr\n\tlocal max_index = 0\n\twhile index<k do\n\t\tif pivot\
    \ < arr[index] then\n\t\t\tarr[index] = pivot\n\t\tend\n\t\tindex = index + 1\n\
    \tend\n\tmax_index = k\n\tfor i = 1, k do\n\t\tarr[i] = max_arr[i]\n\tend\n\t\
    return arr\nend", "    assert(k > 0 and k <= #arr, \"invalid k\")\n    local a\
    \ = {}\n    for i = 1, k do\n        table.insert(a, #arr > i and arr[math.random(#arr)]\n\
    \            or #arr * -1000)\n    end\n    return a\nend", "  -- write your code\
    \ here\nend", '    local result = { }', "  -- We use binary search to find the\
    \ maximum element\n  local high = #arr\n  local pivot = arr[1]\n  local low =\
    \ 0\n  while low < high do\n    local mid = (low + high) / 2\n    if arr[mid]\
    \ < pivot then\n      high = mid\n    else\n      low = mid + 1\n    end\n  end\n\
    \  -- We return the k elements after the pivot\n  -- We return the k-th element\
    \ (which is kth from the end)\n  return arr[low + k - 1]\nend", "  local maxNum,\
    \ maxValue, maxIndex, maxCount = 0, math.inf, 0, 0\n  for i = 1, k do\n    if\
    \ (arr[i] > maxValue) and (maxValue > 0) then\n      maxValue = arr[i]\n     \
    \ maxIndex = i\n      maxCount = 1\n    elseif (arr[i] > maxValue) and (maxValue\
    \ == maxNum) then\n      maxCount = maxCount + 1\n    end\n  end\n  if maxCount\
    \ > k then return end\n  arr[maxIndex] = arr[maxIndex] - maxCount\n  return maximum(arr,\
    \ k-1)\nend", "    local max_value = -1000\n    local max_index = -1\n    for\
    \ i = 1, k do\n        if arr[i] > max_value then\n            max_value = arr[i]\n\
    \            max_index = i\n        end\n    end\n    return arr[k][max_index\
    \ + 1]\nend", "  if k < 1 then return nil end\n  if k == 1 then return arr end\n\
    \  if k == len(arr) then return arr end", "  if k == 0 then return arr end\n \
    \ local biggest = arr[1]\n  for i = 2, k do\n    if biggest < arr[i] then\n  \
    \    biggest = arr[i]\n    end\n  end\n  return biggest\nend", "\tlocal result\
    \ = {}\n\tlocal min = arr[1]\n\tlocal max = arr[1]\n\tfor i = 2, k do\n\t\tif\
    \ arr[i] > max then\n\t\t\tmax = arr[i]\n\t\tend\n\t\tif arr[i] < min then\n\t\
    \t\tmin = arr[i]\n\t\tend\n\tend\n\tfor i = 1, k do\n\t\tresult[i] = min + (max-min)/i\n\
    \tend\n\treturn result\nend", "  if k < 1 then return nil end\n  if k == 1 then\
    \ return arr end\n  local t = {}\n  local i = 1\n  repeat\n    local j = k\n \
    \   while j < i do\n      t[j] = arr[j]\n      j = j + 1\n    end\n    i = i +\
    \ 1\n  until i = 1\n  return t\nend", "    assert(k == nil or k > 0 and k > 999\
    \ and k <= 1000)\n    if k == 1 then\n        return {arr}\n    end\n    local\
    \ ans = {}\n    for i = 1, k do\n        local _max = arr[1]\n        for j =\
    \ 2, k do\n            if arr[j] > _max then\n                _max = arr[j]\n\
    \            end\n        end\n        ans[#ans + 1] = _max\n    end\n    return\
    \ ans\nend", "  -- Base case\n  if k == 1 then\n    return arr\n  end\n  -- Get\
    \ the minimum number from the first k elements in arr\n  local min_element = arr[1]\n\
    \  for i = 2, k do\n    if arr[i] < min_element then\n      min_element = arr[i]\n\
    \    end\n  end\n  -- Get the maximum number from the remaining elements in arr\n\
    \  local max_element = arr[k]\n  for i = k + 1, #arr do\n    if arr[i] > max_element\
    \ then\n      max_element = arr[i]\n    end\n  end\n  return { min_element, max_element\
    \ }\nend", "\t-- base case\n\tif k == 1 then\n\t\treturn arr\n\tend", "    local\
    \ n = #arr\n    local max_array = {}\n    if k > n then return max_array end\n\
    \    for i = 1, k do\n        max_array[i] = max (max_array[i], arr[i])\n    end\n\
    \    if k <= n then\n        max_array[k] = arr[n - 1]\n    end\n    return max_array\n\
    end", "   local maxArray = { }\n   local maxLength = 0\n   for _, v in pairs(arr)\
    \ do\n      if v > maxLength then\n         maxLength = v\n      end\n   end\n\
    \   if k == nil then\n      return maxLength\n   else\n      return { arr[maxLength],\
    \ arr[k] }\n   end\nend", "  if k <= 0 then return nil end\n  if k > #arr then\
    \ return nil end", '    local sorted_arr = { }', "    local ans = {}\n    local\
    \ max = 0\n    for i = 1, k do\n        if arr[i] > max then\n            max\
    \ = arr[i]\n        end\n    end", "    if k == 0 then\n        return arr\n \
    \   end\n    local i = 0\n    local j = 1\n    local maxValue = -1000\n    local\
    \ index = 1\n    for i = 1, k do\n        if arr[index] > maxValue then\n    \
    \        maxValue = arr[index]\n        end\n        index = index + 1\n    end\n\
    \    local maxArray = arr:clone()\n    for i = 1, k do\n        local index =\
    \ j\n        local minValue = 1000\n        for j = i + 1, k do\n            if\
    \ arr[index] < minValue then\n                minValue = arr[index]\n        \
    \    end\n            index = index + 1\n        end\n        maxArray[i] = minValue\n\
    \    end\n    return maxArray\nend", "    if k == 0 then return arr end\n    if\
    \ k == 1 then return arr end\n    local m = math.min(k, #arr)\n    local t = {}\n\
    \    for i = 1, m do\n        table.insert(t, arr[i])\n    end\n    table.sort(t)\n\
    \    return t\nend", "\tassert(k > 0 and k <= #arr, \"k out of range\")\n\tlocal\
    \ max_arr = {}\n\tlocal max_k = 0\n\tfor i = 1, k do\n\t\tlocal cur = arr[i]\n\
    \t\twhile #max_arr > 0 and cur > max_arr[1] then\n\t\t\tmax_arr[1] = max_arr[1]\n\
    \t\t\tmax_arr[k] = max_arr[k - 1]\n\t\tend\n\t\tif #max_arr == 0 then\n\t\t\t\
    max_arr[1] = cur\n\t\t\tmax_arr[k] = cur\n\t\telse\n\t\t\tif cur > max_arr[1]\
    \ then\n\t\t\t\tmax_arr[1] = cur\n\t\t\telse\n\t\t\t\tmax_arr[k] = cur\n\t\t\t\
    end\n\t\tend\n\tend\n\treturn max_arr\nend", "\tassert(k>0 and k<=#arr, 'Invalid\
    \ k')\n\t\n\t-- We use a hash table to store the result.\n\tlocal max_arr = {}\n\
    \t\n\t-- Calculate the number of comparisons\n\tlocal num_comparisons = 0\n\t\
    for _,v in pairs(arr) do\n\t\tnum_comparisons = num_comparisons + 1\n\tend\n\t\
    \n\t-- Set the size of the hash\n\tlocal h_size = 1\n\tfor i=1,k do\n\t\th_size\
    \ = h_size * 2\n\tend\n\t\n\t-- Initialize the hash table\n\tlocal hash = {}\n\
    \tfor i=1,h_size do\n\t\thash[i] = 0\n\tend\n\t\n\t-- Initialize the max number\n\
    \tlocal max = 0\n\t\n\t-- Calculate the max number in the range [0, h_size)\n\t\
    for i=1,h_size do\n\t\tlocal v = 0\n\t\tlocal num_comp = 0\n\t\tfor _,v in pairs(arr)\
    \ do\n\t\t\tnum_comp = num_comp + 1 \n\t\t\tif v > max then\n\t\t\t\tmax = v\n\
    \t\t\tend\n\t\tend\n\t\t\n\t\t-- If this is the max number in the range, then\n\
    \t\t-- update the hash table and remove the max element.\n\t\tif num_comp == k\
    \ then\n\t\t\tfor i=1,k do\n\t\t\t\tlocal j = 1\n\t\t\t\twhile j < h_size do\n\
    \t\t\t\t\tif hash[j] == 0 then\n\t\t\t\t\t\thash[j] = v\n\t\t\t\t\t\tbreak\n\t\
    \t\t\t\telse\n\t\t\t\t\t\tj = j + 1\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\
    \tend\n\tend\n\t\n\t-- Return the result as a sorted list\n\tlocal result = {}\n\
    \tfor _,v in pairs(arr) do\n\t\tif max >= v then\n\t\t\ttable.insert(result, v)\n\
    \t\tend\n\tend\n\ttable.sort(result)\n\treturn result\nend", "\tlocal out = {}\n\
    \tlocal largest = arr[1]\n\tfor i = 2, k do\n\t\tlargest = arr[i] and largest\
    \  or arr[i]\n\tend\n\tfor i = 2, #arr do\n\t\tif largest <= arr[i] then\n\t\t\
    \ttable.insert(out, largest)\n\t\t\tlargest = largest + arr[i]\n\t\tend\n\tend\n\
    \treturn out\nend", "  local lst = k and {} or arr\n  for i = #lst, 1, -1 do\n\
    \    for j = #lst, i, -1 do\n      if arr[j] > arr[j + 1] then\n        arr[j],\
    \ arr[j + 1] = arr[j + 1], arr[j]\n      end\n    end\n  end\n  return arr\nend",
  "    local max = []\n    for i = 1, k do\n        table.insert(max, table.max(arr))\n\
    \        table.sort(arr)\n    end\n    return max\nend", '    if k < 1 or k >
    #arr then return end', "\tlocal maxArr = {}\n\tlocal maxIndex = 0\n\tfor i = 1,\
    \ k do\n\t\tlocal tempMax = arr[1]\n\t\tfor j = 2, #arr do\n\t\t\tlocal temp =\
    \ arr[j]\n\t\t\tif temp > tempMax then\n\t\t\t\ttempMax = temp\n\t\t\tend\n\t\t\
    end\n\t\ttable.insert(maxArr, tempMax)\n\tend\n\treturn maxArr\nend", "    if\
    \ not (1 <= k <= #arr) then return nil end\n    local a = {}\n    for i = 1, k\
    \ do\n        local maxElement = arr[1]\n        for j = 2, #arr do\n        \
    \    if arr[j] > maxElement then\n                maxElement = arr[j]\n      \
    \      end\n        end\n        a[i] = maxElement\n    end\n    return a\nend",
  "    if k > #arr or k < 1 then\n        return nil\n    end\n    local a = {}\n\
    \    local i = 1\n    while i <= k do\n        local min = math.max(1, arr[i])\n\
    \        if #a < i then\n            a[i] = min\n        else\n            a[i]\
    \ = a[i] + min\n        end\n        i = i + 1\n    end\n    return a\nend", " \
    \   if k < 1 then return nil end\n    if k == 1 then return arr end\n    if k\
    \ > #arr then return nil end\n    local arr = sort(arr, 0, #arr)\n    local max1,\
    \ max2 = arr[1], arr[1]\n    for i = 2, #arr do\n        if max1 ~= nil then\n\
    \            if max2 ~= nil and max2 > max1 then return nil end\n            if\
    \ arr[i] > max2 then max2 = arr[i] end\n        end\n        if arr[i] > max1\
    \ then max1 = arr[i] end\n    end\n    return max1, max2\nend", "    local arr_size\
    \ = #arr\n    local result = {}\n    local max_element = arr[1]\n    local max_index\
    \ = 1", "    if k == 0 then\n        return arr\n    end", "    local tempMax\
    \ = arr[1]\n    local maxIndex = 1\n    for index = 2, #arr do\n        if arr[index]\
    \ > tempMax then\n            tempMax = arr[index]\n            maxIndex = index\n\
    \        end\n    end\n    if k > maxIndex then\n        return nil\n    end\n\
    \    local result = {}\n    for index = maxIndex, #arr do\n        table.insert(result,\
    \ arr[index])\n    end\n    return maxIndex > k and result or result\nend", " \
    \   if k == 0 then\n        return arr\n    end", "  if k == 0 then\n    return\
    \ arr\n  end\n  \n  local max_so_far = nil\n  local max_element = arr[1]\n  \n\
    \  for i = 2, #arr do\n    local element = arr[i]\n    if element > max_element\
    \ then\n      max_so_far = nil\n      max_element = element\n    else\n      if\
    \ max_so_far == nil or max_element < max_so_far then\n        max_so_far = max_element\n\
    \      else\n        max_element = max_so_far\n      end\n    end\n  end\n  \n\
    \  return maximum(arr, k - 1)\nend", "   local maxes = arr:clone()\n   for i =\
    \ 1, k:len() do\n      for j = 1, k:len() do\n         if maxes[j] > maxes[i]\
    \ then\n            local t = maxes[j]\n            maxes[j] = maxes[i]\n    \
    \        maxes[i] = t\n         end\n      end\n   end\n   return maxes\nend",
  "    if not k then\n        k = 1\n    end\n    local max = nil\n    for i = 1,\
    \ k do\n        local element = arr[i]\n        if element > max then\n      \
    \      max = element\n        else\n            break\n        end\n    end\n\
    \    for i = k + 1, #arr do\n        local element = arr[i]\n        if element\
    \ > max then\n            max = element\n        end\n    end\n    return max\n\
    end", "  if k == 0 then return arr end\n  if k >= #arr then return arr end\n \
    \ local i, j = 1, k\n  local result = {}\n  while i <= #arr do\n    local maximum\
    \ = arr[i]\n    for j = i + 1, #arr do\n      if maximum < arr[j] then\n     \
    \   maximum = arr[j]\n      end\n    end\n    table.insert(result, maximum)\n\
    \    i = j + 1\n  end\n  return result\nend", "\tif k ~= nil then\n\t\tif k <\
    \ 1 then \n\t\t\treturn nil \n\t\telse \n\t\t\t-- Sort the given array and return\
    \ the max k elements.\n\t\t\treturn arr:sorted():take(k)\n\t\tend\n\telse\n\t\t\
    -- Return the maximum k elements.\n\t\treturn arr:sorted():take(k)\n\tend\nend",
  "    if not (type(arr) == 'table') then return end\n    if not (type(k) == 'number')\
    \ then return end\n    if k > #arr then return end\n    local temp = {}\n    local\
    \ temp1 = {}\n    local j = 1\n    for i = 1, k do\n        temp[i] = 0\n    \
    \    temp1[i] = 0\n    end\n    for i = 1, #arr do\n        temp[i] = arr[i]\n\
    \        temp1[i] = arr[i]\n        if temp[i] > temp1[i] then\n            for\
    \ j = i, #temp do\n                temp[j] = temp[j]\n                temp1[j]\
    \ = temp1[j]\n            end\n        end\n    end\n    for i = k + 1, #temp\
    \ do\n        temp[#temp + k] = temp[i]\n        temp1[#temp1 + k] = temp1[i]\n\
    \    end\n    return temp\nend", "    local n = math.min(k, #arr)\n    local max_list\
    \ = []\n    for i = 1, n do\n        max_list[#max_list + 1] = arr[i]\n    end\n\
    \    for i = 2, k do\n        local max_element = max_list[1]\n        local max_element_index\
    \ = 2\n        for j = 2, #max_list do\n            if max_element < max_list[j]\
    \ then\n                max_element = max_list[j]\n                max_element_index\
    \ = j\n            end\n        end\n        max_list[max_element_index] = arr[i\
    \ - 1]\n    end\n    return max_list\nend", "\tif k > #arr then\n\t\tk  = #arr\n\
    \tend\n\tlocal maxValue = -1000\n\tlocal result   = {}\n\tfor i = 1, k do\n\t\t\
    if arr[i] > maxValue then\n\t\t\tmaxValue = arr[i]\n\t\tend\n\tend\n\tfor i =\
    \ 1, k do\n\t\tresult[i] = arr[i]\n\tend\n\tfor i = k, #arr do\n\t\tresult[i]\
    \ = maxValue\n\tend\n\treturn result\nend", "  if k == 0 then return arr end\n\
    \  if k >= #arr then return arr end\n  if arr[k] >= arr[k-1] then\n    arr[k]\
    \ = maximum(arr, k-1)\n    return maximum(arr, k-1)\n  end\n  \n  return arr\n\
    end", "    local arr2 = {}\n    local index = 0\n    for i = 1, #arr do\n    \
    \    local temp = 0\n        for j = 1, #arr do\n            if arr[i] > arr[j]\
    \ then\n                temp = arr[i]\n            end\n        end\n        arr2[index]\
    \ = temp\n        index = index + 1\n    end\n    if k == 1 then\n        return\
    \ arr2\n    end\n    local arr3 = {}\n    for i = k, #arr2 do\n        arr3[i\
    \ - k + 1] = arr2[i]\n    end\n    return arr3\nend", "  -- base case: if we have\
    \ only one element or fewer elements, just return it.\n  if k == 1 or #arr < k\
    \ then\n    return arr\n  end", "    local max = 0\n    local max_val = nil\n\
    \    \n    if k > #arr then return nil end\n    \n    -- The largest element in\
    \ the list can have at most k elements\n    while #arr > k do\n        if arr[#arr]\
    \ > max then max = arr[#arr] end\n        arr[#arr] = nil\n    end\n    max_val\
    \ = max\n    \n    -- The largest element in the list can have at most k elements\n\
    \    for i = 1, k do\n        if max_val then\n            arr[#arr + 1] = max_val\n\
    \        else\n            arr[#arr + 1] = arr[i]\n        end\n        \n   \
    \     if arr[i] > max_val then\n            max_val = arr[i]\n        end\n  \
    \  end\n    \n    return arr\nend", "    local arrLength = #arr\n    \n    if\
    \ k > arrLength then return nil end\n    \n    if k == 0 then return arr end\n\
    \    \n    local result = {}\n    local maxIndex = 0\n    local maxValue = arr[0]\n\
    \    \n    for index = 1, arrLength do\n        if arr[index] > maxValue then\n\
    \            table.insert(result, arr[index])\n            maxValue = arr[index]\n\
    \            maxIndex = index\n        end\n    end\n    \n    table.insert(result,\
    \ arr[maxIndex])\n    \n    return result\nend", "  if k == nil then return arr\
    \ end\n  local maximum, count = {}, 0\n  local i, j = #arr - 1, 0\n  for i = 1,\
    \ k do\n    local element = arr[i]\n    if i == 1 then \n      maximum[element]\
    \ = element\n      count = count + 1\n    else\n      j = i - 1\n      while j\
    \ > 0 and arr[j] > element do\n        maximum[arr[j]] = maximum[arr[j]]\n   \
    \     count = count + 1\n        if count > k then break end\n        j = j -\
    \ 1\n      end\n      maximum[element] = element\n    end\n  end\n  return maximum\n\
    end", "  if k <= 0 or #arr <= k then\n    return nil\n  end\n  local i = 1\n \
    \ local max = 0\n  local max_i = 0\n  local max_arr = []\n  local cur_max = 0\n\
    \  -- Initialize max with first element of arr\n  max = arr[1]\n  -- Initialize\
    \ max_arr with first element of arr\n  max_arr = arr[1]\n  -- While there are\
    \ still elements to compare\n  -- Check if next element is greater or equal than\
    \ max and append it to the max_arr\n  while i <= #arr and arr[i] <= max do\n \
    \   if arr[i] > max then\n      -- If max is greater than current element, then\
    \ update max and max_i\n      if cur_max < arr[i] then\n        max = arr[i]\n\
    \        max_i = i\n      else\n        -- If max is not greater than current\
    \ element and greater than previous max \n        -- then replace current max\
    \ with current element and update i\n        if arr[i] > cur_max then\n      \
    \    max = arr[i]\n          max_i = i\n        end\n      end\n      max_arr\
    \ = arr[i]\n      -- update cur_max to max if current element is greater than\
    \ previous max\n      cur_max = max\n    end\n    -- Append arr[i] to max_arr\
    \ if current element is greater than previous max\n    max_arr = max_arr .. arr[i]\n\
    \    i = i + 1\n  end\n  return max_arr\nend", "  assert(k>0 and k<=#arr)\n  local\
    \ max_so_far = arr[1]\n  local max_so_far_index = 1\n  local max_so_far_indexes\
    \ = {1}\n  for i = 2, #arr do\n    if arr[i] > max_so_far then\n      max_so_far\
    \ = arr[i]\n      max_so_far_index = i\n      max_so_far_indexes = {}\n    end\n\
    \    max_so_far_indexes[max_so_far_index + 1] = i\n  end\n  local max_so_far_indexes\
    \ = {max_so_far_indexes[1]}\n  for i = 1, k do\n    local current_index = max_so_far_indexes[i]\n\
    \    for j = max_so_far_index + 2, #max_so_far_indexes do\n      if max_so_far_indexes[j]\
    \ ~= current_index then\n        table.insert(max_so_far_indexes, current_index)\n\
    \        break\n      end\n    end\n  end\n  return max_so_far_indexes\nend",
  "    local out = {}\n    local n = 1\n    for i = 1, k do\n        for j = 1, n\
    \ do\n            local v = out[j]\n            if arr[i] > v then\n         \
    \       out[j] = arr[i]\n            end\n        end\n        n = n + 1\n   \
    \ end\n    return table.concat(out, \".\")\nend", "  -- Base cases\n  if k ==\
    \ 0 or k == 1 then\n    return arr\n  else\n    -- Initialization\n    local curr\
    \ = arr[1]\n    local maximum, max = curr, arr[1]", '  if k > length(arr) then
    return nil end', "   -- Base case\n   if k == 0 then return arr end\n   if k ==\
    \ 1 then return arr[1] end\n   local biggest = maximum(arr, k-1)\n   if arr[k]\
    \ > biggest then return biggest else return arr[k] end\n   -- recursive step\n\
    \   return maximum(arr, k-1)\nend\nprint(maximum([-6, -4, -1, -2, -5, 3, 7, 9,\
    \ 10], 3))", "    if k < 1 then return nil end\n    if k == 1 then\n        if\
    \ arr[1] == arr[2] then\n            return arr\n        else\n            return\
    \ [arr[1]]\n        end\n    end\n    \n    local max_list = nil\n    local max_index\
    \ = nil\n    local max_val = nil\n    for i = 1, #arr do\n        if arr[i] >\
    \ max_val then\n            max_val = arr[i]\n            max_index = i\n    \
    \    end\n    end\n    if max_val == arr[0] then\n        max_list = arr\n   \
    \ else\n        max_list = arr\n        table.insert(max_list, max_index)\n  \
    \  end\n    \n    max_list = sort(max_list, k)\n    return max_list\nend", " \
    \ local maxArray = {}\n  for _, x in ipairs(arr) do\n    if x == nil then\n  \
    \    break -- we dont want nil values at any point in the process\n    end\n \
    \   if x > maxArray[1] then\n      maxArray[1] = x\n    end\n  end", "  if k >\
    \ #arr then return nil end\n  local maxArr = {x = 0, y = arr[#arr]}\n  for i =\
    \ 1, #arr do maxArr.y = max(maxArr.y, arr[i]) end\n  for i = 1, k do maxArr =\
    \ {x = maxArr.x + 1, y = arr[i], z = maxArr} end\n  return maxArr\nend", "  if\
    \ k == 1 then\n    return arr\n  end\n  local m = {}\n  for _, v in ipairs(arr)\
    \ do\n    if v > m[k] then\n      m[k] = v\n    end\n  end\n  return maximum(arr,\
    \ k - 1)\nend\nprint(maximum([-3, 4, -2, 1, 5, 6, -7, 8, -9, 10], 3))", "  --\
    \ Initialize maxVal with first element of arr\n  local maxVal = arr[1]\n  -- Initialize\
    \ i with second element of arr\n  local i = 2\n  -- Initialize maxArr with first\
    \ element of arr\n  local maxArr = arr[1]\n  -- Start loop while i < k\n  while\
    \ i <= k do\n    -- If current element of arr is greater than maxVal, update maxVal\
    \ and maxArr\n    if arr[i] > maxVal then\n      maxVal = arr[i]\n      maxArr\
    \ = arr[i]\n    -- Otherwise, update maxArr\n    else\n      maxArr = maxArr\n\
    \    end\n    -- Increment i\n    i = i + 1\n  end\n  -- Return maxArr\n  return\
    \ maxArr\nend", "    local maxIndex = 1\n    local maxValue = arr[1]\n    for\
    \ index = 2, k do\n        if arr[index] > maxValue then\n            maxIndex\
    \ = index\n            maxValue = arr[index]\n        end\n    end\n    return\
    \ maxIndex, maxValue\nend", "  -- Your code here\n  local results = {}\n  local\
    \ i = 0\n  while i < k do\n    local current = arr[i]\n    local max_idx = 0\n\
    \    for idx = i, #arr do\n      if arr[idx] > current then\n        local tmp\
    \ = arr[idx]\n        arr[idx] = current\n        current = tmp\n      end\n \
    \     if idx > max_idx then max_idx = idx end\n    end\n    table.insert(results,\
    \ current)\n    i = max_idx + 1\n  end\n  return results\nend", "    local count\
    \ = 1\n    local maxCount = 0\n    for i = 1, k do\n        count = 1\n      \
    \  maxCount = count\n        for j = 1, k do\n            if arr[i] > arr[j] then\n\
    \                count = count + 1\n            else\n                maxCount\
    \ = maxCount + 1\n            end\n        end\n    end\n    local list = {}\n\
    \    for i = 1, k do\n        if count == maxCount then\n            table.insert(list,\
    \ arr[i])\n        end\n    end\n    return list\nend", "   local lst = table.removeValues(\
    \ arr, k )\n   for i = k + 1,#arr do\n      if arr[i] > lst[#lst] then\n     \
    \    lst[#lst] = arr[i]\n      end\n   end\n   return lst\nend", "\t-- Initialize\
    \ max to arr[0].\n\tlocal max = {}\n\t-- Initialize flag to false.\n\tlocal flag\
    \ = false\n\t-- Increment i by 1.\n\ti = i + 1\n\t-- Iterate until i is less than\
    \ or equal to k.\n\twhile i < k do\n\t\t-- Initialize max to current number in\
    \ arr.\n\t\tlocal current = arr[i]\n\t\t-- If the current number is greater than\
    \ max, set the flag to true.\n\t\tif current > max then\n\t\t\tflag = true\n\t\
    \t\t-- Set max to the current number.\n\t\t\tmax = current\n\t\telse\n\t\t\t--\
    \ If current number is equal to max, increment i by 1.\n\t\t\tif current == max\
    \ then\n\t\t\t\ti = i + 1\n\t\t\tend\n\t\tend\n\tend\n\t-- Return arr if k is\
    \ less than or equal to number of elements in arr.\n\tif k > i then\n\t\treturn\
    \ arr\n\telse\n\t\treturn flag and arr or nil\n\tend\nend", "\tif k > #arr then\
    \ return nil end\n\tlocal max_arr = {}\n\tlocal cur_max = arr[1]\n\tfor i = 2,\
    \ #arr do\n\t\tif cur_max >= arr[i] then\n\t\t\tcur_max = arr[i]\n\t\tend\n\t\t\
    table.insert(max_arr, cur_max)\n\tend\n\treturn max_arr\nend", "    if k == 0\
    \ then\n        return arr\n    end", "    local maxArr = {}\n    local size =\
    \ #arr\n    local sortedArray = arr -- copy arr\n    if k <= 0 then\n        return\
    \ sortedArray\n    end\n    if k > size then\n        k = size -- reduce k to\
    \ upper limit if k exceeds size of arr\n    end", "    local max = 0\n    local\
    \ max_idx\n    for i = 1, k do\n        max_idx = i\n        for j = 1, k do\n\
    \            if arr[i] > arr[max_idx] then\n                max_idx = j\n    \
    \        end\n        end\n        max = arr[max_idx]\n    end\n    return max\n\
    end", "    local i = 1\n    local max_count = 0\n    local max_list = []\n   \
    \ for _,x in ipairs(arr) do\n        if x >= max_count then\n            table.insert(max_list,\
    \ x)\n        elseif x == max_count then\n            max_count = x\n        \
    \    table.insert(max_list, x)\n        end\n    end\n    return max_list\nend",
  "  assert(k>0 and k<=#arr, 'Parameter k out of range!')\n  local ans = {}\n  for\
    \ i = 1, k do\n    local temp = arr[1]\n    for j = 2, #arr do\n      if arr[j]\
    \ > temp then\n        temp = arr[j]\n      end\n    end\n    table.insert(ans,\
    \ temp)\n  end\n  return ans\nend", "    if k > #arr then\n        return nil\n\
    \    end", "    if k > #arr then return nil end\n    local max = {}\n    for i\
    \ = 1, k do\n        local x = array[i]\n        for j = i + 1, k do\n       \
    \     if x > array[j] then x = array[j]\n            end\n        end\n      \
    \  max[i] = x\n    end\n    return max\nend", "  -- Initialize max to the first\
    \ k elements.\n  local max = arr[1]\n  for i = 2, k do\n    -- Update the max\
    \ if the current max is greater than arr[i].\n    if max > arr[i] then\n     \
    \ max = arr[i]\n    end\n  end", "    local maxes = {}\n    for i = 1, k do\n\
    \        local tmp = 0\n        for j = 1, #arr do\n            if arr[j] > tmp\
    \ then\n                tmp = arr[j]\n            end\n        end\n        maxes[i]\
    \ = tmp\n    end\n    return maxes\nend", "  assert(type(k) == \"number\" \n \
    \     and k > 0 and k <= #arr, \"k out of range\")\n  \n  local result = {}\n\
    \  local largest = {}\n  local length = 0\n  \n  for i = 1, #arr do\n    length\
    \ = length + 1\n    local value = arr[i]\n    if length == k then\n      table.insert(result,\
    \ value)\n    elseif length > k and value < largest[length] then\n      table.insert(result,\
    \ value)\n      largest[length] = value\n    end\n  end\n  return result\nend",
  "    if k == 0 then\n        return arr\n    end\n    if k == 1 then\n        return\
    \ arr\n    end\n    \n    local max_k = 0\n    local max_elem = nil\n    local\
    \ current_max = nil\n    local i = 1\n    \n    while i <= #arr do\n        if\
    \ arr[i] > current_max then\n            current_max = arr[i]\n            max_k\
    \ = i - 1\n        end\n        i = i + 1\n    end\n    \n    local j = 1\n  \
    \  while j <= k do\n        if max_k + j - 1 > #arr then\n            break\n\
    \        end\n        if max_k + j - 1 < 0 then\n            break\n        end\n\
    \        if arr[j] > arr[max_k + j - 1] then\n            max_k = max_k + j -\
    \ 1\n            max_elem = arr[j - 1]\n        end\n        j = j + 1\n    end\n\
    \    \n    return max_k + 1, max_elem\nend", "    if k > #arr then\n        return\
    \ 0\n    end\n    \n    local max = 0\n    local maxIndex = 0\n    local tempMax\
    \ = 0\n    local tempMaxIndex = 0\n    \n    for i = 1, #arr do\n        if arr[i]\
    \ > max then\n            temp = arr[i]\n            maxIndex = i\n          \
    \  max = temp\n        end\n    end\n    \n    for i = 1, #arr do\n        if\
    \ arr[i] > max and arr[i] > tempMax then\n            tempMax = arr[i]\n     \
    \       tempMaxIndex = i\n        end\n    end\n    \n    local index = k\n  \
    \  for i = 1, #arr do\n        if arr[i] > max then\n            index = i - 1\n\
    \            break\n        end\n    end\n    \n    return tempMaxIndex, index\n\
    end", "  assert(k > 0 and k <= #arr)\n  local max = -math.inf\n  local results\
    \ = {}\n  for i = 1, k do\n    local elem = arr[i]\n    if elem > max then\n \
    \     max = elem\n    end\n    results[i] = elem\n  end\n  return table.concat(results,\
    \ k)\nend", "  if k == 0 then\n    return arr\n  else\n    local n = 1\n    local\
    \ index = 1\n    local max = 0\n    while n <= k do\n      if max < arr[index]\
    \ then\n        max = arr[index]\n      end\n      if index == #arr then\n   \
    \     break\n      end\n      index = index + 1\n      n = n + 1 \n    end\n \
    \   return arr\n  end\nend", "    if k <= 0 or k > #arr then\n        return nil\n\
    \    end\n    local result = {}\n    local n = #arr\n    for i = 1, k do\n   \
    \     local max = arr[i - 1]\n        for j = 1, n do\n            if max < arr[j]\
    \ then\n                max = arr[j]\n            end\n        end\n        result[#result\
    \ + 1] = max\n    end\n    return result\nend", "  -- base case\n  if k == 0 then\
    \ \n    return {arr} \n  end\n  -- k is larger than the length of arr\n  if k\
    \ >= #arr then \n    return {arr} \n  end\n  -- get the max number in the first\
    \ k\n  local m = #arr\n  local max_num = arr[1]\n  -- find max number in the rest\
    \ of the arr\n  for i = 2, k do\n    if arr[i] > max_num then \n      m = i\n\
    \      max_num = arr[i]\n    end\n  end\n  -- return the max arr slice with maximum\
    \ nums in arr[m..k]\n  return maximum(arr, k - 1) + {arr[m, max_num]}\nend", " \
    \   local max = {}\n    local max = arr[0]\n    for i = 1, k do\n        max =\
    \ {max, arr[i]}\n    end\n    return max\nend", "\tif k <= 0 then\n\t\treturn\
    \ nil\n\tend", "  local sorted\n  local maximum\n  if k <= 0 then\n    sorted\
    \ = arr\n  else\n    sorted = arr:sort(function(a, b) return a > b end)\n    maximum\
    \ = sorted[k]\n  end\n  return sorted:sub(1, k), maximum\nend", "\t-- k is the\
    \ number of maximal elements to output\n\t-- k is in [0, len(arr))\n\tif k > #arr\
    \ then return nil end\n\t\n\t-- sort the array from max to min\n\tlocal max =\
    \ arr[1]\n\tfor i = 2, #arr do\n\t\tif arr[i] > max then\n\t\t\tmax = arr[i]\n\
    \t\tend\n\tend", "   assert(k > 0 and arr and k <= #arr)\n   local max_so_far\
    \ = arr[1]\n   local max_after = arr[k]\n   local i = 1\n   while i <= k do\n\
    \      if max_after > max_so_far then\n         max_so_far = max_after\n     \
    \ else\n         max_after = arr[i]\n      end\n      i = i + 1\n   end\n   return\
    \ max_so_far\nend", "    if not k then\n        return arr\n    end\n    if k\
    \ >= #arr then\n        return arr\n    end\n    local max_arr = arr[k]\n    local\
    \ max_idx = k\n    for i = k + 1, #arr do\n        if arr[i] > max_arr then\n\
    \            max_arr = arr[i]\n            max_idx = i\n        end\n    end\n\
    \    return maximum(arr, max_idx - 1)\nend", "    local a = {}\n    for i = 1,k\
    \ do\n        a[i] = 0\n    end\n    for i = 1,#arr do\n        if arr[i] > a[#a]\
    \ then\n            a[#a] = arr[i]\n        end\n    end\n    return a\nend",
  "    if k <= 0 or k > #arr then\n        return nil\n    end", "  local arr = arr\
    \ or {}\n  local length = #arr\n  assert(k > 0 and k <= length, \"k is out of\
    \ bounds\")\n  local result = {}\n  local max = -math.huge\n  local cur = 0\n\
    \  for i = 1, length do\n    if arr[i] > max then\n      max = arr[i]\n      cur\
    \ = i\n    end\n  end\n  if cur ~= length then\n    for i = 1, k do\n      table.insert(result,\
    \ max)\n    end\n  end\n  return result\nend", "    if k > #arr then\n       \
    \ return arr\n    end", "    if k < 1 or k > 1000 then return nil end\n    local\
    \ h = {}\n    for i = 1,k do\n        h[i] = 0\n    end\n    for i = 1,#arr do\n\
    \        local v = arr[i]\n        if h[v] < i then\n            h[v] = i\n  \
    \      end\n    end\n    for i = 1,k do\n        arr[i] = h[i]\n    end\n    return\
    \ arr\nend", "\tif k == nil then return arr end\n\tif k > #arr then return nil\
    \ end", "    if k == 0 then return arr\n    else if k <= 0 then return nil end\n\
    \    -- Base case\n    if arr[1] <= arr[2] then\n        local max = maximum(arr,\
    \ k - 1)\n        if max ~= nil then\n            table.insert(max, arr[1])\n\
    \        end\n        return max\n    end\n    -- Find the max number in arr\n\
    \    local mn = math.max(1, arr[1])\n    local max = nil\n    for i = 2, k do\n\
    \        if arr[i] > mn then\n            mn = arr[i]\n            max = arr\n\
    \        end\n        max = max[1]\n    end\n    table.insert(max, mn)\n    return\
    \ max\nend", "  -- write your code here\n  return arr\nend", "    if k < 1 then\n\
    \        return nil\n    end\n    \n    local max_num = 0\n    local max_idx =\
    \ 0\n    local i = 1\n    \n    for i = 1, k do\n        if arr[i] > max_num then\n\
    \            max_idx = i\n            max_num = arr[i]\n        end\n    end\n\
    \    \n    return arr[k - 1], max_idx, max_num\nend", "  -- Base Case\n  if k\
    \ == 0 then\n    return arr\n  end", "  local function helper(arr, k)\n    local\
    \ ans = {}\n    for i = 1, k do\n      local max, v = 0, arr[1]\n      for j=1,\
    \ #arr do\n        if v > max then\n          max, v = j, arr[j]\n        elseif\
    \ v == max then\n          max = v\n        end\n      end\n      table.insert(ans,\
    \ max)\n    end\n    return ans\n  end\n  if k > #arr then return arr end\n  if\
    \ k == #arr then return helper(arr, k) end\n  return helper(arr, k - 1) + helper(arr,\
    \ k)\nend", "  assert(k > 0 and arr:len() > 0)\n  \n  local max_elements = {}\n\
    \  local index = 1\n  \n  repeat\n  \n    -- Find the max element in the array.\n\
    \    local max = arr[index]\n    local max_index = -1\n    local max_value_index\
    \ = 0\n    \n    for i = 1, k do\n      if arr[i] > max then\n        max = arr[i]\n\
    \        max_index = i\n      end\n      if arr[i] == max then\n        max_value_index\
    \ = i\n      end\n    end\n    \n    -- If this max element has already been found,\
    \ break the loop.\n    if max_index >= 0 then\n      index = max_index\n     \
    \ break\n    end\n    \n    -- If there is no max element, add the element to\
    \ the max element list.\n    if max_value_index == -1 then\n      max_elements[#max_elements\
    \ + 1] = max\n      break\n    end\n    \n    -- If there is still room to insert\
    \ the max element, swap the current max element with the max element that has\
    \ yet to be inserted.\n    if max_index == k - 1 then\n      arr[max_value_index],\
    \ arr[#arr] = arr[#arr], arr[max_value_index]\n      max_elements[#max_elements\
    \ + 1] = max\n      break\n    end\n    \n    -- If no room left to insert the\
    \ max element, insert it.\n    max_elements[#max_elements + 1] = max\n    \n \
    \   -- Insert the max element to the next position in the array.\n    index =\
    \ max_index + 1\n    \n  until index > #arr", "\tif k > #arr then\n\t\treturn\
    \ nil\n\tend", "    local max_set = { }\n    local max_index = 1\n    local max_value\
    \ = -1000", "  local arr_size = #arr\n  if arr_size ~= 0 then\n    local max_count\
    \ = 0\n    local max_val\n    for i = 1, arr_size do\n      local tmp_val = arr[i]\n\
    \      if tmp_val > max_val then\n        max_val = tmp_val\n      elseif tmp_val\
    \ == max_val then\n        max_count = max_count + 1\n      end\n    end\n   \
    \ if k > max_count then return end\n    local max_arr_val = 0\n    for i = 1,\
    \ arr_size do\n      local tmp_val = arr[i]\n      if tmp_val > max_arr_val then\n\
    \        max_arr_val = tmp_val\n      end\n    end\n    if k == max_count then\n\
    \      local arr_val = max_arr_val\n      for i = 1, arr_size do\n        arr[i]\
    \ = arr_val\n      end\n    end\n    for i = 1, arr_size do\n      arr[i] = max_arr_val\n\
    \    end\n  end\n  return arr\nend", "    local n = 0\n    local m = math.max(math.min(k,\
    \ #arr), 1) -- k is valid in range [1, #arr]\n    for i = m, 1, -1 do -- n <=\
    \ m < len(arr)\n        if arr[i] > arr[n] then\n            n = i\n        end\n\
    \    end\n    \n    local result\n    if n then\n        result = arr[n]\n   \
    \     -- if k is greater than #arr, result should be arr[1]\n        if k > #arr\
    \ then\n            result = arr[1]\n        end\n    end\n    return result\n\
    end", "    local n = math.min(k, #arr)\n    local max_arr = {}\n    local max_val\
    \ = -math.inf\n    for i = 1, n do\n        if arr[i] > max_val then\n       \
    \     max_val = arr[i]\n        end\n        max_arr[i] = max_val\n    end\n \
    \   return max_arr\nend", "    if k < 1 or k > #arr then\n        return 'Invalid\
    \ parameters'\n    end\n    local sorted_arr = tablex.new()\n    local max_index\
    \ = 0\n    local max_val = -math.inf\n    for i = 1, k do\n        for j = 1,\
    \ #arr do\n            if arr[j] < arr[max_index] then\n                local\
    \ tmp = arr[j]\n                arr[j] = arr[max_index]\n                arr[max_index]\
    \ = tmp\n            else\n                local tmp = arr[max_index]\n      \
    \          arr[max_index] = arr[j]\n                arr[j] = tmp\n           \
    \ end\n        end\n        table.insert(sorted_arr, arr[max_index])\n       \
    \ max_index = max_index + 1\n        if max_val < arr[max_index] then\n      \
    \      max_val = arr[max_index]\n        end\n        if k == 1 then\n       \
    \     break\n        end\n    end\n    return sorted_arr\nend", "  if k == 1 then\n\
    \    return arr\n  else\n    local max = {arr[1]}\n    for i = 2, k do\n     \
    \ local value = arr[i]\n      local j = 1\n      for _, v in ipairs(max) do\n\
    \        if value > v then\n          value = v\n          j = i\n        end\n\
    \      end\n      table.insert(max, value)\n      arr[j] = i\n    end\n    return\
    \ arr\n  end\nend", "  if k > #arr then\n    return nil\n  else\n    local l =\
    \ 0\n    local h = 1\n    local max = 1\n    local index = 1\n    while true do\n\
    \      local element = arr[index]\n      if element > max then\n        max =\
    \ element\n        index = index + 1\n      elseif index == k then\n        return\
    \ max\n      end\n      if element < arr[l] then\n        l = index\n      elseif\
    \ element > arr[h] then\n        h = index\n      end\n    end\n  end\nend", " \
    \   if k == 0 then\n        return 0\n    end", "    if k == 0 then\n        --\
    \ do nothing\n        return\n    end\n    local maxArray = {}\n    local maxElement\
    \ = arr[1]\n    for i = 2, k do\n        if arr[i] > maxElement then\n       \
    \     maxElement = arr[i]\n        end\n    end\n    for i = 2, k do\n       \
    \ if arr[i] ~= maxElement then\n            if arr[i] > maxElement then\n    \
    \            table.insert(maxArray, arr[i])\n            else\n              \
    \  maxElement = arr[i]\n            end\n        end\n    end\n    -- remove duplicates\n\
    \    table.sort(maxArray)\n    return maxArray\nend", "    if k == 0 then\n  \
    \      return arr\n    end", "    if k == 0 then\n        return arr\n    end\n\
    \    if k == 1 then\n        local max = arr[1]\n        for i = 2, #arr do\n\
    \            if arr[i] > max then\n                max = arr[i]\n            end\n\
    \        end\n        return max\n    end\n    local max = arr[1]\n    for i =\
    \ 2, #arr do\n        if arr[i] > max then\n            max = arr[i]\n       \
    \ end\n    end\n    local result = {}\n    for i = 2, #arr do\n        if arr[i]\
    \ > max then\n            result[#result + 1] = arr[i]\n        end\n    end\n\
    \    return maximum(result, k - 1)\nend", "\tif k == nil then k = #arr end\n\t\
    if k == 0 then return arr end\n\tlocal max_element\n\tlocal max_element = arr[1]\n\
    \tlocal max_index = k\n\tfor i = 2, k do\n\t\tif arr[i] > max_element then\n\t\
    \t\tmax_element = arr[i]\n\t\t\tmax_index = i\n\t\tend\n\tend\n\treturn maximum(arr,\
    \ k-1)\nend", "  -- base case\n  if k == 1 then return arr end\n  \n  -- initialize\
    \ max and max_idx\n  local max_idx = k \n  local max = arr[1]\n  \n  -- find the\
    \ max value less than current max value\n  for idx = 2, k do\n    local cur_val\
    \ = arr[idx]\n    if cur_val <= max then\n      max = cur_val\n      max_idx =\
    \ idx\n    end\n  end", "\tlocal arr_size = #arr\n\tlocal max_arr_size = arr_size\
    \ * k\n\tlocal max_arr = {}\n\tlocal max_arr_size = arr_size * k\n\tlocal max_num\
    \ = nil\n\tlocal max_num = nil\n\tlocal arr_pos\n\tlocal tmp_pos\n\tlocal tmp_num\n\
    \tlocal tmp_num_arr\n\tlocal arr_pos\n\tlocal tmp_pos\n\tlocal tmp_num\n\tlocal\
    \ tmp_num_arr\n\tlocal pos\n\tlocal num\n\tlocal num_arr\n\t\n\tfor pos = 1, arr_size\
    \ do\n\t\tif pos > max_arr_size then\n\t\t\tbreak\n\t\telseif pos > max_arr_size\
    \ then\n\t\t\tmax_arr_size = max_arr_size * 2\n\t\telse\n\t\t\tarr_pos = pos\n\
    \t\t\ttmp_num_arr = arr[arr_pos]\n\t\t\tfor num = 1, k do\n\t\t\t\tif tmp_num_arr\
    \ > arr[arr_pos] then\n\t\t\t\t\ttmp_pos = arr_pos\n\t\t\t\t\ttmp_num = tmp_num_arr\n\
    \t\t\t\t\ttmp_num_arr = arr[tmp_pos]\n\t\t\t\telse\n\t\t\t\t\tarr_pos = arr_pos\
    \ + 1\n\t\t\t\t\ttmp_num_arr = arr[arr_pos]\n\t\t\t\tend\n\t\t\tend\n\t\t\tif\
    \ tmp_num_arr > arr[arr_pos] then\n\t\t\t\tmax_arr[pos] = tmp_num\n\t\t\telse\n\
    \t\t\t\tarr_pos = arr_pos + 1\n\t\t\t\ttmp_num_arr = arr[arr_pos]\n\t\t\tend\n\
    \t\tend\n\tend\n\treturn max_arr\nend", "    if k == 0 then\n        return arr\n\
    \    elseif k <= 0 then\n        error(\"k must be positive\")\n    end", "  \
    \ if k > #arr then return nil end\n   local lst, i, tmp, curr = {}, 1, arr[1],\
    \ true\n   repeat\n      if i >= k then\n         if curr ~= arr[i] then\n   \
    \         lst[#lst+1] = curr\n         end\n         i = 0\n      elseif curr\
    \ ~= arr[i] then\n         lst[#lst+1] = curr\n         i = i+1\n      end\n \
    \     curr = arr[i]\n   until curr == nil\n   if curr ~= arr[i] then\n      lst[#lst+1]\
    \ = curr\n   end\n   return lst\nend", "    if k > #arr then return arr end\n\
    \    local max_value = -math.inf\n    local max_idx = 1\n    for idx = 2, k do\n\
    \        if arr[idx] > max_value then\n            max_value = arr[idx]\n    \
    \        max_idx = idx\n        end\n    end\n    return max_idx, max_value\n\
    end", "\tassert(type(arr) == \"table\" and k == nil or k == k, \"invalid arguments\"\
    )\n\tassert(k == nil or type(k) == \"number\" and k <= length(arr))\n\tlocal t\
    \ = {}\n\tlocal max\n\t\n\tif k == nil then\n\t\tmax = arr[1]\n\t\tfor i = 2,\
    \ #arr do\n\t\t\tif arr[i] > max then max = arr[i] end\n\t\tend\n\telse\n\t\t\
    max = arr[1]\n\t\tlocal i = 1\n\t\tfor i = 2, #arr do\n\t\t\tif arr[i] > max then\
    \ max = arr[i] end\n\t\t\tif i == k then break; end\n\t\tend\n\tend\n\tfor i =\
    \ 2, #arr do\n\t\tif arr[i] > max then max = arr[i] end\n\tend\n\treturn max\n\
    end", "\tif k > #arr or k < 1 then\n\t\treturn nil\n\tend", "    local res = {}\n\
    \    local _arr = arr\n    for _ = 1, k do\n        local max = _arr[1]\n    \
    \    for i = 2, #_arr do\n            if _arr[i] > max then\n                max\
    \ = _arr[i]\n            end\n        end\n        table.insert(res, max)\n  \
    \      _arr[1] = max\n    end\n    return res\nend", "    local max = nil\n  \
    \  local maxnum = 0\n    for i = 1, k do\n        local num = arr[i]\n       \
    \ if num > maxnum then\n            max = num\n            maxnum = num\n    \
    \    else\n            if num == maxnum then\n                maxnum = num\n \
    \           else\n                max = num\n                maxnum = num\n  \
    \          end\n        end\n    end\n    return max\nend", "  -- Base case\n\
    \  if k == 1 then\n    return arr\n  else\n    -- Recursion\n    local max_sublist\
    \ = maximum(arr, k-1)\n    local max_number = max(max_sublist)\n    -- Return\
    \ the maximum sublist + the maximum number in it\n    return max_sublist + [max_number]\n\
    \  end\nend", "  if k == nil then\n    return arr\n  end", "  local output = {}\n\
    \  local pos = 0\n  for i = 1, #arr do\n    if pos >= k then\n      table.insert(output,\
    \ arr[pos])\n      pos = 0\n    else\n      if arr[pos] > arr[pos+1] then\n  \
    \      table.insert(output, arr[pos])\n      end\n      pos = pos + 1\n    end\n\
    \  end\n  return output\nend", "  assert(k > 0 and k and #arr > 0 and k and #arr\
    \ <= 1000)\n  \n  local a = {}\n  local n = 0\n  for i = 1, k do\n    local max\
    \ = math.max(1, arr[n])\n    for j = 1, #arr do\n      local v = arr[j]\n    \
    \  if v > max then max = v end\n    end\n    a[i] = max\n    n = n + 1\n  end\n\
    \  \n  local r = {} --return array\n  for i = k, 1, -1 do\n    r[#r+1] = a[i]\n\
    \  end\n  return r\nend", "  local start = 1\n  local last = math.min(k, #arr)\n\
    \  -- start point by 1\n  -- last point by k\n  for i = start , 1, last do\n \
    \   local max = arr[i]\n    -- use for loop\n    -- arr[i] != nil\n    local j\
    \ = 1\n    while j <= last and arr[j] < max do\n      -- arr[j] < max\n      max\
    \ = arr[j]\n      -- use for loop\n      -- j +1 , j+k\n      j = j + 1\n    end\n\
    \    -- arr[j] <= max\n    arr[j] = max\n  end\n  return arr\nend\nprint(maximum(arr,\
    \ 2))", "    local arrSize = #arr\n    if k < 1 or arrSize == 0 then\n       \
    \ error(\"Invalid parameters\")\n    end\n    local sortedArr = {}\n    if k ==\
    \ 1 then\n        for i = 1, k do\n            table.insert(sortedArr, arr[i])\n\
    \        end\n        return sortedArr\n    end\n    local maxValues = {}\n  \
    \  local maxValueIndex = -1\n    local lastValue = arr[1]\n    for i = 2, arrSize\
    \ do\n        local currentValue = arr[i]\n        if currentValue > lastValue\
    \ then\n            lastValue = currentValue\n            maxValueIndex = 1\n\
    \        else\n            lastValue = currentValue\n            maxValueIndex\
    \ = maxValueIndex + 1\n        end\n        if maxValueIndex > k then\n      \
    \      break\n        end\n        if maxValues[maxValueIndex] == nil then\n \
    \           maxValues[maxValueIndex] = lastValue\n        else\n            if\
    \ maxValues[maxValueIndex] < lastValue then\n                maxValues[maxValueIndex]\
    \ = lastValue\n            end\n        end\n    end\n    for i = 1, arrSize do\n\
    \        table.insert(sortedArr, maxValues[i])\n    end\n    return sortedArr\n\
    end", "\tif k > #arr then\n\t\tprint('ERROR: The length of arr must be no greater\
    \ than k.')\n\t\treturn nil\n\telse\n\t\tlocal largest = arr[1]\n\t\tfor i = 2,\
    \ k do\n\t\t\tif arr[i] > largest then\n\t\t\t\tlargest = arr[i]\n\t\t\tend\n\t\
    \tend\n\t\treturn largest\n\tend\nend", "    local max_count = arr[1]\n    local\
    \ max_list = arr\n    for i = 2, k do\n        if arr[i] > max_count then\n  \
    \          max_count = arr[i]\n            max_list = arr\n        end\n    end\n\
    \    return max_count\nend", "  local arr = arr or {}\n  k = k or 0\n  local results\
    \ = {}\n  local len = #arr\n  assert(k > 0 and k - 1 <= len)\n  assert(k > 0 and\
    \ arr[1] < 1000)", "    local max_count = 0\n    local max_count = 0\n    local\
    \ max_arr = {}\n    local max_arr = {}\n    for i = 1, k do\n        for j = 1,\
    \ #arr do\n            if arr[j] > arr[j+k] then\n                arr[j], arr[j+k]\
    \ = arr[j+k], arr[j]\n            end\n        end\n        if #arr > max_count\
    \ then\n            max_count = #arr\n            max_arr = arr\n        end\n\
    \    end\n    return max_arr\nend", "    local max_num = math.inf\n    local max_idx\
    \ = -1\n    for idx = 1, k do\n        if arr[idx] > max_num then\n          \
    \  max_num = arr[idx]\n            max_idx = idx\n        end\n    end\n    return\
    \ max_num, max_idx\nend", "\tlocal result = {}\n\tlocal largest = 0\n\t\n\t--\
    \ Sort arr in descending order\n\tfor i = #arr, 1, -1 do\n\t\tif arr[i] > largest\
    \ then\n\t\t\tlargest = arr[i]\n\t\tend\n\tend\n\t\n\t-- Get largest k numbers\
    \ in arr\n\tlocal i = 1\n\twhile i <= k do\n\t\tif arr[i] > largest then\n\t\t\
    \tlargest = arr[i]\n\t\tend\n\t\ti = i + 1\n\tend\n\t\n\t-- Add largest k numbers\
    \ in arr to result\n\tfor i = 1, k do\n\t\ttable.insert(result, largest)\n\tend\n\
    \t\n\t-- Sort result from largest to smallest\n\ttable.sort(result)\n\t\n\treturn\
    \ result\nend", "    local output = {}\n    local i = 1\n    \n    repeat\n  \
    \      local x = arr[i]\n        \n        local j = i - 1\n        \n       \
    \ while j ~= 0 and arr[j] > x do\n            output[i + 1] = arr[j]\n       \
    \     j = j - 1\n        end\n        \n        output[i + 1] = x\n        i =\
    \ i + 1\n    until k == 0\n    \n    return output\nend", "  assert(k > 0 and\
    \ k <= #arr, \"k is out of range\")\n  if k == 1 then \n    return arr\n  end\n\
    \  local a = {} --array to hold maximum k elements\n  local m = 0 \n  for i =\
    \ 1, k do\n    if arr[i] > arr[m] then\n      m = i\n    end\n  end\n  table.insert(a,\
    \ arr[m])\n  for i = k + 1, #arr do\n    if arr[i] > arr[m] then\n      table.insert(a,\
    \ arr[i])\n    end\n  end\n  return a\nend", "    local maxes = {}\n    for i\
    \ = 1, k do\n        table.insert(maxes, -1000)\n    end\n    table.sort(maxes)\n\
    \    for _, max in ipairs(maxes) do\n        for i = 1, k do\n            if arr[i]\
    \ > max then\n                table.insert(maxes, arr[i])\n            end\n \
    \       end\n    end\n    return maxes\nend", "  local max_arr = {}\n  local current_max_value\
    \ = 0\n  local count = 0\n  for i = 1, k do\n    if current_max_value > arr[i]\
    \ then\n      count = count + 1\n      max_arr[count] = arr[i]\n      current_max_value\
    \ = arr[i]\n    else\n      count = count + 1\n      max_arr[count] = current_max_value\n\
    \      current_max_value = arr[i]\n    end\n  end\n  if k <= count then\n    for\
    \ i = k+1, count do\n      max_arr[i] = arr[i]\n    end\n  end\n  return max_arr\n\
    end", "    local function helper(arr, i, l, s, max)\n        if i > l then\n \
    \           return max\n        end\n        if arr[i] > max then\n          \
    \  max = arr[i]\n        end\n        return helper(arr, i + 1, l, s, max)\n \
    \   end\n    \n    local _max = helper(arr, 1, #arr, {}, -1000)\n    \n    for\
    \ i = 2, k do\n        _max = helper(arr, i, #arr, _max, -1000)\n    end\n   \
    \ \n    return _max\nend", "\t-- Write your code here\n\treturn arr\nend", " \
    \   assert(k > 0 and k == k, \"k should be integer and greater than zero\")\n\
    \    local n = math.max(2, #arr)\n    local ans = arr[1]\n    for i = 2, n do\n\
    \        if arr[i] > ans then\n            ans = arr[i]\n        end\n    end\n\
    \    return ans\nend", "    local n = #arr\n    local i = 1\n    while i <= n\
    \ do\n        if arr[i] > arr[i - 1]\n        then\n            arr[i - 1], arr[i]\
    \ = arr[i], arr[i - 1]\n        end\n        i = i + 1\n    end\n    local result\
    \ = {arr[i - 1]}\n    for i = (k - 1) to 1 do\n        result[#result + 1] = arr[i]\n\
    \    end\n    return result\nend", "    if k == 0 then\n        return arr\n \
    \   end", "    if k > #arr or k < 1 then\n        return nil\n    end", "  if\
    \ k == 0 then\n    return arr\n  end\n  \n  local max_element = arr[1]\n  local\
    \ max_idx = 0\n  \n  for idx = 2, #arr do\n    if arr[idx] > max_element then\n\
    \      max_element = arr[idx]\n      max_idx = idx\n    end\n  end\n  \n  local\
    \ result = {}\n  for idx = 1, k do\n    result[idx] = arr[max_idx - idx + 1]\n\
    \  end\n  return result\nend", "\tlocal n = 0\n\tlocal max = arr[1]\n\tlocal max_arr\
    \ = []\n\t\n\tfor i = 2, #arr do\n\t\tif arr[i] > max then\n\t\t\tn = n + 1\n\t\
    \t\tmax = arr[i]\n\t\tend\n\tend\n\t\n\tif k > n then\n\t\treturn nil\n\telseif\
    \ k == 0 then\n\t\treturn arr\n\telseif n == k then\n\t\treturn max_arr\n\telse\n\
    \t\treturn arr[(n - 1)]:maximum(arr, n - 1)\n\tend\nend", "    if k > #arr then\
    \ return end\n    \n    local maxHeap = {}\n    \n    for i = k - 1, 1,-1 do\n\
    \        table.insert(maxHeap, table.max(arr))\n        arr.remove(table.max(arr))\n\
    \    end\n    \n    return maxHeap\nend", "    if k > #arr then return nil end\n\
    \    if k == 0 then\n        return arr\n    end\n    local temp = {}\n    local\
    \ maxv = arr[#arr]\n    for i = 1, k do\n        local v = arr[i]\n        if\
    \ v ~= maxv then\n            table.insert(temp, v)\n        end\n    end\n  \
    \  return temp\nend", "   assert(k > 0, \"k should bigger than 0\")\n   assert(k\
    \ < 1000, \"k should smaller than or equal to 1000\")\n   assert(arr ~= nil, \"\
    arr should bigger than 0\")\n   assert(arr ~= nil, \"arr should bigger than 0\"\
    )\n   \n   -- sort\n   if k == 0 then\n      -- sort without modifying original\
    \ array\n      return table.sort(arr)\n   else\n      -- use partial sort for\
    \ better performance\n      local partialSort = partial_sort()\n      local newArr\
    \ = {}\n      local maxArray = {}\n      local max = 0\n      \n      -- find\
    \ max number in arr\n      local maxNumber = arr[#arr]\n      for _, v in pairs(arr)\
    \ do\n         if v > maxNumber then\n            maxNumber = v\n         end\n\
    \      end\n      \n      -- create new array with max k elements\n      for _,\
    \ v in pairs(arr) do\n         if v > max then\n            max = v\n        \
    \    newArr[#newArr+1] = v\n         end\n      end\n      \n      -- create partial\
    \ sort and sort new array using it\n      local partialSortNewArr = partialSort(newArr,\
    \ max)\n      \n      -- merge partial sorted array and original array\n     \
    \ local mergedArr = {}\n      for _, v in pairs(partialSortNewArr) do\n      \
    \   mergedArr[#mergedArr+1] = v\n      end\n      table.insert(mergedArr, arr[#partialSortNewArr])\n\
    \      \n      -- return result\n      return mergedArr\n   end\nend", "    if\
    \ k > #arr then return nil end\n    if k == 0 then return arr end\n    local pivot\
    \ = arr[1]\n    local max_l = #arr\n    local max_r = 1\n    for i = 2, k do\n\
    \        if arr[i] > pivot then\n            max_l = max_r\n            max_r\
    \ = i\n        end\n    end\n    local max = maximum(arr, max_l-1)\n    local\
    \ max_left = arr[1]\n    local max_right = arr[k-1]\n    for i = k+2, max_r do\n\
    \        if arr[i] > max then\n            max = arr[i]\n        end\n       \
    \ if arr[i] > max_left then\n            max_left = arr[i]\n        end\n    \
    \    if arr[i] > max_right then\n            max_right = arr[i]\n        end\n\
    \    end\n    return {max, max_left, max_right}\nend", "    local tmp\n    local\
    \ max_idx\n    local tmp2\n    for idx = 1, k do\n        if arr[idx] > arr[idx+1]\
    \ then\n            tmp = arr[idx]\n            max_idx = idx\n        else\n\
    \            tmp = arr[idx+1]\n            max_idx = idx+1\n        end\n    end\n\
    \    local new_arr = {}\n    for idx = 1, k do\n        if idx == max_idx then\n\
    \            new_arr[idx] = tmp\n        else\n            new_arr[idx] = arr[idx]\n\
    \        end\n    end\n    return new_arr\nend", "    assert(k > 0 and k <= #arr,\
    \ 'Invalid input')\n    local result = {}\n    for i = 1, k do\n        local\
    \ max_idx = #result - 1\n        for j = 1, #arr do\n            if arr[j] > arr[max_idx]\
    \ then\n                max_idx = j\n            end\n        end\n        result[max_idx]\
    \ = arr[max_idx]\n    end\n    return result \nend", "  -- base case\n  if k <=\
    \ 0 or k > #arr then\n    return arr\n  end", "\tif k < 1 then\n\t\terror(\"k\
    \ must be positive\")\n\tend\n\t\n\tlocal n = #arr\n\tif n == 0 then\n\t\treturn\
    \ {}\n\tend", "    local a = {}\n    for i = 1, k do\n        local max_val =\
    \ -1000\n        for j = 1, k do\n            if arr[j] > max_val then\n     \
    \           max_val = arr[j]\n            end\n        end\n        a[i] = max_val\n\
    \    end\n    return a\nend", "  if k <= 0 or #arr <= k then\n    return nil\n\
    \  end\n  \n  local res = {}\n  local i = 0\n  \n  repeat\n    local vmax = arr[i]\n\
    \    \n    for j = i + 1, k do\n      if arr[j] > vmax then\n        vmax = arr[j]\n\
    \      end\n    end\n    \n    res[#res + 1] = vmax\n    i = i + 1\n  until #arr\
    \ <= i\n  \n  return res\nend", '  local result = {}', "    if k == 0 then \n\
    \        return arr\n    elseif k == 1 then \n        return arr[1]\n    else\n\
    \        local lb = arr[1]\n        local ub = arr[1]\n        for i = 2, k do\n\
    \            lb = lb + (arr[i] / 2) \n            ub = ub + (arr[i] / 2)\n   \
    \     end\n        if lb > ub then\n            return arr[k]\n        else\n\
    \            return maximum(arr, k - 1) + arr[k]\n        end\n    end\nend",
  "    local ans = {} -- Initialize an array for storing the results\n    \n    local\
    \ i = 0 -- Initialize an index for traversing the input array\n    for _,x in\
    \ ipairs(arr) do \n        local j = 0 -- Initialize an index for traversing the\
    \ result array\n        for j = 1,k do \n            if ans[i] < x then\n    \
    \            local tmp = ans[i]\n                ans[i] = x\n                x\
    \ = tmp\n            end\n        end\n        i = i + 1\n    end\n    \n    return\
    \ ans\nend", "\tif k < 0 then return nil end\n\tif k > #arr then return nil end\n\
    \tlocal i, maxIdx, curMax = 1, #arr, arr[1]\n\tfor i = 2, k do\n\t\tif arr[i]\
    \ > curMax then\n\t\t\tmaxIdx, curMax = i, arr[i]\n\t\tend\n\tend\n\treturn arr[(k+1):(#arr+1)],\
    \ maxIdx\nend", "    if k == 1 then\n        return arr\n    end\n    local m\
    \ = math.min(k, #arr)\n    local mIdx = math.max(0, math.ceil(k / 2) - 1)\n  \
    \  local maxArray = { arr[mIdx] }\n    for i = 1, m do\n        local idx = m\
    \ - i\n        local curVal = arr[idx]\n        local maxIdx = math.min(idx +\
    \ 1, #arr)\n        if curVal > arr[maxIdx] then\n            arr[idx] = arr[maxIdx]\n\
    \            arr[maxIdx] = curVal\n        end\n        maxArray = table.concat(maxArray,\
    \ \"-\")\n    end\n    return maxArray\nend", "  -- write your code here\n  local\
    \ ans = {}\n  for i = 1,k do\n    local max = -1000\n    for j = 1,#arr do\n \
    \     if arr[j] > max then\n        max = arr[j]\n      end\n    end\n    table.insert(ans,\
    \ max)\n  end\n  return ans\nend", "  if k == 1 or k == 0 then\n    return arr\n\
    \  end\n  \n  local sorted_arr = {} -- Create an empty array\n  local max = arr[1]\n\
    \  local i = 1\n  \n  while i <= k do\n    max = max > arr[i] and arr[i] or max\n\
    \    sorted_arr[i] = max\n    i = i + 1\n  end\n  \n  return sorted_arr\nend",
  "\tif k > #arr then return nil end\n\tif k == 1 then\n\t\treturn arr[1]\n\tend\n\
    \tlocal max = arr[1]\n\tlocal cur = 1\n\tfor i = 2, k do\n\t\tif arr[i] > max\
    \ then\n\t\t\tmax = arr[i]\n\t\t\tcur = i\n\t\tend\n\tend\n\treturn arr[cur]\n\
    end", "    local sorted_arr = arr\n    local max_arr = {}\n    local max_idx =\
    \ 0", "    local max_len = k -- Initialize max_len\n    local max_element = arr[max_len]\
    \ -- Initialize max_element\n    for i = 1, k do\n        if arr[i] > max_element\
    \ then\n            max_element = arr[i]\n        end\n    end\n    for i = 1,\
    \ k do\n        arr[i] = arr[max_len]\n    end\n    arr[max_len] = max_element\
    \ -- Update max_element\nend", "  if k == 1 then\n    return arr\n  end\n  local\
    \ max_array = arr\n  local max_idx = k - 1\n  for i = k, 1, -1 do\n    if arr[i]\
    \ > arr[i+1] then\n      table.insert(max_array, arr[i])\n      max_idx = i -\
    \ 1\n    end\n  end\n  return max_array\nend", "    assert(k > 0 and k < #arr,\
    \ \"k is out of range\")\n    assert(k <= #arr, \"k is out of range\")", "   \
    \ if k == 0 then\n        return arr\n    end\n    local result = {}\n    local\
    \ maxElem = -math.inf", "    local arr1 = {}\n    for i = 1, k do\n        arr1[i]\
    \ = arr[i]\n    end\n    arr1 = arr1\n    local arr2 = {}\n    for i = 1, k do\n\
    \        arr2[i] = arr2[i] + 1\n    end\n    local max = arr2[1]\n    for i =\
    \ 2, k do\n        max = max > arr2[i] and max or arr2[i]\n    end\n    return\
    \ arr1[#arr1] + max\nend", "  if k > #arr then return nil end\n  local max_arr\
    \ = {}\n  local max_len = #max_arr\n  for i=1,k do\n    local elem = maximum1(arr,\
    \ i)\n    if elem ~= nil then\n      table.insert(max_arr, elem)\n      max_len\
    \ = #max_arr\n    end\n  end\n  if #max_arr == 0 then return nil end\n  return\
    \ max_arr\nend", "  if k >= #arr or k < 0 then\n    return nil\n  end", "  --\
    \ Base case: if the length is less than or equal to k, return the empty array.\n\
    \  if k > 0 and k > #arr then return arr end", "  local results = {}\n  local\
    \ current_max = -math.inf", "    if k == 0 then\n        -- corner case for k\
    \ == 0\n        return arr\n    end\n    \n    local arrLength = #arr\n    \n\
    \    if k >= arrLength then\n        -- corner case for k > arrLength\n      \
    \  k = arrLength\n    end\n    \n    local largest, lastMax = arr[1], arr[1]\n\
    \    \n    for i = 2, arrLength do\n        local currentMax = last > arr[i] and\
    \ arr[i] or lastMax\n        if currentMax < largest then\n            largest,\
    \ lastMax = currentMax, lastMax\n        else\n            lastMax = arr[i]\n\
    \        end\n    end\n    \n    return largest\nend", "  local maxArray = {}\n\
    \  local j = 1\n  for i = 1, k do\n    if j > #arr then\n      return maxArray\n\
    \    end\n    maxArray[j] = arr[i]\n    j = j + 1\n  end\n  return maxArray\n\
    end", "    local sorted_list = {}\n    local index = 1\n    while index < k do\n\
    \        sorted_list[#sorted_list + 1] = arr[index]\n        index = index + 1\n\
    \    end\n    return sorted_list\nend", "    if not arr then return end\n    local\
    \ results = {}\n    for i = 1, k do\n        local max = nil\n        for j =\
    \ 1, #arr do\n            if max and max < arr[j] then\n                max =\
    \ nil\n            end\n            if arr[j] >= max then\n                max\
    \ = arr[j]\n            end\n        end\n        results[i] = max\n    end\n\
    \    return table.concat(results)\nend", "  if k > #arr then\n    return nil\n\
    \  end", "  local result = {}\n  local i = 1\n  \n  -- Use an iterator to solve\
    \ the problem. Because we want to keep track of the indices in the array that\
    \ were already considered,\n  -- we use a reverse iterator.\n  for i = #arr, -1,\
    \ -1 do\n    local value = arr[i]\n    \n    -- Add the new maximum to the result\
    \ if the new value is the same as the current maximum.\n    if i > 0 and value\
    \ > result[i] then\n      table.insert(result, value)\n    end\n  end\n  \n  --\
    \ If the array is empty, return the empty list.\n  if #result == 0 then\n    return\
    \ []\n  end\n  \n  -- Return the result list.\n  return result\nend", "\t-- Set\
    \ max to -1000\n\tlocal max = -1000\n\t\n\t-- Set a counter to 0\n\tlocal i =\
    \ 0\n\t\n\t-- Iterate over each element in arr\n\t-- If this element is greater\
    \ than max, then set max to this element\n\tfor i = 1, k do\n\t\tif arr[i] > max\
    \ then\n\t\t\tmax = arr[i]\n\t\tend\n\tend\n\t\n\t-- Return max\n\treturn max\n\
    end", "    local arr_size = #arr\n    if k <= arr_size then\n        if k == 0\
    \ then\n            return arr\n        else\n            return arr:sort()[arr_size\
    \ - k]\n        end\n    else\n        return arr:sort()[arr_size - k]\n    end\n\
    end", "\tlocal maxArr = {}\n\tlocal maxNum = -1000\n\tlocal size = #arr\n\tlocal\
    \ index = 1\n\twhile index <= size and k ~= 0 do\n\t\tif arr[index] >= maxNum\
    \ then\n\t\t\tmaxNum = arr[index]\n\t\tend\n\t\tif k <= index then\n\t\t\tbreak\n\
    \t\tend\n\t\tmaxArr[index] = arr[index]\n\t\tindex = index + 1\n\tend\n\treturn\
    \ maxArr\nend", "    assert(k > 0 and k <= #arr)\n    \n    local ans = {arr[1]}\n\
    \    for i = 2, #arr do\n        if ans[#ans-1] > arr[i] then\n            ans[#ans-1]\
    \ = arr[i]\n        end\n    end", "  if k == 0 then\n    return arr\n  elseif\
    \ k == 1 then\n    return arr[1]\n  end\n  \n  local result = {arr[1]}\n  for\
    \ i = 2, #arr do\n    local max_value = result[1]\n    for j = 1, k do\n     \
    \ if arr[i] > max_value then\n        max_value = arr[i]\n      end\n    end\n\
    \    table.insert(result, max_value)\n  end\n  \n  return result\nend", "  assert(k\
    \ == nil or type(k) == 'number', \"k should be number\")\n  assert(arr == nil\
    \ or type(arr) == 'table', \"arr should be table\")\n  assert(k == nil or type(k)\
    \ == 'number', \"k should be number\")\n  assert(arr == nil or type(arr) == 'table',\
    \ \"arr should be table\")\n  assert(k == nil or type(k) == 'number', \"k should\
    \ be number\")", "  assert(k, \"k cannot be empty\")\n  if k == 0 then\n    return\
    \ arr\n  end", "  if k == 0 then\n    return arr\n  end\n  local arr_size = #arr\n\
    \  local max_arr_size = arr_size\n  if k > arr_size then\n    k = arr_size\n \
    \ end\n  local max_arr = {}\n  local max_idx = 1\n  local cur_idx = 0\n  while\
    \ cur_idx <= arr_size do\n    local max_value = arr[cur_idx]\n    local cur_value\
    \ = max_arr_size\n    while cur_value <= max_value do\n      table.insert(max_arr,\
    \ arr[cur_value])\n      cur_value = cur_value + 1\n    end\n    table.insert(max_arr,\
    \ max_value)\n    max_arr_size = cur_value\n    cur_idx = cur_idx + 1\n  end\n\
    \  max_arr_size = max_arr_size - 1\n  max_arr = table.concat(max_arr, max_arr_size)\n\
    \  return max_arr\nend", "  if k == nil then return arr end\n  local result =\
    \ {}\n  local posMax = 0\n  for i = 1, k do\n    posMax = math.max(posMax, result[i\
    \ - 1])\n  end\n  for i = 1, k do\n    result[i] = arr[posMax + i]\n  end\n  return\
    \ result\nend", "    local output = {}\n    local maxValue = #arr\n    for i =\
    \ 1, k do\n        local element = arr[i]\n        output[#output + 1] = element\n\
    \    end\n    for i = 1, maxValue do\n        if arr[maxValue - i] > arr[maxValue\
    \ - i - 1]\n            then\n                local element = arr[maxValue - i]\n\
    \                output[#output + 1] = element\n                arr[maxValue -\
    \ i] = arr[maxValue - i - 1]\n                arr[maxValue - i - 1] = element\n\
    \        end\n    end\n    return output\nend", "  local maxArray = {}\n  local\
    \ tempMax = -1000\n  for i = 1, k do\n    if arr[i] > tempMax then\n      tempMax\
    \ = arr[i]\n    end\n    maxArray[i] = tempMax\n  end\n  return maxArray\nend",
  "    local res = {}\n    local maxCount = 0", "    if k > #arr then\n        return\
    \ nil\n    end\n    local maxArr = {} -- {numberToString(arr[1]), arr[1], arr[2]}\n\
    \    for i = 2, k do\n        if arr[i] > maxArr[2] then\n            maxArr =\
    \ {numberToString(arr[i]), arr[i], arr[i-1]}\n        elseif arr[i] > maxArr[1]\
    \ then\n            maxArr[1] = arr[i]\n        elseif arr[i] > maxArr[2] then\n\
    \            maxArr[2] = arr[i]\n        end\n    end\n    return maxArr\nend",
  "    local ans = arr[k]\n    for i = k+1, #arr do\n        local tmp = ans \n  \
    \      ans = arr[i] \n        if tmp > ans then break end\n    end\n    return\
    \ ans\nend", "    local t = {}\n    if k > #arr then\n        return t\n    end\n\
    \    \n    if k < 0 then\n        k = -k\n    end", "    local _max = nil\n  \
    \  local _len = #arr\n    for i = 1, k do\n        if _max == nil then\n     \
    \       _max = _arr[math.random(_len)]\n        elseif _max < _arr[math.random(_len)]\
    \ then\n            _max = _arr[math.random(_len)]\n        end\n    end\n   \
    \ return _max\nend", "  local a = {} -- create an empty array for storing the\
    \ maximum values\n  for i = 1, k do\n    table.insert(a, math.max(arr[i]))\n \
    \ end\n  return a\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
