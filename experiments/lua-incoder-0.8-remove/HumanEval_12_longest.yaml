name: HumanEval_12_longest
language: lua
prompt: "-- Out of list of strings, return the longest one. Return the first one in\
  \ case of multiple\n-- strings of the same length. Return None in case the input\
  \ list is empty.\nlocal function longest(strings)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = longest\n\
  \    lu.assertEquals(candidate({}), None)\n    lu.assertEquals(candidate({'x', 'y',\
  \ 'z'}), 'x')\n    lu.assertEquals(candidate({'x', 'yyy', 'zzzz', 'www', 'kkkk',\
  \ 'abc'}), 'zzzz')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    if #strings == 0 then\n        return nil\n    end", "\tif type(strings)\
    \ ~= 'table' or #strings == 0 then return end\n\tlocal longest, longest_len =\
    \ strings[1], #strings[1]\n\tlocal len = #strings[1]\n\tfor i=2,#strings do\n\t\
    \tif #strings[i] == len then\n\t\t\tlongest = strings[i]\n\t\t\tlongest_len =\
    \ len\n\t\telse\n\t\t\tlen = #strings[i]\n\t\tend\n\tend\n\treturn longest or\
    \ strings[#strings]\nend", "  if #strings == 0 then\n    return nil\n  end", " \
    \ local max_len = -1\n  for str in strings do\n    local len = #str\n    if len\
    \ > max_len then max_len = len end\n  end\n  if #strings == 0 then return nil\
    \ end\n  local result = {}\n  for str in strings do\n    local len = #str\n  \
    \  if len == max_len then table.insert(result, str) end\n  end\n  return result[1]\n\
    end", "   assert(type(strings) == 'table')\n   for _, v in ipairs(strings) do\n\
    \      if type(v) == 'string' then\n         return v\n      end\n   end\nend",
  "\tassert(type(strings) == 'table')\n\tassert(#strings > 0)\n\tlocal longest = {}\n\
    \tfor i = 1, #strings do\n\t\tlocal length = strings[i].len or #strings[i]\n\t\
    \tif length == #longest[1] then\n\t\t\tlongest[1] = strings[i]\n\t\t\ttable.insert(longest,\
    \ strings[i])\n\t\telse\n\t\t\tif not length or length > #longest[2] then\n\t\t\
    \t\tlongest[1] = strings[i]\n\t\t\t\tlongest[2] = length\n\t\t\tend\n\t\tend\n\
    \tend\n\tif #longest > 1 then\n\t\tlongest = longest[1]\n\tend\n\treturn longest\n\
    end", "   assert(type(strings) == 'table')\n   if not strings then return nil\
    \ end", "  if #strings == 0 then return nil end\n  local lengths = setmetatable({},\
    \ { __len = function(t) return #t end })\n  for i = 1, #strings do\n    local\
    \ length = #strings[i]\n    if lengths[length] == nil then\n      lengths[length]\
    \ = strings[i]\n    else\n      local max_length = length\n      for j = 1, #strings\
    \ do\n        if strings[j][length] == strings[i][length] then\n          max_length\
    \ = length\n        end\n      end\n      if max_length > lengths[length] then\n\
    \        lengths[length] = strings[i]\n      end\n    end\n  end\n  local longest\
    \ = lengths[#lengths]\n  if #lengths > 1 then\n    longest = longest, lengths[#lengths]\n\
    \  end\n  return longest\nend", "\tlocal longest = nil\n\tlocal longestLength\
    \ = 0\n\tfor _, string in ipairs(strings) do\n\t\tlocal stringLength = string.len()\
    \ or 1\n\t\tif stringLength > longestLength then\n\t\t\tlongestLength = stringLength\n\
    \t\t\tlongest = string\n\t\tend\n\tend\n\treturn longest, longestLength\nend",
  '    local lens = { }', "  if #strings == 0 then return nil end\n  local max_len\
    \ = -1\n  local max_index\n  for i, v in ipairs(strings) do\n    local l=len(v)\n\
    \    if l > max_len and l > 0 then\n      max_len = l\n      max_index = i\n \
    \   end\n  end\n  return strings[max_index] if max_index~=nil then\n    return\
    \ strings[max_index+1]\n  else\n    return strings[max_index]\n  end\nend", " \
    \   if #strings == 0 then return nil end\n    local longest, longestLength = nil,\
    \ 0\n    for _, s in ipairs(strings) do\n        longest = s or longest\n    \
    \    if string.len(s) > longestLength then\n            longest, longestLength\
    \ = s, string.len(s)\n        end\n    end\n    return longest\nend", "    local\
    \ longest_string\n    local longest_string_len\n    local longest = strings[1]",
  "    local max_len = -1\n    local res = \"\"\n    for str in strings do\n     \
    \   local curr_len = #str\n        if max_len == -1 or curr_len > max_len then\n\
    \            max_len = curr_len\n            res = str\n        end\n    end\n\
    \    return res\nend", "    local maxlen = 0\n    local longest", "    if #strings\
    \ == 0 then\n        return nil\n    end\n    local longest_length = 0\n    local\
    \ longest_string", '   if not strings then return end', "    local len = -1\n\
    \    for _, s in ipairs(strings) do\n        len = len and (len > #s or len ==\
    \ #s and len) or #s\n    end\n    return strings[len] and strings[len] or len\n\
    end", "    if #strings < 1 then\n        return nil\n    end\n    local maxlen\
    \ = 0\n    local maxstring\n    for i=1, #strings do\n        local len = string.len(strings[i])\n\
    \        if len > maxlen then\n            maxlen = len\n            maxstring\
    \ = strings[i]\n        end\n    end\n    return maxstring\nend", "   local longest,\
    \ longestlength = nil, -1\n   for _,v in ipairs(strings) do\n      if longestlength\
    \ == -1 or v:len() > longestlength then\n         longest, longestlength = v,\
    \ v:len()\n      end\n   end\n   return longest, longestlength\nend", "    if\
    \ not strings or #strings == 0 then\n        return false\n    end\n    local\
    \ longest = strings[1]\n    for i = 2, #strings do\n        if #strings[i] ==\
    \ #longest then\n            longest = strings[i]\n        else\n            break\n\
    \        end\n    end\n    return longest\nend", "   local longest_len = math.max(1,\
    \ #strings)\n   if #strings == 0 then return nil end\n   for _, str in pairs(strings)\
    \ do\n      if string.len(str) > longest_len then\n         longest_len = string.len(str)\n\
    \         longest_str = str\n      end\n   end\n   return longest_str\nend", " \
    \ if #strings == 0 then return nil end\n  local longest_str = strings[1]\n  for\
    \ i = 2, #strings do\n    if strings[i].len > longest_str.len then\n      longest_str\
    \ = strings[i]\n    end\n  end\n  return longest_str\nend", "\tif not strings\
    \ then\n\t\treturn None\n\tend", "\tlocal longest = strings[1]\n\tfor i = 2, #strings\
    \ do\n\t\tif longest:len() < strings[i]:len() then\n\t\t\tlongest = strings[i]\n\
    \t\tend\n\tend\n\treturn longest\nend", "   local longest, length = strings[1],\
    \ #strings[1]\n   for _, str in pairs(strings) do\n      if length == #str then\n\
    \         longest, length = str, #str\n      end\n   end\n   return longest\n\
    end", "    local longest = nil\n    for _, string in ipairs(strings) do\n    \
    \    local len = #string\n        if len > #longest then\n            longest\
    \ = string\n        end\n    end\n    if longest and #strings == 1 then\n    \
    \    return longest\n    end\n    for _, string in ipairs(strings) do\n      \
    \  if #longest > #string then\n            return string\n        end\n    end\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a tags=lua,lua-table dscore=2 |>\nA simple\
    \ solution is to sort your table and then return the last item of it by its index.\
    \ \n<code>", "  if #strings == 0 then\n    return nil\n  end\n  if #strings ==\
    \ 1 then\n    return strings[1]\n  end\n  local longest = strings[1]\n  for i\
    \ = 2, #strings do\n    if strings[i] == longest then\n      return strings[i]\n\
    \    end\n    longest = longest .. strings[i]\n  end\n  return longest\nend",
  '  local longest = nil', "\tassert(#strings > 0, \"Cannot use an empty list of strings\"\
    )\n\tlocal result = {}\n\tfor i = 1, #strings do\n\t\tlocal len = string.len(strings[i])\n\
    \t\tif #result > 0 then\n\t\t\tlocal last = result[#result]\n\t\t\tif len < string.len(last)\
    \ then\n\t\t\t\treturn last\n\t\t\tend\n\t\tend\n\t\tresult[#result + 1] = strings[i]\n\
    \tend\n\tif #result > 0 then\n\t\treturn result[#result]\n\tend\n\treturn nil\n\
    end", "    local longest_length = 0\n    local longest_string\n    for _, string\
    \ in ipairs(strings) do\n        if string.len > longest_length then\n       \
    \     longest_length = string.len\n            longest_string = string\n     \
    \   end\n    end\n    return longest_string\nend", "   local longest = {}\n  \
    \ local first = nil", "    local longest, last_longest = nil, false\n    for str\
    \ in strings:gmatch(\"[^\\r\\n]+\") do\n        if str == last_longest then\n\
    \            return str\n        end\n        last_longest = str\n        if string.len(str)\
    \ > string.len(longest) then\n            longest, last_longest = str, str\n \
    \       end\n    end\n    return longest\nend", '    local longest_string = strings[1]',
  "  if #strings == 0 then return nil end\n  local longest_length = 1\n  local longest_string\
    \ = \"\"\n  for i = 1, #strings do\n    local string = \"\"\n    for j = 1, #strings\
    \ do\n      -- If we're not at the start or the end of a string, check the length\n\
    \      if i ~= 1 then string = (string..\" \") end\n      if j ~= #strings then\
    \ string = (string..\"\\n\") end\n      local string_length = string.len(strings[i\
    \ - 1])\n      if string_length >= #string then\n        -- If the string is longer,\
    \ we assign its length and update the string\n        if string_length > longest_length\
    \ then\n          longest_length = string_length\n          longest_string = string\n\
    \        end\n      end\n    end\n  end\n  return longest_string\nend", "    local\
    \ longest = table.remove(strings, 1)\n    for _, string in ipairs(strings) do\n\
    \        if string.len() > longest.len() then\n            longest = string\n\
    \        end\n    end\n    return longest\nend", "  if #strings == 0 then\n  \
    \  return string\n  elseif #strings == 1 then\n    return strings[1]\n  else\n\
    \    local max = strings[1]\n    for i=2,#strings do\n      if max == strings[i]\
    \ then\n        return strings[i]\n      else\n        max = strings[i]\n    \
    \  end\n    end\n  end\nend", "    if #strings == 0 then\n        return nil\n\
    \    end\n    local max_len = -1\n    local max_len = strings[1]\n    for i =\
    \ 2, #strings do\n        if max_len == strings[i] then\n            max_len =\
    \ strings[i]\n        elseif max_len > strings[i] then\n            max_len =\
    \ strings[i]\n        end\n    end\n    return max_len\nend", "  for i, str in\
    \ ipairs(strings) do\n    if #str ~= 0 then return str end\n  end\n  return strings[1]\n\
    end", "\tassert(#strings > 0, 'Invalid list of strings')\n\tassert(all(type(s)\
    \ ~= 'string' or #s == 1 or s == s[2] or #s == 3 for s in strings), 'Invalid list\
    \ of strings')\n\tif #strings == 1 then return strings[1] end\n\tlocal maxLength\
    \ = -1\n\tlocal maxString\n\tfor i = 1, #strings do\n\t\tlocal length = #strings[i]\n\
    \t\tif length == maxLength then maxString = strings[i] end\n\t\tif length > maxLength\
    \ then\n\t\t\tmaxLength = length\n\t\t\tmaxString = strings[i]\n\t\tend\n\tend\n\
    \treturn maxString\nend", "  if #strings == 0 then\n    return false\n  elseif\
    \ #strings == 1 then\n    return true\n  else\n    local maxLength = tonumber(strings[1])\n\
    \    local results = {}\n    for i = 1, #strings do\n      if tonumber(strings[i])\
    \ > maxLength then\n        local maxLength = tonumber(strings[i])\n      else\n\
    \        results[#results + 1] = strings[i]\n      end\n    end\n    return results[#results]\n\
    \  end\nend", "    if #strings == 0 then\n        return nil\n    end\n    local\
    \ longest = strings[1]\n    for i = 2, #strings do\n        if #longest < #strings[i]\
    \ then\n            longest = strings[i]\n        end\n    end\n    return longest\n\
    end", "  if #strings == 0 then\n    return nil\n  end\n  local max_length = strings[1]:len()\n\
    \  for i = 2, #strings do\n    if strings[i]:len() > max_length then\n      max_length\
    \ = strings[i]:len()\n    end\n  end\n  return strings[max_length]\nend", "  assert(#strings\
    \ > 0, 'Cannot have empty list of strings')\n  local longestLength = #strings[1]\n\
    \  for i = 2, #strings do\n    local currentLength = #strings[i]\n    if currentLength\
    \ > longestLength then\n      longestLength = currentLength\n    end\n  end\n\
    \  if longestLength == 1 then\n    return strings[1]\n  else\n    return strings[longestLength]\n\
    \  end\nend", "    local longest_str = strings[1]\n    for _, str in ipairs(strings)\
    \ do\n        if str:len() > longest_str:len() then\n            longest_str =\
    \ str\n        end\n    end\n    return longest_str\nend", "\tlocal longest =\
    \ \"\"\n\tlocal longest_len = -1\n\tfor k, v in pairs(strings) do\n\t\tlocal len\
    \ = (v:len() + 1):len() -- Add 1 to account for \"\\n\"\n\t\tif len > longest_len\
    \ then\n\t\t\tlongest = k\n\t\t\tlongest_len = len\n\t\tend\n\tend\n\treturn longest\n\
    end", "\tif #strings == 0 then return nil end\n\tlocal max_len = -1\n\tlocal max_string\
    \ = \"\"\n\tfor string in strings do\n\t\tif string.len > max_len then\n\t\t\t\
    max_len = string.len\n\t\t\tmax_string = string\n\t\tend\n\tend\n\treturn max_string\n\
    end", "    if next(strings) == nil then return end\n    for i = 1, #strings do\n\
    \        local longest_len = math.min(#strings, i)\n        for j = i + 1, #strings\
    \ do\n            local len = #strings[i]\n            if len > longest_len then\n\
    \                longest_len = len\n            end\n        end\n        if longest_len\
    \ > 1 then\n            return strings[longest_len]\n        end\n    end\nend",
  "  local max = 0\n  for _,s in ipairs(strings) do\n    max = max or #s\n    if max\
    \ < #s then return s end\n  end\n  if #strings == 0 then return nil end\n  return\
    \ strings[#strings]\nend", "   if #strings == 0 then\n      return nil\n   elseif\
    \ #strings == 1 then\n      return strings[1]\n   else\n      local maxlen = 0\n\
    \      for _, str in pairs(strings) do\n         if str:len() > maxlen then\n\
    \            maxlen = str:len()\n         end\n      end\n      return strings[maxlen]\n\
    \   end\nend", "  if #strings == 0 then\n    return nil\n  end\n  local longest\
    \ = strings[1]\n  local length = 1\n  for i, str in ipairs(strings) do\n    if\
    \ #str > length then\n      longest = str\n      length = #str\n    end\n  end\n\
    \  return longest\nend", "   if #strings == 0 then return nil end\n   local longest\
    \ = strings[1]\n   for i=2,#strings do\n      if #strings[i] == #longest then\
    \ return strings[i]:sub(1,#longest) end\n      if #strings[i] > #longest then\
    \ longest = strings[i] end\n   end\n   return longest\nend", '  assert(#strings
    > 0)', "  if #strings == 0 then return None end\n  local longest = strings[1]\n\
    \  for i = 2, #strings do\n    local s = strings[i]\n    if string.len(s) == string.len(longest)\
    \ and s == longest then\n      longest = s\n    else\n      return longest\n \
    \   end\n  end\nend", "    if #strings == 0 then\n        return nil\n    end",
  "  assert(#strings > 0, 'Expected list of strings')\n  local max_len = math.min(#strings,\
    \ #strings)\n  for i = 1, max_len do\n    if #strings[i] == max_len then\n   \
    \   return strings[i]\n    end\n  end\n  return nil\nend", "    if #strings ==\
    \ 0 then\n        return nil\n    end\n    local max = 0\n    local max_str =\
    \ nil\n    for i = 1, #strings do\n        local str = string.sub(strings, i,\
    \ i)\n        local len = string.len(str)\n        if len > max then\n       \
    \     max = len\n            max_str = str\n        end\n    end\n    return max_str\n\
    end", "    if next(strings) == nil then\n        return nil\n    end", "    if\
    \ not strings then return end\n    local maxSize = #strings[1]\n    for _, str\
    \ in ipairs(strings) do\n        maxSize = math.max(maxSize, #str)\n    end\n\
    \    for _, str in ipairs(strings) do\n        if maxSize == #str then\n     \
    \       return str\n        end\n    end\n    return nil\nend", "  if #strings\
    \ == 0 then\n    return nil\n  elseif #strings == 1 then\n    return strings[1]\n\
    \  end", "  if #strings == 0 then\n    return nil\n  end\n  local longest, curLongest\
    \ = #strings[1], strings[1]\n  for i = 2, #strings do\n    if #strings[i] < curLongest\
    \ then\n      curLongest = #strings[i]\n      longest = strings[i]\n    end\n\
    \  end\n  return curLongest > #longest\n    and curLongest or longest\nend", " \
    \ for _, str in ipairs(strings) do\n    local len = #str\n    if len == 0 then\n\
    \      return nil\n    end\n    if len > 1 then\n      return str\n    end\n \
    \ end\n  return strings[1]\nend", "\tif not strings then return nil end\n\tif\
    \ not #strings then return strings end\n\tlocal maxLen = -1\n\tlocal maxString\
    \ = strings[1]\n\tfor i=1, #strings do\n\t\tlocal len = #strings[i]\n\t\tif len\
    \ > maxLen then maxLen = len end\n\t\tif len == maxLen then\n\t\t\tmaxString =\
    \ strings[i]\n\t\tend\n\tend\n\treturn maxString\nend", "  local max_len = -1\n\
    \  local max_str = nil\n  for i = 1, #strings do\n    local len = string.len(strings[i])\n\
    \    if max_len < len then\n      max_len = len\n      max_str = strings[i]\n\
    \    end\n  end\n  return max_str, max_len\nend", "\tassert(type(strings) == 'table',\
    \ 'invalid input strings')\n\tlocal lengths = {}\n\tfor _, str in ipairs(strings)\
    \ do\n\t\tif lengths[#lengths + 1] == nil then\n\t\t\tlengths[#lengths + 1] =\
    \ #str\n\t\telseif lengths[#lengths + 1] < #str then\n\t\t\tlengths[#lengths +\
    \ 1] = #str\n\t\tend\n\tend\n\treturn lengths[#lengths] and strings[#lengths]\
    \ and strings[#lengths][lengths[#lengths]] or nil\nend", "  if #strings == 0 then\n\
    \    return nil\n  else\n    return strings[#strings]\n  end\nend", "  if not\
    \ strings then\n    return nil\n  end\n  local longest = strings[1]\n  for i =\
    \ 2, #strings do\n    if strings[i].len > longest.len then\n      longest = strings[i]\n\
    \    end\n  end\n  return longest\nend", "  for _, v in ipairs(strings) do\n \
    \   local len = #v\n    if len > 0 then\n      longest = v\n      break\n    end\n\
    \  end\n  return longest\nend", "\tlocal longest_length = 0\n\tlocal longest_string\
    \ = nil\n\tfor _, string in ipairs(strings) do\n\t\tif string.len() > longest_length\
    \ then\n\t\t\tlongest_length = string.len()\n\t\t\tlongest_string = string\n\t\
    \tend\n\tend\n\treturn longest_string, longest_length\nend", "  assert(#strings\
    \ > 0, 'Must have at least one string in list')", "  local longest_length = -1\n\
    \  for _, string in pairs(strings) do\n    local length = string.len\n    if length\
    \ >= 0 then\n      if length > longest_length then\n        longest_length = length\n\
    \      end\n    end\n  end\n  if longest_length > 0 then\n    return strings[longest_length]\n\
    \  end\nend", "    if #strings == 0 then\n        return false\n    end\n    local\
    \ maxlen = false\n    local maxlenlen = 0\n    local maxstr = false\n    for i\
    \ = 1, #strings do\n        local str = strings[i]\n        local len = string.len(str)\n\
    \        if maxlenlen < len then\n            maxlenlen = len\n            maxlen\
    \ = str\n        end\n        if maxlenlen == len then\n            if maxstr\
    \ then\n                maxlen = string.sub(maxstr, 1, len - 1)\n            end\n\
    \        end\n    end\n    return maxlen\nend", "  if #strings == 0 then return\
    \ end\n  local max = 0\n  for i = 1, #strings do\n    if strings[i] == strings[max]\
    \ then return strings[i] end\n    if max > 0 and strings[i]:len() > max then\n\
    \      max = i\n    end\n  end\nend", '  local longest = strings[1]', "  if #strings\
    \ == 0 then return end\n  local len = strings[1].len\n  for i = 2, #strings do\n\
    \    if strings[i].len > len then\n      len = strings[i].len\n    end\n  end\n\
    \  return strings[#strings]\nend", "    local longest = strings[1]\n    for i\
    \ = 2, #strings do\n        if strings[i]:len() > longest:len() then\n       \
    \     longest = strings[i]\n        end\n    end\n    return longest\nend", " \
    \ if #strings == 0 then\n    return nil\n  elseif #strings == 1 then\n    return\
    \ strings[1]\n  else\n    local max_len = -1\n    local longest_string = nil\n\
    \    for _, string in ipairs(strings) do\n      if string.len > max_len then\n\
    \        max_len = string.len\n        longest_string = string\n      end\n  \
    \  end\n    return longest_string\n  end\nend", "  if #strings == 0 then\n   \
    \ return nil\n  end\n  local max_len = -1\n  local max_idx = 1\n  for idx = 1,\
    \ #strings do\n    local len = string.len(strings[idx])\n    if len > max_len\
    \ and len > 1 then\n      max_len = len\n      max_idx = idx\n    end\n  end\n\
    \  if max_idx > 1 then\n    return strings[max_idx]\n  end\n  return strings[1]\n\
    end", "    if not strings then\n        return nil\n    end\n    local longest_len\
    \ = strings[1]:len()\n    for _, s in ipairs(strings) do\n        if longest_len\
    \ > s:len() then\n            longest_len = s:len()\n        end\n    end\n  \
    \  return longest_len\nend", "  if #strings == 0 then\n    return nil\n  end",
  "\tif #strings == 0 then\n\t\treturn nil\n\tend", "  local longestStringLength =\
    \ 0\n  local longestString\n  local stringLength\n  for _, str in ipairs(strings)\
    \ do\n    stringLength = str:len() -- In case it's a table instead of a string.\n\
    \    if stringLength > longestStringLength then\n      longestStringLength = stringLength\n\
    \      longestString = str\n    end\n  end\n  return longestString\nend", "  if\
    \ #strings == 0 then return nil end\n  local maxlen = -1\n  local maxstring\n\
    \  for i = 1, #strings do\n    if maxlen < #strings[i] then\n      maxlen = #strings[i]\n\
    \      maxstring = strings[i]\n    end\n  end\n  return maxstring\nend", "  if\
    \ #strings == 0 then\n    return nil\n  end\n  local longest_len = -1\n  local\
    \ longest_str = strings[1]\n  for i = 2, #strings do\n    if strings[i] ~= longest_str\
    \ then\n      if longest_len == -1 or #longest_str > #longest_len then\n     \
    \   longest_len = #longest_str\n        longest_str = strings[i]\n      else\n\
    \        longest_str = strings[i]\n      end\n    end\n  end\n  return longest_str\n\
    end", "  if #strings == 0 then\n    return false\n  end\n  local longest = strings[1]\n\
    \  for i = 2, #strings do\n    if #strings[i] == #longest then\n      longest\
    \ = strings[i]\n    else\n      break\n    end\n  end\n  return longest\nend",
  "   if not strings then return nil end\n   local longest_len = -1\n   local longest_str\
    \ = nil\n   for i=1, #strings do\n      local len = strings[i].len\n      if longest_len\
    \ == -1 or len > longest_len then\n         longest_len = len\n         longest_str\
    \ = strings[i]\n      elseif len == longest_len then\n         longest_str = strings[i]\n\
    \      end\n   end\n   return longest_str\nend", "    if next(strings) == nil\
    \ then return end\n    local len = strings[1]:len()\n    for i = 2, #strings do\n\
    \        if strings[i]:len() < len then len = strings[i]:len() end\n    end\n\
    \    return len\nend", "  if #strings == 0 then return nil end\n  local lengths\
    \ = strings:map(function(s) return #s end)\n  return lengths[torch.argmin(lengths)]\n\
    end", "  if #strings == 0 then return None end\n  local longest_size = -1\n  local\
    \ longest_index = -1\n  for i = 1, #strings do\n    local length = strings[i]\n\
    \    if length == longest_size then\n      longest_index = i\n    else\n     \
    \ longest_size = length\n      longest_index = i\n    end\n  end\n  return strings[longest_index]\n\
    end", "  if #strings == 0 then return None end\n  local maxLen = strings[1].len\n\
    \  for i = 2, #strings do\n    if strings[i].len > maxLen then\n      maxLen =\
    \ strings[i].len\n    end\n  end\n  if #strings > 1 then\n    return strings[#strings]\n\
    \  end\n  return maxLen > 2 and strings[1] or nil\nend", "    local longest_string\
    \ = \"\"\n    local max_size = -1", "  local longest_len = -1\n  local longest_string\
    \ = nil", "  if #strings == 0 then\n    return nil\n  end\n  local longest, count\
    \ = strings[1], 1\n  for _, str in pairs(strings) do\n    if str:len() > count\
    \ then\n      longest, count = str, str:len()\n    end\n  end\n  return longest\n\
    end", "    local longest, count = None, 0\n    for s in strings do\n        count\
    \ = count + 1\n        if string.len(s) > count then\n            longest = s\n\
    \        end\n    end\n    return longest\nend", "  local longest, longestLen,\
    \ longestIndex = 0, nil, -1\n  for i, s in ipairs(strings) do\n    if #s > longestLen\
    \ then\n      longest, longestLen = s, #s\n      longestIndex = i\n    end\n \
    \ end", "    if #strings == 0 then\n        return nil\n    end\n    local longest_string\
    \ = strings[1]\n    for i = 3, #strings do\n        if #longest_string < #strings[i]\
    \ then\n            longest_string = strings[i]\n        end\n    end\n    return\
    \ longest_string\nend", "    local maxLen = 0\n    local longestStr\n    for i\
    \ = 1, #strings do\n        local len = #strings[i]\n        if len > maxLen then\n\
    \            maxLen = len\n            longestStr = strings[i]\n        end\n\
    \    end\n    return longestStr\nend", "\tlocal longest_string = nil\n\tfor _,\
    \ string in ipairs(strings) do\n\t\tif string.len() > string.len() and string.len()\
    \ > longest_string.len() then\n\t\t\tlongest_string = string\n\t\tend\n\tend\n\
    \tif longest_string == nil then\n\t\treturn nil\n\telse\n\t\treturn longest_string\n\
    \tend\nend", "  if #strings == 0 then\n    return nil\n  end\n  local longest\
    \ = strings[1]\n  for i = 2, #strings do\n    if strings[i].len > longest.len\
    \ then\n      longest = strings[i]\n    end\n  end\n  return longest\nend", "\t\
    if not strings then\n\t\treturn nil\n\tend\n\tlocal longest = strings[1]\n\tfor\
    \ i, v in ipairs(strings) do\n\t\tif v == longest then\n\t\t\treturn v\n\t\tend\n\
    \tend\n\treturn longest\nend", "  assert(#strings > 0, \"Empty list of strings\"\
    )\n  local maxLen = 0\n  local longestString = \"\"\n  local firstString\n  for\
    \ _, firstString = pairs(strings) do\n    if maxLen == 0 or firstString:len()\
    \ > maxLen then\n      maxLen = firstString:len()\n      longestString = firstString\n\
    \    end\n  end\n  if maxLen > 0 then\n    return longestString\n  end\nend",
  "  if #strings == 0 then\n    return nil\n  end", "  local longest_length = 0\n\
    \  local longest_string = nil\n  for _, string in ipairs(strings) do\n    local\
    \ string_length = #string\n    if string_length > longest_length then\n      longest_length\
    \ = string_length\n      longest_string = string\n    end\n  end\n  return longest_string\n\
    end", "  if #strings == 0 then\n    return nil\n  end\n  local longest, longestString\
    \ = 0, \"\"\n  for str in pairs(strings) do\n    if #str > #longestString then\n\
    \      longest, longestString = #str, str\n    end\n  end\n  return longestString\n\
    end", "\tlocal longest = nil\n\tlocal length = 0\n\tfor i = 1, #strings do\n\t\
    \tif strings[i] ~= \"\" then\n\t\t\tif length > length then\n\t\t\t\tlongest =\
    \ strings[i]\n\t\t\t\tlength = #strings[i]\n\t\t\tend\n\t\telse\n\t\t\tlength\
    \ = length + 1\n\t\tend\n\tend\n\tif longest ~= nil and length > 0 then\n\t\t\
    return longest\n\telse\n\t\treturn strings[1]\n\tend\nend", "   if #strings ==\
    \ 0 then\n      return None\n   else\n      return strings[#strings]\n   end\n\
    end\n</cell>\n<text>\nLet's see how this looks in action...", "\tif not strings\
    \ then\n\t\treturn nil\n\tend", "  assert(#strings > 0)\n  if #strings == 1 then\n\
    \    return strings[1]\n  end\n  local max = strings[1]:len()\n  for _, string\
    \ in pairs(strings) do\n    if max:len() < string:len() then\n      max = string\n\
    \    end\n  end\n  return max\nend", "  if #strings == 0 then\n    return nil\n\
    \  end\n  local longest = strings[1]\n  local i = 1\n  for s in strings[#strings]\
    \ do\n    if string.len(s) > string.len(longest) then\n      longest = s\n   \
    \ end\n    i = i + 1\n  end\n  return longest\nend", "  if #strings == 0 then\n\
    \    return nil\n  end\n  local longest_length = 1\n  local longest_string = strings[1]\n\
    \  for i = 2, #strings do\n    local length = string.len(strings[i])\n    if length\
    \ > longest_length then\n      longest_length = length\n      longest_string =\
    \ strings[i]\n    end\n  end\n  return longest_string\nend", "    if #strings\
    \ == 0 then return end\n    if #strings <= 1 then return strings[1] end\n    local\
    \ max_len = -1\n    local max_string\n    for i = 1, #strings do\n        local\
    \ length = tonumber(strings[i])\n        if length ~= 0 then\n            if length\
    \ >= max_len then\n                max_len = length\n                max_string\
    \ = strings[i]\n            end\n        end\n    end\n    return max_string\n\
    end", "  if #strings == 0 then\n    return nil\n  end\n  local longest = strings[1]\n\
    \  for i = 2, #strings do\n    if strings[i] == longest then\n      return longest\n\
    \    end\n    longest = longest .. strings[i]\n  end\n  return longest\nend",
  "    if #strings == 0 then\n        return false\n    end", "  if #strings == 0\
    \ then\n    return nil\n  end", "  if #strings == 0 then return end\n  local maxLength\
    \ = 0\n  local length = 0\n  for s in strings do\n    length = #s\n    if length\
    \ >= maxLength then maxLength = length end\n  end\n  local firstString = strings[math.min(maxLength,\
    \ #strings)]\n  if #firstString == maxLength then return firstString end\n  return\
    \ nil\nend", "    local longest = {}\n    if not strings or #strings == 0 then\n\
    \        return longest\n    end\n    for _, str in ipairs(strings) do\n     \
    \   for _, str2 in ipairs(strings) do\n            local len1 = #str\n       \
    \     local len2 = #str2\n            if len1 > len2 then\n                longest\
    \ = str\n            elseif len2 > len1 then\n                longest = str2\n\
    \            else\n                break\n            end\n        end\n    end\n\
    \    return longest\nend", "    if strings == nil then\n        return None\n\
    \    end\n    if #strings == 0 then\n        return None\n    end", "  local maxlen\
    \ = 0\n  local maxstring\n  local maxpos = 1\n  for _, string in ipairs(strings)\
    \ do\n    if maxlen < #string then\n      maxlen = #string\n      maxstring =\
    \ string\n      maxpos = 1\n    elseif maxlen == #string then\n      maxpos =\
    \ maxpos + 1\n    end\n  end\n  return maxstring, maxpos\nend", '  if #strings
    == 0 then return nil end', "    if #strings == 0 then\n        return\n    end",
  "  local stringTable = {}\n  for _, string in ipairs(strings) do\n    if not stringTable[#stringTable\
    \ + 1] or #stringTable[#stringTable] > #string then stringTable[#stringTable +\
    \ 1] = string end\n  end\n  if #stringTable == 0 then return nil end\n  return\
    \ stringTable[#stringTable]\nend", "   local lengths = terralib.newlist()\n  \
    \ for _, s in ipairs(strings) do\n      lengths:insert(#s)\n   end\n   local max_length\
    \ = lengths:maxNumber()\n   if #lengths == 0 then return nil end\n   local max_length_so_far\
    \ = lengths[lengths:len() - 1]\n   for _, s in ipairs(strings) do\n      local\
    \ cur_len = #s\n      if cur_len > max_length_so_far then\n         max_length_so_far\
    \ = cur_len\n      end\n   end\n   return strings[lengths:len() - max_length_so_far\
    \ + 1]\nend", "  if not strings then return end\n  local longest_len = -1\n  local\
    \ longest_str = \"\"\n  for _, str in pairs(strings) do\n    local str_len = #str\n\
    \    if longest_len < str_len then\n      longest_len = str_len\n      longest_str\
    \ = str\n    end\n  end\n  return longest_str\nend", "  if #strings == 0 then\n\
    \    return nil\n  elseif #strings == 1 then\n    return strings[1]\n  end\n \
    \ local longestLength = 0\n  local longestString = ''\n  for _, str in ipairs(strings)\
    \ do\n    local length = #str\n    if length == 0 then\n      length = 100\n \
    \   end\n    if length > longestLength then\n      longestLength = length\n  \
    \    longestString = str\n    end\n  end\n  return longestString\nend", "   if\
    \ #strings == 0 then\n      return nil\n   end", "    if strings == nil then return\
    \ nil end\n    local longest = strings[1]\n    for i = 1, #strings do\n      \
    \  if longest:len() > strings[i]:len() then\n            longest = strings[i]\n\
    \        end\n    end\n    return longest\nend", "   assert(#strings > 0, 'Input\
    \ list must be non-empty')", "   if #strings == 0 then return nil end\n   local\
    \ longest = strings[1]\n   for i = 2, #strings do\n      if strings[i] ~= strings[longest]\
    \ then\n         longest = strings[i]\n      end\n   end\n   return longest\n\
    end\n</code>\nThis assumes you want to return the longest string and the index\
    \ within the list where the longest string is found. For example, calling it with\
    \ [\"asdf\", \"def\", \"asdf\"] and \"asdf\" would return (\"asdf\", 2). Just\
    \ change the comparison operator to return whatever you like.\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 |>\nI would probably use a local variable as a counter for\
    \ the longest string.\n<code>", "   if #strings == 0 then return nil end\n   local\
    \ len = math.min((#strings), 3)\n   local longest = strings[len]\n   for i = 1,\
    \ #strings do\n      if len > 1 then\n         if #strings[i] < len then break\
    \ end\n      end\n      len = len - 1\n      if len == 0 then\n         if strings[len]\
    \ ~= \"\" then return strings[len] end\n         return strings[1]\n      end\n\
    \      longest = strings[len]\n   end\n   return longest\nend", "    if strings\
    \ and #strings == 1 then\n        local str = strings[1]\n        return str:len()\
    \ > str:len() and str or\n        -- If strings are the same length, return the\
    \ last one. Since Lua strings are immutable\n        -- this returns the same\
    \ string that appears last in the table.\n        strings[#strings]\n    else\n\
    \        return nil\n    end\nend", "  for _, string in ipairs(strings) do\n \
    \   if string.len > longest.len then\n      longest.len = string.len\n      longest.string\
    \ = string\n    end\n  end\n  return longest.string or false\nend", "  local lengths\
    \ = table.concat(strings, function(s) return #s end)\n  local maxChars = math.min(#lengths,\
    \ 1)\n  local longestString = strings[#strings]\n  while #lengths > 1 and lengths[#lengths]\
    \ <= maxChars do\n    table.insert(lengths, lengths[#lengths] + 1)\n  end\n  if\
    \ #lengths == 1 then\n    return longestString\n  elseif #lengths > 1 then\n \
    \   return strings[#lengths - 1]\n  else\n    return nil\n  end\nend", "  if #strings\
    \ == 0 then\n    return nil\n  end\n  local longestLength = #strings[1]\n  for\
    \ i = 2, #strings do\n    local length = #strings[i]\n    if length > longestLength\
    \ then\n      longestLength = length\n    end\n  end\n  if longestLength == 1\
    \ then\n    return strings[1]\n  end\n  return strings[longestLength]\nend", "\t\
    assert(#strings > 0)\n\tlocal maxLength = 0\n\tlocal maxString = \"\"\n\tlocal\
    \ maxCount = 0\n\tfor _, s in ipairs(strings) do\n\t\tlocal length = #s\n\t\t\
    if length >= maxLength and maxCount <= 1 then\n\t\t\tmaxCount = 1\n\t\t\tmaxLength\
    \ = length\n\t\t\tmaxString = s\n\t\telseif length > maxLength and maxCount >\
    \ 1 then\n\t\t\tmaxCount = 1\n\t\t\tmaxLength = length\n\t\t\tmaxString = s\n\t\
    \telseif length >= maxLength then\n\t\t\tmaxCount = maxCount + 1\n\t\tend\n\t\
    end\n\treturn maxString\nend", "    local longest_str = ''\n    local longest_len\
    \ = -1\n    for _,str in ipairs(strings) do\n        local len = #str\n      \
    \  if longest_len < len then\n            longest_str = str\n            longest_len\
    \ = len\n        end\n    end\n    return longest_str\nend", "\tif #strings ==\
    \ 0 then\n\t\treturn nil\n\tend\n\tlocal longest = 0\n\tfor i = 1, #strings do\n\
    \t\tif #strings[i] == longest then\n\t\t\tlongest = #strings[i]\n\t\tend\n\tend\n\
    \tif longest == 0 then\n\t\treturn strings[1]\n\telseif longest > #strings[1]\
    \ then\n\t\treturn strings[1]\n\tend\n\treturn strings[#strings]\nend", "\tif\
    \ not strings then return end\n\tlocal longest = strings[1]\n\tfor i = 2, #strings\
    \ do\n\t\tif #longest < #strings[i] then\n\t\t\tlongest = strings[i]\n\t\tend\n\
    \tend\n\treturn longest\nend", "    local longest_string\n    for _, string in\
    \ ipairs(strings) do\n        local length = string.len()\n        if length ~=\
    \ 0 and longest_string == nil or length > longest_string.len then\n          \
    \  longest_string = string\n        end\n    end\n    return longest_string\n\
    end", "  for idx, value in ipairs(strings) do\n    if idx == #strings then\n \
    \     return value\n    end\n    if #value > #strings[idx + 1] then\n      return\
    \ value\n    end\n  end\n  return nil\nend", "  local longest_length = 0\n  local\
    \ longest_string = \"\"\n  local max_length = 0\n  local min_length = 0", "\t\
    local longest, max_length = nil, 0\n\tfor _, s in pairs(strings) do\n\t\tlocal\
    \ length = #s\n\t\tif length > max_length then\n\t\t\tmax_length = length\n\t\t\
    \tlongest = s\n\t\tend\n\tend\n\treturn longest\nend", "    if #strings == 0 then\
    \ return end\n    local max_len = 0\n    local max_length = -1\n    for i, s in\
    \ ipairs(strings) do\n        if #s > max_len then\n            max_len = #s\n\
    \            max_length = i\n        end\n    end\n    if max_length == -1 then\n\
    \        return nil\n    end\n    return strings[max_length]\nend", "\tif not\
    \ strings or #strings == 0 then\n\t\treturn nil\n\tend\n\tlocal max_len = strings[1]:len()\
    \ -- Assume that strings[0] is the longest string\n\tfor i, string in ipairs(strings)\
    \ do\n\t\tif string:len() > max_len then\n\t\t\tmax_len = string:len()\n\t\tend\n\
    \tend\n\treturn strings[#strings]\nend", "    local stringsByLength = {}\n   \
    \ local longestString = \"\"\n    local longestStringLength = 0\n    local longestStringIdx\
    \ = -1\n    local stringIdx = 1", "  local maxLength = nil\n  for _, str in pairs(strings)\
    \ do\n    if maxLength == nil or #str <= maxLength then\n      maxLength = #str\n\
    \    end\n  end\n  return maxLength and strings[math.min(#strings, maxLength)]\n\
    end", "\tif not strings then return nil end\n\tlocal max_len = -1\n\tfor _, s\
    \ in ipairs(strings) do\n\t\tif max_len == -1 or max_len < #s then\n\t\t\tmax_len\
    \ = #s\n\t\tend\n\tend\n\tif max_len == -1 then\n\t\treturn nil\n\tend\n\tfor\
    \ _, s in ipairs(strings) do\n\t\tif max_len > #s then\n\t\t\treturn s\n\t\tend\n\
    \tend\nend", "\tassert(type(strings) == 'table')\n\tassert(#strings > 0)\n\tlocal\
    \ longest_so_far = strings[1]\n\tfor _, s in pairs(strings) do\n\t\tif #longest_so_far\
    \ > #s then\n\t\t\tlongest_so_far = s\n\t\tend\n\tend\n\treturn longest_so_far\n\
    end", "    if #strings == 0 then\n        return nil\n    end\n    local longest_length\
    \ = -1\n    local longest_string = nil\n    for i = 1, #strings do\n        local\
    \ string = strings[i]\n        if string.len() > longest_length then\n       \
    \     longest_string = string\n            longest_length = string.len()\n   \
    \     else\n            if string.len() == longest_length then\n             \
    \   longest_string = longest_string .. string\n            end\n        end\n\
    \    end\n    return longest_string\nend", "\tassert(#strings > 0)\n\tlocal longest,\
    \ count = torch.Tensor(1)\n\tfor i = 1, #strings do\n\t\tlocal count = strings[i]\
    \ ~= \"\" and 1 or 0\n\t\tif count > longest[1] then\n\t\t\tlongest = torch.Tensor({strings[i],\
    \ count})\n\t\tend\n\tend\n\tif longest[1] ~= 1 then return end\n\tlocal i = 2\n\
    \twhile i <= #strings do\n\t\tif strings[i - 1] ~= strings[i] then\n\t\t\treturn\
    \ strings[i - 1]\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn nil\nend", "  if #strings\
    \ == 0 then\n    return nil\n  end\n  local longest_len = -1\n  local longest_str\n\
    \  for _, str in ipairs(strings) do\n    local len = #str\n    if len > longest_len\
    \ then\n      longest_len = len\n      longest_str = str\n    end\n  end\n  return\
    \ longest_str\nend", "  for _, str in ipairs(strings) do\n    if #str > 0 then\n\
    \      return str\n    end\n  end\n  return strings[1]\nend", "    if not strings\
    \ then\n        return nil\n    end", "\tlocal longestString = \"\"\n\tlocal longestLength\
    \ = -1\n\tfor _, str in pairs(strings) do\n\t\tlocal len = string.len(str)\n\t\
    \tif len > longestLength then\n\t\t\tlongestString = str\n\t\t\tlongestLength\
    \ = len\n\t\tend\n\tend\n\treturn longestString\nend", "    if not strings then\n\
    \        return nil\n    end\n    local longest = strings[1]\n    for _, v in\
    \ ipairs(strings) do\n        if v:len() > longest:len() then\n            longest\
    \ = v\n        end\n    end\n    return longest\nend", "  local longest_string\n\
    \  local longest_string_length\n  local longest_string_length_index\n  for index,\
    \ string in ipairs(strings) do\n    local string_length = #string\n    if string_length\
    \ == 0 then\n      -- Empty string return it\n      return string\n    end\n \
    \   if string_length > longest_string_length then\n      longest_string_length\
    \ = string_length\n      longest_string = string\n      longest_string_length_index\
    \ = index\n    end\n  end\n  return longest_string\nend", "  for _, str in ipairs(strings)\
    \ do\n    if string.len(str) > string.len(longest) then\n      longest = str\n\
    \    end\n  end\n  return longest\nend", "  local longestLength = 0\n  local longestString\n\
    \  for _, str in ipairs(strings) do\n    local len = string.len(str)\n    if len\
    \ > longestLength then\n      longestLength = len\n      longestString = str\n\
    \    end\n  end\n  return longestString\nend", "  local longest_string = nil\n\
    \  for _, string in ipairs(strings) do\n    if string.len() > longest_string.len()\
    \ then\n      longest_string = string\n    end\n  end\n  return longest_string\n\
    end", "    if #strings == 0 then\n        return nil\n    end", "    if #strings\
    \ == 0 then\n        return nil\n    end\n    local longestString = strings[1]\n\
    \    local longestLength = #longestString\n    for i = 2, #strings do\n      \
    \  if #strings[i] == longestLength then\n            longestString = strings[i]\n\
    \        else\n            return longestString\n        end\n    end\n    return\
    \ longestString\nend", "  for _, s in ipairs(strings) do\n    local _, len = pcall(function()\n\
    \      return s:len()\n    end)\n    if len ~= nil then\n      return len\n  \
    \  end\n  end\n  return nil\nend", "  assert(#strings > 0, \"At least one string\
    \ is required\")\n  if #strings == 1 then return strings[1] end", "  if #strings\
    \ == 0 then\n    return nil\n  end\n  local longest = strings[1]\n  for i = 2,\
    \ #strings do\n    if #strings[i] < #longest then\n      longest = strings[i]\n\
    \    end\n  end\n  return longest\nend", "  if #strings == 0 then\n    return\
    \ nil\n  end\n  local longest_length = strings[1][1]\n  for i = 2, #strings do\n\
    \    local length = strings[i][1]\n    if length > longest_length then\n     \
    \ longest_length = length\n    end\n  end\n  return longest_length\nend", "  local\
    \ longest_length = 0\n  local longest_string", "  local longest = table.remove(strings,\
    \ 1, true)\n  for i = 2, #strings do\n    if strings[i]:len() > longest:len()\
    \ then\n      longest = strings[i]\n    end\n  end\n  return longest\nend", " \
    \   if #strings == 0 then\n        return nil\n    end\n    local len = strings[1]:len()\n\
    \    for i = 2, #strings do\n        if strings[i]:len() < len then\n        \
    \    len = strings[i]:len()\n        end\n    end\n    return len\nend", "\tlocal\
    \ lengths = terralib.newlist()\n\tlocal start = 0\n\tlocal longest\n\tfor idx\
    \ = start, #strings do\n\t\tlocal len = terralib.newsymbol(c.size_t, \"len\")\n\
    \t\tlocal string = strings[idx]\n\t\tlocal size = #string\n\t\tlengths:insert(len)",
  "  if #strings == 0 then\n    return nil\n  end\n  if #strings == 1 then\n    return\
    \ strings[1]\n  end\n  local max_len = strings[1]:len()\n  local max_len_idx =\
    \ 1\n  for i = 2, #strings do\n    if strings[i]:len() > max_len then\n      max_len\
    \ = strings[i]:len()\n      max_len_idx = i\n    end\n  end\n  return strings[max_len_idx]\n\
    end", "    local longest_len = -1\n    local longest_string = \"\"\n    for _,\
    \ s in ipairs(strings) do\n        local len = #s\n        if len > longest_len\
    \ then\n            longest_len = len\n            longest_string = s\n      \
    \  end\n    end\n    return longest_string\nend", "\tif #strings == 0 then return\
    \ end\n\tlocal maxLength = 0\n\tlocal maxString = nil\n\tfor _, string in ipairs(strings)\
    \ do\n\t\tlocal length = #string\n\t\tif length > maxLength then maxLength = length\
    \ end\n\t\tif maxString and length > maxLength then return nil end\n\t\tmaxString\
    \ = string\n\tend\n\treturn maxString\nend", "\tlocal longest = \"\"\n\tlocal\
    \ i = 1", "   if #strings == 0 then return end\n   local longest_length = 1\n\
    \   local longest_string = strings[1]\n   for i = 2, #strings do\n      if strings[i].len\
    \ > longest_length then\n         longest_length = strings[i].len\n         longest_string\
    \ = strings[i]\n      end\n   end\n   return longest_string\nend", "   if #strings\
    \ == 0 then\n      return nil\n   end", "\tif #strings == 0 then\n\t\treturn None\n\
    \tend\n\tlocal len = #strings[1]\n\tlocal res = strings[1][1]\n\tfor i = 2, #strings\
    \ do\n\t\tif strings[i][1] > len then\n\t\t\tlen = strings[i][1]\n\t\t\tres =\
    \ strings[i][1]\n\t\tend\n\tend\n\treturn res\nend", "  assert(#strings > 0)\n\
    \  local longest, longest_len = strings[1], #strings[1]\n  for i = 2, #strings\
    \ do\n    local len = #strings[i]\n    if longest_len > len then\n      longest,\
    \ longest_len = strings[i], len\n    end\n  end\n  return longest\nend\nlongest._name\
    \ = 'longest'", "\tassert(type(strings) == 'table' and #strings > 0)\n\tlocal\
    \ max_len = -1\n\tlocal max_str\n\tfor i=1, #strings do\n\t\tlocal len = strings[i].len\n\
    \t\tif len > max_len then\n\t\t\tmax_len = len\n\t\t\tmax_str = strings[i]\n\t\
    \tend\n\tend\n\treturn max_str\nend", "  if #strings == 0 then\n    return nil\n\
    \  elseif #strings ~= 1 then\n    error(\"lists: longest expected a string as\
    \ input\")\n  end\n  local longest_length = strings[1]:len()\n  for i = 2, #strings\
    \ do\n    if strings[i]:len() > longest_length then\n      longest_length = strings[i]:len()\n\
    \    end\n  end\n  return longest_length\nend", "  local len = -1\n  local longest_str\
    \ = ''\n  for i = 1, #strings do\n    len = len or #strings[i]\n    if len > #longest_str\
    \ then\n      longest_str = strings[i]\n    end\n  end\n  return len > 1 and len\
    \ or longest_str\nend", "  if #strings == 0 then\n    return nil\n  end\n  local\
    \ len = strings[1]:len()\n  for i = 2, #strings do\n    if strings[i]:len() >\
    \ len then\n      len = strings[i]:len()\n    end\n  end\n  return len\nend",
  "    local longestString\n    local longestStringLength = -1\n    for _, str in\
    \ pairs(strings) do\n        local stringLength = #str\n        if stringLength\
    \ > longestStringLength then\n            longestString = str\n            longestStringLength\
    \ = stringLength\n        end\n    end\n    return longestString\nend", "    if\
    \ not strings then\n        return nil\n    end", "    local longest\n    local\
    \ longest_length\n    local longest_value", "  if #strings == 0 then return end\n\
    \  local longest = strings[#strings]\n  for i = #strings - 1, 1, -1 do\n    if\
    \ strings[i] ~= largest then break end\n    longest = strings[i]\n  end\n  return\
    \ longest\nend", '  if #strings == 0 then return None end', "  if #strings ==\
    \ 0 then\n    return nil\n  end\n  local maxLen = 0\n  for i = 1, #strings do\n\
    \    local len = string.len(strings[i])\n    if maxLen < len then\n      maxLen\
    \ = len\n    end\n  end\n  if maxLen > 0 then\n    table.insert(strings, maxLen)\n\
    \  end\n  return table.max(strings)\nend", "\tlocal longest, current_len = False,\
    \ 0\n\tfor _, string in pairs(strings) do\n\t\tif current_len > string#string\
    \ then\n\t\t\tcurrent_len = string#string\n\t\t\tlongest = string\n\t\tend\n\t\
    end\n\treturn longest or strings[1]\nend", "  if not strings then return end\n\
    \  local max_len, max_idx = -1, -1\n  for idx, s in ipairs(strings) do\n    if\
    \ #s > max_len and #s > 0 then\n      max_len = #s\n      max_idx = idx\n    end\n\
    \  end\n  return strings[max_idx]\nend", "    local len = max(natural.length,\
    \ strings:map(function(s) return #s end))\n    if len ~= 0 then\n        local\
    \ i = 1 -- Skip empty strings\n        for i = 1, len do\n            if #strings[i]\
    \ < len then\n                return strings[i]\n            end\n        end\n\
    \    end\nend", "  if not strings then\n    return false\n  end", "  if #strings\
    \ <= 0 then return nil end\n  local lengths = {}\n  for i = 1, #strings do\n \
    \   table.insert(lengths, #lengths)\n  end\n  -- Iterate in reverse order so it's\
    \ more efficient\n  for i = #strings - 1, 1, -1 do\n    local max = 0\n    local\
    \ max = lengths[#lengths]\n    for j = 0, i do\n      if lengths[j] > max then\n\
    \        max = lengths[j]\n      end\n    end\n    table.insert(lengths, max)\n\
    \  end\n  -- Return the first string in case of multiple strings of the same length\n\
    \  -- return strings[#lengths]\n  return lengths[#lengths]\nend", "  if #strings\
    \ == 0 then\n    return nil\n  end\n  local longest = strings[1]\n  for i = 2,\
    \ #strings do\n    if longest:len() > strings[i]:len() then\n      longest = strings[i]\n\
    \    end\n  end\n  return longest\nend", "  if #strings == 0 then\n    return\
    \ nil\n  elseif #strings == 1 then\n    return strings[1]\n  else\n    local maxlen\
    \ = 0\n    local maxstring\n    for i = 1, #strings do\n      if #strings[i] >\
    \ maxlen then\n        maxlen = #strings[i]\n        maxstring = strings[i]\n\
    \      end\n    end\n    return maxstring\n  end\nend", "  if #strings == 0 then\
    \ return None end\n  local maxlen = 0\n  local longest_len = nil\n  for i = 1,\
    \ #strings do\n    local len = string.len(strings[i])\n    if len > maxlen then\n\
    \      maxlen = len\n      longest_len = strings[i]\n    end\n  end\n  return\
    \ longest_len\nend", "\tif #strings == 0 then\n\t\treturn None\n\tend", "    local\
    \ longest, longestSize = nil, 0\n    for _, s in pairs(strings) do\n        if\
    \ s == \"\" then\n            continue\n        end\n        longest, longestSize\
    \ = s, #s\n        break\n    end\n    if longest == \"\" then\n        return\
    \ nil\n    end\n    if longestSize > longestSize then\n        longest, longestSize\
    \ = nil, 0\n        for _, s in pairs(strings) do\n            if longestSize\
    \ < #s then\n                longest, longestSize = s, #s\n                break\n\
    \            end\n        end\n    end\n    return longest\nend", "    if strings\
    \ == nil then return end\n    local longest_length = 0\n    local longest_string\
    \ = \"\"\n    for string in pairs(strings) do\n        local length = len(string)\n\
    \        if length > longest_length then\n            longest_length = length\n\
    \            longest_string = string\n        end\n    end\n    return longest_string\n\
    end", "    local maxLength = 0\n    local string\n    for string in pairs(strings)\
    \ do\n        if string.len() > maxLength then\n            maxLength = string.len()\n\
    \        end\n    end\n    return maxLength\nend", "    local longest_str, longest_len\
    \ = nil, nil\n    for i, str in ipairs(strings) do\n        if str == longest_str\
    \ then\n            longest_len = i\n        else\n            if longest_len\
    \ == nil then\n                longest_str = str\n                longest_len\
    \ = i\n            elseif longest_len > i then\n                longest_str =\
    \ str\n                longest_len = i\n            end\n        end\n    end\n\
    \    return longest_str, longest_len\nend\n</code>\nYou would then use longest()\
    \ as:\n<code>\nif longest(words) == nil then\n    print(\"Empty list\")\nelse\n\
    \    print(\"Longest word: \", longest(words))\nend\n</code>\n<|/ a |>\n<| a tags=lua\
    \ |>\nI think this could be done more elegantly with metamethods, but I couldn't\
    \ find a way to get the original index while using them inside a closure. \n<code>",
  "    if not strings then return nil end\n    local longest_string = strings[1][1]\n\
    \    for i = 2, #strings do\n        if strings[i][1] ~= longest_string then\n\
    \            longest_string = strings[i][1]\n        end\n    end\n    return\
    \ longest_string\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
