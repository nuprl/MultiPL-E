name: HumanEval_112_reverse_delete
language: lua
prompt: "-- Task\n-- We are given two strings s and c, you have to deleted all the\
  \ characters in s that are equal to any character in c\n-- then check if the result\
  \ string is palindrome.\n-- A string is called palindrome if it reads the same backward\
  \ as forward.\n-- You should return a tuple containing the result string and True/False\
  \ for the check.\n-- Example\nlocal function reverse_delete(s, c)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = reverse_delete\n\
  \    lu.assertEquals(candidate('abcde', 'ae'), {'bcd', false})\n    lu.assertEquals(candidate('abcdef',\
  \ 'b'), {'acdef', false})\n    lu.assertEquals(candidate('abcdedcba', 'ab'), {'cdedc',\
  \ true})\n    lu.assertEquals(candidate('dwik', 'w'), {'dik', false})\n    lu.assertEquals(candidate('a',\
  \ 'a'), {'', true})\n    lu.assertEquals(candidate('abcdedcba', ''), {'abcdedcba',\
  \ true})\n    lu.assertEquals(candidate('abcdedcba', 'v'), {'abcdedcba', true})\n\
  \    lu.assertEquals(candidate('vabba', 'v'), {'abba', true})\n    lu.assertEquals(candidate('mamma',\
  \ 'mia'), {'', true})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tlocal new_s = \"\" -- store the new string\n\tlocal flag = true --\
    \ flag to indicate a palindrome\n\tlocal count = 0 -- count the characters in\
    \ s", "\tlocal result = \"\"\n\tfor i=1, #s do\n\t\tif s[i] == c then\n\t\t\t\
    result = result .. s[i]\n\t\telse\n\t\t\tresult = result .. s[#s]\n\t\t\tbreak\n\
    \t\tend\n\tend\n\tlocal result = string.sub(result, 1, #result - 1)\n\treturn\
    \ result, #result == 0\nend", "   local is_palindrome = true,\n      reversed_string\
    \ = \"\",\n      i = 0,\n      j = #s - 1\n   while i < #s do\n      if s[i] ~=\
    \ c then\n         is_palindrome = false\n         break\n      end\n      reversed_string\
    \ = reversed_string .. s[i]\n      i = i + 1\n   end\n   if is_palindrome then\n\
    \      return reversed_string, true\n   else\n      return reversed_string, false\n\
    \   end\nend", "  -- Your code here\n  return (s, false)\nend\nprint(reverse_delete('tst',\
    \ 'st'))\nprint(reverse_delete('abc', 'cba'))\nprint(reverse_delete('abc', 'b'))\n\
    print(reverse_delete('abc', 'ba'))\nprint(reverse_delete('abc', 'bb'))", "   local\
    \ result = ''\n   for c in s:gmatch(c) do -- Loop from last to first\n      result\
    \ = result .. c\n      if #result > 0 and c ~= result[#result] then -- If it still\
    \ more characters then the last one\n         return nil, true\n      end\n  \
    \ end\n   if #result > 0 then\n      return nil, true\n   end\n   local reverse\
    \ = result\n   reverse:reverse()\n   return reverse, true\nend", "\t-- We reverse\
    \ and delete the character in s\n\t-- We start by finding the last character in\
    \ s\n\tlocal lastchar = nil\n\tfor i = #s, 1, -1 do\n\t\tif s[i] == c then\n\t\
    \t\tlastchar = i\n\t\t\tbreak\n\t\tend\n\tend", "\tlocal result,rev = \"\",\"\"\
    \n\tfor i = 1,#s do\n\t\tlocal c1 = string.sub(s, i, i)\n\t\trev = rev..c1\n\t\
    end\n\tfor i = 1,#rev do\n\t\tlocal c2 = string.sub(rev, i, i)\n\t\tif c2 ~= c\
    \ then\n\t\t\tresult = result..c2\n\t\tend\n\tend\n\treturn result,string.len(result)==#s\n\
    end", "    local s = s:reverse()\n    local rev = s:sub(1, #s)\n    return (rev,\
    \ (c == rev))\nend", "    local rs = s\n    local rc = 0\n    repeat\n       \
    \ rc = rc + (rc == 0 or s[rc-1] == c) -- we count the chars in s[rs:rc]\n    until\
    \ rc == #s\n    return rs, rc == #s\nend", "  -- code here\nend", "    local s\
    \ = s:lower()\n    local deleted = s:gsub(c,'')\n    if s:sub(1,1) ~= c then\n\
    \        return s, false\n    end\n    return reverse_delete(deleted, c)\nend",
  "\tif s and c then\n\t\tlocal res = ''\n\t\tlocal idx = 1\n\t\twhile idx < #s do\n\
    \t\t\tlocal char = s[idx] or ''\n\t\t\tif char == c then\n\t\t\t\tres = char..res\n\
    \t\t\t\tidx = idx+1\n\t\t\telse\n\t\t\t\tres = res..char\n\t\t\t\tidx = idx+1\n\
    \t\t\tend\n\t\tend\n\t\treturn res, idx == #s\n\tend\n\treturn nil, false\nend",
  "  -- Write your code here\nend", "\tlocal result = ''\n\t\n\tlocal i = 1\n\t\n\t\
    while i < #s do\n\t\tif s[i] == c then\n\t\t\tresult = result .. s[i]\n\t\tend\n\
    \t\t\n\t\ti = i + 1\n\tend\n\t\n\tresult = result..c\n\t\n\treturn result, string.len(result)\
    \ == string.len(s)\nend", "    local result = \"\"\n    local result = \"\"\n\
    \    local found = false\n    local index\n    \n    for index = #s-1 do\n   \
    \   if s == c then\n        found = true\n        break\n      end\n      if s[index]\
    \ == c  then\n        found = found or found\n      else\n        found = found\
    \ or found\n      end\n      result = result .. s[index] \n    end\n    if found\
    \ then\n      return result, true\n    else\n      return result, false\n    end\n\
    end", "    local s, c = s:gsub(c, ''):reverse(), c:gsub(c, ''):reverse()\n   \
    \ return s, c:match('%s*' % s)\nend", "  local r = \"\"\n  local i = 0\n  while\
    \ i <= #s do\n    if s[i] == c then\n      r = r .. s[i]\n      i = i + 1\n  \
    \  else\n      r = r .. s[i]\n    end\n  end", "  local slen = #s\n  local cpos\
    \ = 0\n  local tstring = \"\"\n  local tbool = false\n  while tbool == false do\n\
    \    if cpos < slen then\n      tbool = not (s[cpos] == c)\n      tstring = tstring\
    \ .. s[cpos]\n      cpos = cpos + 1\n    else\n      tbool = not (s[cpos] == c)\n\
    \    end\n  end\n  return (tstring, tbool)\nend", "\tlocal new_s = \"\"\n\tfor\
    \ idx, ch in pairs(s) do\n\t\tif ch == c then\n\t\t\tnew_s = new_s .. ch\n\t\t\
    elseif new_s == \"\" then\n\t\t\tnew_s = new_s .. ch\n\t\telse\n\t\t\tnew_s =\
    \ new_s .. ch\n\t\tend\n\tend\n\treturn new_s, (new_s == reverse(new_s))\nend",
  "\tlocal result = \"\"\n\t\n\t-- Loop through all chars in s\n\tfor _, char in s:gmatch(\"\
    %a\") do\n\t\t-- If char is equal to char in c, remove it\n\t\tif char == c then\n\
    \t\t\t-- Remove it\n\t\telse\n\t\t\t-- Add it to result\n\t\t\tresult = result\
    \ .. char\n\t\tend\n\tend\n\t\n\treturn result, not s:gsub(result, \"%a\"):reverse():match(\"\
    a*$\")\nend", "   -- your code goes here\n   return \nend\nassert(reverse_delete(\"\
    abba\", \"b\") ==(\"baba\", true))\nassert(reverse_delete(\"abba\", \"a\") ==(\"\
    abba\", true))\nassert(reverse_delete(\"abba\", \"aa\") ==(\"abba\", true))\n\
    assert(reverse_delete(\"abba\", \"ba\") ==(\"ab\", false))", "\t-- base case\n\
    \tif #s <= 0 or #c <= 0 then return (\"\", false) end", "    local ret = \"\"\n\
    \    local i = #s\n    for k in pairs(s) do\n        if s[k] == c then\n     \
    \       -- Remove c\n            i = i - 1\n        elseif k > i and s[k] == s[i\
    \ - k] then\n            -- Delete character before k\n            ret = ret +\
    \ s[i - k]\n        else\n            -- Keep character before k\n           \
    \ ret = ret + s[k]\n        end\n    end\n    return ret, i >= 1\nend", "    local\
    \ _s = s.chars -- a table\n    local _len = #_s -- number of items in _s (also\
    \ number of chars in s)\n    local _result", "  assert(type(s) is string, \"s\
    \ must be a string\")\n  assert(type(c) is string, \"c must be a string\")", " \
    \   -- Your code here\nend", "   -- TODO\nend", "  -- your code goes here\n  \n\
    \  local result = \"\"\n  local flag = 0\n  for i=1,#s do\n    if s[i] == c then\n\
    \      result = result .. s[i]\n      flag = 1\n      break\n    end\n  end\n\
    \  if flag == 1 then\n    result = result[::-1]\n  end\n  return result,flag\n\
    end", "  if #s == 0 then\n    return (\"\", false)\n  end\n  local i, j = 0, #s\n\
    \  local s = s:gsub(c, '') -- Remove characters\n  repeat\n    i = i -1\n    j\
    \ = j + 1\n    if s[i]:lower() == s[j]:lower() then\n      -- Reverse the string\n\
    \      s[i] = s[j]\n    end\n  until i ~= j\n  -- Reverse the string\n  i = #s\n\
    \  j = #s\n  repeat\n    i = i -1\n    j = j - 1\n    s[i] = s[j]\n  until i ~=\
    \ j\n  return (s:reverse(), true) -- Check the string\nend", "\tlocal t = 0\n\t\
    local tt = {}\n\t\n\tfor i = #s, 1, -1 do\n\t\tlocal s = string.sub(s, i, i)\n\
    \t\t\n\t\tt = t + 1\n\t\tif c == s then\n\t\t\ttt = tt .. s\n\t\tend\n\tend",
  "    local str = \"\"\n    for i = 1, #s do\n        str = str .. tostring(s[i])\n\
    \    end\n    str = str .. tostring(c)\n    return str, str == str[::-1]\nend",
  "    -- write your solution here\nend", "\tlocal reversed = reverse(s)\n\tlocal\
    \ result  = \"\"\n\tlocal palindrome = false", "  -- Your code here\nend", " \
    \   local result = \"\"\n    for i = 1, #s do\n        if s[i] == c then result\
    \ = result .. s[i] end\n    end\n    return (result, result == reverse(result)[1])\n\
    end", "    if s == nil or c == nil then\n        return nil, false\n    end",
  "\tlocal result = s\n\tlocal is_pal = false\n\tfor i = 0, #result do\n\t\tif result[i]\
    \ ~= c then\n\t\t\tresult = result..c\n\t\telse\n\t\t\tis_pal = true\n\t\t\tresult\
    \ = result..c\n\t\tend\n\tend\n\treturn result, is_pal\nend", "    if not s then\
    \ return \"s\" end\n    local result\n    local pal_s = reverse_delete(s, \"s\"\
    )\n    local pal_c = reverse_delete(c, \"c\")\n    if pal_s ~= pal_c then\n  \
    \      if pal_c ~= \"\" then\n            result = pal_s\n        else\n     \
    \       result = pal_s\n        end\n    else\n        result = s\n    end\n \
    \   if tostring(result) == tostring(s) then\n        return { s = s, check = True}\n\
    \    end\n    return { s = result, check = False}\nend", "    -- Your code here\n\
    end", "\t-- code here\nend", "    local result = \"a\"\n    -- remove all the\
    \ characer c from s\n    for i = 1, #s do\n        if s[i] == c then\n       \
    \     s = s:sub(1, i)\n        end\n    end\n    if s == result then\n       \
    \ return result, true\n    else\n        return s, false\n    end\nend", "  local\
    \ ans = \"\"\n  for i = #s, 1, -1 do\n    ans = ans .. s[#ans + 1]\n  end\n  for\
    \ i = #c, 1, -1 do\n    ans = ans .. c[#ans + 1]\n  end\n  return ans\nend", " \
    \   local result = s\n    for i=#s-1,0,-1 do\n        result = s.sub(i,#s)\n \
    \       if result == c then\n            return result,true\n        end\n   \
    \ end\n    return result,false\nend", "    local rev_s = s -- Reverse the string\n\
    \    local i = 0\n    while i < #rev_s do\n        if rev_s[i] == c then\n   \
    \         rev_s[i] = nil -- Remove this character from the string\n        else\n\
    \            i = i + 1\n        end\n    end\n    rev_s = rev_s:reverse() -- Reverse\
    \ the string again", "  -- write your code here\n  return s, true\nend", "   assert(type(s)\
    \ == 'string', 'The argument must be a string')\n   assert(type(c) == 'string',\
    \ 'The argument must be a string')", "    if #s == 0 then return s, true end\n\
    \    if #c == 0 then return s, false end\n    if s[#s] ~= c then return reverse_delete(s[#s]..c,\
    \ c), false end\n    if s[#s] ~= c then return reverse_delete(s[#s]..c, c), true\
    \ end\n    return reverse_delete(s[#s]..c, c), reverse_delete(s[#s+1]..s[#s]..s[#s+1],\
    \ c)\nend", "\tlocal ans, is_palindrome = false, false\n\tfor i = 1, #s do\n\t\
    \tif c == s[i] then\n\t\t\tans = true\n\t\t\tbreak\n\t\tend\n\tend\n\treturn ans,\
    \ is_palindrome\nend", "    local result = \"\"\n    local resultIsPalindrome\
    \ = true\n    local cPos = 1\n    local sPos = 1", "\tlocal result = ''\n\tfor\
    \ i = 1, #s do\n\t\tif s[i] == c then\n\t\t\tresult = result .. c\n\t\telse\n\t\
    \t\tresult = result .. s[i]\n\t\tend\n\tend\n\treturn result, result == reverse(result)\n\
    end", "   -- The result string\n   local result = ''\n   -- Looping through all\
    \ the characters in s\n   for i = #s, 1, -1 do\n      -- If the character in s\
    \ is equal to c\n      if s[i] == c then\n         -- Reverse it\n         result\
    \ = result .. s[i]\n      else\n         -- We have not found the character to\
    \ be deleted yet, so copy it to a new string\n         result = result .. s[i]\n\
    \      end\n   end\n   -- Return the result string and the check result\n   return\
    \ result, result == result\nend", "   local rev_s = s:reverse()\n   if rev_s ==\
    \ c then\n      return (true, true)\n   else\n      return (false, false)\n  \
    \ end\nend", "  assert(type(c) == 'string')\n  assert(len(c) == 1)", "  -- Base\
    \ Case\n  if not s then\n    return (s, false)\n  end\n  -- If the first character\
    \ is not equal to the target char we are deleting.\n  if c ~= s[1] then\n    --\
    \ Return with the result and the check is false\n    return (reverse_delete(s[2:],\
    \ c), false)\n  end\n  -- Reverse the second character and recursively process\
    \ the rest of the string.\n  -- This makes the checking a bit easier!\n  -- We\
    \ now need to check if the string is palindrome\n  local ret, reversed = reverse_delete(s[2:],\
    \ c)\n  if reversed then\n    -- If the returned string is palindrome, return\
    \ with the result and the check is true.\n    return (ret, true)\n  end\n  --\
    \ Otherwise return the result and the check is false\n  return (ret, false)\n\
    end\nprint(reverse_delete(\"ab\", \"c\"))\nprint(reverse_delete(\"ab\", \"a\"\
    ))\nprint(reverse_delete(\"abc\", \"a\"))\nprint(reverse_delete(\"abc\", \"c\"\
    ))\nprint(reverse_delete(\"aaabb\", \"b\"))\nprint(reverse_delete(\"ab\", \"a\"\
    ))", "\t-- Write your solution here.\nend", "    local i = 1\n    local result\
    \ = ''\n    while i < (#s) do\n        if s[i] == c then\n            result =\
    \ result .. s[i]\n            i = i + 1 -- Delete the character\n        else\n\
    \            if result == '' then\n                result = result .. s[i]\n \
    \           end\n            i = i + 1\n        end\n    end\n    return (result,\
    \ #result > 0)\nend", "    local result = ''\n    for i, c in ipairs(s) do\n \
    \       if c == c then\n            result = result .. c\n        else\n     \
    \       if result ~= '' then\n                local tmp = '' .. result\n     \
    \           tmp:reverse()\n                if tmp ~= result then\n           \
    \         result = ''\n                else\n                    result = result\
    \ .. c\n                end\n            else\n                result = result\
    \ .. c\n            end\n        end\n    end\n    if result ~= '' then\n    \
    \    local tmp = '' .. result\n        tmp:reverse()\n        if tmp ~= result\
    \ then\n            result = ''\n        else\n            result = result ..\
    \ c\n        end\n    end\n    return result, result ~= result\nend", "  -- your\
    \ code goes here\nend", "    if #s < 1 then return false, false end\n    if #c\
    \ < 1 then return false, false end\n    local result = \"\"\n    for i = #s, 1,\
    \ -1 do\n        if s[i] ~= c then result = result .. s[i] else i = i + 1 end\n\
    \    end\n    local reversed = reverse_delete(result, c)\n    if reversed == result\
    \ then return reversed, true else return reversed, false end\nend", "\tlocal result\
    \ = s\n\tfor index, char in ipairs(s) do\n\t\tif char == c then\n\t\t\tresult\
    \ = string.gsub(result, char, \"\")\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\t\
    return (result, result == result)\nend", "  -- your code goes here\nend", "  local\
    \ result = \"\"\n  for i = #s, 1, -1 do\n    local x = s[i]\n    local y = c[i]\n\
    \    if x == y then\n      result = result .. x\n    else\n      result = result\
    \ .. y\n    end\n  end\n  return result, tostring(string.gsub(result, \"^\" ..\
    \ c .. \"$\", \"\"))\nend", "    --  Pre: s is a string\n    --      c is a string\n\
    \    --  Post: The result is a string and if the result is palindrome and the\
    \ original string is palindrome or not.\n    --       Note that we only allow\
    \ c to be a string\n    --  Return: result is a string and if result is a palindrome\
    \ and the original string is palindrome or not.\n    --        Note that we only\
    \ allow c to be a string\n    \n    local new_s = string.gsub(s, \"$\" .. c, \"\
    $\" .. \"\")\n    local new_c = string.gsub(c, \"$\" .. s, \"$\" .. \"\")\n  \
    \  \n    local result = new_s .. new_c\n    local is_palindrome = false\n    if\
    \ new_s == new_c then\n        is_palindrome = true\n    end\n    \n    return\
    \ result, is_palindrome\nend", "    if #s == 0 then\n        c, result = \"\"\
    , \"\"\n        return c, result\n    end", "  -- reverse the string\n  local\
    \ s_reverse = \"\"\n  for i = #s, 1, -1 do\n    s_reverse = s_reverse .. tostring(s:sub(i,i))\n\
    \  end\n  -- delete the characters\n  s_reverse = s_reverse:gsub(c,\"\")\n  --\
    \ check if it a palindrome\n  return s_reverse, s_reverse == s\nend", "   -- base\
    \ case\n   if s:len() == 1 then\n      if s ~= c then return s, false end\n  \
    \    return s, true\n   end\n   \n   -- recursion\n   local s = reverse_delete(s:sub(1),\
    \ c) -- we delete the first character\n   local r = s:sub(1, s:len() - 1) -- we\
    \ remove the last character\n   return s, s == r\nend", "    local res\n    local\
    \ done = false\n    while not done do\n        local t = reverse(s)\n        res\
    \ = t\n        done = true\n        for i = 1, #c do\n            if c[i] == t[i]\
    \ then\n                done = false\n            end\n        end\n        s\
    \ = t\n    end\n    return res, #s == 0 and true or false\nend", "  -- Your code\
    \ goes here\n  local reverse = \"\"\n  local result = \"\"\n  for i = 1, #s do\n\
    \    if s[i] == c then\n      reverse = reverse .. s[i]\n    else\n      result\
    \ = result .. s[i]\n    end\n  end\n  return (reverse, result == reverse)\nend",
  "\t-- Write your code here\nend", "    local res, pal = s:reverse():find(c):reverse()\n\
    \    return (pal ~= nil and pal) or res, pal ~= nil\nend", "   local r1, reverse\
    \ = rsv_chars(s,c)\n   local r2, reverse = rsv_chars(reverse,c)\n   -- If the\
    \ original string s and c are the same it means we deleted the characters\n  \
    \ -- we need to check if they are the same\n   return (r1 == r2) && rsv_chars(s,c)\
    \ == reverse\nend", "  -- Your code goes here\n  return s\nend", "\tlocal result,\
    \ rev = s:reverse():reverse()\n\treturn (result == s and result == c, rev)\nend",
  "  -- Write your code here\nend", "    local is_palindrome = s:find(c) == #s\n \
    \   local s = s:sub(1, #s) - c\n    local reverse = s:reverse()\n    local result\
    \ = s and reverse == s\n    return { result = result, palindrome = is_palindrome\
    \ }\nend", "\t-- Your code here\nend", "    local function delete_reverse(s)\n\
    \        local ret = \"\"\n        for i = #s, 1, -1 do\n            ret = ret\
    \ .. s[#ret]\n        end\n        return ret\n    end\n    local function delete_forward(s)\n\
    \        local ret = \"\"\n        for i = #s, 1, -1 do\n            ret = ret\
    \ .. s[i]\n        end\n        return ret\n    end\n    local result = reverse_delete(s,\
    \ c)\n    if result and result==reverse_delete(result,c) then\n        return\
    \ (result, true)\n    else\n        return (result, false)\n    end\nend", "\t\
    s = s:lower()\n\tc = c:lower()\n\tlocal result = {\"\"}\n\tlocal ok, result =\
    \ pcall(\n\t\tfunction()\n\t\t\tfor i = #s, 1, -1 do\n\t\t\t\tif s[i] ~= c then\
    \ break end\n\t\t\tend\n\t\t\tif #s == i then ok = true end\n\t\tend\n\t)\n\t\
    if ok then\n\t\tresult...s = s\n\t\tresult...c = c\n\t\treturn result\n\tend\n\
    \treturn {\"\"}\nend", "  -- Your code here!\nend", "\t-- Your code here\n\t--\
    \ If your solution works, please do not remove.\n\t-- This part is ok and it works.\n\
    \t-- We are doing this because we also need to check if the reverse of the string\
    \ matches the original string.\n\t-- If they do not match then we must reverse\
    \ the string and check it again with the original string.\n\t-- If the strings\
    \ match then the result is True.\n\t-- You do not need to change anything below.\n\
    \t-- You do not need to change anything above here.", "    local result = s\n\
    \    for i = #s, 1, -1 do\n        result = result..c\n    end\n    return result,\
    \ s:reverse()==result\nend", "    local result, isPalindrome = \"\", true\n  \
    \  for i = #s - 1, #0, -1 do\n        if s[i] ~= c then\n            result =\
    \ result .. s[i]\n        else\n            isPalindrome = false -- means not\
    \ palindrome\n            break\n        end\n    end\n    return result, isPalindrome\n\
    end", "  -- start from the end and work back\n  for i = #s, 1, -1 do\n    -- check\
    \ what remains\n    if s[i] == c then\n      -- remove it\n      s = sub(s, i+1)\n\
    \      -- check if it is palindrome\n      if s == reverse then -- remove it if\
    \ palindrome\n        s = sub(s, 1, i-1)\n        break\n      end\n    end\n\
    \  end\n  return s\nend", "\t-- Preconditions\n\tassert(type(s) == \"string\"\
    )\n\tassert(type(c) == \"string\")", "\tassert(type(s) == \"string\" and \"string\"\
    \ == type(c.c), \"Invalid input type. Both s should be a string, and c should\
    \ also be a string\")\n\t\n\t-- Your code here\n\tlocal slen = #s\n\tlocal clen\
    \ = len(c.c)\n\t\n\tlocal i = 0\n\tlocal j = slen - 1\n\t\n\twhile i < j  do\n\
    \t\tif s[i] != c.c[j] then\n\t\t\ti = i + 1\n\t\telse\n\t\t\tj = j - 1\n\t\tend\n\
    \tend\n\t\n\tlocal result = s..#c.c\n\t\n\treturn (result,i>0)\nend", "\t-- write\
    \ your code here\nend", '    local newString = ""', "    local result = {}\n \
    \   local is_palindrome = true -- we assume that it is palindrome string\n   \
    \ for i=1, #s do\n        if s[i]:lower() == c:lower() then\n            table.insert(result,\
    \ s[i])\n        elseif s[i]:lower() ~= c:lower() then\n            is_palindrome\
    \ = false\n            break\n        end\n    end\n    return (table.concat(result),\
    \ is_palindrome)\nend\nprint(reverse_delete(\"abba\", \"b\"))\nprint(reverse_delete(\"\
    abba\", \"A\"))\nprint(reverse_delete(\"abba\", \"Ba\"))\nprint(reverse_delete(\"\
    abba\", \"c\"))\nprint(reverse_delete(\"abba\", \"bc\"))\nprint(reverse_delete(\"\
    abba\", \"cba\"))\nprint(reverse_delete(\"abba\", \"caba\"))\nprint(reverse_delete(\"\
    abba\", \"ca\"))\nprint(reverse_delete(\"abba\", \"bb\"))\nprint(reverse_delete(\"\
    abba\", \"bba\"))\nprint(reverse_delete(\"abba\", \"bba\"))\nprint(reverse_delete(\"\
    abba\", \"bbc\"))\nprint(reverse_delete(\"abba\", \"bbca\"))\nprint(reverse_delete(\"\
    abba\", \"bbcba\"))\nprint(reverse_delete(\"abba\", \"bba\"))\nprint(reverse_delete(\"\
    abba\", \"aa\"))\nprint(reverse_delete(\"abba\", \"aab\"))\nprint(reverse_delete(\"\
    abba\", \"aaab\"))\nprint(reverse_delete(\"abba\", \"aaba\"))\nprint(reverse_delete(\"\
    abba\", \"bba\"))\nprint(reverse_delete(\"abba\", \"bb\"))\nprint(reverse_delete(\"\
    abba\", \"bb\"))\nprint(reverse_delete(\"abba\", \"a\"))\nprint(reverse_delete(\"\
    abba\", \"a\"))\nprint(reverse_delete(\"abba\", \"a\"))\nprint(reverse_delete(\"\
    abba\", \"a\"))\nprint(reverse_delete(\"abba\", \"a\"))\nprint(reverse_delete(\"\
    abba\", \"a\"))\nprint(reverse_delete(\"abba\", \"a\"))\nprint(reverse_delete(\"\
    abba\", \"a\"))\nprint(reverse_delete(\"abba\", \"a\"))\nprint(reverse_delete(\"\
    abba\", \"a\"))\nprint(reverse_delete(\"abba\", \"a\"))\nprint(reverse_delete(\"\
    abba\", \"a\"))\nprint(reverse_delete(\"abba\", \"a\"))\nprint(reverse_delete(\"\
    abba\", \"a\"))\nprint(reverse_delete(\"abba\", \"a\"))\nprint(reverse_delete(\"\
    abba\", \"a\"))\nprint(reverse_delete(\"abba\", \"a\"))\nprint(reverse_delete(\"\
    abba\", \"a\"))\nprint(reverse_delete(\"abba\", \"a\"))\nprint(reverse", "\tlocal\
    \ result = {}\n\t\n\tfor i = 1, #s do\n\t\tlocal c = s[i]\n\t\t\n\t\t-- remove\
    \ the char and check it\n\t\tlocal new_s = string.rep(s, i, 1)\n\t\t\n\t\tif new_s\
    \ ~= s then\n\t\t\t-- not palindrome\n\t\t\ttable.insert(result, new_s)\n\t\t\
    else\n\t\t\t-- palindrome\n\t\tend\n\tend\n\t\n\treturn table.concat(result),\
    \ result ~= reverse(s)\nend", "   -- Your code here\n   -- return \n   end", "\t\
    if s == nil then\n\t\treturn nil, true\n\tend\n\tlocal result = {}\n\tlocal index\
    \ = 0\n\twhile index <= #s - 1 do\n\t\tif s[index] == c then\n\t\t\tindex = index\
    \ + 1\n\t\telse\n\t\t\ttable.insert(result, s[index])\n\t\tend\n\tend\n\tlocal\
    \ result_str = table.concat(result)\n\treturn result_str, #result_str == #s and\
    \ result_str == result_str:reverse()\nend", "    --your code here\nend", "   \
    \ local res\n    local flag = false\n    for i, elem in ipairs(s) do\n       \
    \ if elem == c then\n            res = res..elem\n            flag = true\n  \
    \      elseif flag == true then\n            res = res..c\n            flag =\
    \ false\n        end\n    end\n    if flag == true then\n        return res, true\n\
    \    else\n        return res, false\n    end\nend", "    local result, isPalindrome\n\
    \    local length = #s\n    local i, j = 1, #c\n    while i <= length and j <=\
    \ length do\n        if s[i] ~= c[j] then\n            i = i + j\n        else\n\
    \            result[#result+1] = s[i]\n            j = j + j - i + 1\n       \
    \ end\n    end\n    isPalindrome = result == result\n    return result, isPalindrome\n\
    end", "\t-- write your code here\n\treturn s, true\nend", "    local s_reversed\
    \ = s[#s]\n    local result\n    for i = 1, #s_reversed do\n        if s_reversed:sub(i,\
    \ i) == c then\n            result = result .. s_reversed:sub(1, i)\n        else\n\
    \            result = result .. s_reversed:sub(i)\n        end\n    end\n    return\
    \ result, s_reversed == result\nend", "\t-- TODO: your code here\n\t-- Don't forget\
    \ to return the result tuple here \nend", "\tif c == '' then return (s, true)\
    \ end", "   -- base case\n   if #s == 0 then\n      return s, true\n   end", " \
    \ return \nend", "\tif #s == 0 then\n\t\treturn s, true\n\tend\n\t\n\tlocal newS\
    \ = \"\"\n\t\n\tfor i = 1, #s do\n\t\tif s[i] == c then\n\t\t\tnewS = newS..s[i+1]\n\
    \t\telse\n\t\t\tnewS = newS..s[i]\n\t\tend\n\tend\n\t\n\treturn newS, false\n\
    end", "    local function check(result)\n        -- Here we are checking if the\
    \ result is palindrome or not.\n        if result == s then\n            return\
    \ true\n        else\n            return false\n        end\n    end\n    \n \
    \   local function delete(index, end)\n        local sub = string.sub(s,index,end)\n\
    \        \n        -- For example we are deleting 'e' so first we check if there\
    \ is any 'e' in our string.\n        if string.find(sub, c) == nil then\n    \
    \        -- If there is no such character we return string.sub(s,1,end) because\
    \ it is the original string.\n            return string.sub(s,1,end)\n       \
    \ end\n        \n        -- If we found the character we need to remove it from\
    \ the string and remove 'e' too.\n        return string.sub(s,index,index-1)\n\
    \    end\n    \n    -- First we get rid of all the characters in s that match\
    \ the character to delete.\n    local result = string.sub(s,1,string.find(s,c))\n\
    \    \n    -- We are looping from back to front.\n    for i=1, string.len(s) -\
    \ 1 do\n        -- For example if i = 1 we are checking if s = a or s = aa\n \
    \       if i = 1 then\n            -- For example if s = a then we check if delete\
    \ s = a.\n            if check(delete(i, string.len(s) - i)) then\n          \
    \      -- If check returns true then we exit the loop.\n                break\n\
    \            end\n        elseif check(i + 1 .. delete(i, string.len(s) - i))\
    \ then\n            -- If check returns true then we exit the loop.\n        \
    \    break\n        end\n    end\n    \n    -- We return the result and check\
    \ the result.\n    return result, check(result) == true\nend", "    local _,result\
    \ = s:gsub(c,'')\n    return result, #result == 0 and result:sub(1,1) == result\n\
    end", "    local reverse = \"\"\n    local reversed = false\n    for i = 1, #s\
    \ do\n        reversed = false\n        if s[i] == c then\n            reverse\
    \ = reverse .. s[i]\n            reversed = true\n        end\n    end\n    if\
    \ reverse == s then\n        return (reverse, false)\n    else\n        return\
    \ (reverse, true)\n    end\nend", "  local result = ''\n  for i = 1, #s do\n \
    \   if s[i] == c then\n      result = result .. s[i]\n      i = i - 1\n    end\n\
    \  end\n  \n  if result == s then\n    return (result, true)\n  else\n    return\
    \ (result, false)\n  end\nend", "   -- your code here\nend", "    local r = \"\
    \"\n    local t = false\n    for i = #s, 1, -1 do\n        if s[i] == c then\n\
    \            -- if the character matches then move forward\n            i = i\
    \ + 1\n        else\n            -- if not then start adding to r\n          \
    \  r = r .. s[i]\n        end\n    end\n    if r == s then\n        t = true\n\
    \    end\n    return r, t\nend", "  -- TODO: write your implementation here\n\
    end", "    local r = \"\"\n    for i = #s, 1, -1 do\n        if s[i] == c then\n\
    \            r = r .. s[i]\n        else\n            break\n        end\n   \
    \ end\n    return r, s[i] == c\nend", end, "    local is_palindrome = true\n \
    \   local result = \"\"\n    local len = #s\n    local i = 0", "  local result\
    \ = ''\n  local is_palindrome = false", "  if s ~= c then\n    return reverse_delete(reverse_delete(s,\
    \ c:sub(1)), c:sub(1, c))\n  else\n    return s, true\n  end\nend\n</cell>\n<cell>",
  "    local result = \"\"\n    for i = #s, 1, -1 do\n        if s[i:sub(1, i)] =\
    \ c then\n            result = result .. c\n        elseif s[i:sub(1, i)] = s[i]\
    \ then\n            result = result .. s[i]\n        else\n            result\
    \ = result .. s[i]\n        end\n    end\n    return (result, true)\nend", " \
    \ -- Write your code here\n  -- Your code here\n  -- Your code here\n  -- Your\
    \ code here\n  return { result = string.gsub(s, c:reverse()), ok = false }\nend",
  "    local i, n = 0, 0\n    local str_result = \"\"", '    local res, ok = false,
    nil', "   local result = ''\n   local i = 1\n   while i <= #s do\n      local\
    \ c = s[i]\n      if c ~= c then\n         result = result .. c\n      elseif\
    \ c == c then\n         result = result .. c\n      else\n         result = result\
    \ .. c\n      end\n      i = i + 1\n   end\n   if s == result then\n      return\
    \ {result, true}\n   else\n      return {result, false}\n   end\nend", "  -- Your\
    \ code here\n  -- return\nend", "\ts = string.gsub(s, \"([\" .. c:lower() .. \"\
    ])(..)\",  \"\\2\\1\")\n\ts = string.gsub(s, \"([\" .. c:lower() .. \"])(.)\"\
    ,  \"\\2\\1\")\n\treturn s, string.gsub(s, \"(.)([\" .. c:lower() .. \"])\", \"\
    \\2\\1\") = \"...\"\nend", "    local reverse = s:reverse()\n    local result\
    \ = reverse:gsub(c, '')\n    local isPalindrome = result:reverse():upper() ==\
    \ result\n    return result, isPalindrome\nend", "    local r = \"\"\n    for\
    \ i = #s, 1, -1 do\n        r = r..s[i]\n    end\n    return r, r == c\nend",
  "    if s == nil then\n        return '', false\n    end\n    local new_s = ''\n\
    \    for i = 1, #s do\n        if s[i] == c then\n            new_s = new_s ..\
    \ s\n        else\n            if s[i] ~= c then\n                new_s = new_s\
    \ .. s[i]\n            end\n        end\n    end\n    local new_s = new_s:reverse()\n\
    \    if new_s == s then\n        return '', true\n    end\n    return '', false\n\
    end", "\tlocal result = {}\n\tfor i = #s, 1, -1 do\n\t\tif s:sub(i, 1) == c then\n\
    \t\t\ttable.insert(result, s:sub(i, 1))\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\
    \ttable.sort(result)\n\tlocal palindrome = table.concat(result) == s\n\treturn\
    \ { palindrome, result }\nend", "  -- Your code here\n  return \"Hello world\"\
    , true\nend", "\t-- Your code here\nend", "    -- write your function here\n \
    \   if #s > 0 then\n       for i = #s - 1 , -1 , -1 do\n          s = s.Substring(0,\
    \ i) + s.Substring(i+1)\n       end\n       if s == c then return s , true\n \
    \      else return s , false\n    end\n    return s , false\nend", "  assert(s\
    \ and c and\n         type(s) == 'string' and type(c) == 'string' and\n      \
    \   #s == #c and 'a' == c[1] and 'b' == c[2] and 'c' == c[3] and #s == 1 and #c\
    \ == 1 and\n         not ( s == 'abba' and c == 'cb' ))\n  if string.sub(s,1,#c)\
    \ == string.sub(s,#s,#c) then -- delete everything that equals c\n    return s,\
    \ true\n  else -- not equal, delete everything before and after the c\n    local\
    \ start, end = string.find(s, 'c', 1, true)\n    if start > 0 then\n      local\
    \ deleted = string.sub(s,1,start-1) + string.sub(s,end+1)\n      return reverse_delete(deleted,\
    \ c)\n    else\n      return s, false\n    end\n  end\nend", "  local deleted,\
    \ news = 0, {}\n  for i = #s, 1, -1 do\n    deleted = deleted + 1 if s[i]:sub(1,\
    \ 1) == c end\n    if deleted > 0 then\n      news[#news+1] = s[i]\n    end\n\
    \  end\n  return news, #news == #s\nend", "    if not s or not c then\n      \
    \  return s, false\n    end", "    --\n    -- your code here\n    --\n    \n \
    \   \n    return result, result==pali_inverse\nend", "    local i = 0\n    while\
    \ s[i] do\n        if s[i] == c then\n            i = i - 1\n        end\n   \
    \     i = i + 1\n    end\n    return string.sub(s, 1, i), true\nend", "\tlocal\
    \ result = \"\"\n\tfor i, k in ipairs(s) do\n\t\tresult = result .. c\n\t\tif\
    \ s[i] == k then\n\t\t\tresult = result .. k\n\t\telse\n\t\t\tresult = result\
    \ .. k\n\t\tend\n\tend\n\tresult = string.gsub(result, \"^[\" .. c .. \"]\", \"\
    \")\n\tresult = string.gsub(result, \"[\" .. c .. \"]$\", \"\")\n\tresult = string.gsub(result,\
    \ \"^\", \"\")\n\tresult = string.gsub(result, \"$\", \"\")\n\treturn result,\
    \ string.gsub(result, \"^[\" .. c .. \"]$\", \"false\") == \"true\"\nend", " \
    \  -- Base case\n   if s ~= c then return (s, false) end", "\tif c ~= \"\" then\n\
    \t\tlocal news = \"\"\n\t\tfor i,v in pairs(s) do\n\t\t\tif v == c then\n\t\t\t\
    \tnews = news..v\n\t\t\telse\n\t\t\t\tnews = news..v..c\n\t\t\tend\n\t\tend\n\t\
    \treturn news, true\n\telse\n\t\treturn \"\", false\n\tend\nend", "    -- write\
    \ your code here\n    return s, true\nend", "\tlocal reverse = {}\n\tfor i = 1,\
    \ #s do\n\t\treverse[i] = c\n\tend\n\tfor i = 1, #c do\n\t\treverse[#reverse +\
    \ #c - i] = c[i]\n\tend\n\tlocal result = {}\n\tfor i, v in ipairs(reverse) do\n\
    \t\tresult[i] = v\n\tend\n\treturn result\nend", "    local result = \"\";\n \
    \   for i = #s - 1, 1, -1 do\n        if s[i] == c then\n            result =\
    \ result .. s[i];\n        else\n            -- append all the chars in s\n  \
    \          result = result .. s[i];\n        end\n    end\n    return result,\
    \ true;\nend\nprint(reverse_delete(\"aaa\", \"a\"));", "  return true,true,true,true,true,true,true,true\n\
    end", "    return true, true\nend", "  local s = s .. c\n  local reverse = s:reverse()\n\
    \  reverse = reverse:reverse()\n  local reversed = reverse:sub(1, #reverse)\n\
    \  if s == reversed then\n    return { s = reversed, check = true }\n  else\n\
    \    return { s = reversed, check = false }\n  end\nend", "    local p = True\n\
    \    local rest = ''\n    for i = #s, 1, -1 do\n        if s == c then\n     \
    \       p = not p\n        else\n            rest = rest .. s[i]\n        end\n\
    \    end\n    return (rest, p)\nend", "   local result=string.copy(s)\n   for\
    \ i=1,#c do result=string.sub(result,1,#result)..string.sub(result,#result)..c\
    \ end\n   return result==s,string.len(result)==string.len(s) and result==reverse_delete(result,c)\n\
    end", '    if not s then return false end', "\tlocal result = \"\"\n\tlocal is_palindrome\
    \ = true\n\tfor char in s:gmatch(\"[\" .. tostring(c) .. \"]\") do\n\t\tif char\
    \ == c then\n\t\t\tresult = result .. char\n\t\telseif char == c then\n\t\t\t\
    result = result .. char\n\t\t\tis_palindrome = false\n\t\telse\n\t\t\tresult =\
    \ result .. char\n\t\tend\n\tend\n\treturn result, is_palindrome\nend", "  --\
    \ Write your solution here\n  -- If you can't figure it out yourself, check out\
    \ my hints below!\n  -- Hint: use the function \"str.reverse\" to reverse a string\n\
    end\nprint(reverse_delete(\"aba\", \"a\"))\nprint(reverse_delete(\"aba\", \"b\"\
    ))\nprint(reverse_delete(\"aba\", \"c\"))", "    local l = 1\n    local r = #s\
    \ - 1\n    while l <= r do\n        if s[l] == c then\n            s[l] = nil\n\
    \            l = l + 1\n        elseif s[r] == c then\n            s[r] = nil\n\
    \            r = r - 1\n        else\n            l = l + 1\n            r = r\
    \ - 1\n        end\n    end\n    if s == \"\" then\n        return true, false\n\
    \    end\n    if s[#s - 1] == c then\n        s[#s - 1] = \"\"\n        return\
    \ true, false\n    end\n    return s, false\nend", "    local ans = \"\"\n   \
    \ for i = #s, 1, -1 do\n        if s[i] == c then\n            ans = ans..s[i]\n\
    \        else\n            break\n        end\n    end\n    return ans, c==ans\
    \ -- palindrome\nend\nprint(reverse_delete(\"racecar\", \"a\"))\nprint(reverse_delete(\"\
    racecar\", \"a\"))\nprint(reverse_delete(\"racecar\", \"c\"))\nprint(reverse_delete(\"\
    racecar\", \"a\"))\nprint(reverse_delete(\"racecar\", \"r\"))\nprint(reverse_delete(\"\
    racecar\", \"r\"))\nprint(reverse_delete(\"racecar\", \"c\"))\nprint(reverse_delete(\"\
    racecar\", \"c\"))\nprint(reverse_delete(\"racecar\", \"c\"))\nprint(reverse_delete(\"\
    racecar\", \"c\"))\nprint(reverse_delete(\"racecar\", \"r\"))\nprint(reverse_delete(\"\
    racecar\", \"r\"))\nprint(reverse_delete(\"racecar\", \"r\"))\nprint(reverse_delete(\"\
    racecar\", \"r\"))\nprint(reverse_delete(\"racecar\", \"a\"))\nprint(reverse_delete(\"\
    racecar\", \"a\"))\nprint(reverse_delete(\"racecar\", \"a\"))\nprint(reverse_delete(\"\
    racecar\", \"a\"))\nprint(reverse_delete(\"racecar\", \"a\"))\nprint(reverse_delete(\"\
    racecar\", \"a\"))\nprint(reverse_delete(\"racecar\", \"a\"))\nprint(reverse_delete(\"\
    racecar\", \"a\"))\nprint(reverse_delete(\"racecar\", \"a\"))\nprint(reverse_delete(\"\
    racecar\", \"a\"))\nprint(reverse_delete(\"racecar\", \"a\"))\nprint(reverse_delete(\"\
    racecar\", \"a\"))\nprint(reverse_delete(\"racecar\", \"a\"))\nprint(reverse_delete(\"\
    racecar\", \"a\"))\nprint(reverse_delete(\"racecar\", \"a\"))\nprint(reverse_delete(\"\
    racecar\", \"a\"))\nprint(reverse_delete(\"racecar\", \"a\"))\nprint(reverse_delete(\"\
    racecar\", \"a\"))\nprint(reverse_delete(\"racecar\", \"a\"))\nprint(reverse_delete(\"\
    racecar\", \"a\"))\nprint(reverse_delete(\"racecar\", \"a\"))\nprint(reverse_delete(\"\
    racecar\", \"a\"))\nprint(reverse_delete(\"racecar\", \"a\"))\nprint(reverse_delete(\"\
    racecar\", \"a\"))\nprint(reverse_delete(\"racecar\", \"a\"))\nprint(reverse_delete(\"\
    racecar\", \"a\"))\nprint(reverse_delete(\"racecar\", \"a\"))\nprint(reverse_delete(\"\
    racecar\", \"a\"))\nprint(reverse_delete(\"racecar\", \"a\"))\nprint(reverse_delete(\"\
    racecar\", \"a\"))\nprint(reverse_delete(\"racecar\", \"a\"))\nprint(reverse_delete(\"\
    racecar\", \"a\"))\nprint(reverse_delete(\"", "\tlocal str = {}\n\tfor str in\
    \ string.gmatch(s, c) do\n\t\ttable.insert(str, str)\n\tend\n\treturn (table.concat(str,\
    \ \"\"), str)\nend", "    if not s then return nil end\n    local n = #s\n   \
    \ local result = ''\n    for i = 1, n do\n        if s[i] == c then\n        \
    \    result = result .. s[i]\n        else\n            if string.len(result)\
    \ == 0 then\n                result = string.reverse(s)\n                return\
    \ string.reverse(result) == result and {true, false}\n            else\n     \
    \           result = result .. s[i]\n            end\n        end\n    end\n \
    \   if string.len(result) == 0 then\n        result = string.reverse(s)\n    \
    \    return string.reverse(result) == result and {true, false}\n    end\n    return\
    \ string.reverse(result) == result and {result, true}\nend", "  -- Write your\
    \ code here\nend", "   local sL = #s\n   local cL = #c\n   local result = \"\"\
    \n   local result1 = \"\"", "   -- Write your code here.\n   -- Your code here\n\
    \   -- return (s,True)\n   end\n   \n   local function palindrome(s)\n      local\
    \ result = reverse_delete(s, string.sub(s, 1, #s))\n      return (result[1],result[2]\
    \ == true)\n   end\n   \n   assert(palindrome(\"abba\")) == false\n   assert(palindrome(\"\
    aba\")) == true\n   \n   return palindrome(\"baba\")\nend\n</cell>\n<cell>\n#hide",
  "   -- Base case: palindrome if s is empty or c is empty.\n   if s == '' or c ==\
    \ '' then return \"\", false end\n   -- Reverse the string and delete all chars\
    \ which are equal to c\n   local result = reverseString(s)\n   for i = 1, #c do\n\
    \      result = removeChar(result, c[i])\n   end\n   -- Check if result is a palindrome\n\
    \   if result == reverseString(s) then return result, true else return result,\
    \ false end\nend", "  assert(type(s) == \"string\")\n  assert(type(c) == \"string\"\
    )", "\t-- write your code here\n\t-- return (s, result)\n\treturn (s, true)\n\
    end", "  -- Your code here\n  return ...\nend", "\tlocal res, isPal = true, true\n\
    \tlocal len = #s\n\tlocal i = 1\n\twhile i <= len and isPal do\n\t\tif not s[i-1]\
    \ == c then isPal = false end\n\t\ti = i + 1\n\tend\n\tif i > len then\n\t\treturn\
    \ res, isPal\n\telse\n\t\tres = string.sub(s, 1, i)\n\t\tres, isPal = reverse_delete(res,\
    \ c)\n\tend\n\treturn res, isPal\nend", "  s = s:gsub(c,\"\")\n  s = s:reverse()\n\
    \  if s:sub(1, #s)~=s then return (s, false) else return (s,true) end\nend", " \
    \   local s, c, s, c, s, c, s, c = unpack((\"?*s\"..c))\n    local result = \"\
    \"\n    for i = 1, #s do\n        if s[i] ~= c then\n            result = result\
    \ .. s[i]\n        end\n    end\n    local is_palindrome = result == result\n\
    \    return (result, is_palindrome)\nend", "-- Your code here\nend", "  local\
    \ a = {}\n  for i = 1, #s do\n    a[i] = s[i]\n  end\n  local r = \"\"\n  for\
    \ i = #s-1, 1, -1 do\n    if a[i] ~= c then\n      r = r..a[i]\n    end\n  end\n\
    \  return r, r == s\nend", "    if s == \"nil\" then\n        return nil, false\n\
    \    end\n    local result = \"\"\n    for i = 1, #s do\n        if s[i] == c\
    \ then\n            result = result .. (#s + 1)\n        else\n            if\
    \ result ~= \"\" then\n                -- We need to delete all characters\n \
    \               -- until we find one that isn't equal to\n                -- any\
    \ character of c\n                local deleted_characters = 1\n             \
    \   while true do\n                    if s[deleted_characters] == c then\n  \
    \                      break\n                    elseif deleted_characters >\
    \ #s then\n                        break\n                    else\n         \
    \               result = result .. (#s + deleted_characters)\n               \
    \         deleted_characters = deleted_characters + 1\n                    end\n\
    \                end\n            end\n        end\n    end\n    -- We need to\
    \ delete all characters until we find one that isn't equal to any character of\
    \ c\n    local deleted_characters = 1\n    while true do\n        if s[deleted_characters]\
    \ == c then\n            break\n        elseif deleted_characters > #s then\n\
    \            break\n        else\n            result = result .. (#s + deleted_characters)\n\
    \            deleted_characters = deleted_characters + 1\n        end\n    end\n\
    \    -- If result is not an empty string, then it is the palindrome\n    if result\
    \ ~= \"\" then\n        return result, true\n    end\n    return result, false\n\
    end", "   -- Your code here\n   end\n   return string\nend", "  local result =\
    \ \"\" -- empty string\n  local reverse = s:reverse() -- reverse\n  for _, character\
    \ in reverse:gmatch(\"%c\") do -- loop through each character\n    if character\
    \ == c then -- if character == c\n      result = result .. character -- result\
    \ += character\n    end -- if\n  end -- for\n  return result, result == s:reverse()\
    \ -- return (result, True)/else (result, False)\nend", "    local t = {}\n   \
    \ for i = 1, #s do\n        table.insert(t, tostring(s[i])) --put them in table\
    \ so can use for loop\n    end", "   local result,flag = \"\",false\n   for i\
    \ = 1,#s do\n      if s[i] == c then\n         result = result .. s[i]\n     \
    \ else\n         result = result .. c .. s[i]\n         flag = true\n      end\n\
    \   end\n   if flag and result ~= result then return result, true end\n   if result\
    \ ~= result then return result, false end\n   return result,false\nend", "  if\
    \ #s <= 0 then return \"ERROR\" end\n  if #c <= 0 then return \"ERROR\" end\n\
    \  if #s > #c then return \"ERROR\" end\n  if #c ~= 1 then return \"ERROR\" end\n\
    \  if #s == 1 then return s, false end\n  local rs = s.reverse()\n  for i = #c,\
    \ 1, -1 do\n    if rs[i-1] ~= c then return s, false end\n  end\n  return s, true\n\
    end", "   local new_string = \"\"\n   for i = #s, 1, -1 do\n      if new_string\
    \ == \"\" then\n         new_string = s\n         break\n      elseif new_string\
    \ == c and #new_string > 0 then\n         new_string = new_string:sub(1)\n   \
    \   else\n         new_string = new_string..s\n      end\n   end\n   return new_string,\
    \ #new_string > 0\nend", "    local result = \"\"\n    for i = #s, 1, -1 do\n\
    \        if s[i] == c then\n            -- Remove character\n            i = i\
    \ - 1\n        else\n            result = result .. s[i]\n        end\n    end",
  "   \nend", "    -- Your code here\n    return s, true\nend", "    local n = 1\n\
    \    local r = ''\n    for i = #s do\n        if n == #c then\n            r =\
    \ r..s[i]\n            break\n        end\n        if s[i] == c[n] then\n    \
    \        r=r..s[i]\n            n = n + 1\n        else\n            r=r..'#'\n\
    \        end\n    end\n    if r == s then\n        return (true, true)\n    elseif\
    \ r == reverse then\n        return (false, false)\n    else\n        return (true,\
    \ false)\n    end\nend", "    local result = \"\"\n    for i = #s, 1, -1 do\n\
    \        if s[i] = c then\n            result = result .. s[i]\n        end\n\
    \    end\n    local ok = result == s\n    return result, ok\nend", "    -- Your\
    \ code here\n    return string.reverse(s, 1, string.len(s) - string.len(c)) ==\
    \ s, true\nend", "   -- Write your code here.\n   -- The function will return\
    \ the string and the result\n   -- The result will be a boolean\n   if s == nil\
    \ then\n      return \"nil\", false\n   end", "    if s == nil then return nil,\
    \ false end\n    if c == nil then return s, true end\n    local result = nil\n\
    \    local done = false\n    local i = 1\n    while i <= #s do\n        if s[i]\
    \ == c then\n            if done then break end\n            done = true\n   \
    \     else\n            if done then\n                result, done = reverse_delete(s[i..-1],\
    \ c)\n                if not done then break end\n            else\n         \
    \       break\n            end\n        end\n        i = i + 1\n    end\n    if\
    \ not done then\n        result, done = reverse_delete(s[i..-1], c)\n    end\n\
    \    return result, done\nend", "    local s, c = s:reverse(), c:reverse()\n \
    \   local i, j, temp\n    i, j = 1, #s\n    while i < j do\n        if s[i] ~=\
    \ c[i] then\n            i = i - 1\n        else\n            j = j - 1\n    \
    \    end\n    end\n    temp = s[i]\n    s[i], s[j] = s[j], s[i]\n    return temp\
    \ == \"\" and true or false, false\nend", "\t-- your code goes here\n\treturn\
    \ s, true\nend", "  local str = \"\"\n  local str2 = \"\"\n  local rev = c\n \
    \ local found = false\n  while s do\n    str2 = str..s\n    -- first we delete\
    \ the character in s\n    local pos = 1\n    while pos do\n      pos = string.find(str2,\
    \ rev)\n      if not pos then break end\n      str2 = string.sub(str2, pos+1,\
    \ #str2)\n    end\n    -- then we check if the str2 string is a palindrome\n \
    \   -- if it is not then we return str2 and the answer is not palindrome\n   \
    \ local pos2 = 1\n    while pos2 do\n      pos2 = string.find(str2, c)\n     \
    \ if pos2 then\n        str = str..string.sub(str2, pos2, pos2+1)\n        found\
    \ = true\n        break\n      end\n      pos2 = pos2 + 1\n    end\n    if found\
    \ then break end\n    s = string.sub(s,1,#s-1) -- we delete the first char\n \
    \ end\n  return str2, found\nend", "\t-- Your code here\n\treturn s, true\nend",
  "  local _s = s\n  local _s = s:gsub(c, '')\n  local _s = s:gsub('(.-)' .. c ..\
    \ '$', '$1')\n  local _s = s:gsub('(.-)' .. c .. '$', '$2')\n  local _s = s:gsub('(.-)'\
    \ .. c .. '$', '$3')\n  local _s = s:gsub('(.-)' .. c .. '$', '$4')\n  local _s\
    \ = s:gsub('(.-)' .. c .. '$', '$5')\n  local _s = s:gsub('(.-)' .. c .. '$',\
    \ '$6')\n  local _s = s:gsub('(.-)' .. c .. '$', '$7')\n  local _s = s:gsub('(.-)'\
    \ .. c .. '$', '$8')\n  local _s = s:gsub('(.-)' .. c .. '$', '$9')\n  local _s\
    \ = s:gsub('(.-)' .. c .. '$', '$0')\n  local _s = s:gsub('(.-)' .. c .. '$',\
    \ '') -- The last one is just an extra character", "  local result = {}\n  local\
    \ is_palindrome = nil", "\tlocal result = {}\n\tlocal i = 1 -- because we are\
    \ starting the for loop at 1 instead of 0\n\t\n\t-- while i is less than the length\
    \ of the string\n\twhile i <= #s do\n\t\t-- check if the character of s is the\
    \ same as the character of c\n\t\tif s[i] == c then\n\t\t\t-- append the character\
    \ of c to the result string\n\t\t\ttable.insert(result, c)\n\t\telse\n\t\t\t--\
    \ append the character of s to the result string\n\t\t\ttable.insert(result, s[i])\n\
    \t\tend\n\t\t\n\t\t-- increment i\n\t\ti = i + 1\n\tend\n\t\n\t-- check if the\
    \ result string is palindrome\n\tif table.getn(result) == #s then\n\t\treturn\
    \ {table.concat(result), true}\n\telse\n\t\treturn {table.concat(result), false}\n\
    \tend\nend", "    -- write your code here\nend", "    if string.len(s)==0 or string.len(c)==0\
    \ then\n        return False, False\n    end\n    local result, flag=false, false\n\
    \    local i, j, k\n    for i=1,string.len(s)-1 do\n        k=string.find(s, c,\
    \ i, true)\n        if k==nil then\n            flag=true\n            break\n\
    \        end\n        if k<i then\n            k=string.len(s)-1\n        end\n\
    \        s=string.sub(s,1, i-1)..string.sub(s,k+1)\n    end\n    return s, flag\n\
    end", "\tlocal result = \"\";\n\t\n\tfor i = 1,#s do\n\t\tif s[i] = c then\n\t\
    \t\tresult = result .. s[i];\n\t\telse\n\t\t\tresult = result .. s[i];\n\t\tend\n\
    \tend\n\t\n\treturn result, true;\nend", "\tlocal rev_s = string.gsub(s, c, \"\
    %s\")\n\tlocal is_palindrome = string.gsub(rev_s, c, \"%s\")\n\treturn (rev_s,\
    \ is_palindrome)\nend", "    local result, isPalindrome = false\n    local index\
    \ = string.len(s) - string.len(c)", "   assert(type(s) == 'string', 'The given\
    \ argument \"s\" must be a string')\n   assert(type(c) == 'string', 'The given\
    \ argument \"c\" must be a string')", "    return true, s == reverse(s, c)\nend",
  "\tlocal ret = \"\"\n\tfor c in s do\n\t\tif c == c then\n\t\telse\n\t\t\tret =\
    \ ret + c\n\t\tend\n\tend\n\treturn ret\nend", "    local reverse = \"\"\n   \
    \ for i=1, #s do\n        reverse = reverse .. c\n    end\n    local result =\
    \ reverse\n    for i=1, #s do\n        result = result .. s[#s]\n    end\n   \
    \ if s == result then\n        return result, true\n    else\n        return result,\
    \ false\n    end\nend", "  if #s == 0 then\n    return s, true\n  end\n  if #s\
    \ == 1 and s[0] == c then\n    return s, true\n  end\n  if #s == 1 and #c > 0\
    \ and s[#s - 1] == c then\n    return reverse_delete(s[#s - 1], c)\n  end", " \
    \  -- Your code here\nend", "  local result = \"\"\n  for i, x in ipairs(s) do\n\
    \    if x == c then\n      result = result .. x\n    else\n      result = result\
    \ .. x\n    end\n  end\n  return result, result == reverse_string(result)\nend",
  "    local ret = \"\"\n    for i = 1, #s do\n        if s[i] == c then\n       \
    \     ret:sub(1, #ret):append(s[i])\n        end\n    end\n    return ret, s ==\
    \ ret\nend", "\t-- base case: s has no characters in c\n\tif #s == 0 then\n\t\t\
    return s, true\n\tend", "\tlocal ok = true -- check if this string palindrome\n\
    \t\n\tlocal pal = s:reverse() -- reverse string\n\t\n\tfor i = 0, #pal-1 do\n\t\
    \tif pal[i] ~= c then -- check if character in s is equal to character in c\n\t\
    \t\tok = false\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\treturn (pal, ok)\nend", "\t\
    -- Your code here!\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
