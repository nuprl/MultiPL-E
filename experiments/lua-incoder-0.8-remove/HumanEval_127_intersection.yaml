name: HumanEval_127_intersection
language: lua
prompt: "-- You are given two intervals,\n-- where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n-- The given intervals are closed\
  \ which means that the interval (start, end)\n-- includes both start and end.\n\
  -- For each given interval, it is assumed that its start is less or equal its end.\n\
  -- Your task is to determine whether the length of intersection of these two \n\
  -- intervals is a prime number.\n-- Example, the intersection of the intervals (1,\
  \ 3), (2, 4) is (2, 3)\n-- which its length is 1, which not a prime number.\n--\
  \ If the length of the intersection is a prime number, return \"YES\",\n-- otherwise,\
  \ return \"NO\".\n-- If the two intervals don't intersect, return \"NO\".\n-- [input/output]\
  \ samples:\nlocal function intersection(interval1, interval2)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = intersection\n\
  \    lu.assertEquals(candidate({1, 2}, {2, 3}), 'NO')\n    lu.assertEquals(candidate({-1,\
  \ 1}, {0, 4}), 'NO')\n    lu.assertEquals(candidate({-3, -1}, {-5, 5}), 'YES')\n\
  \    lu.assertEquals(candidate({-2, 2}, {-4, 0}), 'YES')\n    lu.assertEquals(candidate({-11,\
  \ 2}, {-1, -1}), 'NO')\n    lu.assertEquals(candidate({1, 2}, {3, 5}), 'NO')\n \
  \   lu.assertEquals(candidate({1, 2}, {1, 2}), 'NO')\n    lu.assertEquals(candidate({-2,\
  \ -2}, {-3, -2}), 'NO')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tlocal firstStart, firstEnd = interval1[1], interval1[2]\n\tlocal\
    \ secondStart, secondEnd = interval2[1], interval2[2]\n\tlocal intersectionStart\
    \ = 0\n\tlocal intersectionEnd = 0\n\t\n\t\n\tif firstStart > secondStart then\n\
    \t\tlocal tmp = firstStart\n\t\tfirstStart = secondStart\n\t\tsecondStart = tmp\n\
    \tend\n\tif firstEnd < secondEnd then\n\t\tlocal tmp = firstEnd\n\t\tfirstEnd\
    \ = secondEnd\n\t\tsecondEnd = tmp\n\tend\n\t\n\twhile firstStart <= firstEnd\
    \ do\n\t\tlocal currentStart = firstStart\n\t\twhile secondStart <= secondEnd\
    \ do\n\t\t\t\n\t\t\tif currentStart < secondStart then\n\t\t\t\tbreak\n\t\t\t\
    end\n\t\t\t\n\t\t\tlocal currentEnd = secondStart\n\t\t\t\n\t\t\tif currentEnd\
    \ > secondEnd then\n\t\t\t\tbreak\n\t\t\tend\n\t\t\t\n\t\t\t\n\t\t\tif currentStart\
    \ >= firstEnd then\n\t\t\t\tbreak\n\t\t\tend\n\t\t\t\n\t\t\t\n\t\t\tif currentEnd\
    \ <= firstStart then\n\t\t\t\tbreak\n\t\t\tend\n\t\t\t\n\t\t\tif currentStart\
    \ > currentEnd then\n\t\t\t\tbreak\n\t\t\tend\n\t\t\t\n\t\t\tlocal currentLength\
    \ = math.min(currentStart - currentEnd, secondEnd - currentStart)\n\t\t\tintersectionStart\
    \ = currentStart\n\t\t\tintersectionEnd = currentStart + currentLength\n\t\t\t\
    \n\t\t\tfirstStart = currentEnd + 1\n\t\t\tsecondStart = currentStart + currentLength\n\
    \t\t\t\n\t\t\t\n\t\tend\n\t\t\n\t\t\n\t\tif firstStart > firstEnd then\n\t\t\t\
    break\n\t\tend\n\t\t\n\t\t\n\t\t\n\tend\n\t\n\t\n\t\n\t\n\tif intersectionStart\
    \ >= secondStart then\n\t\t\n\t\tif intersectionStart >= firstStart then\n\t\t\
    \treturn \"YES\"\n\t\tend\n\t\t\n\t\treturn \"NO\"\n\tend\n\t\n\t\n\t\n\t\n\t\n\
    \t\n\t\n\t\n\t\n\t\n\t\n\t\n\treturn \"NO\"\nend", "   -- Your code here\nend",
  "    local start1 = interval1[1]\n    local end1 = interval1[2]\n    local start2\
    \ = interval2[1]\n    local end2 = interval2[2]\n    if start1 < end2 and start2\
    \ < end1 then\n        return start2, end1\n    end\nend", "\t-- [string] interval1\n\
    \t-- [string] interval2\n\t-- [string] whether the length of intersection of these\
    \ two intervals is a prime number\n\tlocal length_intersection_prime, length_intersection_not_prime,\
    \ length_intersection_not_prime = 0, 0, 0\n\tlocal interval1Start, interval1End\
    \ = interval1[1], interval1[2]\n\tlocal interval2Start, interval2End = interval2[1],\
    \ interval2[2]\n\tlocal intersection_start, intersection_end = interval1Start,\
    \ interval1End", "  local i1l=interval1[1]:lower\n  local i1u=interval1[1]:upper\n\
    \  local i2l=interval2[1]:lower\n  local i2u=interval2[1]:upper", "\tlocal result1\
    \ = interval1[1] - interval1[0]\n\tlocal result2 = interval2[1] - interval2[0]\n\
    \tif result2 < result1 then\n\t\treturn (interval1[1], interval2[1])\n\telse\n\
    \t\treturn (interval1[0], interval2[1])\n\tend\nend", "  assert(type(interval1)\
    \ == \"table\" and type(interval2) == \"table\")\n  local start1, end1 = interval1[1],\
    \ interval1[2]\n  local start2, end2 = interval2[1], interval2[2]\n  if start1\
    \ < start2 then return end2 >= start2 end1 else return start1 <= end2 end1 end\n\
    end", "\tlocal interval1Start = interval1[1]\n\tlocal interval1End = interval1[2]\n\
    \tlocal interval2Start = interval2[1]\n\tlocal interval2End = interval2[2]\n\t\
    if interval1Start <= interval2End then\n\t\tif interval2Start <= interval1End\
    \ then\n\t\t\treturn interval1[1] < interval2[1] and interval1[2] > interval2[2]\
    \ \n\t\telse\n\t\t\treturn interval1[1] > interval2[1] and interval1[2] < interval2[2]\n\
    \t\tend\n\telse\n\t\tif interval2Start <= interval1End then\n\t\t\treturn interval1[1]\
    \ < interval2[1] and interval1[2] > interval2[2]\n\t\telse\n\t\t\treturn interval1[1]\
    \ > interval2[1] and interval1[2] < interval2[2]\n\t\tend\n\tend\nend", "\tlocal\
    \ result = {{}, {}}\n\tfor i = 1,#interval1 do\n\t\tlocal start = interval1[i]\n\
    \t\tlocal end = interval2[i]\n\t\tfor j=1,#result do\n\t\t\tif start < result[j]\
    \ then\n\t\t\t\tresult[j] = start\n\t\t\t\tbreak\n\t\t\telseif end > result[j]\
    \ then\n\t\t\t\tresult[j] = end\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\t\
    return #result == #interval2 and \"YES\" or \"NO\"\nend", "    local i, j, len\n\
    \    local p1 = interval1[1]\n    local p2 = interval2[1]\n    local len1, len2\n\
    \    local isIntersection = false\n    \n    len1 = p2 - p1 + 1\n    len2 = interval2[2]\
    \ - interval1[2] + 1\n    \n    if len1 > len2 then\n        i, j = interval1[2],\
    \ interval2[2] + 1\n    else\n        i, j = interval1[2] + 1, interval2[2]\n\
    \    end\n    \n    while j <= p2 do\n        local flag = true\n        \n  \
    \      for i = i, j do \n            flag = flag and ((i - p1)%j == 0)\n     \
    \   end\n        \n        if flag then\n            isIntersection = true\n \
    \           break\n        end\n        \n        j = j + 1\n    end\n    \n \
    \   return isIntersection and \"YES\" or \"NO\"\nend", "\tif interval1[1] <= interval2[1]\
    \ then\n\t\tif interval1[1] < interval2[2] then\n\t\t\tlocal a1 = interval1[2]\n\
    \t\t\tlocal b1 = interval2[1]\n\t\t\tlocal a2 = interval1[1]\n\t\t\tlocal b2 =\
    \ interval2[2]\n\t\t\tlocal c1 = a1 + b2\n\t\t\tlocal c2 = a2 + b1\n\t\t\tif a1\
    \ <= a2 then\n\t\t\t\tb1 = a1 + b2\n\t\t\t\tc1 = a1 + b2\n\t\t\telse\n\t\t\t\t\
    b1 = interval2[1]\n\t\t\t\tc1 = a1 + b2\n\t\t\tend\n\t\t\tif b2 <= b1 then\n\t\
    \t\t\tb2 = interval2[2]\n\t\t\t\tc2 = interval2[1] + b2\n\t\t\telse\n\t\t\t\t\
    b2 = interval2[1]\n\t\t\t\tc2 = interval2[2] + b1\n\t\t\tend\n\t\t\tif c1 <= c2\
    \ then\n\t\t\t\treturn c1,c2\n\t\t\telse\n\t\t\t\treturn c2,c1\n\t\t\tend\n\t\t\
    else\n\t\t\treturn interval2[1],interval2[2]\n\t\tend\n\telse\n\t\treturn interval1[1],interval1[2]\n\
    \tend\nend", "\tinterval1 = interval1[1]\n\tinterval2 = interval2[1]", "\tlocal\
    \ firstI = interval1[1]\n\tlocal secondI = interval2[1]\n\tif firstI > secondI\
    \ then\n\t\tlocal tempI = interval1[1]\n\t\tinterval1[1] = interval2[1]\n\t\t\
    interval2[1] = tempI\n\tend\n\t\n\tlocal i1 = interval1[2]\n\tlocal i2 = interval2[2]\n\
    \t\n\tlocal result = firstI + secondI - 2*i1 + i2 - 2*i2\n\tif result == 0 then\n\
    \t\treturn \"NO\"\n\telseif result > 0 then\n\t\treturn \"YES\"\n\telse\n\t\t\
    return \"NO\"\n\tend\nend", "    local start1 = interval1[1]\n    local end1 =\
    \ interval1[2]\n    local start2 = interval2[1]\n    local end2 = interval2[2]\n\
    \    local intersectLength = 0\n    local isIntersect = false\n    local isPrime\
    \ = false\n    if start1 == start2 then\n        if end1 == end2 then\n      \
    \      intersectLength = end1 - start1 + 1\n            isIntersect = true\n \
    \       elseif start1 < start2 then\n            intersectLength = end2 - start2\
    \ + 1\n        else\n            intersectLength = end1 - start2 + 1\n       \
    \ end\n    else\n        if end1 < end2 then\n            intersectLength = start2\
    \ - start1 + 1\n        else\n            intersectLength = end2 - end1 + 1\n\
    \        end\n    end\n    if intersectLength == 0 then\n        isPrime = false\n\
    \    elseif intersectLength == 1 then\n        isPrime = true\n    else\n    \
    \    for i = 1, intersectLength do\n            if intersectLength % i == 0 then\n\
    \                isPrime = false\n                break\n            end\n   \
    \     end\n    end\n    return isIntersect, isPrime\nend", "   local start = interval1[1]\n\
    \   local end = interval2[1]\n   if start <= end then\n      start = start + 1\n\
    \      end = end + 1\n   else\n      start = start - 1\n      end = end - 1\n\
    \   end\n   if start <= end then\n      start = start - 1\n      end = end + 1\n\
    \   else\n      start = start + 1\n      end = end - 1\n   end\n   return start,\
    \ end\nend", "\tlocal intersect = {}\n\tfor _, v in ipairs(interval1) do\n\t\t\
    local start = math.min(v, interval2[1])\n\t\tlocal end = math.max(v, interval2[2])\n\
    \t\tif start <= end then\n\t\t\tintersect[start + 1] = end \n\t\tend\n\tend\n\t\
    return intersect\nend", "\t-- your code\n\treturn true\nend", "\tif interval1[1]\
    \ >= interval2[1] and interval1[1] <= interval2[2] or interval2[1] >= interval1[1]\
    \ and interval2[1] <= interval1[2] then\n\t\treturn interval1\n\tend\n\treturn\
    \ interval2\nend", "\tif interval1[1] < interval2[1] then\n\t\treturn (interval1[1],\
    \ interval2[1])\n\tend\n\tif interval2[1] < interval1[1] then\n\t\treturn (interval2[1],\
    \ interval1[1])\n\tend\n\treturn (interval1[1], interval2[1])\nend", "    if interval2[1]\
    \ < interval1[1] or interval1[1] < interval2[1] then\n        return \"NO\"\n\
    \    end", "\tif interval1 == nil or interval2 == nil then\n\t\treturn nil\n\t\
    end", "\tif interval1[1] < interval1[2] and interval2[1] < interval2[2] then\n\
    \t\treturn {interval1[1], interval2[1]}\n\tend\n\tif interval1[1] < interval1[2]\
    \ and interval2[2] < interval2[1] then\n\t\treturn {interval1[2], interval2[2]}\n\
    \tend\n\tif interval1[2] < interval1[1] and interval2[1] < interval2[2] then\n\
    \t\treturn {interval1[1], interval2[2]}\n\tend\n\tif interval1[2] < interval1[1]\
    \ and interval2[2] < interval2[1] then\n\t\treturn {interval1[2], interval2[1]}\n\
    \tend\nend", "\t-- Your code here\n\tlocal result = {} \n\tlocal i = {}\n\t\n\t\
    for i=1,#interval1 do\n\t\tif interval1[i]>interval2[i] then\n\t\t\ttable.insert(result,\
    \ interval1[i])\n\t\telse\n\t\t\ttable.insert(result, interval2[i])\n\t\tend\n\
    \tend\n\t\n\treturn #result\nend", "  return #(interval1[1] < interval2[2] or\
    \ interval1[2] > interval2[1]) == 1 and #interval1 == #interval2 and \n    (#interval1[1]\
    \ <= 0 or #interval1[2] <= 0 or #interval2[1] <= 0 or #interval2[2] <= 0)\nend",
  "\tlocal start = interval1[1]\n\tlocal end = interval2[1]", "\tlocal interval1_start,\
    \ interval1_end = interval1[1], interval1[2]\n\tlocal interval2_start, interval2_end\
    \ = interval2[1], interval2[2]", "  -- Your code here\n  -- if interval1[1] >\
    \ interval2[1] or interval1[1] < interval2[1] then\n  -- \treturn false\n  --\
    \ end\n  -- if interval1[2] > interval2[2] or interval1[2] < interval2[2] then\n\
    \  -- \treturn false\n  -- end\n  return true\nend", "  return interval1[1] >\
    \ interval2[2] and interval1[2] <= interval2[1]\nend", "    local ret = {}\n \
    \   local start = interval1[1]\n    local end = interval1[2]\n    for _ = 1, interval2[2]\
    \ do ret[#ret+1] = end end\n    for i = start, end do\n        if ret[#ret] ==\
    \ i then\n            -- delete from ret if it's the same\n            -- when\
    \ deleting an element at a particular index, the index\n            -- is shifted\
    \ to the left by 1\n            local delete_index = #ret-1\n            -- delete\
    \ the corresponding element from ret\n            ret[delete_index] = nil\n  \
    \      else\n            -- the element at the index is not the same as the last\
    \ element\n            -- in ret, so insert in the end of ret\n            ret[#ret+1]\
    \ = i\n        end\n    end\n    return ret\nend", "\tlocal start = interval1[1]\n\
    \tlocal end = interval1[2]\n\tlocal interval = interval2[1]\n\tlocal length =\
    \ interval2[2]\n\tif start >= end then\n\t\treturn false\n\tend\n\tlocal interSection\
    \ = math.ceil((end - start + 1) * length / 2)\n\tif interSection == 0 then\n\t\
    \treturn false\n\telse\n\t\treturn start <= interSection and interSection <= end\n\
    \tend\nend", "    if interval1[1] > interval2[1] then\n        -- interval1 is\
    \ open so we don't need to check.\n        return interval2\n    elseif interval1[1]\
    \ < interval2[1] then\n        -- interval2 is open so we don't need to check.\n\
    \        return interval1\n    else\n        -- both intervals are closed so we\
    \ need to check.\n        local left_open = true\n        local right_open = true\n\
    \        local intersect_left = interval1[1]\n        local intersect_right =\
    \ interval1[1]", "    local result = {x = interval2.x - interval1.x, y = interval2.y\
    \ - interval1.y}\n    if result.x < 0 or result.y < 0 then\n        return \"\
    NO\"\n    end\n    if result.y == 0 then\n        return \"YES\"\n    end\n  \
    \  if result.y == 1 then\n        if result.x == 0 then\n            return \"\
    YES\"\n        else\n            return \"NO\"\n        end\n    end\n    \n \
    \   local i = 1\n    while i < result.x do\n        if result.y == 1 then\n  \
    \          if result.x == 0:\n                return \"YES\"\n            else\n\
    \                return \"NO\"\n            end\n        end\n        if result.y\
    \ == 2 then\n            if result.x == result.y - 1 then\n                return\
    \ \"YES\"\n            else\n                return \"NO\"\n            end\n\
    \        end\n        \n        if result.y == 3 then\n            if result.x\
    \ == result.y - 2 then\n                return \"YES\"\n            else\n   \
    \             return \"NO\"\n            end\n        end\n        \n        if\
    \ result.y == 4 then\n            if result.x == result.y - 3 then\n         \
    \       return \"YES\"\n            else\n                return \"NO\"\n    \
    \        end\n        end\n        \n        \n        table.insert(result, i,\
    \ result.y)\n        i = i + 1\n    end\n    \n    return \"NO\"\nend", "  return\
    \ interval1[1] < interval2[2] and interval2[1] < interval1[2]\nend", "    local\
    \ firstStart, firstEnd = interval1[1], interval1[2]\n    local secondStart, secondEnd\
    \ = interval2[1], interval2[2]", "\tlocal result = {}\n\tresult[1] = interval1[1]\n\
    \tresult[2] = interval1[2]\n\tresult[3] = interval2[1]\n\tresult[4] = interval2[2]\n\
    \tlocal intersectCount = 0\n\tlocal intersectNum = 1\n\tlocal intersectLower =\
    \ math.min(interval1[1], interval2[1])\n\tlocal intersectUpper = math.max(interval1[2],\
    \ interval2[2])\n\tlocal intersectRange = intersectUpper - intersectLower\n\t\
    -- count the intersect\n\tfor i = intersectLower, intersectUpper do\n\t\tif intersectRange\
    \ == result[i] - result[i-1] then\n\t\t\tintersectCount = intersectCount + 1\n\
    \t\tend\n\t\tresult[i] = result[i] + intersectNum\n\t\tintersectNum = intersectNum\
    \ * 2\n\tend\n\tif intersectCount % 2 ~= 0 then\n\t\treturn 'NO'\n\telse\n\t\t\
    return 'YES'\n\tend\nend", "    if interval1[1] < interval2[1] then\n        return\
    \ interval1[1]\n    end\n    return interval2[1]\nend", "  local start = interval1[1]\n\
    \  local end = interval1[2]\n  local start2 = interval2[1]\n  local end2 = interval2[2]\n\
    \  if start > end and start2 > end2 then\n    return \"NO\"\n  elseif start >\
    \ end and start2 <= end2 then\n    return \"NO\"\n  elseif start <= end and start2\
    \ >= end2 then\n    return \"NO\"\n  elseif start <= end and start2 < end2 then\n\
    \    return \"YES\"\n  elseif start > end and start2 < end2 then\n    return \"\
    YES\"\n  elseif start < end and start2 > end2 then\n    return \"YES\"\n  else\n\
    \    return \"NO\"\n  end\nend", "\t-- Write your code here.\n\tlocal length =\
    \ math.max(interval1[1], interval2[1]) - math.min(interval1[1], interval2[1])\
    \ + 1\n\treturn length == 2 or (length == 1 and interval1[1] == interval2[1])\n\
    end", "    return interval1[1]:find(interval2[1]) == interval1[1] and interval1[2]:find(interval2[2])\
    \ == interval1[2]\nend", "    return interval1[1] <= interval2[2] and interval2[1]\
    \ <= interval1[2]\nend\n</cell>\n<cell>", "\t-- Write your code here\n\tlocal\
    \ length_intersection = 0\n\t\n\tlocal minimum = math.min(interval1[1], interval2[1])\n\
    \tlocal maximum = math.max(interval1[2], interval2[2])\n\t\n\tfor i = minimum,\
    \ maximum do\n\t\tif interval1[1] < i and i < interval2[1] and interval2[2] <\
    \ i then\n\t\t\tlength_intersection = length_intersection + 1\n\t\tend\n\tend\n\
    \t\n\tif length_intersection == 2 then\n\t\tif interval1[1] == interval2[1] and\
    \ interval1[2] == interval2[2] then\n\t\t\treturn 'YES'\n\t\tend\n\telse\n\t\t\
    return 'NO'\n\tend\nend", "\tif interval1[1] > interval1[2] then -- First interval\
    \ is (start, end)\n\t\treturn nil\n\tend\n\tif interval2[1] > interval2[2] then\
    \ -- Second interval is (start, end)\n\t\treturn nil\n\tend\n\tif interval1[1]\
    \ == interval2[1] or interval1[1] == interval2[2] or interval1[2] == interval2[1]\
    \ or interval1[2] == interval2[2] then -- Two intervals are the same\n\t\treturn\
    \ nil\n\tend\n\tlocal interval1Length = interval1[1] - interval1[2] + 1\n\tlocal\
    \ interval2Length = interval2[1] - interval2[2] + 1\n\tif interval1Length > interval2Length\
    \ then -- First interval is larger\n\t\treturn nil\n\tend\n\t-- Check whether\
    \ interval2 is contained in interval1\n\tlocal interval2End = interval2[1]\n\t\
    local interval1Start = interval1[2]\n\tif interval2End < interval1Start then --\
    \ Second interval is smaller\n\t\treturn nil\n\tend\n\tlocal length = 1\n\twhile\
    \ interval2Start <= interval1End do\n\t\tinterval2End = interval2End + 1\n\t\t\
    length = length + 1\n\tend\n\tif length == 2 or length == 3 and (interval2End\
    \ - interval1Start) == 1 then\n\t\treturn \"YES\"\n\telseif length == 2 and interval2End\
    \ == interval1Start then\n\t\treturn \"NO\"\n\telse\n\t\treturn nil\n\tend\nend",
  "\tlocal interval1_start = interval1[1]\n\tlocal interval1_end = interval1[2]\n\t\
    local interval2_start = interval2[1]\n\tlocal interval2_end = interval2[2]\n\t\
    local interval1_length = interval1_end - interval1_start\n\tlocal interval2_length\
    \ = interval2_end - interval2_start\n\tlocal length_intersection = interval1_length\
    \ + interval2_length\n\t\n\tif interval1_length == 0 and interval2_length == 0\
    \ then\n\t\treturn 0\n\telseif interval1_length > 0 and interval2_length > 0 then\n\
    \t\tlocal i\n\t\tlocal j\n\t\tlocal interval1_prime_numbers = prime_numbers(interval1_length)\n\
    \t\tlocal interval2_prime_numbers = prime_numbers(interval2_length)\n\t\t\n\t\t\
    for i = 2, interval1_length do\n\t\t\tif interval1_prime_numbers[i] == 1 then\n\
    \t\t\t\tfor j = 2, interval2_length do\n\t\t\t\t\tif interval2_prime_numbers[j]\
    \ == 1 then\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\
    \t\t\n\t\tif j == interval2_length then\n\t\t\treturn 1\n\t\telseif j == 1 then\n\
    \t\t\treturn 0\n\t\tend\n\telse\n\t\tif interval1_length == 0 and interval2_length\
    \ > 0 then\n\t\t\treturn 0\n\t\telseif interval1_length > 0 and interval2_length\
    \ == 0 then\n\t\t\treturn 1\n\t\telseif interval1_length == 0 and interval2_length\
    \ == 0 then\n\t\t\treturn 0\n\t\tend\n\tend\nend", "\tlocal start1, end1 = interval1[1],\
    \ interval1[2]\n\tlocal start2, end2 = interval2[1], interval2[2]\n\tlocal length1",
  "    local results = {}\n    for i = 1, #interval1 do\n        local start1 = interval1[i]\n\
    \        local end1 = interval1[i + 1]\n        local start2 = interval2[i]\n\
    \        local end2 = interval2[i + 1]\n        if start1 <= end2 and start2 <=\
    \ end1 then\n            local tmp = (start1 + end2)/2\n            if tmp > start1\
    \ and tmp < end1 then\n                results[#results + 1] = tmp\n         \
    \   end\n            if tmp > start2 and tmp < end2 then\n                results[#results\
    \ + 1] = tmp\n            end\n        end\n    end\n    return results\nend",
  "  local lower = math.min(interval1[1], interval2[1])\n  local higher = math.max(interval1[1],\
    \ interval2[1])\n  local lower = math.min(lower, interval1[2])\n  local higher\
    \ = math.max(higher, interval1[2])", "    local start1 = interval1[1]\n    local\
    \ end1 = interval1[2]\n    local start2 = interval2[1]\n    local end2 = interval2[2]",
  "\tlocal interval1_start, interval1_end = interval1[1], interval1[2]\n\tlocal interval2_start,\
    \ interval2_end = interval2[1], interval2[2]\n\tlocal intersection_start, intersection_end\
    \ = interval1_start, interval1_end", "\tlocal interval1Start, interval1End = interval1[1],\
    \ interval1[2]\n\tlocal interval2Start, interval2End = interval2[1], interval2[2]\n\
    \tif interval1Start > interval1End or interval2Start > interval2End then\n\t\t\
    return false, false\n\tend\n\tlocal interval1Length = interval1End - interval1Start\n\
    \tlocal interval2Length = interval2End - interval2Start\n\tif interval1Length\
    \ > interval2Length then\n\t\treturn false, false\n\tend\n\tif interval1Start\
    \ < interval2Start then\n\t\tinterval1Start, interval1End = interval2Start, interval2End\n\
    \telse\n\t\tinterval1Start, interval1End = interval1Start, interval2End\n\tend\n\
    \tlocal intersectionLength = interval1End - interval1Start\n\tif intersectionLength\
    \ == 0 then\n\t\treturn false, false\n\tend\n\tif intersectionLength % 2 ~= 0\
    \ then\n\t\treturn false, false\n\tend\n\tlocal prime = false -- this will be\
    \ our result\n\tlocal isPrime = true -- we will check if it is a prime\n\t-- iterate\
    \ over the intervals\n\tfor i in math.ceil(1, interval1Length / 2); do\n\t\tlocal\
    \ start = interval1Start + i - 1\n\t\tlocal end = interval1Start + i\n\t\tif start\
    \ < interval1Start then\n\t\t\tstart = interval1Start\n\t\tend\n\t\tif end > interval1End\
    \ then\n\t\t\tend = interval1End\n\t\tend\n\t\tif start > end then\n\t\t\tlocal\
    \ tmp = start\n\t\t\tstart = end\n\t\t\tend = tmp\n\t\tend\n\t\tlocal testInterval\
    \ = interval(start, end)\n\t\tif testInterval[1] ~= nil and testInterval[2] ~=\
    \ nil then\n\t\t\tlocal testIntersection = intersection(testInterval[1], testInterval[2])\n\
    \t\t\tif testIntersection ~= nil then\n\t\t\t\tif testInterval[1] < testIntersection[1]\
    \ then\n\t\t\t\t\tprime = prime or false\n\t\t\t\t\tisPrime = false\n\t\t\t\t\
    end\n\t\t\tend\n\t\tend\n\tend\n\tif prime then\n\t\treturn 'YES'\n\tend\n\treturn\
    \ 'NO'\nend", "\tlocal interval1 = interval1[1]\n\tlocal interval2 = interval2[1]\n\
    \tif interval1[2] < interval2[1] then\n\t\tinterval1, interval2 = interval2, interval1\n\
    \tend\n\tif interval1[2] > interval2[2] then\n\t\treturn nil\n\tend\n\tlocal length\
    \ = interval2[1] - interval1[1]\n\tif length <= 0 or length % 2 == 0 then\n\t\t\
    return nil\n\tend\n\tlocal isPrime = true\n\tlocal sum = 1\n\tlocal startIndex\
    \ = interval1[1]\n\tfor i = interval1[1], interval2[2] do\n\t\tif i % 2 == 0 then\n\
    \t\t\tsum = sum + i\n\t\telse\n\t\t\tif sum == length then\n\t\t\t\tisPrime =\
    \ false\n\t\t\tend\n\t\t\tsum = 1\n\t\tend\n\t\tstartIndex = startIndex + 2\n\t\
    end\n\treturn (isPrime and \"YES\" or \"NO\")\nend", "  -- start with the first\
    \ interval\n  local interval1_start = interval1[1]\n  local interval1_end = interval1[2]\n\
    \  -- then consider the second interval\n  local interval2_start = interval2[1]\n\
    \  local interval2_end = interval2[2]", "    local interval1Begin, interval1End\
    \ = interval1[1], interval1[2]\n    local interval2Begin, interval2End = interval2[1],\
    \ interval2[2]\n    local beginIntersection = interval1Begin\n    local endIntersection\
    \ = interval1End\n    if interval1End < interval2Begin then\n        local temp\
    \ = interval1Begin\n        interval1Begin = interval1End\n        interval1End\
    \ = temp\n    end\n    if interval2End < interval1Begin then\n        local temp\
    \ = interval2Begin\n        interval2Begin = interval2End\n        interval2End\
    \ = temp\n    end\n    if interval1Begin < interval2End then\n        if interval1End\
    \ < interval2Begin then\n            beginIntersection = interval1Begin\n    \
    \        endIntersection = interval2End\n        elseif interval2End < interval1Begin\
    \ then\n            beginIntersection = interval2Begin\n            endIntersection\
    \ = interval1End\n        else\n            endIntersection = interval1End\n \
    \       end\n    else\n        if interval1End < interval2Begin then\n       \
    \     beginIntersection = interval2Begin\n            endIntersection = interval1End\n\
    \        elseif interval2End < interval1Begin then\n            beginIntersection\
    \ = interval1Begin\n            endIntersection = interval2End\n        else\n\
    \            endIntersection = interval2End\n        end\n    end\n    return\
    \ beginIntersection, endIntersection\nend", "    local start, end = interval1[1],\
    \ interval1[2]\n    if start <= end then\n        local start2, end2 = interval2[1],\
    \ interval2[2]\n        if start2 < end2 and start <= start2 and end <= end2 then\n\
    \            -- [begin, end) = interval2\n            -- [begin, end) = interval1\n\
    \            -- begin < end and start < end\n            return true, start, end,\
    \ end2\n        end\n    end\n    return false, start, end, end\nend", "   local\
    \ i, j = interval1[1], interval2[1]\n   if i == j then\n      if i == interval1[1]\
    \ then\n         return \"NO\"\n      else\n         return \"YES\"\n      end\n\
    \   else\n      if interval1[1] < interval2[1] then\n         return \"NO\"\n\
    \      else\n         return \"YES\"\n      end\n   end\nend", "    local interval\
    \ = interval1[1]\n    if interval[1] == interval2[1] then\n        return interval1\n\
    \    elseif interval[1] <= interval2[1] then\n        return interval1\n    end\n\
    \    return interval2\nend", "\tlocal intersect_start = math.max(interval1[1],\
    \ interval2[1])\n\tlocal intersect_end = math.min(interval1[2], interval2[2])\n\
    \tif intersect_start <= intersect_end then\n\t\treturn intersect_end - intersect_start\n\
    \tend\nend", "  local result1, result2 = interval1[1], interval2[1]\n  if result1\
    \ < result2 then\n    interval1[1], interval2[1] = interval2[1], interval1[1]\n\
    \  end\n  local result3, result4 = interval1[2], interval2[2]\n  if result3 <\
    \ result4 then\n    interval1[2], interval2[2] = interval2[2], interval1[2]\n\
    \  end\n  return interval1[1], interval2[2]\nend", "    local start1 = interval1[1]\n\
    \    local end1 = interval1[2]\n    local start2 = interval2[1]\n    local end2\
    \ = interval2[2]\n    local result = {}\n    for i = start1, end1 + 1 do \n  \
    \      table.insert(result, i)\n    end\n    for i = start2, end2 + 1 do \n  \
    \      table.insert(result, i)\n    end\n    if #result == 0 then\n        return\
    \ 'NO'\n    end\n    local prime = 0\n    for _,i in pairs(result) do\n      \
    \  if i % 2 == 0 then\n            prime = prime + 1\n        end\n    end\n \
    \   if prime == #result then\n        return 'YES'\n    end\nend", "\tlocal result\
    \ = {}\n\tlocal i, j = 1, #interval1\n\twhile i <= j do\n\t\tlocal start = interval1[i]\n\
    \t\tlocal end = interval1[j]\n\t\tif start <= end then\n\t\t\tresult[start] =\
    \ end\n\t\t\tj = j + 1\n\t\telse\n\t\t\ti = i + 1\n\t\tend\n\tend\n\tlocal i,\
    \ j = 1, #interval2\n\twhile i <= j do\n\t\tlocal start = interval2[i]\n\t\tlocal\
    \ end = interval2[j]\n\t\tif start <= end then\n\t\t\tresult[start] = end\n\t\t\
    \ti = i + 1\n\t\telse\n\t\t\tj = j + 1\n\t\tend\n\tend\n\tlocal count = 0\n\t\
    for k, v in pairs(result) do\n\t\tif v == v then\n\t\t\tcount = count + 1\n\t\t\
    end\n\tend\n\treturn (count == 1 and count ~= 0) or (count > 1 and count ~= 0)\n\
    end", "\t-- Write your code here\n\treturn true\nend", "\tlocal start = math.min(interval1[1],\
    \ interval2[1])\n\tlocal end = math.max(interval1[2], interval2[2])\n\tlocal intersectionStart\
    \ = math.min(interval1[1], interval2[1])\n\tlocal intersectionEnd = math.max(interval1[2],\
    \ interval2[2])\n\tif start > end or intersectionStart > intersectionEnd then\
    \ return \"NO\" end\n\tif intersectionStart <= start or intersectionEnd <= end\
    \ then return \"NO\" end\n\treturn (start <= end) and (end <= intersectionStart)\
    \ and (start <= intersectionEnd) and (intersectionStart <= intersectionEnd)\n\
    end", "\tlocal interval1Start = interval1[1]\n\tlocal interval1End = interval1[2]\n\
    \tlocal interval2Start = interval2[1]\n\tlocal interval2End = interval2[2]", " \
    \   local start = min(interval1[1], interval2[1])\n    local end = max(interval1[2],\
    \ interval2[2])\n    if start > end then\n        return nil, nil\n    end\n \
    \   return start, end\nend", "\tif interval1[1] <= interval2[1] then\n\t\tlocal\
    \ start1 = interval1[1]\n\t\tlocal end1 = interval1[2]\n\telse\n\t\tlocal start1\
    \ = interval2[1]\n\t\tlocal end1 = interval2[2]\n\tend", "    local start = math.min(interval1[1],\
    \ interval2[1])\n    local end = math.max(interval1[2], interval2[2])\n    local\
    \ length = end - start + 1\n    local isPrime = true\n    -- Prime number > 1\
    \ and odd > 1\n    if length % 2 == 1 and length % 3 ~= 0 then\n        -- All\
    \ odd numbers\n        for i = 3, math.floor(math.sqrt(length)) + 1, 2 do\n  \
    \          if length%i == 0 then\n                isPrime = false\n          \
    \  end\n        end\n    else\n        -- Not prime number\n        isPrime =\
    \ false\n    end\n    return start, length, isPrime\nend", "    return interval1[1]:endpoint()\
    \ >= interval2[1]:endpoint() and\n        interval1[1]:endpoint() <= interval2[2]:endpoint()\n\
    end", "\t-- Your code here\n\treturn false\nend", "  local start, end = interval1[1],\
    \ interval2[1]\n  return start <= end and start + 1 == end or start <= end and\
    \ start + 1 in interval2\nend", "\tif interval1[1] < interval2[1] then\n\t\treturn\
    \ interval2[1]\n\telse\n\t\treturn interval1[1]\n\tend\nend", "\treturn (interval1[1]\
    \ >= interval2[0] and interval1[1] < interval2[2])\n\tor (interval1[2] >= interval2[0]\
    \ and interval1[2] < interval2[1])\nend", "    local function is_intersecting(interval1,\
    \ interval2)\n        local start1, end1 = interval1[1], interval1[2]\n      \
    \  local start2, end2 = interval2[1], interval2[2]\n        return (start1 <=\
    \ end2 and start2 <= end1)\n    end\n    local start1, end1 = interval1[1], interval1[2]\n\
    \    local start2, end2 = interval2[1], interval2[2]\n    if (start1 > end2) or\
    \ (start2 > end1) then\n        return \"NO\"\n    end\n    if not is_intersecting(interval1,\
    \ interval2) then\n        return \"NO\"\n    end\n    if start1 <= start2 then\n\
    \        if end1 < end2 then\n            return \"YES\"\n        else\n     \
    \       return \"NO\"\n        end\n    else\n        if end1 > end2 then\n  \
    \          return \"YES\"\n        else\n            return \"NO\"\n        end\n\
    \    end\nend", "\tlocal i1 = interval1[1]\n\tlocal i2 = interval2[1]\n\tlocal\
    \ i3 = interval1[2]\n\tlocal i4 = interval2[2]", "    local start1 = interval1[1]\n\
    \    local end1 = interval1[2]\n    local start2 = interval2[1]\n    local end2\
    \ = interval2[2]", "    local start = interval1[1]\n    local end = interval2[2]\n\
    \    if start <= end then\n        return start, end\n    else\n        return\
    \ end, start\n    end\nend", "    return math.abs(interval1[1]-interval2[1]) >=\
    \ math.abs(interval1[0]-interval2[0])\nend", "   local interval = {}\n   -- interval[1]\
    \ = interval1[1]\n   -- interval[2] = interval1[2]\n   -- interval[1] = interval2[1]\n\
    \   -- interval[2] = interval2[2]\n   -- interval[1] > interval[2]\n   -- interval[2]\
    \ + interval[1] >= interval1[2]\n   if interval1[1] < interval2[1] then\n    \
    \  interval[1] = interval1[1]\n   else\n      interval[1] = interval2[1]\n   end\n\
    \   if interval1[2] < interval2[2] then\n      interval[2] = interval1[2]\n  \
    \ else\n      interval[2] = interval2[2]\n   end\n   if interval[2] <= interval[1]\
    \ then\n      return \"NO\"\n   end\n   local isPrime = true\n   if interval[1]\
    \ % interval[2] == 0 then\n      for i = 2, interval[1] / interval[2] do\n   \
    \      if interval[i] ~= 1 and interval[i] ~= interval[2] then\n            isPrime\
    \ = false\n            break\n         end\n      end\n   end\n   return isPrime\
    \ and \"YES\" or \"NO\"\nend", "  -- Your code here\n  local a1, b1 = interval1\n\
    \  local a2, b2 = interval2\n  local start = a1 \n  local end = b1\n  local x\
    \ = 1\n  local flag = false\n  local interval = [a1, b1]\n  local new_interval\
    \ = [a1, b1]\n  local length = 1 \n  local end2 = 1\n  while end2 < a2 do\n  \
    \  if start < end2 then\n      if a1 == end and b2 == end2 then\n        length\
    \ = length+1\n      else\n        if a2 == end2 and b1 == end2 then\n        \
    \  length = length+1\n        end\n      end\n    end\n    end2 = end2 + 1\n \
    \ end\n  if length == 1 then \n    return \"NO\"\n  else \n    return \"YES\"\n\
    \  end\nend", "   local start1, end1 = interval1[1], interval1[2]\n   local start2,\
    \ end2 = interval2[1], interval2[2]\n   local length = end1 - start1\n   if length\
    \ <= 0 then return \"NO\" end\n   if start2 < start1 or end2 < end1 then\n   \
    \   -- The two intervals don't intersect.\n      return \"NO\"\n   end", "\tif\
    \ interval2[1] <= interval1[0] then\n\t\treturn \"NO\"\n\tend", "  local start\
    \ = math.min(interval1[1], interval2[1])\n  local end = math.max(interval1[2],\
    \ interval2[2])", "    return interval1[1]:end() >= interval2[1]:start()\n   \
    \     and interval2[1]:end() >= interval1[1]:start()\nend", "\treturn interval1[1]\
    \ <= interval2[1] and interval1[2] <= interval2[2] and \n\t\tinterval1[1] < interval2[2]\
    \ and interval1[1] == interval2[1]\nend\nreturn function(intervals)\n\tlocal result\
    \ = {}\n\tfor index, interval in pairs(intervals) do\n\t\tresult[#result + 1]\
    \ = {\n\t\t\tstart  = interval[1],\n\t\t\tend    = interval[2],\n\t\t\tlength\
    \ = math.abs(interval[1] - interval[2]),\n\t\t\tprime = math.sqrt(math.pow(interval[1]\
    \ - interval[2], 2) / \n\t\t\t\tmath.pow(interval[1] - interval[1], 2)\n\t\t\t\
    )\n\t\t}\n\tend", "   -- use your implementation here\nend", "  local length =\
    \ interval1[1] - interval1[0]\n  if interval2[1] - interval2[0] == 0 then\n  \
    \  return true\n  end\n  if interval1[1] + interval1[0] != interval2[1] then\n\
    \    return false\n  end\n  return true\nend", "\tlocal start = interval1[1]\n\
    \tlocal end = interval1[2]\n\tlocal start2 = interval2[1]\n\tlocal end2 = interval2[2]\n\
    \tlocal length = math.abs(end - start)\n\tlocal length2 = math.abs(end2 - start2)",
  "    local start = math.min(interval1[1], interval2[1])\n    local end = math.max(interval1[2],\
    \ interval2[2])\n    if start > end then\n        return nil\n    end\n    local\
    \ result = {\n        start = start,\n        end = end,\n    }\n    local size\
    \ = end - start + 1 -- number of elements in result\n    local prime = math.sqrt(size)\
    \ -- length of the intersection part\n    local num = 0\n    for i = 1, prime\
    \ do\n        num = num + math.floor((num + start) / 2)\n    end\n    if num %\
    \ 2 == 0 and num > 2 then\n        return nil\n    end\n    if num <= 1 or num\
    \ == prime then\n        return 'NO'\n    end\n    return 'YES'\nend", "\tlocal\
    \ start = interval1[1]\n\tlocal end = interval1[2]\n\tlocal inter = interval2[1]\n\
    \tif start > end then return \"NO\" end\n\tif inter > end then return \"NO\" end\n\
    \tif start < inter then return \"NO\" end\n\tif inter <= start then return \"\
    NO\" end\n\treturn \"YES\"\nend", "    local start = math.min(interval1[1], interval2[1])\n\
    \    local end = math.max(interval1[2], interval2[2])\n    if (start > end) then\n\
    \        -- return false if interval1[1] is greater than interval1[2]\n      \
    \  return false\n    elseif (start < end) then\n        -- return false if interval2[1]\
    \ is greater than interval2[2]\n        return false\n    else\n        -- return\
    \ true if the intervals are the same (which means (1, 5) is (1, 5).\n        return\
    \ true\n    end\nend", "\tif interval1 == nil or interval2 == nil then\n\t\terror(\"\
    The given intervals are nil.\")\n\tend", "\treturn interval1[1] < interval2[1]\
    \ and interval1[1] or interval2[1]\nend", "    local start = interval1[1]\n  \
    \  local end = interval1[2]\n    local interval2Start = interval2[1]\n    local\
    \ interval2End = interval2[2]\n    local intersecInterval, intersecIntervalLength\
    \ = nil, nil", "\tlocal lower = math.max(interval1[1], interval2[1])\n\tlocal\
    \ upper = math.min(interval1[2], interval2[2])\n\tlocal intersection = {}\n\t\
    local length = math.max(lower, upper) - math.min(lower, upper) + 1\n\tfor i =\
    \ 1, length do\n\t\tlocal lower = math.min(lower, interval1[1]+i)\n\t\tlocal upper\
    \ = math.min(upper, interval1[2]+i)\n\t\tif lower < upper then\n\t\t\ttable.insert(intersection,\
    \ lower, upper)\n\t\tend\n\tend\n\treturn intersection\nend", "  local start =\
    \ interval1[1]\n  local end = interval1[2]\n  local start_2 = interval2[1]\n \
    \ local end_2 = interval2[2]\n  if start < end and start_2 < end_2 then\n    local\
    \ len = end - start\n    local len_2 = end_2 - start_2\n    if len == len_2 then\n\
    \      -- [start; end] intersect [start_2; end_2]\n      return (end - start)\
    \ * start_2 + start_2 \n            + (len - len_2) * end\n    else\n      return\
    \ -1\n    end\n  else\n    return -1\n  end\nend", "\tlocal intervals = {}\n\t\
    local i1\n\tlocal i2\n\tlocal i\n\tlocal i1Max\n\tlocal i2Max\n\tlocal i1Min\n\
    \tlocal i2Min\n\tlocal i1Start\n\tlocal i2Start\n\tlocal i1End\n\tlocal i2End\n\
    \tlocal i1Len\n\tlocal i2Len\n\tlocal i1Prime\n\tlocal i2Prime\n\t\n\t-- Add interval\
    \ whose start is less than or equal interval2's end\n\tif interval1[1] <= interval2[2]\
    \ and interval1[2] <= interval2[1] then\n\t\tintervals[#intervals+1] = interval1\n\
    \telseif interval1[1] <= interval2[1] and interval1[2] > interval2[2] then\n\t\
    \tintervals[#intervals+1] = interval1\n\tend\n\t\n\t-- Add interval whose start\
    \ is greater than or equal interval2's end\n\tif interval1[2] >= interval2[1]\
    \ and interval1[1] >= interval2[2] then\n\t\tintervals[#intervals+1] = interval1\n\
    \telseif interval1[2] > interval2[1] and interval1[1] >= interval2[2] then\n\t\
    \tintervals[#intervals+1] = interval1\n\tend\n\t\n\tfor i = #intervals+1, 1 do\n\
    \t\ti1Max = intervals[i - 1][1]\n\t\ti2Max = intervals[i - 1][2]\n\t\ti1Min =\
    \ intervals[i - 1][3]\n\t\ti2Min = intervals[i - 1][4]\n\t\t\n\t\ti1Start = intervals[i\
    \ - 1][1]\n\t\ti2Start = intervals[i - 1][2]\n\t\ti1End = intervals[i - 1][3]\n\
    \t\ti2End = intervals[i - 1][4]\n\t\ti1Len = i1End - i1Start\n\t\ti2Len = i2End\
    \ - i2Start\n\t\t\n\t\t-- If interval2's end is equal to interval1's end,\n\t\t\
    -- then both intervals are the same.\n\t\tif i1End == i2End then\n\t\t\tintervals[i\
    \ - 1] = {\n\t\t\t\t[i1Start],\n\t\t\t\t[i1End],\n\t\t\t\t[i2Start],\n\t\t\t\t\
    [i2End]\n\t\t\t}\n\t\t\t\n\t\t\t-- If the length of the intersection of two intervals\
    \ is a prime number,\n\t\t\t-- return \"YES\" else \"NO\"\n\t\t\tif i1Len % 2\
    \ == 0 and i2Len % 2 == 0 then\n\t\t\t\ti1Prime = i1Len / 2\n\t\t\t\ti2Prime =\
    \ i2Len / 2\n\t\t\t\tif i1Prime == i2Prime then\n\t\t\t\t\treturn \"YES\"\n\t\t\
    \t\telse\n\t\t\t\t\treturn \"NO\"\n\t\t\t\tend\n\t\t\tend\n", "  local start =\
    \ math.min(interval1[1], interval2[1])\n  local end = math.max(interval1[2], interval2[2])\n\
    \  if start > end then return nil end\n  return start, end\nend", "\tif interval1[1]\
    \ == interval2[2] then\n\t\treturn interval1\n\tend\n\treturn interval1[1], interval2[2]\n\
    end", "\tlocal interval1_start = interval1[1]\n\tlocal interval1_end = interval1[2]\n\
    \tlocal interval2_start = interval2[1]\n\tlocal interval2_end = interval2[2]",
  "  -- Write your code here\nend", "\tlocal start = math.min(interval1[1], interval2[1])\n\
    \tlocal end = math.max(interval1[2], interval2[2])\n\tif (end - start) < 2 then\n\
    \t\treturn \"NO\"\n\tend\n\tlocal length = end - start + 1\n\tlocal prime = true\n\
    \tfor i = 2 to length and prime do\n\t\tif (length % i) == 0 then\n\t\t\tprime\
    \ = false\n\t\tend\n\tend\n\tif (prime == true) then\n\t\treturn \"YES\"\n\tend\n\
    \treturn \"NO\"\nend", "\treturn math.max(interval1[1], interval2[1]), math.min(interval1[2],\
    \ interval2[2])\nend", "  -- write your code here\nend", "\t-- write your code\
    \ here\n\tlocal interval1start, interval1end = interval1[1], interval1[2]\n\t\
    local interval2start, interval2end = interval2[1], interval2[2]", "   local start\
    \ = interval1[1]\n   local end = interval1[2]\n   local interval2start = interval2[1]\n\
    \   local interval2end = interval2[2]\n   if start < end and interval2start <\
    \ interval2end then\n      return (end - start) * (interval2end - interval2start)\
    \ < (interval1end - interval1start)\n   else\n      return false\n   end\nend",
  "\tif interval1 ~= nil and interval2 ~= nil then\n\t\tlocal start = interval1[1]\n\
    \t\tlocal end = interval2[1]\n\t\tlocal length = math.abs(end - start)\n\t\tlocal\
    \ length = math.floor(length)\n\t\tif length <= 0 then\n\t\t\treturn \"NO\"\n\t\
    \telseif length == 1 then\n\t\t\treturn \"YES\"\n\t\telse\n\t\t\tif end <= start\
    \ then\n\t\t\t\treturn \"NO\"\n\t\t\tend\n\t\t\tlocal intervals = interval1[2]\n\
    \t\t\tlocal interval = interval2[2]\n\t\t\tlocal i = 1\n\t\t\twhile i < #intervals\
    \ do\n\t\t\t\tif intervals[i] == interval then\n\t\t\t\t\tinterval = intervals[i]\n\
    \t\t\t\telse\n\t\t\t\t\tinterval = nil\n\t\t\t\tend\n\t\t\t\ti = i + 1\n\t\t\t\
    end\n\t\t\tif interval == nil then\n\t\t\t\treturn \"YES\"\n\t\t\tend\n\t\tend\n\
    \tend\nend", "\tinterval1, interval2 = interval1 -- unpack intervals\n\tlocal\
    \ l1, r1 = interval1[1], interval1[2]\n\tlocal l2, r2 = interval2[1], interval2[2]\n\
    \tif l2 < l1 then -- l2 < l1, then l2 < r1\n\t\tl2, r2 = r1, l2\n\tend\n\tif r1\
    \ > r2 then -- r1 > r2, then r1 > l1\n\t\tl1, r1 = r1, l1\n\tend\n\treturn l2,\
    \ r2 -- return intersection\nend", "  local start1 = interval1[1]\n  local end1\
    \ = interval1[2]\n  local start2 = interval2[1]\n  local end2 = interval2[2]\n\
    \  local i1 = start1\n  local i2 = start2\n  while i1 <= end1 and i2 <= end2 do\n\
    \    if i1 == i2 then\n      return true\n    end\n    i1, i2 = i1 + 1, i2 + 1\n\
    \  end\n  return false\nend", "    local len1 = interval1[1] - interval1[0] +\
    \ 1\n    local len2 = interval2[1] - interval2[0] + 1\n    if len2 == 0 then\n\
    \        return nil, \"NO\"\n    end\n    if len1 == 0 then\n        return nil,\
    \ \"NO\"\n    end\n    local result = 0\n    if interval1[1] > interval1[2] or\
    \ interval2[1] > interval2[2] then\n        result = 1\n    else\n        result\
    \ = interval1[1]:min(interval2[1]):max(interval1[2]):min(interval2[2]):max(interval1[1]):max(interval2[1])\n\
    \    end\n    if result == 0 then\n        return nil, \"NO\"\n    end\n    if\
    \ result == len1 then\n        return \"YES\"\n    end\n    if result == len2\
    \ then\n        return \"YES\"\n    end\n    if result % len1 == 0 or result %\
    \ len2 == 0 then\n        return \"NO\"\n    end\n    return intersection(interval1[2],\
    \ interval2[2]):intersection(interval1[3], interval2[3])\nend", "  local start,\
    \ end\n  local start = interval1[1]\n  local end = interval2[1]\n  local length\
    \ = end-start\n  if length == 0 then\n    return false\n  end\n  local isPrime\
    \ = true\n  for _, v in ipairs(primes) do\n    if v == length and start < v then\n\
    \      isPrime = false\n      break\n    end\n  end\n  if isPrime then\n    return\
    \ \"YES\"\n  else\n    return \"NO\"\n  end\nend", "    local ret = {}\n    for\
    \ i = 1, #interval1 do\n        local tmp1 = interval1[i]\n        local tmp2\
    \ = interval2[i]\n        if tmp1 > tmp2 then\n            table.insert(ret, tmp2)\n\
    \        else\n            table.insert(ret, tmp1)\n        end\n    end\n   \
    \ return ret\nend", "    local interval1Start1 = interval1[1]\n    local interval1End1\
    \ = interval1[2]\n    local interval1Start2 = interval2[1]\n    local interval1End2\
    \ = interval2[2]\n    local lengthOfInterval1 = interval1End1 - interval1Start1\n\
    \    local lengthOfInterval2 = interval2End2 - interval2Start2\n    local newInterval\
    \ = interval1Start1 <= interval2Start2 and interval2Start1 <= interval1End2 or\
    \ interval1Start2 <= interval2Start1 and interval2Start2 <= interval1End1\n  \
    \  local isIntersect = lengthOfInterval1 ~= 0 and lengthOfInterval2 ~= 0\n   \
    \ if newInterval then\n        if isIntersect then\n            local lengthOfIntersection\
    \ = interval1End1 - interval2Start2\n            local isPrime = checkPrimeNumber(lengthOfIntersection)\n\
    \            return isPrime\n        end\n    else\n        return false\n   \
    \ end\nend", "  -- Your code here\n  local interval1_length = interval1[1] - interval1[1]\n\
    \  local interval2_length = interval2[1] - interval2[1]\n  if interval1_length\
    \ <= interval2_length then\n    return interval1[1]\n  else\n    return interval2[1]\n\
    \  end\nend", "  local s1, e1 = interval1[1], interval1[2]\n  local s2, e2 = interval2[1],\
    \ interval2[2]\n  if s1 <= s2 and s1 <= e2 and s2 <= e2 then -- [s1, e1) intersects\
    \ (s2, e2)\n    if e1 == s2 then\n      return s1 \n    elseif e2 == s1 then\n\
    \      return s2\n    else\n      local i1, i2 = e1, s2\n      while i1 <= i2\
    \ do\n        local s, e = i1 + 1, i2 \n        while s < e do\n          -- [s,\
    \ e) intersect (i1, i2)\n          i1, i2 = i2, i1 + 1\n        end\n      end\n\
    \      return i1\n    end\n  else -- (s1, e1) doesn't intersect (s2, e2)\n   \
    \ return \"NO\"\n  end\nend", "\tlocal a1, a2, b1, b2 = interval1[1], interval1[2],\
    \ interval2[1], interval2[2]\n\treturn a1 <= a2 and b1 <= b2\nend", "\tlocal result\
    \ = { } -- result will be a pair of two integers\n\t-- check whether start is\
    \ lesser than end or not\n\tif (interval1[1] < interval2[1]) then\n\t\t-- start\
    \ is lesser than end\n\t\t-- set the result with end value\n\t\tresult[1] = interval2[1]\n\
    \telse\n\t\t-- end is lesser than start\n\t\t-- set the result with start value\n\
    \t\tresult[1] = interval1[1]\n\tend\n\t-- check whether end is lesser than end\
    \ or not\n\tif (interval1[2] < interval2[2]) then\n\t\t-- end is lesser than start\n\
    \t\t-- set the result with end value\n\t\tresult[2] = interval1[2]\n\telse\n\t\
    \t-- end is lesser than start\n\t\t-- set the result with start value\n\t\tresult[2]\
    \ = interval2[2]\n\tend\n\t-- check if intersection exists or not\n\tif (result[1]\
    \ > result[2]) then\n\t\t-- intersection exists\n\telse\n\t\t-- intersection does\
    \ not exist\n\tend\n\treturn result\nend", "    if interval1[1] < interval2[1]\
    \ then\n        return interval1\n    elseif interval2[1] < interval1[1] then\n\
    \        return interval2\n    elseif interval1[1] < interval2[1] then\n     \
    \   return interval2\n    else\n        return interval1\n    end\nend", "  local\
    \ l1 = interval1[1]:bound(2)\n  local l2 = interval2[1]:bound(2)\n  \n  -- Check\
    \ if there are any intersection\n  if l1 < l2 then\n    return interval1[1]:bound(2)\n\
    \  else\n    return interval2[1]:bound(2)\n  end\nend", "\tif interval1[1] < interval2[1]\
    \ then\n\t\treturn interval1\n\telse\n\t\treturn interval2\n\tend\nend", "   \
    \ local start = interval1[1]\n    local end = interval2[1]\n    if start > end\
    \ then return \"NO\" end\n    local result = 0\n    for i = start, end do\n  \
    \      result = result + 1 -- count up\n    end\n    if result == 0 then return\
    \ \"NO\" end\n    if result % 2 == 0 then\n        return \"NO\"\n    end\n  \
    \  local isPrime = true\n    for i = 2 to result do\n        if i % 2 == 0 then\n\
    \            isPrime = false\n            break\n        end\n    end\n    return\
    \ isPrime and \"YES\" or \"NO\"\nend", "  -- Your code here\nend\nreturn intersection\n\
    end\n</cell>\n<cell>", "\tlocal start = interval1[1]\n\tlocal end = interval1[2]\n\
    \tlocal interval = interval2[1]\n\tlocal interval2 = interval2[2]", "\tlocal interval1_start,\
    \ interval1_end = interval1[1], interval1[2]\n\tlocal interval2_start, interval2_end\
    \ = interval2[1], interval2[2]\n\tlocal intersection_start, intersection_end\n\
    \tlocal intersection_length = math.min(interval1_end, interval2_end) - math.max(interval1_start,\
    \ interval2_start)\n\t\n\tif interval1_end <= interval2_start and interval1_start\
    \ >= interval2_end then\n\t\treturn \"NO\"\n\telseif interval1_end <= interval2_end\
    \ and interval1_start >= interval2_end then\n\t\treturn \"NO\"\n\telseif interval1_end\
    \ <= interval2_end and interval1_start <= interval2_end then\n\t\tintersection_start\
    \ = math.min(interval1_start, interval2_start)\n\t\tintersection_end = math.max(interval1_end,\
    \ interval2_end)\n\telse\n\t\tintersection_start = math.max(interval1_start, interval2_start)\n\
    \t\tintersection_end = math.min(interval1_end, interval2_end)\n\tend\n\t\n\tif\
    \ intersection_length % 2 == 0 then\n\t\treturn \"NO\"\n\telse\n\t\treturn \"\
    YES\"\n\tend\nend", "\tlocal start1 = interval1[1]\n\tlocal end1 = interval1[2]\n\
    \tlocal start2 = interval2[1]\n\tlocal end2 = interval2[2]", "\tlocal start1,\
    \ end1 = interval1[1], interval1[2]\n\tlocal start2, end2 = interval2[1], interval2[2]",
  "\treturn (interval1[1] < interval2[1] and interval1[2] <= interval2[2]) or (interval1[1]\
    \ >= interval2[1] and interval1[2] < interval2[2])\nend", "\treturn ((interval1[1]\
    \ >= interval2[1]) and (interval1[1] <= interval2[2]))\nend", "\treturn math.max(interval1[1],\
    \ interval2[1]) \n\t\tand math.min(interval1[2], interval2[2])\nend", "\tlocal\
    \ results = {}\n\tlocal result = false\n\tif interval1[1] > interval2[1] then\n\
    \t\ttable.insert(results, interval2[1])\n\t\ttable.insert(results, interval1[1])\n\
    \t\ttable.insert(results, interval2[1])\n\t\tresult = true\n\telse\n\t\ttable.insert(results,\
    \ interval1[1])\n\t\ttable.insert(results, interval1[1])\n\t\ttable.insert(results,\
    \ interval2[1])\n\t\tresult = true\n\tend\n\t\n\tif interval1[2] < interval2[2]\
    \ then\n\t\ttable.insert(results, interval2[2])\n\t\ttable.insert(results, interval1[2])\n\
    \t\ttable.insert(results, interval2[2])\n\t\tresult = true\n\telse\n\t\ttable.insert(results,\
    \ interval1[2])\n\t\ttable.insert(results, interval1[2])\n\t\ttable.insert(results,\
    \ interval2[2])\n\t\tresult = true\n\tend\n\treturn results\nend", "\treturn interval1[1]:intersects(interval2[1])\
    \ or interval2[1]:intersects(interval1[1]) or interval1[1]:contains(interval2[1])\n\
    end", "  return interval1[1] > interval2[1] and interval1[1] < interval2[2]\n\
    \  or  interval1[2] > interval2[1] and interval1[2] < interval2[2]\nend", "\t\
    local left, right = interval1[1], interval1[2]\n\tif interval1[2] <= interval2[1]\
    \ and interval1[2] >= interval2[2] then\n\t\tleft, right = interval2[1], interval2[2]\n\
    \tend\n\treturn (left <= right) and (left >= interval1[1] and left <= interval2[1]\
    \ and left >= interval2[2])\nend", "\t-- Write your code here\n\tlocal interval1Length\
    \ = interval1[1] - interval1[0]\n\tlocal interval2Length = interval2[1] - interval2[0]\n\
    \tif interval1Length == 0 or interval2Length == 0 then\n\t\treturn nil, \"Intervals\
    \ must intersect!\"\n\tend\n\tif interval1Length == interval2Length then\n\t\t\
    if interval1[1] <= interval2[2] and interval1[2] >= interval2[1] then\n\t\t\t\
    return interval1[1], interval2[1]\n\t\telseif interval1[2] <= interval2[1] and\
    \ interval1[1] >= interval2[2] then\n\t\t\treturn interval1[2], interval2[2]\n\
    \t\telse\n\t\t\treturn nil, \"Intervals don't intersect!\"\n\t\tend\n\telse\n\t\
    \treturn nil, \"Intervals don't intersect!\"\n\tend\nend", "    local interval1start\
    \ = interval1[1]\n    local interval1end = interval1[2]\n    local interval2start\
    \ = interval2[1]\n    local interval2end = interval2[2]\n    local interval1length\
    \ = interval1end - interval1start\n    local interval2length = interval2end -\
    \ interval2start\n    local interval1start1 = interval1start + interval1length\n\
    \    local interval1end1 = interval1start - interval1length\n    local interval2start2\
    \ = interval2start + interval2length\n    local interval2end2 = interval2start\
    \ - interval2length\n    local length1 = interval1end - interval1start\n    local\
    \ length2 = interval2end - interval2start\n    local length1interval1 = interval1length\
    \ + interval1start1\n    local length2interval2 = interval2length + interval2start2\n\
    \    local result\n    if length1interval1 > length1interval2 then\n        result\
    \ = interval1start - interval1length\n    else\n        result = interval2start\
    \ + length2interval2\n    end\n    if result == interval1start1 then\n       \
    \ return \"YES\"\n    else\n        return \"NO\"\n    end\nend", "  local start1,\
    \ end1 = interval1[1], interval1[2]\n  local start2, end2 = interval2[1], interval2[2]\n\
    \  local start1start, start1end = start1 < start2 ? start1, start2 : start2, start1\n\
    \  local start2start, start2end = start1 < start2 ? start2, start1 : start1, start2\n\
    \  local end1start, end1end = end1 < end2 ? end1, end2 : end2, end1\n  local end2start,\
    \ end2end = end1 < end2 ? end2, end1 : end2, end2\n  local length = end1end -\
    \ start1end\n  local is_intersection = start1start <= end1end and start2start\
    \ <= end2end\n  if is_intersection and is_prime == true then return \"YES\" end\n\
    \  if end1start <= start1end or end2start <= start2end then return \"NO\" end\n\
    \  return \"NO\"\nend", "\treturn math.min(interval1[1], interval2[1]) - math.max(interval1[1],\
    \ interval2[1])\nend", "  -- Your code goes here\n  local interval1_x = interval1[1]\n\
    \  local interval1_y = interval1[2]\n  local interval2_x = interval2[1]\n  local\
    \ interval2_y = interval2[2]\n  local result_x = interval1_x + interval2_x\n \
    \ local result_y = interval1_y + interval2_y\n  local is_prime = result_x % 2\
    \ == 0 and result_y % 2 == 0 and result_x % result_y == 0\n  return is_prime\n\
    end", "\tlocal low1, high1 = interval1\n\tlocal low2, high2 = interval2\n\t\n\t\
    if low1 > high2 then return nil end\n\tif low2 > high1 then return nil end\n\t\
    \n\tlocal intersection = {}\n\tlocal new_high = math.max(high1, high2)\n\t\n\t\
    for i = low2, new_high, 1 do\n\t\tlocal prime = true\n\t\t\n\t\tfor j = low1,\
    \ new_high, 1 do\n\t\t\tif j > new_high then break end\n\t\t\tif j % i == 0 then\
    \ prime = false; break end\n\t\tend\n\t\t\n\t\tif prime then table.insert(intersection,\
    \ i) end\n\tend\n\t\n\tif #intersection == 0 then return nil end\n\t\n\tif new_high\
    \ > high1 then \n\t\tfor i = #intersection, high2, 1 do\n\t\t\ttable.insert(intersection,\
    \ new_high)\n\t\tend\n\telseif new_high > high2 then \n\t\tfor i = #intersection,\
    \ high1, 1 do\n\t\t\ttable.insert(intersection, new_high)\n\t\tend\n\tend\n\t\n\
    \treturn #intersection == #interval1 and #intersection == #interval2 and #intersection\
    \ == 2 and \n\t\t(#interval1 < #interval2) or (#interval1 > #interval2) and #intersection\
    \ > 1\nend", "  -- Your code here\n  return \nend", "    local start = interval1[1]\n\
    \    local end = interval1[2]\n    local interval1 = interval1[1]\n    local interval2\
    \ = interval2[1]", "\tlocal count = 0\n\tlocal start1 = interval1[1]\n\tlocal\
    \ end1 = interval1[2]\n\tlocal start2 = interval2[1]\n\tlocal end2 = interval2[2]\n\
    \tfor i = start1, end1 do\n\t\tif i <= end2 then\n\t\t\tcount = count + 1\n\t\t\
    end\n\tend\n\tif count = 0 then\n\t\treturn nil\n\telse\n\t\treturn interval1[1],\
    \ interval1[2], interval2[1], interval2[2]\n\tend\nend", "   local result = {}\n\
    \   for i=1,#interval1 do\n      table.insert(result, interval1[i])\n   end\n\
    \   for i=1,#interval2 do\n      table.insert(result, interval2[i])\n   end\n\
    \   local inter = #result -- the length of intersection\n   if inter > 1 then\n\
    \      local count = 0\n      for i=1,#result do\n         if result[i]>result[i+1]\
    \ then\n            count = count + 1\n         end\n      end\n      inter =\
    \ #result-count\n   end\n   if inter % 2 ~= 0 then\n      return \"NO\"\n   else\n\
    \      return \"YES\"\n   end\nend", "    local interval1Start = interval1[1]\n\
    \    local interval1End = interval1[2]\n    local interval2Start = interval2[1]\n\
    \    local interval2End = interval2[2]", "\tlocal start = interval1[1]\n\tlocal\
    \ end = interval1[2]\n\tlocal length1 = interval1[2]-interval1[1]+1\n\tlocal length2\
    \ = interval2[2]-interval2[1]+1\n\tlocal length = length1*length2\n\tlocal result\
    \ = \"\"\n\tlocal i = 1\n\twhile i < length do\n\t\tif i == 1 then\n\t\t\tresult\
    \ = result .. \"(\"\n\t\telseif i == length1 then\n\t\t\tresult = result .. \"\
    )\"\n\t\telseif i == length2 then\n\t\t\tresult = result .. \"(\"\n\t\telseif\
    \ i%2 = 0 then\n\t\t\tresult = result .. \"(\"\n\t\telse\n\t\t\tresult = result\
    \ .. \",(\"\n\t\tend\n\t\tresult = result .. i\n\t\tresult = result .. \",\"\n\
    \t\tresult = result .. i\n\t\tresult = result .. \")\"\n\t\ti = i+2\n\tend\n\t\
    return result\nend", "   if interval1[1] <= interval2[1] then\n      if interval1[2]\
    \ <= interval2[2] then\n\t return interval1\n      else\n\t return interval2\n\
    \      end\n   else\n      if interval1[2] >= interval2[2] then\n\t return interval1\n\
    \      else\n\t return interval2\n      end\n   end\nend", "\t-- Write your code\
    \ here\n\tlocal count = 0\n\tlocal len = 0\n\tfor i=1,#interval1 do\n\t\tif interval1[i]<interval2[i]\
    \ then\n\t\t\tcount = count + 1\n\t\telse\n\t\t\tlen = len + 1\n\t\tend\n\tend\n\
    \tif count == 0 then\n\t\treturn \"NO\"\n\telseif len == 1 then\n\t\treturn \"\
    YES\"\n\telse\n\t\treturn \"NO\"\n\tend\nend", "    return function(start, end)\n\
    \        start = math.min(start, end)\n        end = math.max(start, end)\n  \
    \      return start <= end and start < interval1[2] and interval1[2] < end \n\
    \    end\nend", "    local start1 = interval1[1]\n    local start2 = interval2[1]\n\
    \    local end1 = interval1[2]\n    local end2 = interval2[2]", "\tlocal start\
    \ = interval1[1]\n\tlocal end = interval1[2]\n\tlocal start2 = interval2[1]\n\t\
    local end2 = interval2[2]\n\tlocal isIntersect = false\n\tif start <= end2 then\n\
    \t\tisIntersect = true\n\telse\n\t\tisIntersect = false\n\tend\n\tif start2 <=\
    \ end then\n\t\tisIntersect = true\n\telse\n\t\tisIntersect = false\n\tend\n\t\
    return isIntersect\nend", "\treturn #(interval1[1] < interval1[2] and interval2[1]\
    \ < interval2[2]) ? #(interval1[2] < interval1[1] and interval2[2] < interval2[1])\
    \ : #(interval1[2] > interval1[1] and interval2[2] > interval2[1])\nend", "\t\
    local start1L, start1R = interval1[1]\n\tlocal end1L, end1R = interval1[2]", " \
    \   local len1 = interval1[1] - interval1[0]\n    local len2 = interval2[1] -\
    \ interval2[0]\n    if len1 < len2 then \n        interval1 = interval1\n    \
    \    interval2 = interval2\n    else\n        interval1 = interval2\n        interval2\
    \ = interval1\n    end\n    local len_inter = interval1[1] - interval1[0]\n  \
    \  local len_inter_new = interval2[1] - interval2[0]\n    if len_inter == len_inter_new\
    \ then\n        local i_start1 = interval1[0]\n        local i_start2 = interval2[0]\n\
    \        local i_end1 = interval1[1]\n        local i_end2 = interval2[1]\n  \
    \      if i_start1 <= i_end1 and i_start2 <= i_end2 then\n            return false\n\
    \        else\n            return true\n        end\n    end\nend", "  local results\
    \ = {}\n  local length = math.abs(interval2[1]-interval1[1])\n  if interval1[1]\
    \ < interval2[1] then\n    for i=1,length do\n      if interval1[1] == interval2[1]+i\
    \ then\n        results[#results+1] = interval1\n      else\n        results[#results+1]\
    \ = interval2\n      end\n    end\n  else\n    for i=1,length do\n      if interval1[1]\
    \ == interval2[1]-i-1 then\n        results[#results+1] = interval2\n      else\n\
    \        results[#results+1] = interval1\n      end\n    end\n  end\n  return\
    \ results\nend", "\tlocal i1, i2 = interval1[1], interval1[2]\n\tlocal i3, i4\
    \ = interval2[1], interval2[2]\n\tlocal result1, result2 = i2, i4\n\tif i1 > i3\
    \ then\n\t\tresult1, result2 = i1, i3\n\tend\n\t\n\tif result1 == result2 then\n\
    \t\treturn \"NO\"\n\tend\n\tif result1 < result2 then\n\t\tresult2, result1 =\
    \ result1, result2\n\tend\n\t\n\tlocal result\n\tif i1 ~= result1 then\n\t\tif\
    \ i2 ~= result2 then\n\t\t\tif i3 == result1 then\n\t\t\t\tresult = i1\n\t\t\t\
    elseif i4 == result2 then\n\t\t\t\tresult = i2\n\t\t\telse\n\t\t\t\tlocal m =\
    \ math.max(result2, result1)\n\t\t\t\tlocal n = math.min(result2, result1)\n\t\
    \t\t\tif m == n then\n\t\t\t\t\tresult = math.min(result1, result2)\n\t\t\t\t\
    else\n\t\t\t\t\tlocal m1 = math.max(result1, result2)\n\t\t\t\t\tlocal n1 = math.min(result1,\
    \ result2)\n\t\t\t\t\tif m1 == n1 then\n\t\t\t\t\t\tresult = math.max(result1,\
    \ result2)\n\t\t\t\t\telse\n\t\t\t\t\t\tif m1 < n1 and i3 > i4 then\n\t\t\t\t\t\
    \t\tresult = m1\n\t\t\t\t\t\telseif n1 > i3 and i4 > i1 then\n\t\t\t\t\t\t\tresult\
    \ = n1\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\
    \t\n\treturn result\nend", "\tlocal results = {}\n\tlocal start, end = interval1[1],\
    \ interval2[1]\n\tif start > end then\n\t\treturn false\n\tend\n\tfor i = start,\
    \ end do\n\t\tif start <= i and end >= i then\n\t\t\ttable.insert(results, i)\n\
    \t\tend\n\tend\n\treturn results\nend", "\tlocal start = interval1[1]\n\tlocal\
    \ end = interval2[1]\n\tlocal length = 0\n\t-- Calculate the length of the intersection\n\
    \twhile start <= end do\n\t\tif start <= interval2[2] and end >= interval1[2]\
    \ then\n\t\t\tlength = length + 1\n\t\tend\n\t\tstart = start + 1\n\t\tend = end\
    \ + 1\n\tend\n\treturn length\nend", "  return interval1[1] < interval2[1] and\
    \ interval1[1] > interval2[2] and interval1[2] > interval2[1] and interval1[2]\
    \ > interval2[2]\nend", "  -- Write your code here.\n  return true\nend", "  local\
    \ inter = {}\n  local start = math.min(interval1[1], interval2[1])\n  local end\
    \ = math.max(interval1[2], interval2[2])\n  for i=start,end do table.insert(inter,\
    \ i) end\n  local i = start\n  while i<end do\n    if inter[#inter] == i then\n\
    \      i = i + 1\n      continue\n    end\n    break\n  end\n  if i == end then\n\
    \    return \"NO\"\n  end\n  local j = 1\n  while i ~= end do\n    if inter[#inter]\
    \ == j then\n      j = j + 1\n    else\n      break\n    end\n    i = i + 1\n\
    \  end\n  if j == 1 then\n    return \"YES\"\n  end\n  return \"NO\"\nend", " \
    \ local interval1Start, interval1End = interval1[1], interval1[2]\n  local interval2Start,\
    \ interval2End = interval2[1], interval2[2]\n  local interval1Start, interval1End\
    \ = interval1Start or 1, interval1End or 1\n  local interval2Start, interval2End\
    \ = interval2Start or 1, interval2End or 1\n  local intervalsStart, intervalsEnd\
    \ = interval1Start + interval2Start, interval1End + interval2End\n  local primeNumbers\
    \ = { 2, 3 }\n  local intersect\n  for i = 2, intervalsEnd do\n    local interval1Step\
    \ = interval1Start + interval1End - i\n    local interval2Step = interval2Start\
    \ + interval2End - i\n    if interval1Step > 0 and interval2Step > 0 then\n  \
    \    -- if interval1 has two or more intervals with\n      -- same length, it\
    \ must be the shortest one\n      if interval1Step < interval2Step then\n    \
    \    -- find the shortest interval\n        intersect = interval1Start, interval1End\n\
    \        interval1Start = i - interval1Step\n        interval1End = i\n      else\n\
    \        -- find the shortest interval\n        intersect = interval2Start, interval2End\n\
    \        interval2Start = i - interval2Step\n        interval2End = i\n      end\n\
    \    elseif interval1Step > 0 and interval2Step < 0 then\n      -- if interval1\
    \ has two or more intervals with\n      -- same length, it must be the shortest\
    \ one\n      if interval1Step < interval2Step then\n        -- find the shortest\
    \ interval\n        intersect = interval1Start, interval1End\n        interval1Start\
    \ = i - interval1Step\n        interval1End = i\n      else\n        -- find the\
    \ shortest interval\n        intersect = interval2Start, interval2End\n      \
    \  interval2Start = i - interval2Step\n        interval2End = i\n      end\n \
    \   elseif interval1Step < 0 and interval2Step > 0 then\n      -- if interval1\
    \ has two or more intervals with\n      -- same length, it must be the shortest\
    \ one\n      if interval1Step < interval2Step then\n        -- find the shortest\
    \ interval\n        intersect = interval1Start, interval1End\n        interval1End\
    \ = i - interval1Step\n        interval1Start = i\n      else\n        -- find\
    \ the shortest interval\n        intersect = interval2Start, interval2End\n  \
    \      interval2End = i - interval2Step\n        interval2Start = i\n      end\n\
    \    elseif interval1Step < 0 and interval2Step < 0 then\n      -- if ", "\tlocal\
    \ start1 = interval1[1]\n\tlocal end1 = interval1[2]\n\tlocal start2 = interval2[1]\n\
    \tlocal end2 = interval2[2]\n\tif start2 < start1 or end2 < end1 then return \"\
    NO\" end\n\treturn start2 <= end1 and end2 <= start1 and start1 < end2 and end1\
    \ < start2 ? \"YES\" : \"NO\"\nend", "\tlocal start = interval1[1]\n\tlocal end\
    \ = interval1[2]\n\tlocal start2 = interval2[1]\n\tlocal end2 = interval2[2]\n\
    \tif start > end then return 'NO' end\n\tif start > start2 then return 'NO' end\n\
    \tif end < end2 then return 'NO' end\n\treturn 'YES'\nend", "  -- Your code goes\
    \ here\nend", "\tlocal start1, end1, start2, end2 = interval1[1], interval1[2],\
    \ interval2[1], interval2[2]", "\tlocal ret = {}\n\tlocal start = interval1[1]\n\
    \tlocal end = interval1[2]\n\tlocal start = interval2[1]\n\tlocal end = interval2[2]\n\
    \tfor i = start, end do table.insert(ret, i) end\n\treturn ret\nend", "    return\
    \ ((interval1[1] > interval2[1] and interval1[2] < interval2[2]) or (interval1[1]\
    \ < interval2[1] and interval1[2] > interval2[2]))\nend", "   local interval1_start,\
    \ interval1_end = interval1[1], interval1[2]\n   local interval2_start, interval2_end\
    \ = interval2[1], interval2[2]", "\tlocal start1End = interval1[1]:find(interval2[1])\
    \ \n\tlocal end1Start = interval1[2]:find(interval2[2]) \n\tlocal end2End = interval2[2]:find(interval1[2])\
    \ \n\t\n\treturn (start1End and end1Start and end2End) ~= nil\nend", "  -- write\
    \ your code here\n  local i1 = interval1[1]\n  local i2 = interval2[1]\n  local\
    \ i3 = interval2[2]\n  if i1 <= i2 then\n    if i2 <= i3 then\n      return (i1\
    \ <= i3 and i2 <= i3)\n    end\n  else\n    return (i2 <= i3 and i3 <= i1)\n \
    \ end\nend", "\tlocal start1 = interval1[1]\n\tlocal end1 = interval1[2]\n\tlocal\
    \ start2 = interval2[1]\n\tlocal end2 = interval2[2]\n\tlocal intersectionStart,\
    \ intersectionEnd = 0, interval1[2]\n\tfor i = start1, end1 + 1 do\n\t\tif i ==\
    \ intersectionStart then\n\t\t\tintersectionStart = interval2[2]\n\t\tend\n\t\t\
    intersectionEnd = i\n\tend\n\tlocal intersect = interval1[2] - intersectionEnd\n\
    \tif intersect == 0 then\n\t\treturn 'YES'\n\telse\n\t\tif intersect == 1 then\n\
    \t\t\tif start1 == start2 then\n\t\t\t\treturn 'YES'\n\t\t\telse\n\t\t\t\treturn\
    \ 'NO'\n\t\t\tend\n\t\telse\n\t\t\tif start1 < start2 then\n\t\t\t\treturn 'NO'\n\
    \t\t\telse\n\t\t\t\treturn 'YES'\n\t\t\tend\n\t\tend\n\tend\nend", "\tlocal result\
    \ = {}\n\tfor i, x in pairs(interval1) do\n\t\tif x >= interval2[1] or x <= interval2[2]\
    \ then\n\t\t\ttable.insert(result, x)\n\t\tend\n\tend\n\ttable.sort(result)\n\t\
    return #result == 2 and result[1] or result\nend", "\tlocal intersect_start =\
    \ math.min(interval1[1], interval2[1])\n\tlocal intersect_end = math.max(interval1[2],\
    \ interval2[2])\n\treturn intersect_start, intersect_end\nend", "  -- Write your\
    \ code here\n  return ...\nend", "    local inter = {}\n    if interval1[1] <\
    \ interval2[1] then\n        table.insert(inter, interval1[1])\n        table.insert(inter,\
    \ interval2[1])\n    else\n        table.insert(inter, interval2[1])\n       \
    \ table.insert(inter, interval1[1])\n    end", "    local start, end = interval1[1],\
    \ interval1[2]\n    if start > end then return \"NO\" end\n    \n    local start_i,\
    \ end_i = interval2[1], interval2[2]\n    \n    -- if start <= end then \n   \
    \ if start_i <= end_i then \n        \n        local start, end = interval1[1],\
    \ interval1[2]\n        local start_i, end_i = interval2[1], interval2[2]\n  \
    \      \n        -- If start is less than or equal to end\n        if start <=\
    \ end then\n            if start_i <= end then \n                return \"YES\"\
    \ -- If the length of intersection between interval1 and interval2 is prime \n\
    \            else\n                return \"NO\" -- if the length of intersection\
    \ between interval1 and interval2 is not prime \n            end\n        else\n\
    \            return \"NO\"\n        end\n    end\nend", "\tlocal start = math.min(interval1[1],\
    \ interval2[1])\n\tlocal end = math.max(interval1[2], interval2[2])\n\treturn\
    \ start, end\nend", "    local l1 = interval1[1]\n    local l2 = interval2[1]\n\
    \    local r1 = interval1[2]\n    local r2 = interval2[2]\n    local length =\
    \ math.min(l1, r1, r2, l2)\n    if length == r1 then return \"NO\" end\n    if\
    \ l1 < r1 then r1 = r1 end\n    if l2 < r2 then r2 = r2 end\n    local results\
    \ = {}\n    for i = 1, length do\n        local m = (l1 + i) % length\n      \
    \  local n = (r1 + i) % length\n        local ok, j = 0, 0\n        while j <=\
    \ m do\n            if n >= l2 and n <= r2 then\n                results[#results+1]\
    \ = n\n                j = j + 1\n            end\n            local m = m + 1\n\
    \            local n = n + 1 \n        end\n    end\n    if #results == 1 then\n\
    \        return \"YES\"\n    else\n        return \"NO\"\n    end\nend", "\tlocal\
    \ start = interval1[1]\n\tlocal end = interval2[2]\n\tif start >= end then\n\t\
    \treturn \"NO\"\n\tend\n\tlocal length = 0\n\tfor i = start, end do\n\t\tlength\
    \ = length + 1\n\tend\n\tif length <= 1 then\n\t\treturn \"YES\"\n\tend\n\tlocal\
    \ prime\n\tfor i = 3, sqrt(length), 2 do\n\t\tif length % i == 0 then\n\t\t\t\
    prime = true\n\t\t\tbreak\n\t\tend\n\tend\n\tif prime == false then\n\t\treturn\
    \ \"NO\"\n\tend\n\treturn \"YES\"\nend", "\t-- Your code here\n\t-- The intervals\
    \ are always open, so the end must not equal the start.\n\t-- The return value\
    \ is a pair of two numbers. The first number is the length of the intersection,\n\
    \t-- and the second is the sum of their ends.\n\t-- If there is an intersection\
    \ then return that length and add their ends.\n\t-- If there is not, return 0\
    \ and 0.\n\t-- If none of the intervals is open, return 0 and 0.\n\t-- Otherwise,\
    \ if the intervals intersect then:\n\t\t-- If one end is less than the other,\
    \ the length will be the smaller number.\n\t\t-- If the two ends are the same,\
    \ the length will be the smaller of the smaller of the lengths of the two ends.\n\
    \t\t-- If the two ends are equal, the length will be the smaller of the length\
    \ of the two ends.\n\t\t-- If the two ends are different and both numbers are\
    \ the same, return \"YES\".\n\t\t-- If neither the two ends are different, return\
    \ \"NO\".", "  -- Your code here\n  local start, end = interval1[1], interval1[2]\n\
    \  if start > end then\n    local tmp = start\n    start = end\n    end = tmp\n\
    \  end\n  if start <= end then\n    local tmp = end\n    end = start\n    start\
    \ = tmp\n  end\n  local length = end-start\n  -- return (length == 1) or (length\
    \ == 2)\n  -- return (length == 1)\n  -- return (length == 2)\n  -- return (length\
    \ == 3)\n  -- return (length == 4)\n  -- return (length == 5)\n  -- return (length\
    \ == 6)\n  -- return (length == 7)\n  -- return (length == 8)\n  -- return (length\
    \ == 9)\n  -- return (length == 10)\n  return length == 2 or length == 3\nend",
  "    local intersect, start = 0, interval1[1]\n    for i = 2, interval2[1] do\n\
    \        if start > interval1[2] or start > interval2[2] then\n            return\
    \ false\n        end\n        if interval1[2] <= interval2[2] and interval1[2]\
    \ >= interval2[1] then\n            intersect = interval1[2]\n            start\
    \ = interval1[2]\n        end\n        if interval1[2] <= interval2[2] and interval2[2]\
    \ >= interval1[1] then\n            intersect = interval2[2]\n            start\
    \ = interval2[2]\n        end\n    end\n    if intersect == interval1[2] then\n\
    \        return true\n    elseif intersect == interval2[2] then\n        return\
    \ true\n    else\n        return false\n    end\nend", "  local start = interval1[1]\n\
    \  local end = interval2[2]\n  local length\n  if start <= end then\n    length\
    \ = (start < end) and (end - start)\n  else\n    length = -(start > end) and (end\
    \ - start)\n  end\n  if length then\n    if length == (start + end) then\n   \
    \   -- The intersection is equal to the whole interval\n      return \"YES\"\n\
    \    end\n    if length % 2 == 1 then\n      -- The intersection is at least 1\
    \ unit length\n      return \"NO\"\n    end\n  else\n    return \"NO\"\n  end\n\
    end", "  if interval1[1] < interval2[1] then\n    local temp = interval1[1]\n\
    \    interval1[1] = interval2[1]\n    interval2[1] = temp\n  end\n  if interval1[2]\
    \ > interval2[2] then\n    local temp = interval1[2]\n    interval1[2] = interval2[2]\n\
    \    interval2[2] = temp\n  end\n  local start1 = interval1[1]\n  local start2\
    \ = interval2[1]\n  local end1 = interval1[2]\n  local end2 = interval2[2]\n \
    \ local result = {}\n  local j = 1\n  for i = start1, end1 do\n    if j > start2\
    \ and start2 < end2 then\n      result = result + [j - 1]\n      j = j + 1\n \
    \   elseif start1 > end2 and start1 > start2 then\n      result = result + [j]\n\
    \      j = j + 1\n    end\n  end\n  local size = #result\n  if size == 1 and result[1]\
    \ == size then\n    return \"YES\"\n  else\n    return \"NO\"\n  end\nend", "\t\
    if interval1 == nil or interval2 == nil then\n\t\treturn nil\n\tend", "\tlocal\
    \ i1start, i1end = interval1[1]\n\tlocal i2start, i2end = interval2[1]\n\tlocal\
    \ i1len, i2len = interval1[2][1], interval2[2][1]\n\t\n\tif i1start <= i2start\
    \ and i1end >= i2end then\n\t\treturn true\n\tend\n\tif i1start > i2start and\
    \ i1end < i2end then\n\t\treturn true\n\tend\n\t\n\t-- If the intervals are disjoint,\
    \ they are disjoint \n\tif i1start <= i2end and i1end >= i2start then\n\t\treturn\
    \ true\n\tend\n\tif i1start > i2start and i1end < i2end then\n\t\treturn true\n\
    \tend\n\t\n\t-- If the intervals are identical, then the length is \n\t-- equal\
    \ to the smallest one\n\tif i1start == i2start then\n\t\treturn i1len == i2len\n\
    \tend\n\t\n\t-- If the intervals are disjoint, return false\n\tif i1start == i2end\
    \ and i1end == i2start then\n\t\treturn false\n\tend\n\t\n\t-- If the intervals\
    \ are identical, \n\t-- then return the smallest one\n\tif i1start == i2start\
    \ and i1len == i2len then\n\t\treturn i1len\n\tend\n\t\n\t-- Get the smaller end\
    \ value\n\tif i1start > i2start and i1end < i2end then\n\t\tlocal minstart = i1end\n\
    \t\tlocal minlen = i1len\n\telseif i1start <= i2start and i1end > i2end then\n\
    \t\tlocal minstart = i1start\n\t\tlocal minlen = i1len\n\telseif i1start < i2start\
    \ and i1end <= i2end then\n\t\tlocal minstart = i1start\n\t\tlocal minlen = i2len\n\
    \telseif i1start < i2start and i1end > i2end then\n\t\tlocal minstart = i2start\n\
    \t\tlocal minlen = i2len\n\telse\n\t\tlocal minstart = i2start\n\t\tlocal minlen\
    \ = i2len\n\tend\n\t\n\t-- Do the rest of the checking\n\tlocal len = 1\n\t\n\t\
    -- Check for equal length\n\tif minlen == i1len then\n\t\tlen = minlen\n\telseif\
    \ minlen == i2len then\n\t\tlen = minlen\n\tend\n\t\n\t-- Check for equal start\
    \ and end\n\tif minstart == i1start and minlen == i1len then\n\t\tlen = minlen\n\
    \telseif minstart == i2start and minlen == i2len then\n\t\tlen = minlen\n", " \
    \  local i1 = interval1[1]\n   local i2 = interval2[1]\n   local e1 = interval1[2]\n\
    \   local e2 = interval2[2]\n   local i3 = i1 + e2\n   if i2 < e1 then\n     \
    \ return false\n   elseif i1 == e1 then\n      return i2 == e2\n   elseif i3 ==\
    \ e1 then\n      return true\n   else\n      return false\n   end\nend", "\tlocal\
    \ intersection = {}\n\tlocal interval1start = interval1[1]\n\tlocal interval1end\
    \ = interval1[2]\n\tlocal interval2start = interval2[1]\n\tlocal interval2end\
    \ = interval2[2]\n\tif interval1start > interval1end or interval2start > interval2end\
    \ then\n\t\treturn false\n\telse\n\t\tif interval1start < interval2start then\n\
    \t\t\tif interval1end <= interval2start then\n\t\t\t\ttable.insert(intersection,\
    \ interval1start)\n\t\t\t\ttable.insert(intersection, interval1end)\n\t\t\t\t\
    return true\n\t\t\telse\n\t\t\t\treturn false\n\t\t\tend\n\t\telseif interval1end\
    \ >= interval2end then\n\t\t\treturn false\n\t\telse\n\t\t\ttable.insert(intersection,\
    \ interval1start)\n\t\t\ttable.insert(intersection, interval1end)\n\t\t\ttable.insert(intersection,\
    \ interval2start)\n\t\t\ttable.insert(intersection, interval2end)\n\t\t\treturn\
    \ true\n\t\tend\n\tend\nend", "  local start = interval1[1]\n  local end = interval1[2]\n\
    \  local result = (interval2[2] >= start and interval2[1] >= end)\n  if result\
    \ then return end\n  else return \"NO\"\n  end\nend", "  local start1, end1, start2,\
    \ end2 = interval1[1], interval1[2], interval2[1], interval2[2]\n  local length\
    \ = end1 - start1 + end2 - start2\n  if length <= 0 then\n    return nil\n  end\n\
    \  local intersect = start1 < end2 and start2 < end1\n  if intersect then\n  \
    \  return interval1[1] < interval2[1] and interval1[2] < interval2[2]\n  else\n\
    \    return length ~= 2\n  end\nend", "\tlocal start = interval1[1]\n\tlocal end\
    \ = interval2[2]\n\tlocal l1 = interval1[1]\n\tlocal l2 = interval2[2]\n\tif l1\
    \ <= l2 then\n\t\tif l1 > l2 then \n\t\t\tstart = start\n\t\t\tend = end\n\t\t\
    else\n\t\t\tstart = l1\n\t\t\tend = l2\n\t\tend\n\telse\n\t\tif l1 > l2 then\n\
    \t\t\tend = end\n\t\telse\n\t\t\tstart = start\n\t\tend\n\tend\n\tif start <=\
    \ end then\n\t\treturn {start, end}\n\telse\n\t\treturn nil\n\tend\nend", "  local\
    \ start1 = interval1[1]\n  local end1 = interval1[2]\n  local start2 = interval2[1]\n\
    \  local end2 = interval2[2]", "\tlocal start1 = interval1[1]\n\tlocal end1 =\
    \ interval1[2]\n\tlocal start2 = interval2[1]\n\tlocal end2 = interval2[2]\n\t\
    if start1 > end2 then\n\t\treturn \"NO\"\n\telseif start2 < start1 then\n\t\t\
    return \"NO\"\n\telseif start1 == start2 then\n\t\tif end1 < end2 then\n\t\t\t\
    return \"YES\"\n\t\telse\n\t\t\treturn \"NO\"\n\t\tend\n\telse\n\t\treturn \"\
    NO\"\n\tend\nend", "    local interval = interval1[1]..\"..\"..interval2[1]\n\
    \    for i = 2, #interval1 do\n        interval = interval..\"..\"..interval1[i]\n\
    \    end\n    for i = 2, #interval2 do\n        interval = interval..\"..\"..interval2[i]\n\
    \    end\n    \n    local primes = primes()\n    if primes[interval] == nil then\n\
    \        return \"NO\"\n    end\n    \n    return \"YES\"\nend", "  return interval1[1]\
    \ < interval2[1] and interval1[2] > interval2[2] or\n         interval1[1] > interval2[1]\
    \ and interval1[2] < interval2[2]\nend", "    return interval1[1] < interval2[1]\
    \ and interval1[1] < interval2[2]\n        and interval1[2] < interval2[1] and\
    \ interval1[2] < interval2[2]\nend", "  return interval1[1] < interval2[1] and\
    \ interval2[1] < interval1[2]\nend", "  -- write your code here\n  local interval1_start\
    \ = interval1[1]\n  local interval1_end = interval1[2]\n  local interval2_start\
    \ = interval2[1]\n  local interval2_end = interval2[2]\n  local intersection_start\
    \ = interval1_start and interval2_start and interval1_start <= interval2_start\
    \ or interval1_end and interval2_end <= interval1_end\n  local intersection_end\
    \ = interval1_start and interval2_start and interval1_end and interval1_end >=\
    \ interval2_end or interval1_end and interval2_end >= interval1_end\n  local intersection_length\
    \ = intersection_start and intersection_end and interval1_start and interval1_end\
    \ and interval2_start and interval2_end and interval1_start <= interval2_start\
    \ and interval1_end >= interval2_end and interval1_start < interval2_start and\
    \ interval1_end > interval2_end\n  return intersection_length and interval1_start\
    \ and interval1_end and interval2_start and interval2_end and interval1_start\
    \ <= interval2_start and interval1_end >= interval2_end and interval1_start <\
    \ interval2_start and interval1_end > interval2_end\nend", "    local start =\
    \ math.min(interval1[1], interval2[1])\n    local end = math.max(interval1[2],\
    \ interval2[2])\n    if start > end then\n        return nil\n    end\n    return\
    \ start, end \nend", "\t-- The given intervals are closed which means that the\
    \ interval (start, end)\n\t-- includes both start and end.\n\t-- For each given\
    \ interval, it is assumed that its start is less or equal its end.\n\t-- Your\
    \ task is to determine whether the length of intersection of these two \n\t--\
    \ intervals is a prime number.\n\t-- Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n\t-- which its length is 1, which not a prime number.\n\
    \t-- If the length of the intersection is a prime number, return \"YES\",\n\t\
    -- otherwise, return \"NO\".\n\t-- If the two intervals don't intersect, return\
    \ \"NO\".", "    local left1 = interval1[1]\n    local right1 = interval1[2]\n\
    \    local left2 = interval2[1]\n    local right2 = interval2[2]\n    local length\
    \ = math.abs(right1 - left1) + math.abs(right2 - left2)\n    if length > 0 then\n\
    \        for i = 1, length do\n            local mid = (left1 + right1) / 2\n\
    \            local mid2 = ((left1 + right1) / 2) + ((left2 + right2) / 2)\n  \
    \          if (mid2 >= left1) and (mid2 <= right2) then\n                left1\
    \ = mid\n                right1 = mid2\n            else\n                left2\
    \ = mid\n                right2 = mid2\n            end\n        end\n    end\n\
    \    return left1, right1, left2, right2, length\nend", "    if interval1[1] <=\
    \ interval2[2] and interval1[2] <= interval2[1] then\n        return interval1[2]\n\
    \    end\nend", "\tlocal start = math.min(interval1[1], interval2[1])\n\tlocal\
    \ end = math.max(interval1[2], interval2[2])\n\tif start < end then\n\t\tlocal\
    \ interval = (start, end)\n\t\tlocal len = math.abs(end - start) \n\t\t-- If the\
    \ two intervals intersect, return intersection.\n\t\tif len > 1 then\n\t\t\treturn\
    \ interval\n\t\t-- If the length of interval (start, end) is a prime number\n\t\
    \t-- return \"YES\"\n\t\telseif is_prime(len) then\n\t\t\treturn true\n\t\t--\
    \ If the length of interval (start, end) is not a prime number\n\t\t-- return\
    \ \"NO\"\n\t\telse\n\t\t\treturn false\n\t\tend\n\telse\n\t\treturn false\n\t\
    end\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
