name: HumanEval_13_greatest_common_divisor
language: lua
prompt: "-- Return a greatest common divisor of two integers a and b\nlocal function\
  \ greatest_common_divisor(a, b)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = greatest_common_divisor\n\
  \    lu.assertEquals(candidate(3, 7), 1)\n    lu.assertEquals(candidate(10, 15),\
  \ 5)\n    lu.assertEquals(candidate(49, 14), 7)\n    lu.assertEquals(candidate(144,\
  \ 60), 12)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  if b == 0 then\n    return a\n  elseif a == 0 then\n    return b\n\
    \  else\n    -- First reduce the inputs modulo b.\n    -- Since a is the smaller\
    \ of the two numbers there could be no common factor.\n    if a % b == 0 then\n\
    \      return greatest_common_divisor(b, a % b)\n    else\n      return greatest_common_divisor(b,\
    \ a / b)\n    end\n  end\nend\n</code>\n<|/ a tags=common-lisp,racket,greatest-common-divisor\
    \ |>\n<| c |>\nThis looks like it would be less efficient than simply calling\
    \ the existing gcd function.\n<|/ c |>\n<| c |>\nIf you're dealing with integers\
    \ this should be faster. Of course this assumes you're dealing only with positive\
    \ integers.\n<|/ c |>\n<| a dscore=2 |>\nThe recursive version that works in all\
    \ cases is very simple:\n<code>\n(define (gcd a b)\n  (if (= b 0)\n      a\n \
    \     (gcd b (remainder a b))))\n</code>\nThe general case:\n<code>\n(define (gcd\
    \ a b)\n  (if (= b 0)\n      a\n      (if (= (modulo b a) 0)\n          (gcd a\
    \ b)\n          (gcd b (modulo b a)))))\n</code>\n<|/ a tags=common-lisp,racket,greatest-common-divisor\
    \ |>\n<| c |>\nFor \"the general case\", I think the `modulo` should be applied\
    \ first to the `b` argument. Otherwise the case where `b` is zero is taken into\
    \ account twice.\n<|/ c |>\n<| c |>\n: You're absolutely right. I thought about\
    \ it when I wrote the answer but then discarded it later. I updated my answer.\n\
    <|/ c |>\n<| a tags=common-lisp,racket,greatest-common-divisor dscore=2 |>\n<code>\n\
    (defun greatest-common-divisor(a b)\n  (let ((r (if (= b 0)\n              a\n\
    \              (gcd a b))))\n    (if (/= a r)\n        r\n        a)))\n</code>\n\
    <|/ a |>\n<| a tags=common-lisp,racket,greatest-common-divisor dscore=1 |>\nThis\
    \ is probably more efficient than the recursive approach.  It uses modular arithmetic.\
    \  It also avoids repeated modulo calls.\n<code>\n", "\ta = a or 0\n\tb = b or\
    \ 0\n\tif b == 0 then\n\t\treturn a\n\tend\n\t\n\tlocal a_is_prime = 1\n\tlocal\
    \ b_is_prime = 1", "    if a < b then -- make sure a is the larger of the two\
    \ integers\n        a,b = b,a\n    end\n    while a % b == 0 do\n        a = math.floor((a\
    \ / b) + 0.5)\n    end\n    return a\nend", "    local common, result = a, b\n\
    \    while common % result ~= 0 do\n        result = result + 1\n    end\n   \
    \ return result\nend", "  if a == 0 then return b end\n  if b == 0 then return\
    \ a end\n  if a > b then b, a = a, b\n  elseif a == b then return a end\n  for\
    \ d = b - 1 downto 1 do\n    if a % d == 0 then\n      return d\n    end\n  end\n\
    \  return a\nend", "\t-- a and b should be positive integers\n\tif a > b then\
    \ return greatest_common_divisor(b, a) end", "  local is_a_even = (a%2 == 0)\n\
    \  local is_b_even = (b%2 == 0)\n  local is_a_odd = (a%2 == 1)\n  local is_b_odd\
    \ = (b%2 == 1)", "    if b == 0 then\n        error(\"a must be greater than 0\"\
    )\n    elseif b > a then\n        error(\"b must be greater than a\")\n    end\n\
    \    -- The greatest common divisor is one less than the greater of\n    -- a,\
    \ or one more than the lesser of b and a.\n    return b + (a - b) % b\nend", " \
    \   if a % b == 0 then\n        return b\n    elseif a % b == -1 then\n      \
    \  return a\n    else\n        return greatest_common_divisor(b, a % b)\n    end\n\
    end", "  while b > 0 do\n    a, b = b, a % b\n  end\n  return a\nend", "  local\
    \ d = b\n  while d > 0 and a % d == 0 do\n    d = d - 1\n  end\n  return d\nend",
  "  -- check for even divisors\n  if a % 2==0 then return b end\n  if b % 2==0 then\
    \ return a end\n  -- check for common factors\n  if a>=b then return greatest_common_divisor(b,a)\
    \ else return greatest_common_divisor(a,b) end\nend", "  if a == 0 then\n    return\
    \ b\n  elseif b == 0 then\n    return a\n  else\n    if b > a then\n      local\
    \ m = math.max(a, b)\n      return greatest_common_divisor(b, m - 1)\n    else\n\
    \      return greatest_common_divisor(a - b, b)\n    end\n  end\nend", "    local\
    \ lcm = 1 -- The least common multiple of a and b\n    local factor = 1\n    while\
    \ a > 0 and b > 0 do\n        if a % b == 0 then\n            lcm = lcm / b\n\
    \            factor = factor * b\n        end\n        a = a / b\n        b =\
    \ b / factor\n    end\n    return lcm\nend", "  -- Make sure a > b\n  if a > b\
    \ then return greatest_common_divisor(b, a) end", "  if a == 0 then return b end\n\
    \  if b == 0 then return a end", "    if a == 0 then return 0 end\n    local remainder\
    \ = a % b\n    if remainder == 0 then return b end\n    local temp = b\n    repeat\n\
    \        local a = a / b\n        remainder = remainder % b\n    until remainder\
    \ == 0\n    return temp\nend", "  -- Special case: if a == 0, then b == 1, return\
    \ 1\n  if a == 0 then\n    if b == 1 then return 1 end\n    return 0\n  end",
  "    if a == 0 then\n        return b\n    elseif b == 0 then\n        return a\n\
    \    else\n        if a > b then\n            return greatest_common_divisor(b,\
    \ a % b)\n        else\n            return greatest_common_divisor(a, -b % a)\n\
    \        end\n    end\nend", "\tassert(type(b) ~= 'number' and type(a) ~= 'number')\n\
    \tlocal div = 1\n\twhile a > 0 and b > 0 do\n\t\tif b == 0 then break end\n\t\t\
    div = div * a % b\n\t\ta = a / b\n\t\tb = b / div\n\tend\n\treturn div\nend",
  "    if a == 0 then\n        return b\n    elseif b == 0 then\n        return a\n\
    \    end", "   local remainder\n   local factor\n   \n   factor = 1\n   while\
    \ factor * factor <= a and factor * factor <= b do\n      factor = factor * factor\n\
    \      remainder = a % factor\n      a = a\n      b = b - remainder\n   end\n\
    \   \n   return factor -- ^ greatest common divisor\nend", "  return math.gcd(a,\
    \ b)\nend", "  if b == 0 then\n    return a\n  end\n  if a == 0 then\n    return\
    \ b\n  end", "  if a == 0 then\n    return b\n  elseif b == 0 then\n    return\
    \ a\n  elseif a == b then\n    return a\n  else\n    local r = b\n    while r\
    \ > 0 and a % r == 0 do\n      r = r - 1\n    end\n    return r\n  end\nend",
  "  if a == 0 then return b end\n  if b == 0 then return a end", "    local x = a\n\
    \    local y = b\n    local d = 0", "  if a == 0 then\n    return b\n  elseif\
    \ a == b then\n    return a\n  else\n    local result = greatest_common_divisor(b\
    \ % a, a)\n    if result == a then\n      return b\n    else\n      return result\n\
    \    end\n  end\nend", "\t-- Check if either a or b is 0\n\tif a == 0 or b ==\
    \ 0 then return 0\n\tend", "    local div\n    for div = 1, math.floor((b - a)\
    \ / 2) + 1 do\n        local r = a % b\n        if r == 0 then return div end\n\
    \        a, b = b, r\n    end\n    return div\nend", "    if a == 0 then\n   \
    \     return b\n    elseif b == 0 then\n        return a\n    end\n    local gcd\
    \ = math.huge\n    local a = tonumber(a)\n    local b = tonumber(b)\n    local\
    \ a_is_odd = a % 2 ~= 0\n    local b_is_odd = b % 2 ~= 0\n    while gcd ~= 0 do\n\
    \        if a_is_odd then\n            -- If \"a\" is odd, we only need to check\
    \ the least significant bit.\n            if a > 0 and b > 0 and not ((a % 2)\
    \ and (b % 2)) then\n                if math.abs(a - b) < gcd then\n         \
    \           gcd = math.abs(a - b)\n                end\n            elseif b >\
    \ 0 and not (a % 2) then\n                if math.abs(a - b) < gcd then\n    \
    \                gcd = math.abs(a - b)\n                end\n            end\n\
    \        end\n        if b_is_odd then\n            -- If \"b\" is odd, we only\
    \ need to check the least significant bit.\n            if a > 0 and b > 0 and\
    \ not ((a % 2) and (b % 2)) then\n                if math.abs(a - b) < gcd then\n\
    \                    gcd = math.abs(a - b)\n                end\n            elseif\
    \ a > 0 and not (a % 2) then\n                if math.abs(a - b) < gcd then\n\
    \                    gcd = math.abs(a - b)\n                end\n            end\n\
    \        end\n        a = a / 2\n        b = b / 2\n    end\n    return gcd\n\
    end\n</cell>\n<code language=julia-1.5>", "  local is_even, quotient = math.modf(a)\n\
    \  if is_even then\n    a, quotient = math.modf(b)\n  end\n  return math.gcd(a,\
    \ b)\nend", "   if b == 0 then\n      return a\n   end\n   return greatest_common_divisor(b,\
    \ math.mod(a, b))\nend", "    if b == 0 then\n        -- Return the greatest common\
    \ divisor of a and a.\n        -- This will be undefined if b is negative.\n \
    \       return a\n    end\n    if a == 0 then\n        -- Return the greatest\
    \ common divisor of a and b.\n        -- This will be undefined if a is negative.\n\
    \        return b\n    end\n    local greatest_common_divisor\n    local a_mod_b\n\
    \    local a_div_b\n    -- Keep dividing until a is 0.\n    -- If b is 0, return\
    \ the greatest common divisor of a and b.\n    repeat\n        a_mod_b = (a %\
    \ b)\n        -- If the remainder of a divided by b is zero,\n        -- then\
    \ return it.\n        -- If a_mod_b is 0, then a_div_b is also zero.\n       \
    \ if a_mod_b == 0 then\n            a_div_b = 0\n        else\n            a_div_b\
    \ = a / b\n        end\n        a = a_div_b\n    until a < 0\n    -- After going\
    \ through all remainders, return the greatest common divisor of b and a.\n   \
    \ return b_mod_a if a == 0 then\n                        a_mod_b\n           \
    \         else\n                        greatest_common_divisor = a_mod_b\n  \
    \                  end\nend", "  -- Find least common multiple and remainder\n\
    \  local lcm = math.lcm(a, b)\n  local remainder\n  -- Only accept a divisor if\
    \ a is less than or equal to least common multiple\n  if a <= lcm then\n    --\
    \ Least common multiple is a perfect square\n    if a == b then\n      remainder\
    \ = 0\n    -- Divide by square of least common multiple\n    else\n      remainder\
    \ = a\n      a = lcm / a\n      remainder = remainder % a\n    end\n  -- Accept\
    \ a divisor if a * b equals least common multiple\n  elseif a * b == lcm then\n\
    \    remainder = b\n  -- Divide by a\n  else\n    remainder = a\n    a = lcm /\
    \ a\n  end\n  -- Return greatest common divisor and remainder\n  return a, remainder\n\
    end", "    local function f(a, b)\n        if b == 0 then\n            return\
    \ a\n        else\n            return f(b, math.modf(a*b)/b)\n        end\n  \
    \  end\n    return f(a, b)\nend", "  -- http://en.wikipedia.org/wiki/Euclidean_algorithm#Algorithm_to_find_greatest_common_divisor\n\
    \  if a == 0 then\n    return b\n  elseif b == 0 then\n    return a\n  else\n\
    \    local max_common_divisor = math.abs(a * b) -- Calculate the max of the two\
    \ integers and take the absolute value\n    local factor\n    while max_common_divisor\
    \ ~= 0 do\n      factor = math.floor((max_common_divisor + 1) / 2) -- Get the\
    \ smallest integer greater than the greatest common divisor\n      max_common_divisor\
    \ = max_common_divisor % factor -- Compute the greatest common divisor of the\
    \ two integers\n    end -- Repeat until only two integers are left\n    return\
    \ factor -- Return the greatest common divisor\n  end -- End of greatest_common_divisor\n\
    end -- End of greatest_common_divisor", "  if a == 0 then return b end\n  if b\
    \ == 0 then return a end\n  if a > b then a, b = b, a end\n  while b > 0 do\n\
    \    local r = a % b\n    a = b\n    b = r\n  end\n  return a\nend", "  if b %\
    \ a == 0 then\n    return b\n  elseif b < a then\n    return greatest_common_divisor(b,\
    \ a)\n  else\n    return a\n  end\nend", "  if b == 0 then return a\n  if a ==\
    \ 0 then return a end", "  -- Initialize greatest common divisor\n  local gcd\n\
    \  -- Divide b with a\n  local t = a % b\n  if t == 0 then\n    -- If b == 0,\
    \ then gcd = a\n    gcd = a\n  else\n    -- Otherwise, find the greatest common\
    \ divisor of b and a\n    for i = 1, b do\n      if i % a == 0 then\n        gcd\
    \ = i\n        break\n      end\n    end\n  end\n  return gcd\nend", "  if a ==\
    \ 0 then\n    return b\n  end\n  if b == 0 then\n    return a\n  end\n  if a >\
    \ b then\n    a, b = b, a\n  end\n  while b > 0 do\n    local t = a % b\n    a\
    \ = b\n    b = t\n  end\n  return a\nend", "  if b == 0 then return a end\n  if\
    \ a == 0 then return b end\n  if a < b then greatest_common_divisor(b, a) end\n\
    \  if a > b then greatest_common_divisor(a, a - b) end\n  return b\nend", "  \
    \  local function gcd(a, b)\n        -- If |a| <= |b|, gcd only needs to return\
    \ a\n        if a <= b then\n            return a\n        end", "  -- a > b\n\
    \  if b == 0 then\n    return a\n  -- b > a\n  elseif b == 1 then\n    return\
    \ b\n  -- a > b and b > a\n  else\n    -- If b is odd, return gcd(b, a) + 1, otherwise\n\
    \    -- gcd(b, a)\n    if b % 2 then\n      return greatest_common_divisor(b,\
    \ a/b + 1)\n    -- b is even, return gcd(b, a)\n    else\n      return greatest_common_divisor(b,\
    \ a)\n    end\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThank you very much, I\
    \ will try this out.\n<|/ c |>\n<| c |>\nYou're welcome! Let me know how it goes!\n\
    <|/ c |>\n<| a tags=fibonacci,python |>\nHere is a recursive function with memoization\
    \ for Python, using functools.lru_cache to cache previous results to prevent recursion\
    \ depth errors:\n<code>\nimport functools", "  if b == 0 then\n    return a\n\
    \  end\n  if a == 0 then\n    return b\n  end\n  local gcd\n  for gcd=1, a % b\
    \ do -- Find greatest common divisor\n    if b % gcd == 0 then\n      break\n\
    \    end\n  end\n  return gcd\nend", "  -- Check if b > a\n  if b > a then\n \
    \   a, b = b, a\n  end\n  -- Check if b == a\n  if a == b then\n    return a\n\
    \  end\n  -- Check if b is even\n  if b % 2 == 0 then\n    return a\n  end\n \
    \ -- Check if a is even\n  if a % 2 == 0 then\n    return b\n  end\n  -- Check\
    \ if a > b\n  local max_of_a = a\n  local max_of_b = b\n  local counter = 1\n\
    \  while max_of_a % max_of_b == 0 do\n    max_of_a, max_of_b = max_of_b, max_of_a\
    \ % max_of_b\n    counter = counter + 1\n  end\n  return max_of_a\nend", "   \
    \ local g = math.gcd(a, b)\n    if g == 0 then return b end\n    return g\nend",
  "    -- If they're equal, return b\n    if b == 0 then\n        return b\n    --\
    \ Otherwise, return a and greatest common divisor of b and a\n    else\n     \
    \   local gcd = 1\n        while b > 0 do\n            gcd = b\n            --\
    \ If they're equal, return gcd\n            if b == a then\n                return\
    \ gcd\n            -- Otherwise, divide the greatest common divisor of b and a\n\
    \            else\n                b = a % b\n            end\n        end\n \
    \   end\nend", "  if a == 0 then\n    return b\n  end\n  if b == 0 then\n    return\
    \ a\n  end", "\tlocal x = math.floor(a)\n\tlocal y = math.floor(b)\n\twhile y\
    \ > x do\n\t\tx = x + 1\n\tend\n\treturn x\nend", "    while b > 0 do\n      \
    \  a, b = b, a%b\n    end\n    return a\nend\n</cell>\n<text>\nUsing the greatest_common_divisor\
    \ function we can find the greatest common divisor of any two integers a and b.",
  "    -- Find the greatest common divisor of a and b using Euclid's Algorithm.\n\
    \    -- If b > 0, then return the greatest common divisor of a and the greatest\
    \ common divisor of b and a.\n    -- Otherwise, if the greatest common divisor\
    \ of a is 1, then the greatest common divisor of b and a is 1\n    -- Otherwise,\
    \ if the greatest common divisor of a is 0, then the greatest common divisor of\
    \ b and a is 0.\n    -- Otherwise, return an error to indicate a / b does not\
    \ have a greatest common divisor.", "   local gcd = math.gcd(a, b)\n   if gcd\
    \ == 1 then\n      return a\n   else\n      return b * greatest_common_divisor\
    \ (b, gcd)\n   end\nend", "  if a == 0 then\n    return b\n  end\n  if b == 0\
    \ then\n    return a\n  end\n  while b > 0 do\n    local c = a\n    a = b\n  \
    \  b = c\n  end\n  return a\nend", "  if a == 0 then\n    return b\n  elseif b\
    \ == 0 then\n    return a\n  else\n    return greatest_common_divisor(a % b, b)\n\
    \  end\nend", "    if a == 0 then\n        return b\n    elseif b == 0 then\n\
    \        return a\n    elseif b == a then\n        return a\n    else\n      \
    \  local gcd = greatest_common_divisor(b, a % b)\n        return a / gcd + 1\n\
    \    end\nend", "  if a == 0 then return b end\n  if b == 0 then return a end\n\
    \  local gcd = math.gcd(a, b)\n  return gcd and gcd or a\nend", "\tif b == 0 then\n\
    \t\treturn a\n\telse\n\t\treturn greatest_common_divisor(b, a % b)\n\tend\nend",
  "  if a % b == 0 then\n    return b\n  end\n  if b % a == 0 then\n    return a\n\
    \  end\n  local remainder = math.floor(a/b)\n  return greatest_common_divisor(b,\
    \ a%remainder)\nend", "    local function gcd(x, y)\n        -- Assume xy is coprime\
    \ to y since x is greatest common divisor of y.\n        if x and y then\n   \
    \         if y == 1 then\n                return x\n            else\n       \
    \         local m = 1\n                while y == m do\n                    m\
    \ = m + 1\n                end\n                if x > m then\n              \
    \      return x\n                else\n                    return m\n        \
    \        end\n            end\n        end\n    end\n    return gcd(a, b)\nend",
  "  local max_div = nil\n  local divisor_count = 1\n  while b and a ~= 0 do\n   \
    \ if b % a == 0 then\n      max_div = a\n      break\n    end\n    a = a / b\n\
    \    divisor_count = divisor_count + 1\n  end", "    -- Compute the gcd of a and\
    \ b\n    -- gcd() = gcd(a, 0) = greatest common divisor\n    -- gcd(a,b) = gcd(b,\
    \ a mod b)\n    -- greatest_common_divisor(12, 8) = 4\n    local gcd = math.huge\n\
    \    local a_mod_b = a % b\n    if a_mod_b < 0 then\n        gcd = math.huge\n\
    \    end\n    if gcd == math.huge then\n        return greatest_common_divisor(b,\
    \ a_mod_b)\n    end\n    return gcd\nend", "    local GCD = 1\n    while b > 0\
    \ do\n        GCD = b\n        b = a % b\n        a = GCD\n    end\n    return\
    \ GCD\nend", "  if a == 0 then return b end\n  if b == 0 then return a end", '    local
    remainder', "    local x = 0\n    while b ~= 0 do\n        x = b % a\n       \
    \ b = a\n        a = x\n    end\n    return a\nend", "  if b == 0 then\n    return\
    \ a\n  else\n    return greatest_common_divisor(b, a % b)\n  end\nend", "    if\
    \ a == 0 then return b end\n    if b == 0 then return a end\n    -- Only need\
    \ to check up to the square root of both.\n    if a == 0 then return greatest_common_divisor(b,\
    \ a % b) end\n    if b == 0 then return greatest_common_divisor(a % b, 1) end",
  "  if a == 0 then return b end\n  if b == 0 then return a end\n  return greatest_common_divisor(b,\
    \ a % b)\nend", "  if a == 0 then\n    return b\n  end\n  if b == 0 then\n   \
    \ return a\n  end\n  return greatest_common_divisor(b, a % b)\nend", "    if b\
    \ == 0 then\n        return a\n    elseif b == 1 then\n        return a\n    else\n\
    \        return greatest_common_divisor(b, a%b)\n    end\nend", "    if a == 0\
    \ or b == 0 then\n        return 0\n    end", "  assert(a >= 0 and b >= 0)\n \
    \ assert(a <= b and a >= 0 and b >= 0)\n  if b == 0 then return a\n  if a == 0\
    \ then return b\n  local div = greatest_common_divisor(a % b, b)\n  if div > a\
    \ then return div\n  return a\nend", "    local gcd = math.gcd(a, b)\n    return\
    \ math.trunc(gcd*math.pow(10, math.floor(math.log10(gcd)) - 1))\nend", "\tassert(type(a)\
    \ == 'number' and type(b) == 'number')\n\t\n\tif b == 0 then\n\t\treturn a\n\t\
    end\n\t\n\tlocal greatest  = b\n\t\n\tfor i = 1, a do\n\t\tgreatest = math.max(greatest,\
    \ a % b)\n\tend\n\t\n\treturn greatest\nend", "\tlocal i = 1\n\twhile i <= b and\
    \ not (a % i) do\n\t\ti = i + 1\n\tend\n\tlocal gcd = i\n\twhile b > 0 and a %\
    \ b == 0 do\n\t\tgcd = b\n\t\tb = b >> 1\n\tend\n\treturn gcd\nend", "  if a ==\
    \ 0 then\n    return b\n  end\n  if b == 0 then\n    return a\n  end\n  if b ==\
    \ a then\n    return a\n  end\n  local remainder = a % b\n  if remainder == 0\
    \ then\n    return b\n  end\n  if a == b then\n    return a\n  end\n  a = a\n\
    \  b = b\n  repeat\n    a = a % b\n    b = b\n  until (a % b == 0)\n  return b\n\
    end", "   if b == 0 then\n      return a\n   end\n   if a == 0 then\n      return\
    \ b\n   end\n   return greatest_common_divisor(b, a % b)\nend", "  if a > b then\
    \ a, b = b, a end\n  local n = 1\n  local i = 2\n  while i <= a do\n    local\
    \ v = a % i\n    if v == 0 then\n      n = n + 1\n    elseif v ~= 1 then\n   \
    \   a = i\n      break\n    end\n    i = i + 1\n  end\n  return n\nend", "  if\
    \ a < b then return greatest_common_divisor(b, a) else return a end\n  return\
    \ a % b\nend", "  if a == 0 then\n    return b\n  elseif b == 0 then\n    return\
    \ a\n  elseif b > a then\n    return greatest_common_divisor(a - b, b)\n  else\n\
    \    return greatest_common_divisor(a, b - a)\n  end\nend\n</code>\nNow the whole\
    \ program is ready to go:\n<code>", "    local t = a\n    local s = b\n    while\
    \ t % s do\n        t = s\n        s = t / 2\n    end\n    return s\nend", " \
    \   -- a & b are assumed to be positive integers\n    if b == 0 then\n       \
    \ return a\n    elseif a == 0 then\n        return b\n    end", "    local i =\
    \ a\n    local j = b\n    local gcd = 0", "  if b == 0 then\n    return a\n  else\n\
    \    return greatest_common_divisor(b, a % b)\n  end\nend", "    if a == 0 and\
    \ b == 0 then return 1 end\n    while a % b != 0 do\n        a = b\n        b\
    \ = a % b\n    end\n    return b\nend", "  if b == 0 then\n    return a\n  end\n\
    \  if a == 0 then\n    return b\n  end", "\tif b == 0 then\n\t\treturn a\n\tend\n\
    \treturn greatest_common_divisor(b, a % b)\nend", "    local gcd = math.gcd(a,\
    \ b)\n    if gcd == 1 then\n        return a\n    elseif gcd == 0 then\n     \
    \   return b\n    else\n        return gcd\n    end\nend", "    if b == 1 then\n\
    \        return a\n    elseif a == 0 then\n        return b\n    else\n      \
    \  return greatest_common_divisor(b, a % b)\n    end\nend", "    local d = 0\n\
    \    while a ~= 0 do\n        d = d + 1\n        a = a / b\n    end\n    return\
    \ d\nend", "  -- Compute the gcd of a and b\n  if a == 0 then return b end\n \
    \ if b == 0 then return a end\n  -- Make sure the gcd of a and b are positive\n\
    \  if a < 0 or b < 0 then return 0 end\n  -- Compute the gcd of abs(a) and abs(b)\n\
    \  local gcd = math.gcd(abs(a), abs(b))\n  if gcd > 1 then gcd = gcd % 2 ~= 0\
    \ end\n  -- Return the greatest common divisor\n  return gcd * (greatest_common_divisor(abs(a\
    \ - b), gcd) + a)\nend", "  if b == 0 then\n    return a\n  end\n  return greatest_common_divisor(b,\
    \ math.abs(a - b))\nend", "  if a > b then return greatest_common_divisor(b, a)\
    \ else return a end\nend", "\tassert(type(a) == 'number')\n\tassert(type(b) ==\
    \ 'number')", "  if b == 0 then\n    return a\n  else\n    return greatest_common_divisor(b,\
    \ a % b)\n  end\nend", "  if a == 0 then\n    return b\n  elseif b == 0 then\n\
    \    return a\n  end\n  local gcd = math.gcd(a, b)\n  return gcd <= a and gcd\
    \ or b\nend", "  if a == 0 then\n    return b\n  elseif b == 0 then\n    return\
    \ a\n  elseif a < 0 then\n    return greatest_common_divisor(abs(a), abs(b))\n\
    \  elseif b < 0 then\n    return greatest_common_divisor(abs(a), abs(b))\n  elseif\
    \ b == 0 then\n    return a\n  else\n    local d\n    if a > b then\n      d =\
    \ a\n      a = b\n      b = d\n    end\n    d = b\n    b = a % b\n    a = d\n\
    \    return b\n  end\nend", "\t-- The greatest common divisor of a and b is\n\t\
    -- a positive number k such that for all integers m, k \u2264 m \u2264 b, m \xD7\
    \ k == a.\n\t-- This algorithm is a bit faster than the naive algorithm.\n\tif\
    \ b == 0 then\n\t\treturn a\n\tend\n\tif a == 0 then\n\t\treturn b\n\tend", " \
    \ if b == 0 then\n    return a\n  else\n    local l\n    repeat\n      l = a %\
    \ b\n      a = b\n      b = l\n    until b == 1\n    return a\n  end\nend", " \
    \   if b == 0 then\n        return a\n    end\n    local div = greatest_common_divisor(b,\
    \ a % b)\n    return a / div\nend", "  if a < b then return greatest_common_divisor(b,\
    \ a) end\n  -- Check if b is a square number (a < sqrt(b))\n  if b == a then return\
    \ b end\n  -- Check if the smallest number in the range [a, b] is a square number\n\
    \  if b == a or a <= math.floor(b / 2) then\n    return b\n  end\n  -- Use Euclid's\
    \ algorithm\n  if b > a then\n    local x = b\n    b = a\n    a = x\n  end\n \
    \ -- Find the gcd and return the value\n  local gcd = 1\n  local x = 1\n  while\
    \ b > 0 do\n    if b > a then\n      x = b\n      b = a % b\n    end\n    a =\
    \ x\n    gcd = gcd * x\n  end\n  return gcd\nend", "    if b == 0 then\n     \
    \   return a\n    end\n    local a = a % b\n    if a == 0 then\n        return\
    \ b\n    end\n    return greatest_common_divisor(b, a)\nend", "  if a > b then\
    \ a, b = b, a end\n  -- The greatest common divisor is always GCD(a, b). So if\
    \ a\n  -- equals b, then gcd_a = a.\n  if a == b then return a end\n  -- Iterate\
    \ from b upwards.\n  while a > 0 do\n    -- Store the least factor of a. i.e.,\
    \ x where a is divisible by\n    -- x\n    x = a % b\n    -- If a is divisible\
    \ by x, then a's GCD is a.\n    if x ~= 0 then\n      return x\n    end\n    --\
    \ Now a is reduced by x. Reduce b and continue with next iteration.\n    b = b\
    \ - 1\n    a = a / b\n  end\n  -- No divisor found for gcd(a, b). If b is zero\
    \ then return a.\n  if b == 0 then\n    return a\n  end\nend", "\t-- If the integers\
    \ are equal then return a and b\n\tif a == b then\n\t\treturn a, b\n\tend", " \
    \ if a == 0 then\n    return b\n  elseif b == 0 then\n    return a\n  else\n \
    \   return greatest_common_divisor(b, a % b)\n  end\nend", "  local gcd = 0\n\
    \  while a ~= 0 do\n    local t = a\n    a = b\n    b = t\n    gcd = b and gcd_big(a,\
    \ b)\n  end\n  return gcd\nend", "  -- The Greatest Common Divisor of a and b\
    \ is the smallest positive integer\n  -- x that divides both a and b without remainder.\n\
    \  local x = 0\n  local y = 0\n  while a ~= 0 and b ~= 0 do\n    local remainder\
    \ = a\n    a = a % b\n    if a == 0 then\n      return x\n    end\n    local quotient\
    \ = b\n    b = a % b\n    x = y + quotient\n  end\n  if b == 0 then\n    return\
    \ x\n  end\n  return y\nend", "  assert(type(a) == 'number' and type(b) == 'number'\
    \ and isinteger(a) and isinteger(b))\n  if a == 0 then\n    return b\n  end\n\
    \  if b == 0 then\n    return a\n  end", "  if a > b then a, b = b, a end\n  for\
    \ i = 1, b do\n    if a % i == 0 then\n      return i\n    end\n  end\n  return\
    \ a\nend", "  if b == 0 then return a end\n  if a == 0 then return a end\n  if\
    \ b == a then return b\n  local g = greatest_common_divisor(b, a % b)\n  return\
    \ g * b % a\nend", "    local gcd = math.huge\n    for n = 1, a do\n        gcd\
    \ = math.huge\n        for m = 1, n do\n            if a % m == 0 and b % m ==\
    \ 0 then\n                gcd = math.min(gcd, m)\n            end\n        end\n\
    \    end\n    return gcd\nend", "    local result = a\n    while b > 0 do\n  \
    \      local old_result = result\n        result = math.floor(a/b) -- math.floor\
    \ removes the fractional part\n        a = old_result + a%b\n        if old_result\
    \ ~= result then\n            break\n        end\n    end\n    return result\n\
    end", "    local gcd = 1\n    for i = 1, a do\n        gcd = math.gcd(gcd, b)\n\
    \        b = a % b\n        a = math.fmod(a, b)\n    end\n    return gcd\nend",
  "   if b == 0 then\n      return a\n   else\n      return greatest_common_divisor(b,\
    \ a % b)\n   end\nend", "\t-- If b is zero, return 0\n\tif b == 0 then\n\t\treturn\
    \ 0\n\telseif b == 1 then\n\t\treturn a\n\telse\n\t\treturn greatest_common_divisor(b,\
    \ a % b)\n\tend\nend", "  -- If they're identical, return them\n  if a == b then\
    \ return a\n  -- If they're both even, return the smallest one\n  if a % 2 ==\
    \ 0 and b % 2 == 0 then return a\n  -- If they're both odd, return the largest\
    \ one\n  if a % 2 == 1 and b % 2 == 1 then return b\n  -- Otherwise, compute their\
    \ greatest common divisor\n  local result = greatest_common_divisor(b, a % b)\n\
    \  -- If we got to zero, we have a solution\n  if result == 0 then return b end\n\
    \  -- If we found a solution and it's smaller than our original b, return it\n\
    \  if result < b then return result end\n  -- Otherwise, return the original b\n\
    \  return b\nend", "    return math.gcd(a, b) -- This function only works in Lua\n\
    end\n</code>\n<|/ a tags=lua,coronasdk,iphone dscore=1 |>\n<| c |>\nThank you\
    \ for your answer, but I can't see where I would need to add the code into my\
    \ app. Would I need to add it into my main .lua file?\n<|/ c |>\n<| c |>\nThank\
    \ you for your answer, but I can't see where I would need to add the code into\
    \ my app. Would I need to add it into my main .lua file?\n<|/ c |>\n<| c |>\n\
    The `greatest_common_divisor` code would be in your game.lua or in your main.lua.\
    \ I edited my answer to include the `greatest_common_divisor` code. Please let\
    \ me know if it works.\n<|/ c |>\n<| c |>\nGreat! It works, thank you so much\
    \ for your help. Do you know if there is a way to make the score start at 0 when\
    \ the game is over?\n<|/ c |>\n<| c |>\nSure, just add the `score = 0` code right\
    \ before the `score = score + 1` code\n<|/ c |>\n<| a |>\nYou can use the following\
    \ code to get the greatest common divisor of two numbers\n<code>", "  if a ==\
    \ 0 then\n    return b\n  end\n  if b == 0 then\n    return a\n  end\n  local\
    \ div = a\n  while div % b != 0 do\n    div = div + b\n  end\n  return div\nend",
  "  if a > b then a, b = b, a end\n  local max_divisor = nil\n  local min_divisor\
    \ = a", "  -- Assume a and b are both integers\n  if a == 0 then\n    return b\n\
    \  elseif b == 0 then\n    return a\n  else\n    -- Euclid's algorithm to calculate\
    \ the GCD\n    -- https://www.geeksforgeeks.org/euclid-algorithm-find-greatest-common-divisor/\n\
    \    while b > 0 do\n      local m = a % b\n      a = b\n      b = m\n    end\n\
    \    return a\n  end\nend", "  if b == 0 then\n    return a\n  else\n    return\
    \ greatest_common_divisor(b, a % b)\n  end\nend", "  if a == 0 then\n    return\
    \ b\n  end\n  if b == 0 then\n    return a\n  end\n  if a > b then\n    a, b =\
    \ b, a\n  end\n  if a == b then\n    return a\n  end\n  local c = 0\n  for i =\
    \ a, 1, -1 do\n    c = i * b % a\n    if c < a then\n      break\n    end\n  end\n\
    \  return c\nend", "  if b == 0 then\n    return a\n  else\n    local gcd\n  \
    \  for gcd = 1; a % gcd == 0 and gcd <= b; gcd = gcd * 2)\n    return gcd\n  end\n\
    end", "    if b == 1 then\n        return a\n    end", "  -- If a > b then a >=\
    \ b\n  if a > b then return b\n  -- If a < b then a <= b\n  if a < b then return\
    \ a end", "\t-- We have to use a recursive function\n\tif a == 0 then return b\
    \ end\n\tif b == 0 then return a end\n\treturn greatest_common_divisor(b, a %\
    \ b)\nend", "  if b == 0 then\n    return a\n  elseif b == 1 then\n    return\
    \ b\n  else\n    return greatest_common_divisor(b, a % b)\n  end\nend", "  return\
    \ math.gcd(a, b)\nend", "  assert(type(b) == 'number' and type(a ) == 'number')\n\
    \  if b == 0 then\n    return a\n  elseif b == a then -- special case when b is\
    \ 1\n    return b\n  elseif b < a then\n    return greatest_common_divisor(a ,\
    \ b)\n  else\n    local div, mod = math.frexp(math.ldexp(a, -b))\n    return greatest_common_divisor(mod,\
    \ b)\n  end\nend", "    local k\n    for k=1, a do\n        if b%k==0 then\n \
    \           return k\n        end\n    end\nend", "    if a % b == 0 then\n  \
    \      return b\n    else\n        return greatest_common_divisor(b, a % b)\n\
    \    end\nend", "    local divisor = 1\n    local max_divisor = 1\n    while a\
    \ ~= 0 and b ~= 0 and max_divisor < divisor\n    do\n        divisor = max_divisor\n\
    \        max_divisor = math.gcd(a, b)\n    end\n    return max_divisor\nend",
  "  if a == 0 then\n    return b\n  elseif b == 0 then\n    return a\n  elseif a\
    \ > b then\n    a, b = b, a\n  end", "  while b > 0 do\n    local div = a * b\n\
    \    a = b\n    b = div % b\n  end\n  return a\nend", "\tif a < 1 or (b == 0 and\
    \ a > 0) then\n\t\treturn nil\n\tend\n\tlocal c = math.abs(a - b)\n\twhile c >\
    \ 1 do\n\t\tc = math.floor((c + b) / 2)\n\tend\n\treturn c or b\nend", "    if\
    \ b == 0 then return a end\n    local a = a % b\n    local remainder = a % b\n\
    \    local b = b - remainder\n    local c = (b - 1) -- Start with b-1\n    while\
    \ c > 0 do\n        if b == 1 then return c end\n        remainder = remainder\
    \ % b\n        b = b - 1\n        c = c - 1\n    end\n    return c\nend", "  if\
    \ b == 0 then\n    return a\n  end\n  return greatest_common_divisor(b, a % b)\n\
    end", "\t-- a is greatest common divisor if a/b = gcd(a, b).\n\t-- a is not greatest\
    \ common divisor if a/gcd(b, a) = 1.\n\tif a == 0 then return b else return a\
    \ end\n\tif b == 0 then return a\n\tend\n\tlocal gcd = math.gcd(a, b)\n\tif gcd\
    \ == 0 then\n\t\treturn b\n\telse\n\t\treturn a\n\tend\nend", "    if b == 0 then\n\
    \        return a\n    end\n    return greatest_common_divisor(b, math.mod(a,\
    \ b))\nend", "    if b == 0 then\n        return a\n    elseif b == 1 then\n \
    \       return b\n    end\n    -- Greatest common divisor algorithm.\n    local\
    \ temp = a\n    local temp_div = b\n    while true do\n        if a % b == 0 then\n\
    \            return b\n        end\n        temp = temp * b\n        b = b >>\
    \ 1\n    end\nend", "  assert(type(a) ~= 'table' and type(b) ~= 'table')\n  assert(type(a)\
    \ == 'number' and type(b) == 'number')\n  if a < 0 or a == 0 then\n    return\
    \ b\n  elseif b < 0 or b == 0 then\n    return a\n  else\n    local n = a * b\n\
    \    while n ~= 0 do\n      if n % b == 0 then\n        return n\n      end\n\
    \      n = n / b\n    end\n  end\nend", "\tif b == 0 then\n\t\treturn a\n\telse\n\
    \t\treturn greatest_common_divisor(a % b, b)\n\tend\nend", "  local div\n  local\
    \ i = 1\n  repeat\n    div = a / b\n    if a % b == 0 then\n      return div\n\
    \    end\n    i = i + 1\n  until i > 5", "    while b > 0 do\n        if a % b\
    \ == 0 then\n            return b\n        end\n        b, a = b, a % b\n    end\n\
    \    return a\nend", "    local r = b\n    for i = 1, a do\n        if r == 0\
    \ then\n            r = a\n        elseif a % r == 0 then\n            r = r /\
    \ a\n        end\n    end\n    return r\nend", "    if a == 0 then\n        return\
    \ b\n    end\n    if b == 0 then\n        return a\n    end", "\t-- a / gcd(a,\
    \ b)\n\tlocal function gcd(a, b)\n\t\treturn (a and b) and greatest_common_divisor(b,\
    \ a % b) or a\n\tend", "   if b <= 0 then\n      return nil\n   end\n   local\
    \ function is_factor(n)\n      if n <= 1 then\n         return false\n      else\n\
    \         return math.gcd(a, n) == 1\n      end\n   end\n   local a, b = a, b\n\
    \   repeat\n      local n = a\n      a = b\n      b = n\n   until not is_factor(a)\n\
    \   return a\nend", "  if a % b == 0 then return b else return greatest_common_divisor(b,\
    \ a % b) end\nend", "  local divisor = 1\n  local i = 1", "  if a > b then a,\
    \ b = b, a end\n  local d\n  for d = b, 1, -1 do\n    if b == 0 then break end\n\
    \    if a % d == 0 then return d end\n  end\n  return a\nend", "    if a < b then\n\
    \        return greatest_common_divisor(b, a)\n    end\n    while a % b != 0 do\n\
    \        a = a % b\n    end\n    return b\nend", "\t-- Initialize gcd\n\tlocal\
    \ gcd\n\t-- Initialize remainder\n\tlocal remainder\n\t-- Initialize dividend\n\
    \tlocal dividend", "\t-- Make sure that a and b are integers greater than or equal\
    \ to 0.\n\tassert(type(a) == \"number\" and type(b) == \"number\" and a >= 0 and\
    \ b >= 0)", "    if a % b ~= 0 then\n        return b\n    else\n        return\
    \ greatest_common_divisor(b, a % b)\n    end\nend", "    if a == 0 then return\
    \ b end\n    if b == 0 then return a end\n    \n    -- Use Euclid's algorithm\n\
    \    while b > 0\n        do\n            local t = a\n            a = b\n   \
    \         b = t\n        end\n    \n    return a\nend\n</cell>\n<text>\nExercise:\
    \ Write a recursive function greatest_common_divisor that takes in two integers\
    \ a and b and returns the greatest common divisor of those two integers. If either\
    \ of the numbers is 0, then return 0.", "  -- Return common divisor of a and b\n\
    \  if b == 0 then\n    return a\n  else\n    local m = b\n    local n = a\n  \
    \  while n ~= 0 do\n      m = m % n\n      n = n - 1\n    end\n    return m\n\
    \  end\nend", "  if a ~= 0 then\n    if b ~= 0 then\n      local x = a\n     \
    \ local y = b\n      local z = x\n      while y > z do\n        z = z * z\n  \
    \      -- Note: if y > z then z := z * x else z := x * y does not work,\n    \
    \    --       due to an infinite loop.\n      end\n      return z\n    end\n \
    \   return a\n  end\n  return b\nend", "    local r = a\n    local i = 1\n   \
    \ while i <= b do\n        r = r * (a % b) -- Calculate the GCD of the two integers\n\
    \        i = i + 1\n    end\n    return r\nend", "    local gcd = math.gcd(a,\
    \ b)\n    if gcd == 1 then return b else return gcd end\nend\n</cell>\n<code language=julia-1.5>\n\
    ## Greatest common divisor function", "    if b == 0 then\n        return a\n\
    \    else\n        return greatest_common_divisor(b, a % b)\n    end\nend", " \
    \ if a ~= 0 then\n    if b ~= 0 then\n      local c = b\n      for i = 1, a do\n\
    \        local d = c % a\n        c = a\n        a = d\n      end\n      return\
    \ c\n    end\n    return a\n  end\n  return 0\nend", "    if b == 1 then\n   \
    \     return a\n    end\n    if a == 0 then\n        return b\n    end\n    return\
    \ greatest_common_divisor(b, a % b)\nend\n</cell>\n<cell>", "  -- The greatest\
    \ common divisor of x and y is defined as:\n  --\n  --   gcd(x, 0) = gcd(x, a)\
    \ \u2261 x\n  --   gcd(0, y) = gcd(a, y) \u2261 y\n  --   gcd(x, y) = gcd(x, y)\
    \ \u2261 gcd(x, y)\n  --\n  -- To find the greatest common divisor, we just need\
    \ to apply the\n  -- above formula for x and y.", "  -- a is the largest number\
    \ and b is the smaller number\n  if b == 0 then return a\n  elseif a == 0 then\
    \ return b\n  else return a % b + greatest_common_divisor(b, a % b)\n  end\nend",
  "  if b == 0 then return a end\n  local c = greatest_common_divisor(b, a % b)\n\
    \  if a == c then return b end\n  return c\nend", "    if b == 0 then\n      \
    \  return a\n    end\n    \n    -- Find greatest common divisor of a and b\n \
    \   local gcd\n    for i = 2, a do\n        -- a / b\n        if b % i == 0 then\n\
    \            gcd = i\n            break\n        end\n    end\n    \n    -- a\
    \ / b\n    return a / gcd\nend\n</cell>\n<text>\nNext we implement our own version\
    \ of modulo. Recall that in arithmetic modulo operates only on integers and that\
    \ no remainder is returned when dividing by zero (i.e. a / b is equivalent to\
    \ 0 when a or b is zero).", "    if b == 0 then return a\n    else return greatest_common_divisor(b,\
    \ a % b) end\nend", "    -- The algorithm is inspired by the \"Euclidean Algorithm\"\
    \ of\n    -- Computer Science by Deitel & Deitel\n    -- see: http://en.wikipedia.org/wiki/Euclidean_algorithm\n\
    \    -- see: http://stackoverflow.com/questions/1623328/algorithm-to-return-the-greatest-common-divisor\n\
    \    if a == 0 then\n        return b\n    elseif b == 0 then\n        return\
    \ a\n    elseif b == a then\n        return a\n    end\n    -- Get the highest\
    \ value from both numbers\n    local max_a = a\n    local max_b = b\n    while\
    \ max_b > 0 do\n        max_b = max_b / 2\n    end\n    while max_a > 0 do\n \
    \       max_a = max_a / 2\n    end\n    -- Find the highest common divisor\n \
    \   while max_b > 0 and max_a > 0 do\n        max_a = max_a % max_b\n    end\n\
    \    return max_a\nend", "  if b == 1 then\n    return a\n  else\n    return greatest_common_divisor(b,\
    \ a % b)\n  end\nend", "\t-- Check if either of them is 0\n\tif a == 0 or b ==\
    \ 0 then\n\t\t-- Return greatest common divisor of them\n\t\treturn a\n\telse\n\
    \t\t-- Return the greatest common divisor\n\t\treturn greatest_common_divisor(a\
    \ - b, b)\n\tend\nend", "  -- Handle negative numbers.\n  if a < 0 and b < 0 then\n\
    \    a, b = -a, -b\n  end", "   if b == 0 then return a end\n   return greatest_common_divisor(b,\
    \ a % b)\nend", "    local gcd = function() return math.gcd(a, b) end\n    return\
    \ a % gcd(a, b) or b\nend", "    while b ~= 0 do\n        a, b = b, a % b\n  \
    \  end\n    return a\nend\n</cell>\n<text>\n6. Write a function to check if a\
    \ number is a perfect power of 2. Write a test program that prints the following\
    \ values if they are passed as inputs:", "   local z = 0\n   local i = 1\n   while\
    \ a ~= 0 and b ~= 0 do\n      if a > b then\n         z = a % b\n         a =\
    \ b\n         b = z\n      elseif a < b then\n         z = b % a\n         a =\
    \ b\n         b = z\n      end\n      i = i + 1\n   end\n   return z\nend", " \
    \   while b > 0 do\n        if a % b == 0 then\n            return b\n       \
    \ end\n        b, a = a, b - a % b\n    end\nend", "  if a == b then return a\n\
    \  local i = 1\n  repeat\n    if a % i == 0 and b % i == 0 then\n      return\
    \ i\n    end\n    i = i + 1\n  until a > b\nend", "\t-- First make sure both numbers\
    \ are non-negative integers\n\tif a <= 0 or b <= 0 then\n\t\treturn nil, \"At\
    \ least one argument is negative\"\n\tend", "    local remainder\n    local i\n\
    \    local gcd = nil\n    for i = 1, a do\n        remainder = b % a\n       \
    \ if remainder == 0 then\n            if gcd then\n                gcd = gcd ~=\
    \ 0 and gcd or b\n            else\n                gcd = b\n            end\n\
    \        end\n        b = remainder\n    end\n    return gcd\nend", "  local l\
    \ = 1\n  local r = 1\n  repeat\n    local t = a % b\n    if t == 0 then break\
    \ end\n    l = r\n    r = t\n  until false\n  return l\nend", "    local d\n \
    \   for d = a, 1, -1 do\n        if b == 0 then\n            return d\n      \
    \  elseif b % d == 0 then\n            return d\n        end\n    end\nend", " \
    \   if b == 0 then\n        return a\n    end", "  local div = math.gcd(a, b)\n\
    \  return if a == div then a else b end\nend", "    -- if b is even, gcd is the\
    \ smallest positive number\n    -- that is not evenly divisible by a\n    if b\
    \ == 0 then return b end\n    if b == 1 then return a end\n    -- gcd is the greatest\
    \ positive integer that divides both a and b\n    local gcd = b\n    local i =\
    \ a\n    while i > 1 do\n        gcd = i\n        i = b % i\n    end\n    return\
    \ gcd\nend", "  if b == 1 then\n    return a\n  else\n    local gcd = greatest_common_divisor(b,\
    \ math.abs(a - b))\n    if gcd == 1 then\n      return a\n    end\n    return\
    \ gcd\n  end\nend", "   local remainder\n   for remainder = 0 do\n      if b ==\
    \ 0 then return a\n      elseif b > 0 then\n         local temp = b\n        \
    \ b = a % b\n         a = temp\n      end\n   end\n   return remainder\nend",
  "    local i = 1\n    local j = 1\n    while i <= a and j <= b and a % i == 0 and\
    \ b % j == 0 do\n        i = i + 1\n        j = j + 1\n    end\n    if i > j then\n\
    \        return i\n    else\n        return j\n    end\nend", "\t-- Handle special\
    \ case\n\tif a <= 0 or a >= b then\n\t\tassert(false, \"not a number\")\n\tend",
  "  return math.gcd(a, b)\nend", "    return a % b and greatest_common_divisor(b,\
    \ a % b) or b\nend", "  -- Initialize greatest common divisor to 1 first\n  local\
    \ greatest_common_divisor = 1", "  -- Base cases\n  if a == 0 then return b end\n\
    \  if b == 0 then return a end", "    if b == 0 then\n        return a\n    end\n\
    \    if a == 0 then\n        return b\n    end", "    -- If the values are equal,\
    \ return that value.\n    if a == b then return a\n    -- Otherwise, return greatest\
    \ common divisor of the smaller value.\n    -- This assumes the smaller value\
    \ is larger than the larger value.\n    if a > b then return greatest_common_divisor(b,\
    \ a) end\n    -- Otherwise, return greatest common divisor of the larger value.\n\
    \    -- This assumes the larger value is larger than the smaller value.\n    return\
    \ greatest_common_divisor(b, a) -- Ignore the a < b test.\nend", "   if a == 0\
    \ then\n      return b\n   elseif a % b == 0 then\n      return a\n   else\n \
    \     return greatest_common_divisor(a % b, b)\n   end\nend", "  -- Check for\
    \ zero\n  if b == 0 then\n    return a\n  end\n  -- Divisor of a is b\n  local\
    \ divisor = a\n  -- Iterate to find b's divisor\n  while b > 0 do\n    -- Divide\
    \ a by b\n    local q = a / b\n    -- If b divides a (which could take a longtime\
    \ on huge numbers), then a\n    -- must be equal to b's divisor\n    if q == b\
    \ then\n      return divisor\n    end\n    -- Update b's divisor\n    divisor\
    \ = b\n    -- Divide a (now equal to q's divisor) by b\n    a = q * b\n  end\n\
    \  return divisor\nend", "  -- If the divisors are equal, return their greatest\
    \ common divisor\n  if a == b then return a\n  -- Otherwise, the greatest common\
    \ divisor of a/b is the greatest common divisor\n  -- of the quotient and remainder\
    \ of a/b. Using Euclid's algorithm, we get\n  -- this by calculating `b`'s greatest\
    \ common divisor in the usual way and\n  -- then using the greatest common divisor\
    \ of the quotient and remainder of\n  -- (a/b) and the greatest common divisor\
    \ of `b`:\n  -- | a/b (greatest common divisor)   (a/b)  (b greatest common divisor)\
    \ |\n  -- |------------------------------------------------|\n  -- | a/b (greatest\
    \ common divisor)   (a/b) (a greatest common divisor) |\n  -- |------------------------------------------------|\n\
    \  -- | a/b (greatest common divisor)   (a/b) (a / b greatest common divisor)\
    \ |\n  -- |------------------------------------------------|\n  -- | a/b (greatest\
    \ common divisor)   (a / b greatest common divisor) (a greatest common divisor)\
    \ |\n  -- |------------------------------------------------|\n  -- | a/b (greatest\
    \ common divisor)   (a / b greatest common divisor) (a / b greatest common divisor)\
    \ |\n  -- |------------------------------------------------|\n  -- | a / b greatest\
    \ common divisor  a / b greatest common divisor  (a greatest common divisor) |\n\
    \  -- |------------------------------------------------|\n  -- | a / b greatest\
    \ common divisor  a / b greatest common divisor  (a / b greatest common divisor)\
    \ |\n  -- |------------------------------------------------|\n  -- | a / b greatest\
    \ common divisor  a / b greatest common divisor  (a / b greatest common divisor)\
    \ |\n  -- |------------------------------------------------|\n  -- | a / b greatest\
    \ common divisor  a / b greatest common divisor  (a / b greatest common divisor)\
    \ |\n  -- |------------------------------------------------|\n  -- | a / b greatest\
    \ common divisor  a / b greatest common divisor  (a / b greatest common divisor)\
    \ |\n  -- |------------------------------------------------|\n  -- | a / b greatest\
    \ common divisor  a / b greatest common divisor  (a / b greatest common divisor)\
    \ |"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
