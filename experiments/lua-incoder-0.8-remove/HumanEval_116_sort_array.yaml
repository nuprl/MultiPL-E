name: HumanEval_116_sort_array
language: lua
prompt: "-- In this Kata, you have to sort an array of non-negative integers according\
  \ to\n-- number of ones in their binary representation in ascending order.\n-- For\
  \ similar number of ones, sort based on decimal value.\n-- It must be implemented\
  \ like this:\nlocal function sort_array(arr)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sort_array\n\
  \    lu.assertEquals(candidate({1, 5, 2, 3, 4}), {1, 2, 4, 3, 5})\n    lu.assertEquals(candidate({-2,\
  \ -3, -4, -5, -6}), {-4, -2, -6, -5, -3})\n    lu.assertEquals(candidate({1, 0,\
  \ 2, 3, 4}), {0, 1, 2, 4, 3})\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({2,\
  \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}), {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77})\n    lu.assertEquals(candidate({3,\
  \ 6, 44, 12, 32, 5}), {32, 3, 5, 6, 12, 44})\n    lu.assertEquals(candidate({2,\
  \ 4, 8, 16, 32}), {2, 4, 8, 16, 32})\n    lu.assertEquals(candidate({2, 4, 8, 16,\
  \ 32}), {2, 4, 8, 16, 32})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  -- Write your code here.\nend", "  if #arr < 1 then\n    return arr\n\
    \  end", "  -- We have to convert the array to bits.\n  -- This is an operation\
    \ that costs O(n) time and O(n) memory.\n  local bin = bit.pack(unpack(arr))\n\
    \  -- Count the number of 1s in each bin.\n  local num_ones = count_ones(bin)\n\
    \  -- Sort the array based on the number of 1s in ascending order.\n  -- This\
    \ is O(nlogn) time complexity.\n  table.sort(num_ones, function(a, b) return a\
    \ < b end)\n  -- Convert the sorted array to decimal values.\n  return bit.unpack(num_ones)\n\
    end", "   -- first sort on number of ones\n   if #arr < 2 then\n      return arr\n\
    \   end\n   local function cmp(x, y)\n      local x_cnt = math.floor((x / 2):round())\n\
    \      local y_cnt = math.floor((y / 2):round())\n      return x_cnt > y_cnt or\
    \ (x_cnt == y_cnt and (x - y) or nil)\n   end\n   table.sort(arr, cmp)\n   --\
    \ Now sort on dec\n   if #arr < 2 then\n      return arr\n   end\n   table.sort(arr,\
    \ function(x, y)\n      return (y - x) < (x - y)\n   end)\n   return arr\nend",
  "    local tmp_arr = {}\n    local tmp_nums = {}\n    local tmp_zeros = 0\n    local\
    \ tmp_ones = 0\n    local tmp_arr_index = 0\n    for _, v in pairs(arr) do\n \
    \       if v == 0 then\n            tmp_zeros = tmp_zeros + 1\n        elseif\
    \ v == 1 then\n            tmp_ones = tmp_ones + 1\n        else\n           \
    \ table.insert(tmp_nums, v)\n        end\n    end\n    table.sort(tmp_nums, function(a,\
    \ b) return a > b end)\n    for i=1, #tmp_nums do\n        if tmp_zeros == 0 then\n\
    \            tmp_arr_index = (tmp_arr_index + 1)\n            tmp_arr[i] = tmp_arr_index\n\
    \        end\n        if tmp_ones == 1 then\n            tmp_arr_index = (tmp_arr_index\
    \ + 1)\n            tmp_arr[i] = tmp_arr_index\n        end\n    end\n    return\
    \ tmp_arr\nend", "    -- first sort the array by number of ones\n    local ones_count\
    \ = terralib.newsymbol(int64, \"ones_count\")\n    local ones_idx = std.newarray(\n\
    \      tostring(arr.type), #arr, \"ones_idx\",\n      tostring(arr.type), #arr,\
    \ \"ones_idx\",\n      tostring(arr.type), #arr, \"ones_idx\",\n      tostring(arr.type),\
    \ #arr, \"ones_idx\",\n      tostring(arr.type), #arr, \"ones_idx\",\n      tostring(arr.type),\
    \ #arr, \"ones_idx\",\n      tostring(arr.type), #arr, \"ones_idx\",\n      ones_count,\
    \ #arr, \"ones_count\",\n      ones_count, #arr, \"ones_count\",\n      ones_count,\
    \ #arr, \"ones_count\",\n      ones_count, #arr, \"ones_count\",\n      ones_count,\
    \ #arr, \"ones_count\",\n      ones_count, #arr, \"ones_count\",\n      ones_count,\
    \ #arr, \"ones_count\",\n      ones_count, #arr, \"ones_count\",\n      ones_count,\
    \ #arr, \"ones_count\",\n      ones_count, #arr, \"ones_count\",\n      ones_count,\
    \ #arr, \"ones_count\",\n      ones_count, #arr, \"ones_count\",\n      ones_count,\
    \ #arr, \"ones_count\",\n      ones_count, #arr, \"ones_count\",\n      ones_count,\
    \ #arr, \"ones_count\",\n      ones_count, #arr, \"ones_count\",\n      ones_count,\
    \ #arr, \"ones_count\",\n      ones_count, #arr, \"ones_count\",\n      ones_count,\
    \ #arr, \"ones_count\",\n      ones_count, #arr, \"ones_count\",\n      ones_count,\
    \ #arr, \"ones_count\",\n      ones_count, #arr, \"ones_count\",\n      ones_count,\
    \ #arr, \"ones_count\",\n      ones_count, #arr, \"ones_count\",\n      ones_count,\
    \ #arr, \"ones_count\",\n      ones_count, #arr, \"ones_count\",\n      ones_count,\
    \ #arr, \"ones_count\",\n      ones_count, #arr, \"ones_count\",\n      ones_count,\
    \ #arr, \"ones_count\",\n      ones_count, #arr, \"ones_count\",\n      ones_count,\
    \ #arr, \"ones_count\",\n      ones_count, #arr, \"ones_count\",\n      ones_count,\
    \ #arr, \"ones_count\",\n      ones_count, #arr, \"ones_count\",\n      ones_",
  "    -- do your sorting here\nend", "    return arr:map(function(v) return bit.rshift(v,\
    \ 32):reverse():uint() end)\nend", "  -- Sort using count_one function\n  table.sort(arr,\
    \ count_one)\n  -- Sort based on decimal value\n  table.sort(arr, decimal_value)\n\
    \  -- Return the sorted array\n  return arr\nend", "  -- First find the maximum\
    \ element (for similar number of ones, sort based on decimal value)\n  -- Use\
    \ `#arr` to get the length of `arr`.\n  local max_element = 0\n  local max_element_index\
    \ = nil\n  for i = 0, #arr do\n    if arr[i] > max_element then\n      max_element\
    \ = arr[i]\n      max_element_index = i\n    end\n  end\n  -- Sort array based\
    \ on binary representation\n  -- Start by sorting ascending based on number of\
    \ ones\n  for i = 1, max_element_index do\n    local element = arr[i]\n    local\
    \ j = 1\n    while element ~= 0 and arr[i] ~= 0 do\n      if element == 1 then\n\
    \        arr[i], arr[j] = (arr[j], arr[i])\n      end\n      j = j + 1\n     \
    \ element = element >> 1\n    end\n  end\n  -- Sort ascending based on decimal\
    \ value\n  -- Use `#arr` to get the length of `arr`.\n  for i = 1, max_element_index\
    \ do\n    local element = arr[i]\n    local j = 1\n    while element ~= 0 and\
    \ arr[i] ~= 0 do\n      if element > max_element then\n        max_element = element\n\
    \      end\n      j = j + 1\n      element = element >> 1\n    end\n  end\n  return\
    \ arr\nend", "    local len = #arr\n    local temp = 0", "    local cnts = {}\n\
    \    for i, v in ipairs(arr) do\n        local bits = string_tobit(v)\n      \
    \  cnts[#cnts+1] = bits:count(\"1\")\n    end", "  -- Sort array in descending\
    \ order with binary search.\n  -- First argument is an integer array to be sorted,\
    \ second argument is a function\n  -- that compares two integers and returns -1,\
    \ 0, or 1 as result.\n  return arr[#arr]:sort(function(a, b)\n    local m = math.abs(a\
    \ - b)\n    return m >= 0 and 1 or m == 0 and -1 or 0\n  end)\nend", "  assert(#arr\
    \ <= 50, \"Number of elements must be less than 50\")\n  local result = {}\n \
    \ for i=1, #arr do\n    result[i] = {\n      count = tonumber(arr:sub(i, i)),\n\
    \      value = tonumber(arr:sub(i+1, i+1))\n    }\n  end\n  for i=#result, 1,\
    \ -1 do\n    if result[i].count > result[i-1].count then\n      table.sort(result)\n\
    \      local i = 1\n      for _,v in pairs(result) do\n        result[i].count\
    \ = result[i-1].count\n        result[i].value = result[i-1].value + v.value\n\
    \        i=i+1\n      end\n      break\n    end\n  end\n  -- Sort array ascending\
    \ based on value of dec. value\n  table.sort(result)\n  return result\nend", " \
    \   return arr\nend", "    if #arr == 0 then\n        return arr\n    end", " \
    \   -- write your code here\nend", "  -- Write your code here!\nend", "    --\
    \ arr -- array of non-negative integers\n    --\n    -- return -- the sorted array\n\
    \    -- examples:\n    -- sort_array([1,1,0,0]) -> [1]\n    -- sort_array([2,1,0,1])\
    \ -> [1,2]\n    -- sort_array([0,1,0,1]) -> [2,1,0]\nend", "    -- Write your\
    \ code here\nend", "  return arr\nend", "    local arr = { } -- A new array to\
    \ hold the sorted elements.\n    local n = #arr\n    for i = 1, n do arr[i] =\
    \ i end -- Assign the numbers to the array.\n    table.sort(arr) -- Sort the array\
    \ in ascending order.\n    -- Now sort the array in descending order.\n    for\
    \ i = 1, n do\n        local temp = arr[i]\n        arr[i] = arr[n-i-1]\n    \
    \    arr[n-i-1] = temp\n    end\n    return arr\nend", "  -- Initialize result\
    \ array.\n  -- Remember that arr[i] represents i-th element of the array.\n  --\
    \ The first element of the result array should be 0.\n  local result = {0}\n \
    \ -- Iterate over the array elements and count number of ones.\n  -- Add one to\
    \ the result array at the i-th position.\n  -- When you finish counting, add the\
    \ number of ones to last position of the result array.\n  for i, num in ipairs(arr)\
    \ do\n    local bits = math.floor((num + 1) * (2^(math.ceil(math.log2(num + 1)))))\n\
    \    local index = bits_to_position(bits, true)\n    result[index] = result[index]\
    \ or num + 1\n  end\n  -- Reverse the result array in the descending order.\n\
    \  -- After this operation the result array contains elements of the original\
    \ array.\n  table.sort(result, function(a, b) return b - a end)\n  -- Return sorted\
    \ array.\n  return result\nend", "    if #arr <= 1 then return arr end\n    --\
    \ Reserve space for sorted array\n    local sorted = {}\n    table.insert(sorted,\
    \ arr[1])\n    -- Iterate through the rest\n    for i = 2, #arr do\n        local\
    \ count = math.pow(2, #sorted + 1) - #sorted\n        -- Insert the element at\
    \ i if it's not already in it\n        table.insert(sorted, count + arr[i])\n\
    \    end\n    return sorted\nend", "    if arr == nil then\n        return nil\n\
    \    end", "  -- initialize result array\n  local res_array = {}", "    if #arr\
    \ == 0 then\n        return arr\n    end\n    local n = 0\n    local m = 1\n \
    \   local p = 0\n    local q = 0\n    local t = {[1] = arr[1]}\n    local i =\
    \ 1\n    while i <= #arr do\n        -- Get number of 1s in current iteration\n\
    \        n = tonumber(table.concat(t, \" \"))\n        -- Get last one\n     \
    \   local s = #arr > i and arr[i] or 0\n        -- If n is smaller than m\n  \
    \      if n < m then\n            -- Add to m\n            m = n\n           \
    \ -- Insert new element\n            table.insert(t, s)\n        else\n      \
    \      -- If n is greater than m, then swap between them\n            table.exchange(t,\
    \ p, q)\n            -- Update p\n            p = q\n            -- Move to next\
    \ iteration\n            i = i + 1\n        end\n    end\n    table.sort(t)\n\
    \    return table.concat(t, \" \")\nend", "  -- Sort arr based on the number of\
    \ ones in their binary representation in ascending order.\n  -- For similar number\
    \ of ones, sort based on decimal value.", "  -- arr is an array of non-negative\
    \ integers\n  -- arr is sorted in place\n  -- return nothing\n  local function\
    \ compare(l, r)\n    if l < r then\n      return l\n    elseif l == r then\n \
    \     return 0\n    else\n      return -1\n    end\n  end", "    return arr\n\
    end", "  local counts = arr:clone()\n  local min_count = tonumber(arr[1])\n  arr:apply(function(x)\n\
    \    counts[x] = counts[x] or 0\n    counts[x] = counts[x] + 1\n  end)\n  min_count\
    \ = tonumber(arr[1])\n  arr:apply(function(x)\n    if counts[x] < min_count then\n\
    \      counts[x] = min_count\n    end\n  end)\n  -- Sort the array using counts\n\
    \  local sorted\n  local sorted_count = 0\n  local result\n  while sorted_count\
    \ < #arr do\n    for i = #arr, 1, -1 do\n      if counts[i] < counts[sorted_count]\
    \ then\n        sorted_count = i\n        break\n      end\n    end\n    result\
    \ = arr[sorted_count]\n    arr[sorted_count] = arr[i]\n    arr[i] = result\n \
    \   sorted_count = sorted_count + 1\n  end\n  return arr\nend", "  -- Use local\
    \ variable to make following code shorter\n  local t = {}\n  -- Traverse the array\
    \ to construct t table\n  -- This can be done with one loop as well, but I prefer\n\
    \  -- doing it with two loops for two reasons:\n  --\n  -- 1. Code readability\n\
    \  -- 2. Real life scenario may require more complex sorting.\n  for i = 1, #arr\
    \ do\n    -- If t[arr[i]] exists, then arr[i] will be added in the end\n    --\
    \ of the array\n    t[arr[i]] = nil\n  end\n  -- Sort the t table\n  table.sort(t,\
    \ function(x, y)\n    -- If the number of ones in x is greater than the number\
    \ of ones in\n    -- the y, then return 1\n    if #x > #y then\n      return 1\n\
    \    else\n      -- If the number of ones in x is less than the number of ones\
    \ in\n      -- the y, then return -1\n      return -1\n    end\n  end)\n  -- Return\
    \ sorted array\n  return table.concat(t, \"\")\nend", "\tlocal count = 0\n\tlocal\
    \ tmp = unpack(arr, 2, 1)\n\tassert(tmp[1] ~= nil)\n\t-- assert(tmp[2] == nil)\n\
    \t\n\t-- Use a binary search to find largest number with same number of ones\n\
    \t-- as first element.\n\twhile count ~= 1 do\n\t\t-- Count how many elements\
    \ are left after sorting\n\t\tcount = math.ceil(math.log(math.pow(2, count)) /\
    \ math.log(2))\n\t\tassert(count ~= 0)\n\t\t-- Divide numbers by 2\n\t\tlocal\
    \ tmp = unpack(arr, 2, count-1)\n\t\tassert(tmp[1] ~= nil)\n\t\t-- Use binary\
    \ search to find largest number with same number of ones\n\t\t-- as first element.\n\
    \t\tlocal index = binary_search(tmp[1], tmp[2])\n\t\tif index then\n\t\t\t-- Move\
    \ numbers into the right place\n\t\t\t-- First element in the right place\n\t\t\
    \t-- assert(tmp[1][index] == nil)\n\t\t\ttmp[1][index] = tmp[2][index]\n\t\t\t\
    -- Remove number from the right place\n\t\t\t-- assert(tmp[2][index] == nil)\n\
    \t\t\ttmp[2][index] = tmp[1]\n\t\tend\n\tend\n\t-- Return the sorted array\n\t\
    -- assert(tmp[1] == nil)\n\t-- assert(tmp[2] == nil)\n\t\n\treturn unpack(arr,\
    \ 2, 1)\nend", "  -- Write your sorting code here\n  -- It can be optimized if\
    \ you use \"table\" instead of \"count\"\n  local table = {}\n  local count =\
    \ {}\n  for i = 1, #arr do\n    table[ math.abs(arr[i]) ] = table[ math.abs(arr[i])\
    \ ] + 1\n    count[ table[ math.abs(arr[i]) ] ] = count[ table[ math.abs(arr[i])\
    \ ] ] + 1\n  end\n  table.sort(function(x,y)\n    local count = 0\n    for k,\
    \ v in pairs(count) do\n      if v > 0 then\n        break\n      end\n      count\
    \ = count + 1\n    end\n    if x > y then\n      return 1\n    elseif x < y then\n\
    \      return -1\n    else\n      if count == 1 then\n        return 1\n     \
    \ else\n        return count\n      end\n    end\n  end)\n  -- Return sorted array\n\
    \  return arr\nend", "    local n = 1\n    for i = #arr, 1, -1 do\n        n =\
    \ n * 2\n        if n == 1 then\n            n = n + 1\n        end\n        if\
    \ arr[i-1] == 1 then\n            return arr[i]\n        end\n    end\nend", " \
    \ -- write your code here\n  local counts={}\n  for i=1,#arr do\n    if counts[#counts]==nil\
    \ then counts[#counts]=1 end else\n      counts[#counts]=counts[#counts]+1\n \
    \   end\n  end\n  local res={}\n  for i=1,#arr do\n    if counts[arr[i]]==1 then\
    \ table.insert(res,arr[i]) end\n  end\n  table.sort(res)\n  return res\nend",
  "    local function count_ones(x)\n        local n = 0\n        while x ~= 0 do\n\
    \            n = n + (x % 2)\n            x = x / 2\n        end\n        return\
    \ n\n    end", "  -- base case\n  if #arr == 1 then\n    return arr\n  end", " \
    \   local n = #arr\n    local res1, res2, res3, res4 = 0, 0, -1, 0\n    for i\
    \ = 2, n do\n        local count = 0\n        if arr[i] > 0 then count = count\
    \ + 1 end\n        if arr[i] > 1 then count = count + 1 end\n        if arr[i]\
    \ > 2 then count = count + 1 end\n        if arr[i] > 3 then count = count + 1\
    \ end\n        \n        -- If count is same, than we assume that number is in\
    \ ascending order.\n        if count == n then\n            if arr[i] > res1 then\
    \ res1 = arr[i] end\n        end\n        \n        -- If count is less than n,\
    \ than we assume that number is in descending order.\n        if count < n then\n\
    \            if arr[i] > res2 then res2 = arr[i] end\n        end\n        \n\
    \        -- If count is more than n, than we assume that number is in ascending\
    \ order.\n        if count > n then\n            if arr[i] > res3 then res3 =\
    \ arr[i] end\n        end\n        \n        -- If count is less than n, than\
    \ we assume that number is in descending order.\n        if count > n then\n \
    \           if arr[i] > res4 then res4 = arr[i] end\n        end\n    end\n  \
    \  \n    if res1 > res2 then res1, res2 = res2, res1 end\n    if res3 > res4 then\
    \ res3, res4 = res4, res3 end\n    \n    if res1 < res2 then res1, res2 = res2,\
    \ res1 end\n    if res3 < res4 then res3, res4 = res4, res3 end\n    \n    return\
    \ res1, res2, res3, res4\nend", "    assert(type(arr) == \"table\", \"Input parameter\
    \ must be an array\")\n    local num_ones = 0\n    local decimal_val\n    for\
    \ _, x in pairs(arr) do\n        if x ~= 0 then\n            num_ones = num_ones\
    \ + 1\n            decimal_val = decimal_val * 10 + math.floor(x)\n        end\n\
    \    end\n    if num_ones == 1 then\n        table.sort(arr)\n    else\n     \
    \   table.sort(arr, function(a, b) \n            local a_val = decimal_val\n \
    \           local b_val = decimal_val\n            decimal_val = 0\n         \
    \   if a > b then\n                local tmp = a\n                a = b\n    \
    \            b = tmp\n            end\n            if a == 0 and b == 0 then\n\
    \                decimal_val = math.floor(math.abs(math.ceil(a_val) - math.ceil(b_val)))\n\
    \            else\n                decimal_val = math.floor(math.abs(math.ceil(a_val)\
    \ - math.ceil(b_val)))\n            end\n            if a < b then\n         \
    \       return -1\n            else\n                return 1\n            end\n\
    \        end)\n    end\nend\nprint(table.concat(sort_array(arr), \" \"))\n</code>\n\
    Output:\n<code>\n466 610 616 617 618 619 620 621 623 625 626 627 628 629 631 632\
    \ 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 649 650 651 652\
    \ 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671\
    \ 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690\
    \ 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709\
    \ 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728\
    \ 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747\
    \ 748 749 750 751 752 753 754 755 756 757 758 759", "  -- Write your code here.\n\
    end", "  -- Write your code here.\n  return arr\nend", "    if #arr == 0 then\
    \ return arr end\n    local n = #arr - 1\n    local t = 0\n    local k = nil\n\
    \    local tt = nil\n    local p = 1\n    local m = 1\n    local b = 0\n    local\
    \ i = 0\n    local j = 1\n    local s = 0\n    while i < n do\n        if k ~=\
    \ nil and tt ~= nil and k ~= t and tt ~= t then\n            -- The array is sorted,\
    \ so break the loop.\n            -- k = number of ones in binary representation\
    \ of t\n            -- tt = decimal value of t\n            break\n        end\n\
    \        i = i + 1\n        t = 0\n        k = nil\n        b = 0\n        while\
    \ i <= n do\n            local m = math.floor(i*p)\n            if arr[m] == 1\
    \ then\n                k = k + b\n                t = t + m\n               \
    \ i = i\n            end\n            i = i + 1\n        end\n        -- If k\
    \ == nil and tt == nil, this means all elements are one and the\n        -- array\
    \ is sorted. Otherwise, either k < t or tt < t.\n        if k ~= nil and tt ~=\
    \ nil then\n            if k > t then\n                -- The array is sorted,\
    \ so break the loop.\n                -- t = decimal value of t\n            \
    \    break\n            elseif tt > t then\n                -- The array is sorted,\
    \ so break the loop.\n                -- t = decimal value of t\n            \
    \    break\n            end\n        end\n        if k ~= nil then\n         \
    \   -- k = number of ones in binary representation of t\n            -- s = number\
    \ of decimal zeros places in binary representation of t\n            -- t = decimal\
    \ value of t\n            j = k\n            while j <= n do\n               \
    \ arr[t] = arr[t] + arr[j] -- t = decimal value of t\n                arr[j] =\
    \ arr[j] - 1 -- t = decimal value of t\n                j = j + 1\n          \
    \  end\n            i = i + 1\n        end\n        if tt ~= nil then\n      \
    \      j = s\n            while j <= n do\n                arr[t] = arr[t] + arr[j]\
    \ -- t = decimal value of t\n                arr[j] = arr[j] - 1 -- t = decimal\
    \ value of t\n                j = j + 1\n            end\n            i = i +\
    \ 1\n        end\n    end\n    return arr\nend", "    local sorted_array = { }\n\
    \    local index\n    local temp\n    local i = 1\n    while i <= #arr do\n  \
    \      -- If we have two consecutive 1s, we compare their decimal values.\n  \
    \      -- If they are equal, we don't need to do anything.\n        if index ==\
    \ nil then\n            index = i\n            -- We have to stop searching when\
    \ we have two consecutive 1s.\n            if arr[i] == 1 and arr[i + 1] == 1\
    \ then\n                i = i + 1\n            else\n                index = nil\n\
    \            end\n        elseif arr[i] == 1 and arr[i + 1] == 1 then\n      \
    \      -- We have to compare their decimal values.\n            -- If they are\
    \ equal, we have to compare their decimal values.\n            if arr[index] >\
    \ arr[i] then\n                temp = arr[i]\n                arr[i] = arr[index]\n\
    \                arr[index] = temp\n            end\n            i = i + 1\n \
    \       else\n            index = nil\n        end\n        table.insert(sorted_array,\
    \ arr[i])\n        i = i + 1\n    end\n    return sorted_array\nend", '  local
    counts = { }', "    local function compare(x, y) return (x > y) and (x - y) or\
    \ (x < y) and (y - x) end\n    table.sort(arr, compare)\nend", "  -- sort descending\n\
    \  arr.sort(function(x, y)\n      return x > y then\n          -1 * #x + y\n \
    \     else\n          x\n      end\n  end)\n  -- sort with one\n  for i = 1, #arr\
    \ do\n    if arr[i] then\n      arr[i], arr[#arr+i] = 1\n    end\n  end\nend",
  "    return arr\nend", "  -- First, sort the array based on number of ones.\n  local\
    \ sorted_arr = {}\n  local cnt = 0\n  for i = 1, #arr do\n    if arr[i] > 0 then\n\
    \      table.insert(sorted_arr, arr[cnt])\n      cnt = cnt + 1\n    else\n   \
    \   cnt = 0\n    end\n  end", "    local count = 0\n    for i = 1, #arr do\n \
    \       if arr[i] == 1 then\n            count = count + 1\n        end\n    end\n\
    \    if count == 1 then\n        for i = 1, #arr do\n            arr[i], arr[count]\
    \ = arr[count], arr[i]\n        end\n        table.sort(arr,\n            function\
    \ (a, b)\n                if a == 1 then return -1 end\n                if b ==\
    \ 1 then return 1 end\n                -- Sort based on decimal value here.\n\
    \                return tonumber(string.format(\"%2.10f\", a / b))\n         \
    \   end\n        )\n    else\n        table.sort(arr,\n            function (a,\
    \ b)\n                -- Sort based on decimal value here.\n                return\
    \ tonumber(string.format(\"%2.10f\", a / b))\n            end\n        )\n   \
    \     for i = 1, #arr do\n            arr[i], arr[count] = arr[count], arr[i]\n\
    \        end\n    end\n    return arr\nend", "  return arr\nend", "  -- If there\
    \ are few ones, return array sorted by decreasing value.\n  if #arr <= 1 then\n\
    \    return arr\n  end", "    local arr_size = #arr\n    local arr_ones = {}\n\
    \    local arr_zeros = {}\n    for idx = 1, arr_size do\n        local ones =\
    \ tonumber(string.sub(arr[idx], 1, 1))\n        local zeros = tonumber(string.sub(arr[idx],\
    \ 2, 2))\n        if ones > 0 then\n            table.insert(arr_ones, idx)\n\
    \        end\n        if zeros > 0 then\n            table.insert(arr_zeros, idx)\n\
    \        end\n    end\n    table.sort(arr_ones)\n    table.sort(arr_zeros)\n \
    \   local results = {}\n    for idx = 1, arr_size do\n        if arr_ones[idx]\
    \ == arr_zeros[idx] then\n            results[arr_ones[idx]] = arr_zeros[idx]\n\
    \        else\n            results[arr_zeros[idx]] = arr_ones[idx]\n        end\n\
    \    end\n    return results\nend", "    local n = 0\n    local i = 0\n    local\
    \ l = #arr", "    local counts = {}\n    for i=1,#arr do\n        counts[#counts+1]\
    \ = i\n    end\n    counts = counts[#counts]\n    table.sort(counts, function(a,\
    \ b) return counts[a] - counts[b] end)\n    local i = 0\n    for i=#counts,1,-1\
    \ do\n        arr[i] = counts[i]\n    end\nend", "  -- Count the number of ones\n\
    \  local num_ones = terralib.newsymbol(int64, \"num_ones\")\n  -- Number of ones\
    \ in the elements of the array\n  local num_ones_product = arr:map(function(x)\
    \ return x * 2 end):reduce(function(p, c) p + c end)\n  -- How many times a number\
    \ appears\n  local num_times = terralib.newsymbol(uint64, \"num_times\")\n  --\
    \ Count the number of times a number appears\n  local num_times_product = arr:map(function(x)\
    \ return 1 end):reduce(function(p, c) p + c end)\n  -- Compute the number of ones\n\
    \  num_ones:set(num_ones_product)\n  -- Compute the number of times\n  num_times:set(num_times_product)\n\
    \  -- Compute a mask with zeros and ones to sort with\n  local mask = data.newtuple(num_ones_product)\n\
    \  for i = 0, num_ones_product, 1 do\n    mask[i] = 1\n  end\n  -- Sort the array\
    \ based on the mask\n  local tmp = data.newtuple(2, num_ones_product)\n  mask:foreach(function(_,\
    \ i)\n    if mask[i] == 1 then\n      tmp[1]:set(arr[i])\n      tmp[2]:set(1)\n\
    \    end\n  end)\n  -- Select the ones\n  local ones = tmp[1]:index(0, tmp[2])\n\
    \  -- Return the sorted array\n  return arr:map(function(x) return x * 2 - ones\
    \ + mask[x] end):sort()\nend", "\t-- Write your code here\n\t--return arr\nend",
  "  -- TODO: Your code here.\n  return arr\nend", "  return arr\nend", "    local\
    \ sorted_array = {}\n    local num_ones = 0\n    for i = 1, #arr do\n        local\
    \ val = arr[i]\n        if val > 0 then\n            num_ones = num_ones + 1\n\
    \        end\n    end\n    local decimal_val = num_ones\n    while decimal_val\
    \ > 0 do\n        local binary_val = 1\n        for i = 1, decimal_val do\n  \
    \          binary_val = binary_val * 2\n        end\n        for i = 1, #arr do\n\
    \            local val = arr[i]\n            if val > 0 and binary_val == binary_val\
    \ then\n                sorted_array[#sorted_array + 1] = val\n              \
    \  decimal_val = decimal_val - 1\n                break\n            end\n   \
    \     end\n    end\n    return sorted_array\nend", "    return ...\nend", "  --\
    \ Write your code here.\nend", "    return arr\nend", "   -- write your code here\n\
    end", "  local tmp = arr[1]\n  arr[1] = arr[2]\n  arr[2] = tmp", "   -- Your code\
    \ goes here\nend", "    local num_ones = #(arr:gsub(\"1\", \"0\")) + 1\n    local\
    \ function is_equal(n1, n2)\n        return n1 == n2 and \"string\" == type(n1)\
    \ and \"string\" == type(n2)\n    end\n    return table.sort(\n        arr,\n\
    \        function(n1, n2)\n            -- Sort by number of ones\n           \
    \ local num_ord1 = num_ones\n            local num_ord2 = num_ones\n         \
    \   if num_ord1 < num_ord2 then\n                num_ord1 = num_ord2 - num_ord1\n\
    \            end", '    local sorted_array = arr.new()', "    -- your implementation\n\
    \    return arr\nend", "    local cnt=0\n    local sort_tbl={}\n    for _,i in\
    \ ipairs(arr) do\n        if cnt==0 then\n            sort_tbl[i]=1\n        \
    \    cnt=1\n        elseif cnt==1 then\n            sort_tbl[i]=2*sort_tbl[i-1]\n\
    \            cnt=0\n        else\n            sort_tbl[i]=3*sort_tbl[i-1]+2*sort_tbl[i-2]\n\
    \            cnt=cnt-1\n        end\n    end\n    return sort_tbl\nend", "   --\
    \ arr is an array of non-negative integers\n   -- return an sorted version of\
    \ arr in ascending order\n   -- e.g. sort_array([1,3,5,-3]) should return [-3,5,1,3]\n\
    \   -- Hint: use binary string representation\n   return arr\nend", "  -- The\
    \ return array\n  local ret = {}", "    if not arr then return nil end\n    local\
    \ n = #arr\n    local m = 2^n\n    local t\n    local i, j, k\n    local t = arr[1]\n\
    \    i = 2\n    for j = 2, m do\n        if t < arr[j] then\n            t = arr[j]\n\
    \            k = j\n        end\n        i = i + 1\n    end\n    return k, arr[k],\
    \ i\nend\n</cell>\n<cell>", "  if #arr < 1 then return end\n  local i = 1\n  local\
    \ j = 1\n  while i < #arr and arr[i] > 0 do\n    j = i\n    while j ~= #arr do\n\
    \      if arr[i] > 0 and arr[j] == 0 then\n        arr[i], arr[j] = arr[j], arr[i]\n\
    \      end\n      if arr[i] == 0 and arr[j] > 0 then\n        arr[i], arr[j] =\
    \ arr[j], arr[i]\n      end\n      if arr[j] == 0 and arr[i] > 0 then\n      \
    \  arr[i], arr[j] = arr[j], arr[i]\n      end\n      i = i + 1\n      j = j +\
    \ 1\n    end\n  end\n  return arr\nend", "  -- Write your code here\n  return\
    \ arr\nend\nprint(sort_array([9, 1, 6, 4, 2]))", "  return function (a, b)\n \
    \   -- first count number of ones in each element\n    local count_ones = map_array(function\
    \ (item)\n      return (item == 1)\n    end,arr)\n    count_ones = count_ones[1]\n\
    \    -- then sort according to count_ones\n    local sort_func1 = function (a,\
    \ b)\n      if count_ones[a] ~= count_ones[b] then\n        return count_ones[a]\
    \ - count_ones[b]\n      else\n        return a < b\n      end\n    end\n    --\
    \ then sort according to decimal value\n    local sort_func2 = function (a, b)\n\
    \      if count_ones[a] == count_ones[b] then\n        return a - b\n      else\n\
    \        return count_ones[a] - count_ones[b]\n      end\n    end\n    -- then\
    \ sort according to their decimal values\n    return sort_func1(sort_func2(a,\
    \ b))\n  end\nend", "    local sorted_arr = {}\n    local count_one = {}\n   \
    \ for i, el in ipairs(arr) do\n        count_one[i] = 1\n    end", "  -- sorts\
    \ array in ascending order by number of ones in its binary representation\n  --\
    \ assumes integers are represented with N bits (N <= 32)\n  -- assumes N is power\
    \ of 2\n  local pow2N = 1\n  while pow2N < #arr do\n    pow2N = pow2N * 2\n  end",
  "  return arr\nend", "   -- If given array has zero elements, return it.\n   if\
    \ #arr == 0 then\n      return arr\n   end", "    return arr\nend", "    return\
    \ arr -- TODO: implement this function\nend", "    local sorted = {}\n    local\
    \ i = 0\n    local j = arr.length - 1\n    while i < j do\n        local max_ones\
    \ = 0\n        local max_dec = 0\n        local cur_ones = 0\n        local cur_dec\
    \ = 0\n        for n = i, j do\n            local bin = bin(i)\n            local\
    \ x = bin:len()\n            cur_ones = cur_ones + (x % 2)\n            i = math.floor(i\
    \ / 2)\n            if x % 2 ~= 0 then\n                bin = bin.sub(1, x)\n\
    \            else\n                bin = bin.sub(1)\n            end\n       \
    \     -- Decimal part\n            if bin:len() > max_dec then\n             \
    \   max_dec = bin:len()\n            end\n            -- Count ones\n        \
    \    if bin:len() > max_ones and bin:find(\"1\") ~= nil then\n               \
    \ max_ones = bin:len()\n            end\n        end\n        if max_ones == 0\
    \ then\n            sorted[i] = arr[max_dec]\n            i = i + 1\n        elseif\
    \ max_dec > j then\n            sorted[i] = arr[max_dec]\n            i = i +\
    \ 1\n        else\n            sorted[i] = arr[max_dec]\n            i = i + 1\n\
    \            j = j - 1\n        end\n    end\n    return sorted\nend", "   local\
    \ function get_bit(v, i)\n      -- i represents index of element in arr\n    \
    \  -- v represents arr[i]\n      -- if v is 1, then the index of bit in decimal\
    \ is 2^i\n      -- (2^0 = 1, 2^1 = 2, 2^2 = 4, 2^3 = 8...)\n      return math.pow(2,i)*v\n\
    \   end\n   -- if there are more ones in the arr than there are unique bits in\
    \ their decimal value\n   -- (ex. {1, 1, 0, 0, 0} -> {0, 1, 1, 0, 0}), then return\
    \ false\n   -- if there are more ones in the arr than there are unique bits in\
    \ their decimal value\n   -- (ex. {1, 1, 1, 0, 0, 0} -> {1, 1, 1, 1, 1, 0})\n\
    \   -- then return false\n   -- if there are more ones in the arr than there are\
    \ unique bits in their decimal value\n   -- (ex. {1, 0, 0, 1, 1, 0} -> {1, 1,\
    \ 1, 1, 0, 0})\n   -- then return false\n   -- otherwise, return true\n   local\
    \ function has_duplicates(arr)\n      -- since there are more ones in the arr\
    \ than there are unique bits in their decimal value,\n      -- the result of the\
    \ next two ifs is always true\n      local function has_duplicate_helper(arr,\
    \ len)\n         if len == 0 then\n            return false\n         elseif len\
    \ == 1 then\n            return arr[len] == arr[len+1]\n         else\n      \
    \      -- the first if checks if there is only one unique bit, which is impossible\n\
    \            -- in our case\n            -- the second if checks if there are\
    \ more than 2 unique bits\n            return arr[len] == arr[len+1] or\n    \
    \               (arr[len] == arr[len+2] and\n                    has_duplicate_helper(arr,\
    \ len-1))\n         end\n      end\n      return has_duplicate_helper(arr, #arr)\n\
    \   end\n   -- if there are more ones in the arr than there are unique bits in\
    \ their decimal value\n   -- (ex. {1, 1, 0, 0, 0} -> {0, 1, 1, 0, 0}), then return\
    \ false\n   -- if there are more ones in the arr than there are unique bits in\
    \ their decimal value\n   -- (ex. {1, 1, 1, 0, 0, 0} -> {1, 1, 1, 1, 1, 0})\n\
    \   -- then return false\n   -- if there are more ones in the arr than there are\
    \ unique bits in their decimal value\n   -- (ex. {1, 0, 0, 1, 1, 0} -> {1, 1,\
    \ 1, 1, 0, 0})\n   -- then return false\n   -- otherwise, return true\n   local\
    \ function has_duplicate_sort(arr)\n      -- since there are more ones in the\
    \ arr than there are unique bits in their decimal value,\n      -- the result\
    \ of the next two ", "  local arr_size = 1\n  for _, el in ipairs(arr) do\n  \
    \  arr_size = arr_size * el\n  end\n  arr = arr:byte()\n  local zeros = 0\n  local\
    \ ones = 0\n  for _, el in ipairs(arr) do\n    if el == 0 then\n      zeros =\
    \ zeros + 1\n    elseif el == 1 then\n      ones = ones + 1\n    end\n  end\n\
    \  assert(arr_size == ones + zeros)\n  if ones < zeros then\n    local sort =\
    \ function (a, b)\n      if a < b then\n        return -1\n      elseif a > b\
    \ then\n        return 1\n      else\n        return 0\n      end\n    end\n \
    \   table.sort(arr, sort)\n  end\n  return arr\nend", "    local n = #arr\n  \
    \  local m = {}\n    for i = 1, n do\n        local pos = 0\n        local cnt\
    \ = 0\n        for j = 1, n do\n            if arr[j] == 1 then\n            \
    \    cnt = cnt + 1\n                pos = j\n            end\n        end\n  \
    \      if cnt > 1 then\n            m[pos] = arr[pos]\n        else\n        \
    \    local k = math.floor(n / 2)\n            for j = k, n do\n              \
    \  if arr[j] > m[k] then\n                    k = j\n                end\n   \
    \         end\n            m[k] = arr[pos]\n        end\n    end\n    table.sort(m)\n\
    \    return m\nend", "  local count = 0\n  local result = {}\n  local pos = nil\n\
    \  for i = #arr, 1, -1 do\n    if arr[i] == 1 then\n      count = count + 1\n\
    \      if not pos then\n        pos = i\n      end\n    elseif arr[i] == 0 then\n\
    \      count = count - 1\n      if count < 0 then\n        -- At this point, we\
    \ found a zero, but no ones before it.\n        -- This means, we can stop and\
    \ insert this number in the result table.\n        result[#result + 1] = arr[pos]\n\
    \        pos = nil\n      else\n        -- If the number of ones equals zero,\
    \ insert the number in the result table.\n        -- This will be the first element\
    \ in the result array.\n        result[#result] = arr[pos]\n      end\n    end\n\
    \  end\n  if #result > 1 then\n    result[#result - 1] = arr[pos]\n  end\n  return\
    \ result\nend", "  local n = #arr\n  if n <= 1 then return arr end\n  -- The first\
    \ element is zero, sort it after descending number of ones.\n  if n == 2 then\
    \ return arr .. {-arr[1], arr[1]} end\n  -- Sort the remaining elements.\n  local\
    \ tmp = arr:sub(1,n-1):sort()\n  -- The first element is number of ones in binary\
    \ representation of the first element.\n  local f1 = tonumber(string.format(\"\
    %b\",arr[1]))\n  -- The last element is number of ones in binary representation\
    \ of the last element.\n  local f2 = tonumber(string.format(\"%b\",arr[n]))\n\
    \  -- Get the decimal representation of\n  -- number of ones in binary representation\
    \ of the first element\n  local d1 = tonumber(string.format(\"%b\",tmp[1]))\n\
    \  -- Get the decimal representation of\n  -- number of ones in binary representation\
    \ of the last element\n  local d1 = tonumber(string.format(\"%b\",tmp[n]))\n \
    \ -- Return an array containing both elements,\n  -- sorted by number of ones\
    \ in ascending order and decimal value.\n  return arr .. {f1,f2,d1,d2}\nend",
  "   -- arr is an array of non-negative integers \n   -- sort arr according to number\
    \ of ones in their binary representations\n   -- return sorted arr\nend", "  \
    \  local n = #arr\n    assert(n >= 0 and n ~= 0, \"The array to be sorted has\
    \ invalid size\")", "    local sort_fun = function(a, b) return a > b end\n  \
    \  local sort_fun_abs = function(a, b) return math.abs(a) > math.abs(b) end",
  "  -- Write your code here\n  return nil\nend", "    local tmp = {}\n    local result\
    \ = 0\n    for idx = 1,#arr do\n        local bin = bit.lshift(bit.rshift(arr[#arr],\
    \ (idx-1)), idx)\n        local tmp = bin\n        if bin == 1 then\n        \
    \    tmp = result % 100\n            result = result / 100\n        end\n    \
    \    arr[#arr] = tmp\n    end\n    return arr\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a |>\nThe answer by ninja is great.\nI modified it to work for an array containing\
    \ negative integers or zeros.\n<code>", "\t-- Solution 1:\n\t-- Iterate through\
    \ the array and create an array of zeros and ones,\n\t-- then sort those arrays.\n\
    \t-- It must be implemented like this:\n\t-- local binmap = {}\n\t-- local binarr\
    \ = {}\n\t-- -- Loop through the array.\n\t-- -- Iterate through the array, count\
    \ the ones, store that count in binmap.\n\t-- -- When you find one that is greater\
    \ than 0, increment the count in binmap.\n\t-- -- When you find one that is less\
    \ than 0, decrement the count in binmap.\n\t-- -- When you reach zero, store the\
    \ count in binarr.", "    local arr2 = {}\n    for i=1,#arr do\n        if arr[i]\
    \ == 1 then\n            arr2[i] = arr[i]\n        else\n            arr2[i] =\
    \ arr[i]\n        end\n    end\n    table.sort(arr2, function(a, b) return a.value\
    \ < b.value end)\n    return arr2\nend", "  local tmp = make_array(0)\n  local\
    \ cnt = make_array(0)\n  local len = #arr\n  for i=0,len-1 do\n    cnt[arr[i]]\
    \ = cnt[arr[i]] + 1 if arr[i] ~= 0 end\n    tmp = tmp + arr[i]\n  end\n  table.sort(tmp,\
    \ compare_func)\n  local sortedTable = make_array(0)\n  for i=0,len-1 do\n   \
    \ sortedTable[#sortedTable + 1] = arr[tmp + i]\n    arr[tmp + i] = 0\n  end\n\
    \  for i=0,len-1 do\n    arr[tmp + i] = arr[len-i-1] + cnt[arr[len-i-1]]\n  end\n\
    \  arr[len] = tmp\n  return sortedTable\nend", "    local temp = {}\n    for i\
    \ = 1, #arr do\n        local bin = bit.rshift(arr[i], 32)\n        for j = 0,\
    \ 32 do\n            -- If the last bits are not all 1, insert a new entry\n \
    \           if bit.band(bin, 1 << j) == 0 then\n                table.insert(temp,\
    \ i)\n                i = i + 1\n                break\n            end\n    \
    \    end\n    end\n    table.sort(temp, function(t1, t2)\n        local sum =\
    \ 0\n        local count = 0\n        for i = 1, 32 do\n            -- Count ones\
    \ in binary representation of number\n            sum = sum + arr[t1][i] > 0 and\
    \ 1 or 0\n            count = count + arr[t1][i]\n        end\n        -- Compare\
    \ number with binary representation of number\n        return sum and count and\
    \ sum > count or sum < count or sum == count\n    end)\n    return table.remove_by_ref(arr,\
    \ unpack(temp))\nend", "   local i = 0\n   local n = #arr\n   while i < n do\n\
    \      local ones = 0\n      for j = i, #arr do\n         if arr[j] == 1 then\n\
    \            ones = ones + 1\n            if ones > 0 then\n               break\n\
    \            end\n         end\n      end\n      if ones <= 0 then\n         return\
    \ i - 1\n      else\n         i = i + 1\n      end\n   end\n   return i\nend",
  "    local t = {}\n    local tt = {}\n    local i = 1\n    for k in pairs(arr) do\n\
    \        t[i] = 1\n        if arr[k] == 1 then\n            table.insert(tt, k)\n\
    \        end\n        i=i+1\n    end\n    table.sort(tt, function(a,b)\n     \
    \   return arr[a]<arr[b] or arr[a]<=1\n    end)\n    for k,v in pairs(tt) do\n\
    \        t[k] = arr[v]\n    end\n    return t\nend", "    if #arr == 0 then\n\
    \        return arr\n    end", "  -- Write your code in here. ~~~~\nend", "  local\
    \ n = 0\n  -- Use a table to store a reverse mapping from value to index.\n  --\
    \ This helps us to avoid repeating values.\n  local mapping = {}\n  -- Store a\
    \ reverse mapping from index to value.\n  -- This helps us to avoid repeating\
    \ indexes.\n  local reverse_index = {}\n  for i = 1, #arr do\n    local value\
    \ = tonumber(arr[i])\n    -- If the value exists already, then ignore this value.\n\
    \    -- Otherwise, set its mapping index.\n    if mapping[value] ~= nil then n\
    \ = n + 1 end\n    mapping[value] = i\n    -- Use index to store the reverse value.\n\
    \    reverse_index[#reverse_index + #arr + value] = i\n  end\n  -- Sort the array.\n\
    \  for i = 2, #arr do\n    local j\n    -- Find the index of the element with\
    \ the fewest ones.\n    -- Note that in the following line, if we use i-1, then\
    \ we need to use\n    -- `#reverse_index` in order to access `mapping`.\n    j\
    \ = #reverse_index - #arr + #mapping\n    -- If the number of ones in this number\
    \ is the same, then sort the array\n    -- based on the decimal value.\n    if\
    \ n > j or n == j then\n      for k = 1, (j - 1) do\n        arr[k] = reverse_index[#arr\
    \ + k - 1]\n      end\n      n = j\n    end\n    -- Set the next value to sort\
    \ the array based on the number of ones.\n    j = #reverse_index + #arr + #mapping\
    \ + 1\n    mapping[arr[j]] = j\n  end\nend", "  local result = {}\n  local size\
    \ = #arr\n  local count = {}\n  for i = 1, size do\n    if count[tostring(arr[i])]\
    \ == nil then\n      count[tostring(arr[i])] = 1\n      result[#result+1] = arr[i]\n\
    \    else\n      count[tostring(arr[i])] = count[tostring(arr[i])] + 1\n    end\n\
    \  end\n  for i = 1, size do\n    if count[tostring(arr[i])] > 1 then\n      table.sort(result,\
    \ function (a, b) return sort_number(a) < sort_number(b) end)\n      break\n \
    \   end\n  end\n  return result\nend", "    return arr\nend", "    local counts\
    \ = count_ones(arr)\n    local sorted\n    for i=1,#counts do\n        if counts[i]\
    \ < counts[i+1] then\n            sorted = true\n        end\n    end\n    if\
    \ not sorted then\n        sorted = true\n        for i=1,#counts do\n       \
    \     if counts[i] > counts[i+1] then\n                sorted = false\n      \
    \          break\n            end\n        end\n    end\n    if not sorted then\n\
    \        sorted = true\n        for i=1,#counts do\n            if counts[i] ==\
    \ counts[i+1] then\n                sorted = false\n                break\n  \
    \          end\n        end\n    end\n    if not sorted then\n        sorted =\
    \ true\n        for i=1,#counts do\n            if counts[i] < counts[i+1] then\n\
    \                sorted = false\n                break\n            end\n    \
    \    end\n    end\n    if not sorted then\n        sorted = true\n        for\
    \ i=1,#counts do\n            if counts[i] <= counts[i+1] then\n             \
    \   sorted = false\n                break\n            end\n        end\n    end\n\
    \    if not sorted then\n        sorted = true\n        for i=1,#counts do\n \
    \           if counts[i] < counts[i+1] then\n                sorted = false\n\
    \                break\n            end\n        end\n    end\n    if not sorted\
    \ then\n        sorted = true\n        for i=1,#counts do\n            if counts[i]\
    \ < counts[i+1] then\n                sorted = false\n                break\n\
    \            end\n        end\n    end\n    if not sorted then\n        sorted\
    \ = true\n        for i=1,#counts do\n            if counts[i] <= counts[i+1]\
    \ then\n                sorted = false\n                break\n            end\n\
    \        end\n    end\n    if not sorted then\n        sorted = true\n       \
    \ for i=1,#counts do\n            if counts[i] <= counts[i+1] then\n         \
    \       sorted = false\n                break\n            end\n        end\n\
    \    end\n    if not sorted then\n        sorted = true\n        for i=1,#counts\
    \ do\n            if counts[i] > counts[i+1] then\n                sorted = false\n\
    \                break\n            end\n        end\n    end\n    if not sorted\
    \ then\n        sorted = true\n        for i=1,#counts do\n            if counts[i]\
    \ < counts[i+1] then\n                sorted = false\n                break\n\
    \            end\n        end\n    end\n    if not sorted then\n        sorted\
    \ = true\n        for i=1,#counts do\n            if counts[i] <= counts[i+1]\
    \ then\n                sorted = false\n                break\n            end\n\
    \        end\n    end\n    if not sorted then\n        sorted = true\n       \
    \ for i=1,#counts do\n            if counts[i] > count", "    return arr\nend",
  "  -- We create a temp array to hold the result\n  -- because table.sort needs to\
    \ sort\n  -- it in-place\n  local temp = {}\n  for i = 0, #arr - 1 do\n    table.insert(temp,\
    \ \"\")\n    -- We create an array with zero-width characters\n    -- which would\
    \ store the number in binary\n    table.insert(temp, table.new()\n      -- We\
    \ loop over all zero-width characters\n      -- and set them to 1\n      for j\
    \ = 0, 8 do\n\t-- And we only consider those that are ones\n\tif arr[i] == 1 then\n\
    \t  table.insert(temp[j], 1)\n\tend\n      end\n    )\n  end\n  -- We sort the\
    \ temp array\n  table.sort(temp)\n  -- We return array of result\n  -- since we\
    \ can't sort in-place\n  return temp\nend", "  if #arr <= 1 then return arr end\n\
    \  local result = {}\n  local result2 = {}\n  local index = 1\n  local index2\
    \ = 1\n  while index < #arr do\n    result[index] = arr[index]\n    if result[index]\
    \ == 1 then result2[index2] = arr[index] else result2[index2] = result[index]\
    \ / result[index] end\n    index = index + 1\n    index2 = index2 + 1\n  end\n\
    \  for i = #arr to 2 do\n    result[i] = result2[i]\n  end\n  return result\n\
    end", "   -- Your code here\nend", "  assert(#arr >= 1, \"Array is empty\")\n\
    \  local bins = {}\n  for i = 1, #arr do\n    bins[i] = #bins + tostring(math.ceil(arr[i]\
    \ / 2.0))\n  end\n  return table.sort(bins, function(a, b)\n    return a < b\n\
    \  end)\nend", "    local n = #arr\n    table.sort(arr,\n        function (x,\
    \ y)\n            if x == 0 and y == 0 then\n                return 0\n      \
    \      elseif x == 0 and y == 1 then\n                return 1\n            elseif\
    \ x == 1 and y == 0 then\n                return -1\n            else\n      \
    \          return x > y ? 1 : -1\n            end\n        end)\nend", "    local\
    \ counter = { }\n    local index = 0 \n    \n    -- Initialize counter for binary\
    \ arrays\n    for i = 1, #arr do\n        if arr[i] > 0 then\n            counter[i]\
    \ = 1\n        else\n            counter[i] = 0\n        end\n    end\n    \n\
    \    -- Sort array based on number of ones\n    while #counter > 1 do\n      \
    \  -- Find minimum element in counter\n        local min_idx = 1\n        local\
    \ min_val = counter[min_idx]\n        for i = 1, #counter do\n            if counter[i]\
    \ > min_val then\n                min_val = counter[i]\n                min_idx\
    \ = i\n            end\n        end\n        \n        -- Increment counter by\
    \ one\n        counter[min_idx] = counter[min_idx] + 1\n        \n        -- Move\
    \ all values lower than current min_val to right\n        for i = 1, #counter\
    \ do\n            if counter[i] > min_val then\n                counter[i] = counter[i]\
    \ - 1\n            end\n        end\n    end\n    \n    -- Copy arr into sorted\
    \ array\n    for i = 1, #arr do\n        arr[i] = counter[i]\n    end\nend", " \
    \ local arr2 = {}\n  for i = 1, #arr do\n    arr2[i] = {}\n    for j = 1, #arr[i]\
    \ do\n      arr2[i][j] = arr[i][j]\n    end\n  end\n  table.sort(arr2, function(a,\
    \ b) return a[1] < b[1] end)\n  local arr3 = {}\n  for i = 1, #arr2 do\n    arr3[i]\
    \ = {}\n    for j = 1, #arr2[i] do\n      arr3[i][j] = arr2[i][j]\n    end\n \
    \ end\n  return arr3\nend", "    local a = {}\n    local n = 0", "  -- TODO: Implement\
    \ me!\nend", "    local sorted_arr = {}\n    for i, value in ipairs(arr) do\n\
    \        sorted_arr[i] = value\n    end\n    table.sort(sorted_arr, function(a,\
    \ b) return math.floor(a/b) end)\n    return sorted_arr\nend", "  -- Return the\
    \ array of sorted integers\n  -- Sort array is ascending order based on number\
    \ of ones in its binary representation\n  -- Use recursion to sort array recursively",
  "  -- Your code here\n  return arr\nend", "  -- Write your code here.\nend", " \
    \ -- Count the number of ones in the binary representation of number:\n  -- (This\
    \ can be done by XORing each number with its reverse complement)\n  -- Return\
    \ the array sorted by number of ones\n  -- This can also be done using BitIntFunction.\n\
    \  -- (This can also be done by XORing each number with its reverse complement,\n\
    \  -- and counting the number of zeros -- but this takes more time -- O(n^2)\n\
    \  -- and requires more RAM.\n  return arr\nend", "  if #arr < 1 then return arr\
    \ end\n  local arr = arr:clone()\n  local size = #arr\n  local result = {0, 0}\n\
    \  for i = 1, size do\n    if arr[i] == 1 then\n      table.insert(result, i)\n\
    \    end\n  end\n  if #result == 1 then\n    -- sort in place for equal number\
    \ of ones\n    local i\n    for i = 1, #result do\n      for j = i + 1, #result\
    \ do\n        if result[i] > result[j] then\n          table.insert(result, result[j])\n\
    \          table.remove(result, j)\n        end\n      end\n    end\n  else\n\
    \    -- sort in place for equal number of zeros\n    local i\n    for i = #result,\
    \ 1, -1 do\n      for j = i - 1, 1, -1 do\n        if result[i] < result[j] then\n\
    \          table.insert(result, result[j])\n          table.remove(result, j)\n\
    \        end\n      end\n    end\n  end\n  return result:map(function(x) arr[x])\n\
    end", "  local sorted_arr = {}\n  local is_one = {}\n  for i = 1, #arr do\n  \
    \  local bin = binary[arr[i]]\n    local is_one = is_one[bin]\n    if is_one ==\
    \ nil then\n      is_one[bin] = true\n    end\n  end\n  for i = 1, #arr do\n \
    \   local bin = binary[arr[i]]\n    if is_one[bin] then\n      table.insert(sorted_arr,\
    \ i)\n    end\n  end\n  table.sort(sorted_arr)\n  for i = 1, #sorted_arr do\n\
    \    arr[i] = sorted_arr[i]\n  end\nend", "   -- write your code in JS here\n\
    end", "  -- write your solution here\nend", "   -- Write your solution here\n\
    end", "    if not arr then return nil end\n    if #arr == 0 then return arr end\n\
    \    local res = {}\n    local count = 0\n    local largest = 0\n    for i=1,#arr\
    \ do\n        if arr[i] > largest then\n            largest = arr[i]\n       \
    \     count = i\n        end\n    end\n    res[count] = largest\n    for i=2,#arr\
    \ do\n        local l = 0\n        for j=i,#arr do\n            if arr[j] >= arr[i]\
    \ then l = j\n            end\n        end\n        res[i] = arr[i]\n        arr[i]\
    \ = arr[l]\n    end\n    return res\nend", "  -- sorts array in ascending order\n\
    \  -- returns array of sorted array elements\n  -- return empty array on empty\
    \ input\n  -- or nil on invalid input\n  if arr == nil or #arr == 0 then\n   \
    \ return nil\n  end\n  local sorted_arr = {}\n  for i = 1, #arr do\n    -- convert\
    \ arr to binary string\n    local bin = arr:sub(i, i):binary()\n    -- convert\
    \ binary string to decimal string\n    local decimal = bin:reverse():reverse()\n\
    \    -- convert decimal string to int\n    local int_value = 0\n    for j = 1,\
    \ #decimal do\n      int_value = int_value + (decimal:byte(j) ~= 0)\n    end\n\
    \    -- check number of ones in binary string\n    if int_value == 1 then\n  \
    \    -- if there are more ones in binary string than in decimal string,\n    \
    \  -- then sort based on decimal value\n      table.insert(sorted_arr, arr[i])\n\
    \    else\n      -- if there are less ones in binary string than in decimal string,\n\
    \      -- then sort based on binary string\n      table.insert(sorted_arr, arr[i])\n\
    \    end\n  end\n  return sorted_arr\nend", "    local n = #arr\n    local sorted_arr\
    \ = {}\n    local i, j, k\n    repeat\n        local max_ones_count = 0\n    \
    \    for i=1,n do\n            if arr[i] > 0 then\n                j = i - 1\n\
    \                k = i\n                while j > 0 and arr[j] == 0 do\n     \
    \               j = j - 1\n                end\n                local ones_count\
    \ = j-k+1\n                if ones_count > max_ones_count then\n             \
    \       max_ones_count = ones_count\n                    k = j\n             \
    \   end\n                sorted_arr[k] = arr[i]\n                arr[i] = 0\n\
    \            end\n        end\n        i = k+1\n    until i == n\n    for i=1,n\
    \ do\n        arr[i] = sorted_arr[i]\n    end\n    return arr\nend", "    return\
    \ arr\nend", "    local result = {}\n    for i, v in ipairs(arr) do\n        if\
    \ v == 1 then\n            result[#result + 1] = i\n        end\n    end", '  assert(#arr
    >= 0)', "  -- Write your code here.\nend", "  return table.sort(arr)\nend", " \
    \ return arr\nend", "  assert(#arr > 0, \"Array size should be larger than 0\"\
    )\n  local bin = str:to_bitarray(arr)\n  local sorted_arr = {}\n  -- sort the\
    \ first half of array by counting ones in binary representation\n  -- and sort\
    \ remaining ones in decimal order\n  for i = 1, #bin do\n    local count = 0\n\
    \    for j = 1, #bin do\n      if bin[i] == 1 then\n        count = count + 1\n\
    \      end\n      assert(bin[j] == 1)\n    end\n    assert(#sorted_arr > 0)\n\
    \    sorted_arr[#sorted_arr + 1] = {bin[i], count}\n  end\n  -- sort the second\
    \ half of the array by counting ones in decimal representation\n  -- since binary\
    \ representation is sorted already, we just need to reverse\n  -- sort the whole\
    \ array by decreasing decimal value\n  for i = #sorted_arr - 1, 1, -1 do\n   \
    \ local dec = 0\n    for j = 1, #sorted_arr do\n      dec = dec + sorted_arr[j].dec\n\
    \    end\n    table.insert(sorted_arr, { dec, sorted_arr[i].count })\n  end\n\
    \  return sorted_arr\nend", "   if #arr < 1 then return arr end\n   local cnt\
    \ = 0\n   local res = {}\n   for i = 1, #arr do\n      if cnt > 0 then\n     \
    \    table.insert(res, math.floor((cnt / 2) * (2^((#res + 1) - cnt))) + math.floor((cnt\
    \ - cnt % 2) * (2^((#res + 1) - cnt))));\n      end\n      cnt = cnt + (arr[i]\
    \ > 0 and 1 or -1)\n   end\n   return res\nend", "  -- Create result array and\
    \ copy original array there\n  local result = {}\n  for i = 1,#arr do\n    table.insert(result,\
    \ i)\n  end\n  -- Iterate and sort all items\n  for i = 1,#result do\n    local\
    \ pos = result[i]\n    local smaller = arr[pos]\n    local bigger = arr[pos -\
    \ 1]\n    -- Iterate through array in ascending order if number of ones is equal\n\
    \    for j = pos + 1,#arr do\n      if arr[j] == bigger then\n        bigger =\
    \ arr[j]\n        pos = j\n        break\n      end\n    end\n    -- Swap current\
    \ item with position it belongs to\n    arr[pos], arr[pos - 1] = arr[pos - 1],\
    \ arr[pos]\n    local val = bigger / 2 + bigger % 2 -- Value to sort by\n    table.insert(result,\
    \ pos)\n    table.insert(result, val - 1)\n    table.insert(result, val + 1)\n\
    \  end\n  return result\nend", "    if not arr then return arr end\n    local\
    \ ones\n    local dec\n    local len", "    -- First check if array is sorted.\n\
    \    -- If not -- use bubble sort.\n    if #arr <= 1 then\n        return arr\n\
    \    end", "  -- Base case --\n  if #arr < 2 then\n    return arr\n  end", " \
    \  -- Convert binary numbers to decimal and sort them.\n   -- Since in our kata\
    \ we sort them in ascending order,\n   -- we just need to reverse the array and\
    \ sort again.\n   -- Since we expect an array, not a string, we convert it back\
    \ here.\n   arr = arr:gsub(\"(%b+)\", \"%1 * 2^%2\")\n     :gsub(\"(%b+)\", \"\
    %1 * 2^%2\")\n     :gsub(\"(%b+)\", \"%1 * 2^%2\")\n     :gsub(\"(%b+)\", \"%1\
    \ * 2^%2\")\n     :gsub(\"(%b+)\", \"%1 * 2^%2\")\n     :gsub(\"(%b+)\", \"%1\
    \ * 2^%2\")\n     :gsub(\"(%b+)\", \"%1 * 2^%2\")\n     :gsub(\"(%b+)\", \"%1\
    \ * 2^%2\")\n     :gsub(\"(%b+)\", \"%1 * 2^%2\")\n     :gsub(\"(%b+)\", \"%1\
    \ * 2^%2\")\n     :gsub(\"(%b+)\", \"%1 * 2^%2\")\n     :gsub(\"(%b+)\", \"%1\
    \ * 2^%2\")\n     :gsub(\"(%b+)\", \"%1 * 2^%2\")\n     :gsub(\"(%b+)\", \"%1\
    \ * 2^%2\")\n     :gsub(\"(%b+)\", \"%1 * 2^%2\")\n     :gsub(\"(%b+)\", \"%1\
    \ * 2^%2\")\n     :gsub(\"(%b+)\", \"%1 * 2^%2\")\n     :gsub(\"(%b+)\", \"%1\
    \ * 2^%2\")\n     :gsub(\"(%b+)\", \"%1 * 2^%2\")\n     :gsub(\"(%b+)\", \"%1\
    \ * 2^%2\")\n     :gsub(\"(%b+)\", \"%1 * 2^%2\")\n     :gsub(\"(%b+)\", \"%1\
    \ * 2^%2\")\n     :gsub(\"(%b+)\", \"%1 * 2^%2\")\n     :gsub(\"(%b+)\", \"%1\
    \ * 2^%2\")\n     :gsub(\"(%b+)\", \"%1 * 2^%2\")\n     :gsub(\"(%b+)\", \"%1\
    \ * 2^%2\")\n     :gsub(\"(%b+)\", \"%1 * 2^%2\")\n     :gsub(\"(%b+)\", \"%1\
    \ * 2^%2\")\n     :gsub(\"(%b", "  return -- To change body of implemented function,\
    \ use \"--body sort_array\"\nend", "  local n = #arr\n  if n < 1 then return nil\
    \ end", "\t-- Create a auxiliary array of zeros and ones\n\tlocal aux = [[0 for\
    \ _i = 1, #arr do\n\t\treturn aux[i-1]\n\tend]]\n\t-- Create a auxiliary array\
    \ of decimal values\n\tlocal dec_aux = [[0 for _i = 1, #arr do\n\t\treturn dec_aux[i-1]\n\
    \tend]]\n\t-- Initialize each aux element with zero value\n\tfor _i = 1, #aux\
    \ do\n\t\taux[_i] = 0\n\tend\n\t-- Iterate over each element\n\tfor _i, e in ipairs(arr)\
    \ do\n\t\t-- Set ones to aux array if number is even\n\t\tif e % 2 == 0 then\n\
    \t\t\taux[e] = aux[e] or 1\n\t\tend\n\t\t-- Set decimal value of each element\
    \ by one's binary representation\n\t\tdec_aux[e] = dec_aux[e] or 1\n\t\t-- Set\
    \ decimal value of aux array by sum\n\t\taux[e] = aux[e] + dec_aux[e]\n\tend\n\
    \t-- Return aux array after sorting in ascending order\n\treturn aux\nend", " \
    \  -- write your code for sorting array here\nend", "  -- Write your code here.\n\
    end", "    local count = {}\n    for i = 1, #arr do\n        table.insert(count,\
    \ #arr[i])\n    end\n    table.sort(count, function(left, right)\n        return\
    \ count[left] > count[right]\n    end)\n    for i = 1, #arr do\n        arr[i]\
    \ = count[i]\n    end\n    return arr\nend", "    local result = {}\n    local\
    \ i = 1\n    while i < #arr do\n        local ones = #arr - i\n        local decimal\
    \ = ones / 2\n        if arr[decimal] == 1 then\n            result[#result +\
    \ 1] = decimal\n        else\n            result[#result + 1] = arr[decimal]\n\
    \        end\n        i = i + 1\n    end\n    return result\nend", "  -- Base\
    \ case\n  if #arr == 1 then\n    return arr\n  end", "  -- Write your code here\n\
    \  local table = {}\n  local counts = {}\n  for i = 1,#arr do\n    table.insert(table,1)\n\
    \    table.insert(counts,0)\n  end\n  for i = 1,#arr do\n    local count = table.unpack(counts)\n\
    \    if arr[i] == 0 then\n      counts[table.unpack(counts)+1] = counts[table.unpack(counts)+1]\
    \ + 1\n    else\n      counts[table.unpack(counts)] = counts[table.unpack(counts)]\
    \ + 1\n    end\n  end\n  table.sort(function(a,b) return counts[a] > counts[b]\
    \ end)\n  return arr\nend", "  -- arr should be a list of non-negative integers\n\
    \  -- Return list with sorted numbers. Return -1 when no one found\n  local function\
    \ compare(lhs, rhs)\n    local lhs_ones = tonumber(\n      string.sub(tostring(lhs),\
    \ 1, string.len(tostring(lhs))-2))\n    local rhs_ones = tonumber(\n      string.sub(tostring(rhs),\
    \ 1, string.len(tostring(rhs))-2))\n    if lhs_ones > rhs_ones then\n      return\
    \ 1\n    elseif lhs_ones < rhs_ones then\n      return -1\n    else\n      if\
    \ lhs_ones == 0 then\n        return tonumber(\n          string.sub(tostring(rhs),\
    \ 1, string.len(tostring(rhs))-2))\n      else\n        return tonumber(\n   \
    \       string.sub(tostring(lhs), 1, string.len(tostring(lhs))-2))\n      end\n\
    \    end\n  end\n  table.sort(arr, compare)\n  return arr\nend", "  -- write your\
    \ logic here\nend", "  assert(#arr == 1, \"The array must have only one element\"\
    )\n  local pos = 1\n  local count = {}\n  for i = 1, #arr do\n    count[#count+1]\
    \ = 1\n    for j = pos, #arr:max() do\n      count[#count+1] = count[#count+1]\
    \ * 2 ^ arr[j] % 10\n      arr[j] = 0\n    end\n    pos = pos + count[#count+1]\n\
    \  end\n  return arr\nend", "    if #arr == 0 then return arr end\n    local bin\
    \ = arr:map(function(x) return string.format(\"%0d\", x) end):join(\"_\")\n  \
    \  local ones = bin:sub(1, 2)\n    local dec\n    if ones < 10 then\n        dec\
    \ = tonumber(ones)\n    else\n        dec = tonumber(string.sub(bin, 2, 2))\n\
    \    end\n    table.sort(arr, function(a, b) return dec > a end)\n    return arr\n\
    end", "    local temp={}\n    local cnt={}\n    for i=1,#arr do\n        cnt[#cnt\
    \ + 1]=0 -- Initialize cnt to zero\n        for j=1,8 do\n            cnt[#cnt\
    \ + 1]=cnt[#cnt + 1] + arr[i] and 1 -- Add 1 only when there is a one\n      \
    \  end\n        temp[#temp + 1]=cnt[#cnt + 1]\n    end\n    table.sort(temp,compare_arrays)\n\
    \    return temp\nend", "  -- The first number in binary representation is the\
    \ most significant one\n  -- Thus, we start counting from the least significant\
    \ number\n  -- The array must be sorted in descending order\n  -- We can use Kata's\
    \ sort method here\nend", "    local comp = function(a, b) return a < b end\n\
    \    table.sort(arr, comp)\nend", "  -- We start from largest to smallest number\
    \ of ones.\n  -- For example, if arr is {2, 8, 4, 1}, and we start from 1 and\n\
    \  -- decrease ones, arr should be {8, 2, 4}. \n  -- It can be done with bubble\
    \ sort.\n  -- We call it with 1 iteration. ", "  -- write your logic here\n  return\
    \ arr\nend", "    local max = 0\n    local min = 0\n    local tmp = 0\n    local\
    \ cnt = 0\n    for i=1,#arr do\n        cnt = 1\n        tmp = arr[i]\n      \
    \  max = tmp\n        min = tmp\n        for j=1,#arr do\n            if arr[j]==tmp\
    \ then\n                cnt = cnt + 1\n            elseif cnt>1 then\n       \
    \         break\n            else\n                if cnt==1 then\n          \
    \          if arr[j]>max then\n                        max = arr[j]\n        \
    \            end\n                elseif cnt==2 then\n                    if arr[j]<min\
    \ then\n                        min = arr[j]\n                    end\n      \
    \          end\n            end\n        end\n        if cnt>1 then\n        \
    \    tmp = (max-min)/cnt\n            arr[i] = tmp\n        elseif cnt>1 then\n\
    \            arr[i] = max\n        end\n    end\nend", "  -- base case\n  if #arr\
    \ < 2 then return arr end\n  local result = {}\n  local index = 1\n  -- sort arr\
    \ to descending order based on binary value\n  for i = #arr, 1, -1 do\n    local\
    \ bin = string.sub( tostring( arr[ i - 1 ] ), 1 )\n    local count = 1\n    repeat\n\
    \      local index = bin .. tostring( count )\n      result[ index ] = arr[ i\
    \ - 1 ]\n      count = count + 1\n    until bin == '0'\n  end\n  -- sort result\
    \ with decimal value\n  table.sort(result, function(a,b) return tonumber( tostring(a)\
    \ - tostring(b) ) end)\n  return result\nend", "  if #arr < 2 then\n    return\
    \ arr\n  end", "    local counts = binary_counts(arr)\n    if counts[1] > 0 then\
    \ -- if more than one one\n        local counts2 = counts\n        local decimals\
    \ = counts2:byte()\n        counts2:fill(0)\n        counts2:uint()\n        for\
    \ i = 1, decimals do\n            counts2:byte():add(counts[1])\n        end\n\
    \        local biggest = counts2:uint()\n        for i = 1, biggest do\n     \
    \       counts:byte():add(counts[2])\n        end\n        local index1, index2\
    \ = binary_search(counts, biggest)\n        if index1 == #counts and index2 ==\
    \ #counts then\n            return counts, arr\n        elseif index1 < index2\
    \ then\n            -- swap indexes\n            local tmp = counts\n        \
    \    counts = counts2\n            counts2 = tmp\n        end\n        local tmp\
    \ = arr\n        arr = counts\n        counts = counts2\n        counts2 = tmp\n\
    \    end\n    local counts, arr = sort_array(arr)\n    local index = binary_search(counts,\
    \ #arr)\n    return counts, arr\nend", "  if #arr == 1 then\n    return arr\n\
    \  end\n  if #arr == 0 then\n    return nil\n  end", "    local function compare(x,\
    \ y)\n        -- Return negative number if x < y\n        if x < y then\n    \
    \        return -1\n        end\n        -- Return positive number if x > y\n\
    \        if x > y then\n            return 1\n        end\n        -- Return zero\
    \ if x == y\n        if x == y then\n            return 0\n        end\n     \
    \   -- If x > y, return positive number\n        if x > y then\n            return\
    \ 1\n        end\n        -- If x < y, return negative number\n        if x <\
    \ y then\n            return -1\n        end\n    end\n    return table.sort(arr,\
    \ compare)\nend", "  -- Write your code here\nend", "  -- Solution\n  -- https://leetcode.com/problems/sort-array-by-number-of-ones/discuss/34746/Simple-Python-Sort-Algorithm\n\
    \  -- https://stackoverflow.com/questions/12551831/how-to-sort-an-array-by-value-in-descending-order-using-python\n\
    \  -- https://stackoverflow.com/questions/26004923/sort-array-by-number-of-occurences\n\
    \  -- https://stackoverflow.com/questions/18442488/how-do-i-sort-arrays-in-python-by-the-number-of-occurences-of-each-element",
  "    return arr\nend", "    if #arr == 0 then return nil end\n    local count =\
    \ arr[1]\n    local maxi = #arr\n    for i = 2, maxi do\n        count = count\
    \ + arr[i - 1]\n        if count > 0 then\n            -- We have a new number\
    \ of ones\n            local m = math.floor(count / 2)\n            if arr[m -\
    \ 1] < 0 then\n                -- Swap arr[m - 1] with arr[i]\n              \
    \  arr[m - 1], arr[i] = arr[i], arr[m - 1]\n            else\n               \
    \ -- Swap arr[m - 1] with arr[i]\n                arr[m - 1], arr[i] = arr[i -\
    \ 1], arr[m - 1]\n            end\n            count = count % 2\n        end\n\
    \    end\n    return arr\nend", "    local max = 0\n    local ones = 0\n    for\
    \ i = 1, #arr do\n        if arr[i] == 1 then\n            ones = ones + 1\n \
    \       elseif ones > 0 then\n            if ones > max then\n               \
    \ max = ones\n            end\n            ones = 0\n        else\n          \
    \  -- arr has only zeros, we can just append it\n            arr[i] = 0\n    \
    \    end\n    end\n    if ones > 0 then\n        if ones > max then\n        \
    \    max = ones\n        end\n    end\n    return max\nend", "   local sorted_arr\n\
    \   if #arr < 2 then return sorted_arr end\n   local counts = {}\n   for i = 1,\
    \ #arr do\n      local c = binary_length(arr[i])\n      if counts[c] == nil then\n\
    \         counts[c] = 1\n      else\n         counts[c] = counts[c] + 1\n    \
    \  end\n   end\n   for i = 1, 10 do\n      for j = 1, #counts do\n         if\
    \ counts[j] <= i then\n            -- Sort the array in place according to counts\n\
    \            local tmp = arr[j]\n            arr[j] = arr[i]\n            arr[i]\
    \ = tmp\n         end\n      end\n      -- Update the counts\n      counts = {}\n\
    \      for i = 1, #arr do\n         local c = binary_length(arr[i])\n        \
    \ if counts[c] == nil then\n            counts[c] = 1\n         else\n       \
    \     counts[c] = counts[c] + 1\n         end\n      end\n   end\n   -- Sort the\
    \ array in place\n   table.sort(arr)\n   return arr\nend", "  return function(lhs,\
    \ rhs)\n    if lhs == rhs then\n      return 0\n    elseif lhs < rhs then\n  \
    \    return -1\n    else\n      return 1\n    end\n  end\nend", "  -- Write your\
    \ code here\n  local arrSorted = {}\n  local sortedIdx = 1\n  for i = 1, #arr\
    \ do\n    local currentNum = 0\n    for j = 1, 8 do\n      if arr[i] and bit.band(i,\
    \ j) ~= 0 then\n        currentNum = currentNum + 1\n      end\n    end\n    if\
    \ currentNum == 1 then\n      arrSorted[sortedIdx] = arr[i]\n      sortedIdx =\
    \ sortedIdx + 1\n    end\n  end\n  return arrSorted\nend", "  -- Your code here!\n\
    end", "  -- Write your solution\nend\n</cell>\n<cell>", "  if #arr == 0 then return\
    \ arr end\n  local ones = count_ones(arr[1])\n  local ones_count = tonumber(tostring(ones))\n\
    \  if ones_count == nil then\n    ones_count = tonumber(tostring(count_ones(arr[#arr])))\n\
    \  end", "    local i = 0\n    local numOnes = 0\n    local numZeroes = 0\n  \
    \  for i = 1, #arr do\n        local isZero = arr[i - 1] ~= 0\n        if isZero\
    \ then\n            numZeroes = numZeroes + 1\n        else\n            numOnes\
    \ = numOnes + 1\n        end\n    end\n    if numOnes > numZeroes then\n     \
    \   return numOnes, arr\n    else\n        return numZeroes, arr\n    end\nend",
  "    local function compare_by_count(a,b)\n        local n = tonumber(string.format(\"\
    %.17f\",(a / b)^2))\n        if n==0 then\n            return tonumber(a) - tonumber(b)\n\
    \        end\n        return n\n    end\n    return table.sort(arr,compare_by_count)\n\
    end", "    local sort_keys = {}\n    local sort_orders = {}\n    for i, v in ipairs(arr)\
    \ do\n        local key = '?'\n        local order = '?'\n        if v ~= 0 then\n\
    \            key = string.format(\"%0d\", v)\n            order = string.format(\"\
    %03d\", (v):bit(-1))\n        end\n        table.insert(sort_keys, key)\n    \
    \    table.insert(sort_orders, order)\n    end\n    table.sort(sort_keys, function(a,\
    \ b) return sort_orders[a] < sort_orders[b] end)\n    return sort_keys\nend",
  "  -- Your code goes here\nend", "    return arr\nend", "    -- Write your solution\
    \ here\nend", "  -- initialize counter to 0\n  local counter = 0\n  -- initialize\
    \ min value to 0\n  local min_val = 0\n  -- initialize arr2 to 0 as we will copy\
    \ arr to arr2 here\n  local arr2 = {}\n  -- initialize arr2 to arr here\n  local\
    \ arr3 = arr\n  -- iterate over arr array and increase counter by 1\n  for _,\
    \ elem in ipairs(arr) do\n    -- if counter is less than min_val, update min_val\n\
    \    if counter < min_val then\n      min_val = counter\n    end\n    -- if counter\
    \ is equal to min_val, copy arr to arr2\n    if counter == min_val then\n    \
    \  arr2[#arr2+1] = elem\n    end\n    -- if counter > min_val, increment counter\n\
    \    counter = counter + 1\n  end\n  -- create arr3 here\n  arr3 = {}\n  -- iterate\
    \ over arr2 and copy arr element to arr3 here\n  for _, elem in ipairs(arr2) do\n\
    \    arr3[#arr3+1] = elem\n  end\n  return arr3\nend", '    if #arr == 0 then
    return arr end', "   local ones = {}\n   local decs = {}\n   -- Iterate over all\
    \ elements in the array\n   for i = #arr, 1, -1 do\n      -- Check if element\
    \ is 1\n      if arr[i] == 1 then\n         -- If so, add it's decimal value to\
    \ its corresponding array\n         decs[#decs + 1] = i\n         -- If not, add\
    \ it to its corresponding array too\n      else\n         -- Otherwise add it\
    \ to its corresponding array\n         ones[#ones + 1] = i\n      end\n   end\n\
    \   -- Now you have two sorted arrays of ones and decimal value\n   -- You have\
    \ to sort the ones in ascending order\n   table.sort(ones)\n   -- Now you know\
    \ that all ones have the same number of decimals\n   -- So you have to find their\
    \ decimal values\n   -- Compare them in ascending order\n   table.sort(decs)\n\
    \   -- And finally sort them based on their decimal values\n   table.sort(decs,\
    \ function(a, b)\n      return decs[a] < decs[b]\n   end)\n   -- Now you have\
    \ your sorted arrays\n   return ones, decs\nend", "  assert(arr ~= nil, \"Error:\
    \ invalid array\")\n  local n = #arr\n  if n == 0 then\n    return nil\n  end\n\
    \  local m = math.max(1, n)\n  if n == 1 then\n    if arr[1] ~= 1 then\n     \
    \ return nil\n    else\n      return arr\n    end\n  end\n  -- Sort the first\
    \ n numbers according to their binary representation.\n  -- Then find the maximum\
    \ count of consecutive 1s in the sorted list and\n  -- sort according to the count\
    \ of consecutive 1s.\n  local count = 1\n  local count_max = 1\n  local max_one\
    \ = arr[1]\n  local max_count = 0\n  for i = 2, m do\n    local val = arr[i]\n\
    \    if val == 1 or count == count_max then\n      count = count + 1\n    else\n\
    \      count = count_max\n    end\n    if val == 1 then\n      max_one = val\n\
    \      max_count = count\n    end\n  end\n  -- Now sort the remaining m numbers\
    \ with the largest count of consecutive\n  -- ones\n  local j = 1\n  for i = 2,\
    \ m do\n    local val = arr[i]\n    if val == 1 then\n      count_max = max_count\n\
    \      while max_count > 0 and j < m do\n        if arr[j] == 1 then\n       \
    \   count = count - 1\n        end\n        j = j + 1\n        if count == 0 then\n\
    \          break\n        end\n      end\n      if count > count_max then\n  \
    \      count_max = count\n      end\n    end\n  end\n  return arr\nend", "   \
    \ local temp = {}\n    local temp_count = 0\n    for i = 1, #arr do\n        --\
    \ If the element is not 0, insert it into the array\n        if arr[i] ~= 0 then\n\
    \            temp[temp_count] = arr[i]\n            temp_count = temp_count +\
    \ 1\n        end\n    end\n    table.sort(temp, function(a, b) return a > b end)\n\
    \    for i = 1, #temp do\n        arr[i] = temp[i]\n    end\nend", "  -- Create\
    \ sorted list of integers and zeroes.\n  local sorted_arr = {}\n  -- Create two\
    \ new arrays of zeros and sorted ones to store them.\n  local sorted_zeroes =\
    \ {}\n  -- Iterate over the original array.\n  for i=1,#arr do\n    -- If the\
    \ current value is 1 then the corresponding index in sorted array\n    -- is 1,\
    \ otherwise it's zero.\n    sorted_arr[arr[i]] = i\n    -- If the value is zero\
    \ then append the corresponding index in sorted\n    -- zeroes array to the sorted\
    \ ones array.\n    if arr[i] == 0 then\n      table.insert(sorted_zeroes, i)\n\
    \    end\n  end\n  -- Sort the sorted array.\n  table.sort(sorted_arr)\n  -- If\
    \ the number of ones in the binary representation of the array is\n  -- less than\
    \ the corresponding value in sorted zeroes array then it's the\n  -- smallest\
    \ integer in the array.\n  for i=1,#sorted_zeroes do\n    if sorted_zeroes[i]\
    \ < sorted_arr[sorted_zeroes[i]] then\n      return sorted_arr[sorted_zeroes[i]]\n\
    \    end\n  end\n  -- If the number of ones in the binary representation of the\
    \ array is\n  -- greater than the corresponding value in sorted zeroes array then\
    \ it's the\n  -- largest integer in the array.\n  for i=#sorted_zeroes,1,-1 do\n\
    \    if sorted_zeroes[i] > sorted_arr[sorted_zeroes[i]] then\n      return sorted_arr[sorted_zeroes[i]]\n\
    \    end\n  end\nend", "    if #arr == 0 then\n        return arr\n    end", " \
    \ -- Write your solution here\nend", "    local result = {}\n    for i = 1, #arr\
    \ do\n        if arr[i] == 1 then\n            table.insert(result, i)\n     \
    \   end\n    end\n    table.sort(result, compare_number_of_ones_asc)\n    return\
    \ table.concat(result)\nend", "    if #arr < 2 then return arr end\n    local\
    \ ones = arr:gsub('%d%d+', '%d'):gsub('%d%d-', '%d'):gsub('%d%d*', '%d'):gsub('%d%d/',\
    \ '%d'):gsub('%d%d\\\\', '%d'):gsub('%d%d$', '%d'):gsub('%d%d^', '%d'):gsub('%d%d<',\
    \ '%d'):gsub('%d%d<=', '%d'):gsub('%d%d>', '%d'):gsub('%d%d>=', '%d')\n    local\
    \ decs = arr:gsub('%d%d-%d%d-', '%d%d-%d%d'):gsub('%d%d-%d%d*', '%d%d-%d%d'):gsub('%d%d-%d%d/',\
    \ '%d%d-%d%d'):gsub('%d%d-%d%d\\\\', '%d%d-%d%d'):gsub('%d%d-%d%d$', '%d%d-%d%d'):gsub('%d%d-%d%d^',\
    \ '%d%d-%d%d'):gsub('%d%d-%d%d<', '%d%d-%d%d'):gsub('%d%d-%d%d<=', '%d%d-%d%d'):gsub('%d%d-%d%d>',\
    \ '%d%d-%d%d'):gsub('%d%d-%d%d>=', '%d%d-%d%d')\n    if #ones < #decs then table.sort(decs,\
    \ function(a, b) return a < b end) end\n    return table.concat(decs, '-')\nend",
  "  -- Based on the solution of GeeksForGeeks.\n  local function compare(one, two)\n\
    \    local num_ones = math.abs(one - two)\n    if num_ones == 0 then\n      return\
    \ one\n    elseif num_ones < 0 then\n      return -1\n    elseif num_ones > 0\
    \ then\n      return 1\n    end\n  end\n  table.sort(arr, compare)\n  return arr\n\
    end", "    -- Your code here\nend", "    local i\n    -- Write your code here\n\
    \    local len = #arr\n    if len < 2 then\n        return arr\n    end\n    local\
    \ numOnes = count_ones(arr[1])\n    for i=1,len do\n        if numOnes > count_ones(arr[i])\
    \ then\n            table.sort(arr,function(x,y)\n                return x > y\
    \ or x < y\n            end)\n        end\n    end\n    return arr\nend", "  \
    \  -- write your sorting code here\n    return arr\nend", "  local ones = arr:map(function(x)\n\
    \    return x/2\n  end)\n  -- Now arr is sorted by number of ones.\n  -- Now sort\
    \ this array by decimal value.\n  local arr2 = {}\n  for i,v in ipairs(arr) do\n\
    \    arr2[i] = math.floor(v)\n  end\n  return arr2\nend", "  -- Write your code\
    \ here.\nend", "    local result = {}\n    local max_ones = 0\n    for i = 1,\
    \ #arr do\n        if arr[i] > max_ones then\n            max_ones = arr[i]\n\
    \        end\n    end\n    for i = 1, #arr do\n        if arr[i] == max_ones then\n\
    \            result[i] = i * 10\n        else\n            result[i] = arr[i]\n\
    \        end\n    end\n    for i = 1, #result do\n        result[i] = result[i]\
    \ / max_ones\n    end\n    return result\nend", "    local counts = {}\n    local\
    \ sorted_arr = {}\n    for i = 1, #arr do\n        local bits = tostring(arr[i])\n\
    \        local count = #bits - 1\n        if not counts[count] then\n        \
    \    counts[count] = true\n            sorted_arr[#sorted_arr + 1] = count\n \
    \       end\n    end\n    for i = 1, #counts do\n        counts[i] = #sorted_arr\n\
    \    end\n    table.sort(sorted_arr, function(lhs, rhs)\n        return counts[lhs]\
    \ < counts[rhs]\n    end)\n    return sorted_arr\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
