name: HumanEval_108_count_nums
language: lua
prompt: "-- Write a function count_nums which takes an array of integers and returns\n\
  -- the number of elements which has a sum of digits > 0.\n-- If a number is negative,\
  \ then its first signed digit will be negative:\n-- e.g. -123 has signed digits\
  \ -1, 2, and 3.\nlocal function count_nums(arr)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = count_nums\n\
  \    lu.assertEquals(candidate({}), 0)\n    lu.assertEquals(candidate({-1, -2, 0}),\
  \ 0)\n    lu.assertEquals(candidate({1, 1, 2, -2, 3, 4, 5}), 6)\n    lu.assertEquals(candidate({1,\
  \ 6, 9, -6, 0, 1, 5}), 5)\n    lu.assertEquals(candidate({1, 100, 98, -7, 1, -1}),\
  \ 4)\n    lu.assertEquals(candidate({12, 23, 34, -45, -56, 0}), 5)\n    lu.assertEquals(candidate({0,\
  \ 1}), 1)\n    lu.assertEquals(candidate({1}), 1)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  return #arr\nend", "    local num_sum = 0\n    for i = 1, #arr do\n\
    \        local digit = arr[i] % 10\n        if digit ~= 0 then\n            num_sum\
    \ = num_sum + digit\n        end\n    end\n    return num_sum\nend", "    local\
    \ n = 0\n    local s = -math.floor(math.abs(arr[0]))\n    for i = 1, #arr do\n\
    \        local e = -math.floor(math.abs(arr[i]))\n        if e > s then\n    \
    \        n = n + 1\n            s = e\n        end\n    end\n    return n\nend",
  "  local count = 0\n  for i = 1, #arr do\n    count = count + 1\n    if arr[i] >\
    \ 0 then\n      count = count + count_digits(arr[i]) -- count the digits > 0.\n\
    \    end\n  end\n  return count\nend", "    local cnt = 0\n    for i = 1, #arr\
    \ do\n        local num = arr[i]\n        local sign = num < 0 and \"-\" or \"\
    +\"\n        for d = 1, 10 do\n            local t = ((num % 10) + sign) * d\n\
    \            if t < 0 then\n                t = -(t+1)\n            else\n   \
    \             if t > 9 then\n                    t = t + 10\n                end\n\
    \                cnt = cnt + 1\n            end\n            num = t\n       \
    \ end\n    end\n    return cnt\nend\ncount_nums = wrap(count_nums)", "\t-- The\
    \ input argument arr must be an array of integers.\n\t-- Return the number of\
    \ elements with digits > 0.\n\t-- If there is a 0 as the first digit, then ignore\
    \ it.\n\t-- If there is a 0 as the last digit, then ignore it.\n\t-- If there\
    \ is a 0 between digits, then ignore it.\n\t-- If there is only 1 digit, then\
    \ ignore it.\n\t-- If there is only 2 digits, then ignore it.\n\t-- If there is\
    \ only 3 digits, then ignore it.\n\t-- Otherwise, return 0.\n\t-- For example,\
    \ count_nums({\"-1\",\"2\",\"3\",\"0\",\"0\",\"0\",\"0\"}) returns 1,\n\t-- but\
    \ count_nums({\"-1\",\"2\",\"3\",\"0\",\"0\",\"0\",\"0\",\"-1\"}) returns 0.\n\
    \t-- If n is nil, return 0.", "  if arr == nil then return 0 end\n  local count\
    \ = 0\n  local sign = 0\n  for i = 1, #arr do\n    local digit = arr[i]\n    if\
    \ sign then\n      if digit > 0 then count = count + 1 end\n    else\n      if\
    \ digit > 0 then\n        sign = sign + 1 -- Increment sign only if its first\
    \ digit.\n      else\n        sign = 0 -- Ignore negative numbers.\n      end\n\
    \    end\n  end\n  return count\nend", "    local count = 0\n    for _, i in ipairs(arr)\
    \ do\n        count = count + 1\n    end\n    return count\nend", "  -- arr has\
    \ one entry for each digit.\n  -- For each number, we add the digits until we\
    \ reach 0.\n  -- We then return 1 + the number of negative numbers.\n  -- Example:\
    \ arr = [1, 3, 2, -4] => count_nums(arr) = 2 + 1 = 4\n  -- Example: arr = [-2,\
    \ 0, 1, 4] => count_nums(arr) = 1 + 1 = 0", "  local num_sum = 0\n  for i = 1,\
    \ #arr do\n    -- If element < 0, then use its first digit.\n    -- This works\
    \ for positive numbers, negative numbers will have a\n    -- first digit of <\
    \ 0. This also works for zero elements.\n    if arr[i] < 0 then\n      num_sum\
    \ = num_sum + arr[arr[i]]\n    else\n      num_sum = num_sum + math.abs(arr[arr[i]])\n\
    \    end\n  end\n  return num_sum\nend", "  local count = 0\n  for _, i in pairs(arr)\
    \ do\n    if i >= 0 then\n      if i > 0 then\n        if math.floor(i) ~= i then\n\
    \          count = count + 1\n        end\n      end\n      i = math.floor(i)\n\
    \      if i == 0 then\n        i = -1\n      end\n    end\n  end\n  return count\n\
    end", "    local n = 0\n    for i = 1, #arr do\n        local n = n + (arr[i]\
    \ > 0 and (arr[i] % 10) or -arr[i])\n    end\n    return n\nend", "  for i=1,#arr\
    \ do\n    arr[i] = arr[i] + math.abs(arr[i])\n    if arr[i] > 0 then\n      return\
    \ i\n    end\n  end\nend", "  local nums = 0\n  for _, v in ipairs(arr) do\n \
    \   if v > 0 then\n      nums = nums + math.floor(math.abs(v))\n    end\n  end\n\
    \  return nums\nend", "  -- Write your code in Lua 5.2 with pattern matching ...\n\
    \  local n = 0\n  for i,v in ipairs(arr) do\n    v = v - math.floor(math.log10(v))\n\
    \    if v > 0 then\n      n = n + 1\n    end\n  end\n  return n\nend", "  local\
    \ count = 0\n  for i = 1, #arr do\n    if arr[i] > 0 then\n      count = count\
    \ + 1\n    end\n  end\n  return count\nend", "  -- Write code here.\n  local sum\
    \ = 0\n  for i = 1,#arr do\n    sum = sum + arr[i]\n    if sum > 0 then\n    \
    \  return i\n    end\n  end\n  return nil\nend", "    local cnt = 0\n    for i\
    \ = 1, #arr do\n        local num = arr[i]\n        if num < 0 then\n        \
    \    num = -num\n            arr[i] = num\n        end\n        if tonumber(num)\
    \ == tonumber(sum(arr:sub(1, i))) then\n            cnt = cnt + 1\n        end\n\
    \    end\n    return cnt\nend", "   -- Return the number of elements with an increasing\
    \ sum\n   -- of the digits.  Negative numbers return 0, positive numbers.\n  \
    \ local n = 0\n   for i = 1, #arr do\n      if arr[i] + i > 0 then\n         n\
    \ = n + 1\n      end\n   end\n   return n\nend", "  if #arr == 0 then return 0\
    \ end\n  local ans = 0\n  for i = 1, #arr do\n    local s = arr[i]:byte()\n  \
    \  if s ~= 0 then\n      local digit = s * s\n      ans = ans + (digit > 0)\n\
    \    end\n  end\n  return ans\nend", "  local n = 0\n  for i = 1, #arr do\n  \
    \  n = n + (arr[i] > 0 and math.floor(math.log(math.abs(arr[i]))))\n  end\n  return\
    \ n\nend", "  local count = 0\n  for i = 1, #arr do\n    if i >= 1 then\n    \
    \  local sign = math.abs(arr[i-1]) -- get the sign\n      count = count + sign\
    \ + count_nums(arr:sub(i)) -- add the digits together\n    end\n  end\n  return\
    \ count\nend", "  local n = 0\n  for i = 1, #arr do\n    local x = math.abs(arr[i])\n\
    \    if x > 0 then\n      n = n + x\n    end\n  end\n  return n\nend\n</cell>\n\
    <cell>", "  if #arr == 0 then return 0 end\n  if arr[1] ~= 0 then return 1 end\n\
    \  local sum = 1\n  local pos = 1\n  for i = 2, #arr do\n    sum = sum * 10 +\
    \ (arr[i] - pos)\n    pos = arr[i]\n  end\n  return sum\nend\n</cell>\n<cell>\n\
    count_nums(arr)\n</cell>\n<text>\nQuestion 3.1", "  local counts = {}\n  for i=1,#arr\
    \ do\n    local digit = math.abs(arr[i])\n    if digit>0 then\n      counts[digit]\
    \ = counts[digit] + 1\n    end\n  end\n  return counts\nend", "    local n = 0\n\
    \    for i = 1, #arr do\n        if math.abs(arr[i]) > 0 then\n            n =\
    \ n + 1\n        end\n    end\n    return n\nend", "  local cnt = 0\n  local last\
    \ = -math.floor(math.log10(arr[1] - arr[0]))\n  local sign = 1\n  local i, n",
  "  -- Write your code here.\n  local count = 0\n  for i = 1, #arr do\n    if arr[i]\
    \ > 0 then\n      if arr[i] > 9 then\n        count = count + 1\n      else\n\
    \        count = count + 1\n      end\n    end\n  end\n  return count\nend", " \
    \   local n = 0\n    for i = 1,#arr do\n        if arr[i] ~= 0 then\n        \
    \    n = n + 1\n        end\n    end\n    return n\nend", "  -- Initialize to\
    \ zero\n  local count = 0", "  -- The function should return a list of numbers\
    \ which has a sum of digits\n  -- greater than 0.\n  -- If the number has an odd\
    \ number of digits, then return an empty list.\n  -- Otherwise, return the number\
    \ of elements which has a sum of digits\n  -- greater than 0.\n  -- E.g. count_nums(123)\
    \ = 1 and count_nums(-123) = 3.\n  -- The order of elements in returned list is\
    \ not important.\n  -- If there are no numbers which has a sum of digits greater\
    \ than 0, then\n  -- return a list of one element with value 0.\n  -- E.g. count_nums(123\
    \ and 456 and 789) = 1 and count_nums(123 - 456) = 3.\n  -- The order of elements\
    \ in returned list is not important.\n  -- If there is only one number in the\
    \ list which has a sum of digits greater\n  -- than 0, then return a list of one\
    \ element with value 0.\n  -- E.g. count_nums(123 and 456 and 789) = 1 and count_nums(123\
    \ - 456) = 3.\n  -- The order of elements in returned list is not important.",
  "  local count = 0\n  for i = 1, #arr do\n    -- Negative numbers have a first digit\
    \ of -1\n    if arr[i] < 0 then\n      count = count + 1\n      arr[i] = -arr[i]\n\
    \    end\n  end\n  return count\nend", "  if #arr == 0 then\n    return 0\n  end\n\
    \  if arr[1] < 0 then\n    arr[1] = -arr[1]\n    arr[2] = -arr[2]\n  end\n  local\
    \ count = 0\n  for i = 2, #arr do\n    if arr[i] == 0 then\n      count = count\
    \ - 1\n    else\n      count = count + math.floor(math.log10(arr[i]) + 1)\n  \
    \  end\n  end\n  return count\nend", "  if arr == nil then\n    return 0\n  end\n\
    \  local count = 0\n  for i = 1, #arr do\n    if arr[i] ~= nil then\n      if\
    \ arr[i] % 10 ~= 0 then\n        count = count + 1\n      end\n    end\n  end\n\
    \  return count\nend", "    local count = 0\n    for i = 1, #arr do\n        if\
    \ arr[i] > 0 then\n            count = count + 1\n        end\n    end\n    return\
    \ count\nend", "  local n = 0\n  local sum = 0\n  for i = 1, #arr do\n    sum\
    \ = sum + tostring(arr[i])\n    if sum > 9 then\n      n = n + 1\n      sum =\
    \ sum - 9\n    end\n  end\n  return n\nend\n</cell>\n<text>\nNext, we will test\
    \ our count_nums function with the input array:", "    local count_nums = 0\n\
    \    for i=1,#arr do\n        if arr[i] > 0 then\n            count_nums = count_nums\
    \ + 1\n        end\n    end\n    return count_nums\nend", "  local n = 1\n  local\
    \ num_negative = false\n  local current_sum = 0\n  for i = 1, #arr do\n    current_sum\
    \ = current_sum + tonumber(arr[i])\n    if current_sum > 0 then\n      n = n +\
    \ 1\n      if current_sum >= 10 then\n        if num_negative then\n         \
    \ n = n - 1\n        end\n      elseif current_sum < -10 then\n        num_negative\
    \ = true\n        current_sum = -current_sum\n      end\n    end\n  end\n  return\
    \ n\nend", "  local n = #arr\n  local sum = 0\n  for i = 1, n do\n    sum = sum\
    \ + math.abs(arr[i])\n  end\n  if n <= 0 then\n    return -sum\n  end\n  return\
    \ sum\nend", "    local count = 0\n    for i = 1, #arr do\n        local num =\
    \ arr[i]\n        if num > 0 then\n            count = count + 1\n        end\n\
    \    end\n    return count\nend", "  -- Your code goes here.\n  return #arr\n\
    end", "  local n = 1\n  for i = 2, #arr do\n    local tmp = arr[i - 1]\n    arr[i\
    \ - 1] = (2 * i) + arr[i - 1]\n    arr[i - 1] = tmp\n    n = n + 1\n  end\n  return\
    \ n\nend", "  local cnt = 0\n  for i = 1,math.floor(math.log(math.sqrt(math.abs(arr))))\
    \ do\n    local s = math.abs(arr) % (10 ** i)\n    if s > 0 then\n      cnt =\
    \ cnt + 1\n    end\n  end\n  return cnt\nend", "   local nums = 0\n   for _, num\
    \ in ipairs(arr) do\n      if num < 0 then\n         num = -num\n         arr[_]\
    \ = -arr[num] -- swap first and second digit\n      end\n      nums = nums + num\
    \ % 10\n   end\n   return nums\nend", "  local count = 0\n  for i = 1, #arr do\n\
    \    local sign = arr[i]\n    if sign < 0 then\n      sign = -sign\n    end\n\
    \    count = count + sign * (arr[i] % 10) + count / 10\n  end\n  return count\n\
    end\n</cell>\n<cell>", "    local n = 0\n    for i = 1, #arr do\n        local\
    \ x = arr[i]\n        if x >= 0 then\n            n = n - x % 10\n        else\n\
    \            n = n + ((x - math.abs(x)) % 10)\n        end\n    end\n    return\
    \ n\nend", "  local n = 0\n  for i = 1, #arr do\n    local m = math.abs(arr[i])\n\
    \    if m > 0 then\n      n = n + 1\n      if m ~= math.floor(m/10) then -- check\
    \ for overflow\n        arr[i] = (m % 10) + math.floor(m / 10)\n      end\n  \
    \  end\n  end\n  return n\nend", "    local count = 0\n    for i = 1, #arr do\n\
    \        count = count + 1\n        if arr[i] > 0 and (arr[i] < 10 or (arr[i]\
    \ > 10 and arr[i] < 0)) then\n            count = count + 1\n        end\n   \
    \ end\n    return count\nend", "  if #arr == 0 then return 0 end\n  local n =\
    \ 1\n  for i = 1, #arr do\n    n = n * 10 + (arr[i]-48)\n    if n < 0 then\n \
    \     n = -n\n      arr[i] = -(arr[i]+48)\n    end\n  end\n  return n\nend", " \
    \ local count = 0\n  for i = 1, #arr do\n    count = count + (arr[i] > 0 and arr[i]\
    \ % 10)\n  end\n  return count - arr[1] -- count number of negative numbers because\
    \ the first digit\nend", "  if arr == nil then\n    return 0\n  end\n  local count\
    \ = 0\n  local sign = 0\n  local i = 0\n  while i < #arr do\n    if arr[i] > 0\
    \ then\n      count = count + 1\n      sign = arr[i]\n    else\n      if sign\
    \ == 0 then\n        count = count + 1\n      else\n        count = count + 1\n\
    \        sign = -sign\n      end\n    end\n    i = i + 1\n  end\n  return count\n\
    end", "\t-- Start with the index of the first non-negative number\n\tlocal n =\
    \ 1\n\twhile n < #arr do\n\t\tlocal m = n - 1\n\t\twhile m > 0 and arr[m + 1]\
    \ < 0 do\n\t\t\tm = m - 1\n\t\tend\n\t\tif m > 0 then\n\t\t\t-- We've found a\
    \ number with a positive first digit.\n\t\t\t-- Increment this number and continue\
    \ counting\n\t\t\tn = n + 1 -- Skip this number in the iteration\n\t\telse\n\t\
    \t\t-- We've found a negative first digit.\n\t\t\t-- Add it to the number of positive\
    \ numbers,\n\t\t\t-- decrement the next number and continue\n\t\t\tn = n + 1 --\
    \ Skip this number in the iteration\n\t\t\t-- Note that we could have found a\
    \ negative number already\n\t\t\t-- without finding a positive number, in which\
    \ case the\n\t\t\t-- second iteration will still find the next negative number\n\
    \t\t\t-- without finding a positive number.\n\t\tend\n\tend\n\treturn n\nend",
  "  for i, v in ipairs(arr) do\n    if v <= 0 then\n      return i\n    end\n  end\n\
    \  return nil\nend", "    local count = 0\n    for _, val in ipairs(arr) do\n\
    \        if val < 0 then\n            count = count + math.floor(math.abs(val))\n\
    \        else\n            count = count + 1\n        end\n    end\n    return\
    \ count\nend", "  -- Initialize the count to the smallest possible value\n  local\
    \ cnt = math.min(arr[1])\n  -- Iterate through the remainder array and increment\
    \ the count for each value\n  for i = 2, #arr do\n    cnt = cnt + math.abs(arr[i]\
    \ - math.floor(arr[i]))\n  end\n  return cnt\nend", "  local count = 0\n  for\
    \ i = 1, #arr do\n    if arr[i] > 0 then\n      count = count + 1\n    end\n \
    \ end\n  return count\nend", "  for i = 1, #arr do\n    if arr[i] > 0 then\n \
    \     return 1\n    end\n  end\n  return 0\nend", "  for _, v in ipairs(arr) do\n\
    \    if v < 0 then\n      v = -v\n    end\n    if v % 10 == 0 then\n      count\
    \ = count + 1\n    end\n  end\n  return count\nend", "   local i = 0\n   local\
    \ n = #arr\n   local sum = 0\n   while i < n do\n      sum = sum + arr[i]\n  \
    \    if sum > 9 then\n         sum = sum % 10\n         n = n-1\n      else\n\
    \         n = n-1\n      end\n      i = i + 1\n   end\n   if sum > 0 then\n  \
    \    return n\n   else\n      local x = -(arr[0]%10)\n      if x ~= 0 then\n \
    \        n = n-1\n      end\n      return n\n   end\nend", "    local count =\
    \ 0\n    for _, _ in ipairs(arr) do\n        if arr[_] >= 0 then\n           \
    \ count = count + 1\n        end\n    end\n    return count\nend", "  -- arr is\
    \ an array of integers, where each element may or may not be\n  -- negative, positive\
    \ or negative. Also assume that arr contains\n  -- at least one integer.\n  --\
    \ Note: this assumes that arr contains at least one integer.\n  local n = #arr\n\
    \  local count = 0\n  for i = 1, n do\n    local digit = math.abs(arr[i])\n  \
    \  if digit > 0 then\n      count = count + 1\n    end\n  end\n  return count\n\
    end", "  -- Write your code here.\n  return nil\nend", "  return #arr * (arr >\
    \ 0 and arr < 13 and 1 or -1)\nend\nprint(count_nums({ -123, 1, 2, -3, -4, -5,\
    \ -6 }))", "    local count = 0\n    for i = 1, #arr do\n        if arr[i] + i\
    \ < 0 then\n            count = count + 1\n        elseif arr[i] + i > 9 then\n\
    \            count = count + 1\n        end\n    end\n    return count\nend",
  "  local n = #arr\n  -- We use the fact that sum is commutative\n  if n > 1 then\n\
    \    for i = 1, n do\n      local c = arr[i] + arr[i]\n      if c > 0 then return\
    \ c + 1 else return 1 end\n    end\n  end\n  return n\nend", "  -- This array\
    \ will store the total number of digits that are\n  -- greater than 0.\n  local\
    \ num_sums = {}\n  -- The current sum is 0 initially.\n  local cur_sum = 0\n \
    \ for i = 1, #arr do\n    -- Get the current digit.\n    local cur_digit = arr[i]\n\
    \    -- If the number is negative, add its first digit to the\n    -- current\
    \ sum.\n    if cur_digit >= 0 then\n      cur_sum = cur_sum + cur_digit\n    \
    \  num_sums[i] = cur_sum\n    else\n      -- Add the current digit to cur_sum.\n\
    \      cur_sum = cur_sum - cur_digit + 1\n      -- The current sum is 0 initially.\n\
    \      num_sums[i] = cur_sum\n    end\n  end\n  -- The total number of digits\
    \ are stored in the array num_sums.\n  -- The number of positive numbers is stored\
    \ in num_sums.\n  return #num_sums\nend", "  for i = 1, #arr do\n    if arr[i]\
    \ > 0 then\n      return 1\n    end\n  end\n  return 0\nend", "    local cnt =\
    \ 0\n    for i, v in ipairs(arr) do\n        if v > 0 then\n            cnt =\
    \ cnt + math.abs(v)\n        else\n            cnt = cnt + (-math.abs(v) + 1)\n\
    \        end\n    end\n    return cnt\nend", "  local n = 0\n  for i = 1, #arr\
    \ do\n    n = n + count_digits(arr[i])\n  end\n  return n\nend", "    local count\
    \ = 0\n    for i = 1, #arr do\n        count = count + arr[i]:gsub('(%D+)$','%1')\n\
    \    end\n    return count\nend", "  local count = 0\n  for i = 1, #arr do\n \
    \   local digit = math.abs(arr[i])\n    if digit > 0 then\n      count = count\
    \ + 1\n    end\n  end\n  return count\nend", "    local total = 0\n    local count\
    \ = 0", "  -- Return count of positive numbers with at least one digit > 0 --\n\
    \  return count_with_positive_digit(arr)\nend", "  local num_sum = 0\n  for i\
    \ = 1, #arr do\n    local num = arr[i]\n    if num ~= 0 then\n      num_sum =\
    \ num_sum + num\n    end\n  end\n  return num_sum\nend", "  local n = 0\n  for\
    \ i = 1, #arr do\n    local v = tonumber(arr[i])\n    if v == 0 then\n      break\n\
    \    end\n    local digit = math.floor(v)\n    if v - digit > 0 then\n      break\n\
    \    end\n    n = n + 1\n  end\n  return n\nend", "  -- Start with our accumulator\
    \ and add each digit.\n  local acc = 0\n  for i = 1, #arr do\n    -- If the current\
    \ digit is not a negative number, then add it to our accumulator.\n    if arr[i]\
    \ < 0 then\n      -- If our accumulator is negative, then we're done.\n      if\
    \ acc < 0 then\n        return acc\n      -- If the current digit is negative,\
    \ then subtract it from our accumulator.\n      elseif acc < 0 then\n        acc\
    \ = -1 * acc\n      -- Otherwise just keep adding our current digit.\n      else\n\
    \        acc = acc * 10 + arr[i]\n      end\n    -- Otherwise we're in the negative.\
    \ Add the negative sign, then subtract our accumulator.\n    else\n      acc =\
    \ acc * 10 + arr[i]\n    end\n  end\n  -- If we reach here then our accumulator\
    \ must be positive.\n  assert(acc > 0)\n  -- If our accumulator is negative, our\
    \ first signed digit will be negative.\n  return -1 * acc\nend", "  -- If there's\
    \ no numbers to count, return 0\n  if not arr then return 0 end", "  local count\
    \ = 0\n  for i = 1, #arr do\n    if arr[i] > 0 then\n      count = count + 1\n\
    \    end\n  end\n  return count\nend", "  local n = 0\n  for i = 1, #arr do\n\
    \    n = n + 1\n    if arr[i] > 0 then\n      n = n * 10 + arr[i] % 10\n     \
    \ arr[i] = arr[i] / 10\n    end\n  end\n  return n\nend", "  -- This code is a\
    \ bit ugly; it's a special case of the counting\n  -- algorithm which counts the\
    \ number of positive sums\n  -- Note that we count the first digit of the sum\
    \ to allow for the\n  -- possibility that sum is negative.", "  if arr == nil\
    \ then return 0 end\n  local count = 0\n  for i = 1, #arr do\n    local num =\
    \ int(arr[i])\n    if num < 0 then\n      num = -num\n    end\n    count = count\
    \ + num\n  end\n  return count\nend", "  local count = 0\n  for i = 1, #arr do\n\
    \    count = count + 1\n    if arr[i] > 0 then\n      if ((arr[i] % 10) == 0)\
    \ then\n        count = count + 1\n      end\n    end\n  end\n  return count\n\
    end", "\tlocal count = 0\n\t-- Iterate over all elements.\n\tfor i = 0, #arr do\n\
    \t\tlocal n = arr[i]\n\t\t-- Iterate over each of the digits.\n\t\tfor j = 0,\
    \ #n do\n\t\t\t-- If the digit is a 1, add it to count.\n\t\t\tif n[j] == 1 then\n\
    \t\t\t\tcount = count + 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nend", " \
    \ local n = 0\n  -- Iterate through the array and count positive numbers.\n  for\
    \ i = 1,#arr do\n    if arr[i] > 0 then\n      n = n + 1\n    end\n  end\n  return\
    \ n\nend", "  local cnt = 0\n  for _, num in pairs(arr) do\n    if num < 0 then\n\
    \      num = -num\n    end\n    cnt = cnt + math.floor(math.log(num) + 1)\n  end\n\
    \  return cnt\nend", "  -- Base case: if there's nothing to count, then return\
    \ zero.\n  if #arr == 0 then return 0 end\n  -- Base case: if there's a negative\
    \ number, then return zero.\n  if arr[#arr] < 0 then return 0 end\n  -- Return\
    \ the number of non-negative numbers whose sum of the digits is 0.\n  return 1\
    \ + count_nums(arr:sub(1, #arr)) end\n  return count_nums(arr)\nend", "   -- Write\
    \ your code here.\n   --return count_nums_helper(arr)\n   local result = 0\n \
    \  for i = 1, #arr do\n      if arr[i] > 0 then\n         result = result + 1\n\
    \      end\n   end\n   return result\nend", "    local count = 0\n    for i =\
    \ 1, #arr do\n        count = count + arr[i]\n    end\n    if count >= 0 then\n\
    \        return count * count_nums(math.abs(arr))\n    else\n        return -count_nums(math.abs(arr))\n\
    \    end\nend", "  local n = 0\n  for i = 1, #arr do\n    local digit = math.floor((arr[i]\
    \ - '0') / 1)\n    if digit > 0 then\n      n = n + 1\n    end\n  end\n  return\
    \ n\nend", "  -- Special case for negative numbers\n  if arr[1] == -2 then\n \
    \   return count_nums(arr[2])\n  end\n  -- The base case\n  if #arr == 1 then\n\
    \    return 1\n  end\n  -- The inner case\n  return count_nums(arr[1]) + count_nums(arr[2]\
    \ .. arr[1])\nend", "  -- count all numbers with digits > 0\n  local n = 0\n \
    \ for i = 1, #arr do\n    local v = tonumber(arr[i])\n    if not v then return\
    \ n end\n    if v ~= 0 then\n      if v >= 0 then\n        if v % 10 ~= 0 then\n\
    \          n = n + 1\n        end\n      end\n    end\n  end\n  return n\nend",
  "  local n = 0\n  for i = 1, #arr do\n    if arr[i] > 0 then\n      n = n + 1\n\
    \    end\n  end\n  return n\nend", "  local count_num = 0\n  for i = 1, #arr do\n\
    \    if arr[i] > 0 then\n      count_num = count_num + 1\n      if arr[i] < 9\
    \ then\n        count_num = count_num + arr[i]\n      else\n        count_num\
    \ = count_num + arr[i]/9\n      end\n    end\n  end\n  return count_num\nend",
  "    local count = 0\n    for i = 1, #arr do\n        count = count + 1\n      \
    \  if arr[i] > 0 then\n            if arr[i] > 9 then\n                count =\
    \ count + 1\n            else\n                count = count + 1\n           \
    \     if arr[i] < -9 then\n                    count = count - 1\n           \
    \     end\n            end\n        end\n    end\n    return count\nend", "  return\
    \ count_nums_aux(arr, 0, nil)\nend", "  -- count the number of elements with a\
    \ sum of digits > 0\n  local count = 0\n  for i = 1, #arr do\n    if arr[i] >\
    \ 0 then\n      count = count + 1\n    end\n  end\n  -- if all elements are negative,\
    \ then the count is -1\n  count = -1 if count == #arr then\n  -- else if all elements\
    \ are positive, then the count is 0\n  count = 0 if count == 0 then\n  return\
    \ count\nend", "  -- TODO: use an \"in\" operator instead of \"for i = 1\" loop\n\
    \  for i = 1, #arr do\n    if arr[i] > 0 then\n      return 1\n    end\n  end\n\
    \  return 0\nend", '  local counts = {}', "  local count = 0\n  for i = 1, #arr\
    \ do\n    count = count + arr[i]\n  end\n  return count\nend", "  if arr == nil\
    \ then\n    return 0\n  elseif #arr < 0 then\n    return -1 + count_nums(-arr)\
    \ -- this line was edited by @hakimel: add support for negative numbers\n  else\n\
    \    local sum = 0\n    for i = 1, #arr do\n      sum = sum + math.abs(arr[i])\n\
    \    end\n    return sum\n  end\nend", "   local count = 0\n   for _,v in pairs(arr)\
    \ do \n      if v then\n         count = count + 1\n         for i=1, 10 do\n\
    \            if v % i == 0 then\n               count = count - 1\n          \
    \     break\n            end\n         end\n      end\n   end\n   return count\n\
    end", "\tlocal n = 0\n\tfor i = 1,#arr do\n\t\tif arr[i] > 0 then\n\t\t\tn = n\
    \ + 1\n\t\t\tn = n + count_nums(arr:sub(1,i))\n\t\tend\n\tend\n\treturn n\nend",
  "  local sum = 0\n  for i = 1, #arr do\n    sum = sum + math.abs(arr[i])\n  end\n\
    \  return sum\nend", "  local ret = 0\n  for i = 1, #arr do\n    if i > 1 then\n\
    \      local sign = math.abs(arr[i])\n      if sign == 0 then\n        return\
    \ ret\n      else\n        local m = math.floor(math.abs(math.log10(sign)))\n\
    \        if sign == -sign then\n          ret = ret + m\n        end\n      end\n\
    \    end\n    ret = ret + arr[i]\n  end\n  return ret\nend", "  local count =\
    \ 0\n  for i = 1, #arr do\n    local num = arr[i]\n    if num > 0 then\n     \
    \ count = count + 1\n      if num < 10 then -- negative number\n        if num\
    \ - 100 < 0 then\n          count = count + 1\n        end\n      end\n    end\n\
    \  end\n  return count\nend", "  if #arr == 0 then return 0 end\n  local count\
    \ = 1\n  for i = 1, #arr do\n    if arr[i] > 0 then\n      for j = i-1, i, -1\
    \ do\n        if arr[j] >= 10 then count = count + 1 end\n      end\n    end\n\
    \  end\n  return count\nend", "  local count = 0\n  for i = 1, #arr do\n    if\
    \ arr[i] > 0 then\n      count = count + 1\n    end\n  end\n  return count\nend",
  "  -- Write your code here.\nend", "  -- We keep a running tally of how many digits\
    \ are positive.\n  local num_positive = 0\n  -- Loop through all numbers in arr.\n\
    \  for i = 1, #arr do\n    -- If the number is positive, then the digits are positive.\n\
    \    if arr[i] > 0 then\n      num_positive = num_positive + 1\n    end\n    --\
    \ If the number is negative, then its first signed digit will be\n    -- negative:\n\
    \    -- e.g. -123 has signed digits -1, 2, and 3.\n    if arr[i] < 0 then\n  \
    \    -- The first digit is negative, so the number is negative.\n      -- Remove\
    \ it from arr and then subtract its sign from the tally.\n      num_positive =\
    \ num_positive + 1 -\n        math.abs(math.modf(arr[i])[1])\n    end\n  end\n\
    \  return num_positive\nend", "  local count = 0\n  for i = 1, #arr do\n    count\
    \ = count + arr[i]\n  end\n  return count\nend", "  local n = 0\n  for i = 1,\
    \ #arr do\n    local val = math.floor(math.abs(arr[i]))\n    if val ~= 0 then\n\
    \      if val > 0 then\n        n = n + val\n      else\n        n = n - val\n\
    \      end\n    end\n  end\n  return n\nend", "    local sum = 0\n    for i, v\
    \ in ipairs(arr) do\n        sum = sum + v\n        if v < 0 then\n          \
    \  sum = sum - v\n        end\n    end\n    return sum\nend\n</cell>\n<cell>",
  "  local count = 0\n  for i = 1, #arr do\n    if arr[i] > 0 then\n      count =\
    \ count + 1\n    end\n  end\n  return count\nend", "  local count = 0\n  for i\
    \ = 2, #arr do\n    count = count + arr[i]\n    if arr[i] > 0 then\n      count\
    \ = count + 1\n    end\n  end\n  return count\nend", "  -- Only numbers are accepted\n\
    \  if arr == nil then\n    return 0\n  end", "  local sum = 0\n  for i = 1, #arr\
    \ do\n    sum = sum + math.abs(arr[i]) -- sum of absolute values is abs()\n  \
    \  if sum ~= 0 then\n      break\n    end\n  end\n  return #arr\nend", "  local\
    \ count = 0\n  for i = 1, #arr do\n    local digit = arr[i]\n    if digit > 0\
    \ then\n      count = count + 1\n    end\n  end\n  return count\nend", "  local\
    \ count = 0\n  for i = 1, #arr do\n    count = count + get_digit(arr, i)\n  end\n\
    \  if count <= 0 then\n    count = count_nums(get_negative(arr))\n  end\n  return\
    \ count\nend", "  -- Write code here\nend", "  -- Write your code here.\n  local\
    \ count = 0\n  for i=1,#arr do\n    local s = arr[i]\n    local num = tonumber(string.format(\"\
    %d\",s))\n    local digit = math.floor(tonumber(string.format(\"%d\",num)))\n\
    \    count = count + math.abs(digit)\n  end\n  return count\nend", "    local\
    \ count = 0\n    for i = 1, #arr do\n        local num = tonumber(arr[i])\n  \
    \      if num > 0 then\n            count = count + 1\n        end\n    end\n\
    \    return count\nend\n</code>\nNow we can write our solution as a recursive\
    \ function:\n<code>", "  local n = 0\n  for i = 1, #arr do\n    local n = n *\
    \ 10 + arr[i]\n  end\n  if n > 0 then\n    local s = n % 10\n    if s > 0 then\n\
    \      n = n / 10\n      n = 10 - n - s\n    end\n  end\n  return n\nend\ncount_nums(ARGV)",
  "  local nums = 0\n  for i = 1, #arr do\n    local num = arr[i]\n    if num < 0\
    \ then\n      num = -num\n    end\n    nums = nums * 10 + num\n  end\n  return\
    \ nums\nend", "  if arr == nil then return 0 end\n  local count = 0\n  for i =\
    \ 1, #arr do\n    local n = tonumber(arr[i])\n    if not n then return 0 end\n\
    \    if n < 0 then\n      n = n * -1\n      arr[i] = tonumber(arr[i]) * -1\n \
    \   end\n    count = count + math.floor(math.abs(n) / 10)\n  end\n  return count\n\
    end", "  local nums = 0\n  for i = 1, #arr do\n    if i > 0 and arr[i] >= 0 then\n\
    \      nums = nums + 1\n    end\n  end\n  return nums\nend", "  for i = 1, #arr\
    \ do\n    local num = arr[i]\n    if num < 0 then\n      num = -num\n    end\n\
    \    if num == 0 then\n      -- TODO: This might be unnecessary.\n      -- The\
    \ array might be empty (there are no negative numbers).\n      local n = #arr\n\
    \      arr[n + 1] = arr[n + 1] - 1\n    end\n  end\n  -- NOTE: This algorithm\
    \ is O(n^2), but this is fine for our purposes.\n  return #arr\nend", "    local\
    \ count = 0\n    for _, i in ipairs(arr) do\n        count = count + 1\n     \
    \   if i > 0 then\n            count = count - i\n        end\n    end\n    return\
    \ count\nend", "  if #arr == 1 then return 1 end\n  local n = 0\n  for i = 2,\
    \ #arr do\n    n = n + 1\n    if arr[i - 2] >= 0 then\n      n = n - arr[i - 2]\n\
    \    end\n  end\n  return n\nend", "   -- Write your code here.\nend", "    local\
    \ n = 0\n    for _, v in pairs(arr) do\n        if v > 0 then\n            n =\
    \ n + 1\n        end\n    end\n    return n\nend", "  local cnt = 0\n  for i =\
    \ 1, #arr do\n    local num = 0\n    for j = 1, math.floor(string.len(arr[i])\
    \ / 3) do\n      num = num * 10 + string.byte(arr[i], j) -- multiply by 10 to\
    \ get new digits\n    end\n    cnt = cnt + num > 0\n  end\n  return cnt\nend\n\
    </cell>\n<cell>", "   local nums = 0\n   local first_negative = -1\n   local first_positive\
    \ = nil\n   for v in arr do\n      if v <= 0 then\n         if first_negative\
    \ == -1 then\n            first_negative = first_negative + 1\n         end\n\
    \         first_negative = first_negative - 1\n      else\n         if first_positive\
    \ == nil then\n            first_positive = first_positive + 1\n         end\n\
    \         if first_positive > first_negative + 1 then\n            first_positive\
    \ = first_positive + 1\n         end\n         if first_positive > first_negative\
    \ + 2 then\n            first_positive = first_positive + 1\n         end\n  \
    \       if first_positive > first_negative + 3 then\n            first_positive\
    \ = first_positive + 1\n         end\n         if first_positive > first_negative\
    \ + 4 then\n            first_positive = first_positive + 1\n         end\n  \
    \       if first_positive > first_negative + 5 then\n            first_positive\
    \ = first_positive + 1\n         end\n         if first_positive > first_negative\
    \ + 6 then\n            first_positive = first_positive + 1\n         end\n  \
    \       if first_positive > first_negative + 7 then\n            first_positive\
    \ = first_positive + 1\n         end\n         if first_positive > first_negative\
    \ + 8 then\n            first_positive = first_positive + 1\n         end\n  \
    \       if first_positive > first_negative + 9 then\n            first_positive\
    \ = first_positive + 1\n         end\n         if first_positive > first_negative\
    \ + 10 then\n            first_positive = first_positive + 1\n         end\n \
    \        if first_positive > first_negative + 11 then\n            first_positive\
    \ = first_positive + 1\n         end\n         if first_positive > first_negative\
    \ + 12 then\n            first_positive = first_positive + 1\n         end\n \
    \        if first_positive > first_negative + 13 then\n            first_positive\
    \ = first_positive + 1\n         end\n         if first_positive > first_negative\
    \ + 14 then\n            first_positive = first_positive + 1\n         end\n \
    \        if first_positive > first_negative + 15 then\n            first_positive\
    \ = first_positive + 1\n         end\n         if first_positive > first_negative\
    \ + 16 then\n            first_positive = first_positive + 1\n         end\n \
    \        if first_positive > first_negative + 17 then\n            first_positive\
    \ = first_positive + 1\n         end\n         if first_positive > first_negative\
    \ + 18 then\n            first_positive = first_positive + 1\n         end\n \
    \        if first_positive > first_negative + 19 then\n            first_positive\
    \ = first_positive + 1\n         end\n         if first_positive > first_negative\
    \ + 20 then\n            first_", "  local count = 0\n  for i = 1, #arr do\n \
    \   local digit = string.sub(arr, i, i)\n    if digit ~= \"\" then\n      if digit\
    \ >= '0' and digit <= '9' then\n        count = count + 1\n      else\n      \
    \  if digit == '-' then\n          count = count + 1\n        elseif digit < 0\
    \ then\n          count = count + 1\n          local sign = math.abs(digit)\n\
    \          digit = math.floor((sign % 10)*(sign % 10)+digit)/10\n        end\n\
    \        arr[i] = digit\n      end\n    end\n  end\n  return count\nend", "  local\
    \ cnt = 0\n  for i = 1, #arr do\n    if arr[i] > 0 then\n      cnt = cnt + arr[i]\n\
    \    end\n  end\n  return cnt\nend", "    local count = 0\n    for idx = 1, #arr\
    \ do\n        if arr[idx + 1] > 0 then\n            count = count + 1\n      \
    \  end\n    end\n    return count\nend\nassert(count_nums([1, 2, 3]) == 3)\nassert(count_nums([])\
    \ == 0)", "  local count = 0\n  for i = 1, #arr do\n    count = count + count_digits(arr[i])\n\
    \    if arr[i] > 0 then\n      count = count + math.abs(math.floor(math.log10(arr[i])))\
    \ + 1 -- +1 since log10 is inclusive and counts the number\n    end\n  end\n \
    \ return count\nend\n</cell>\n<cell>\ncount_nums(xs)\n</cell>\n<text>\nTests",
  "  local n = 0\n  local s = arr:byte()\n  while s ~= 0 do\n    if s % 10 ~= 0 then\n\
    \      n = n + s - 10 * (s % 10)\n    end\n    s = math.floor(s / 10)\n  end\n\
    \  return -n\nend", "    local num_sum = 0\n    for i = 1, #arr do\n        local\
    \ num = arr[i]\n        if num ~= 0 then\n            if num < 0 then\n      \
    \          num_sum = num_sum - 1\n                num = -num\n            end\n\
    \            num_sum = num_sum + math.floor(math.log(abs(num), 10)) + 1\n    \
    \    end\n    end\n    return num_sum\nend", "   local sum = 0\n   for i = 1,\
    \ #arr do\n      if arr[i] > 0 then\n         sum = sum + math.abs(arr[i])\n \
    \     end\n   end\n   return sum\nend", "  local count = 0\n  for i = 1, #arr\
    \ do\n    local num = 0\n    while true do\n      local digit = arr % 10\n   \
    \   if digit ~= 0 then\n        num = num * 10 + digit\n        arr = arr / 10\n\
    \      else\n        -- The number has no more digits.\n        return count\n\
    \      end\n      if num > 0 then\n        count = count + 1\n        break\n\
    \      end\n    end\n  end\n  return count\nend", "    local count = 0\n    for\
    \ i=1,#arr do\n        if arr[i] > 0 then\n            count = count + 1\n   \
    \     end\n    end\n    return count\nend", "    local n = 0\n    for i, v in\
    \ pairs(arr) do\n        if v > 0 then\n            n = n + 1\n        end\n \
    \   end\n    return n\nend", "  local count = 0\n  for i = 2, #arr do\n    if\
    \ arr[i - 1] < 0 then\n      count = count + arr[i - 1]\n    else\n      count\
    \ = count + arr[i - 1] / 10\n    end\n  end\n  return count\nend", "  return count_nums_helper(arr,\
    \ 0, #arr, 0)\nend", "  for i = 1, #arr do\n    if arr[i] > 0 then\n      local\
    \ sum = 0\n      local div = 1\n      while ((arr[i] - div) < 0) do\n        sum\
    \ = sum + div\n        div = div * 10\n      end\n      if sum > 0 then\n    \
    \    sum = sum - 1\n      end\n      return i + 1\n    end\n  end\nend", "  local\
    \ n = 0\n  for i = 1, #arr do\n    local n = n + arr[i]\n  end\n  return n\nend",
  "   local count = 0\n   for i = 1, #arr do\n      local num = arr[i]\n      if num\
    \ > 0 then\n         count = count + 1\n      elseif num < 0 then\n         count\
    \ = count + 1\n         num = num * -1\n      elseif num == 0 then\n         count\
    \ = count + 1\n      end\n   end\n   return count\nend", "  -- Write your code\
    \ here.\n  return 0\nend", "  local n = 0\n  for i = 1, #arr do\n    if arr[i]\
    \ > 0 then\n      n = n + 1\n    end\n  end\n  return n\nend", "    local n =\
    \ 1\n    for _, a in ipairs(arr) do\n        n = n * (1 + math.abs(a))\n    end\n\
    \    return n\nend", "  local count = 0\n  local sign = 1", "    local count =\
    \ 0\n    for i = 1, #arr do\n        count = count + arr[i]\n        if count\
    \ > 0 then\n            count = count - sign\n        end\n    end\n    return\
    \ count\nend", "  local num_sum = 0\n  for i = 1, #arr do\n    num_sum = num_sum\
    \ + arr[i]\n    if num_sum > 0 then\n      return 1\n    end\n  end\n  return\
    \ 0\nend", "   local count = 0\n   for i = 1,#arr do\n      count = count + arr[i]\n\
    \      if arr[i] < 0 then\n         count = count + arr[i]\n         arr[i] =\
    \ arr[i] * -1\n      end\n   end\n   return count\nend", "    local count = 0\n\
    \    for i = 1, #arr do\n        if arr[i] > 0 then\n            count = count\
    \ + 1\n        end\n    end\n    return count\nend", "  local n = 0\n  for i =\
    \ 1, #arr do\n    n = n + math.abs(arr[i]) * (math.pow(10, #arr-i-1))\n  end\n\
    \  return n\nend", "  local n = 0\n  for i = 1, #arr do\n    if arr[i] > 0 then\n\
    \      n = n + ((math.floor(math.abs(arr[i]))) * math.pow(10, (#arr) - i))\n \
    \   end\n  end\n  return n\nend", "    local n = 0\n    for i = 1, #arr do\n \
    \       local digit = tonumber(arr[i])\n        if digit > 0 then\n          \
    \  n = n + digit\n        end\n    end\n    return n\nend", "  if #arr == 0 then\n\
    \    return 0\n  else\n    local result = 0\n    for i = 1, (#arr) do\n      result\
    \ = result + digits[arr[i]]\n    end\n    return result\n  end\nend", "  local\
    \ n = 0\n  for i = 1, #arr do\n    local sum = 0\n    while i >= 0 do\n      sum\
    \ = sum + arr[i]\n      i = i - 1\n    end\n    if sum > 0 then\n      n = n +\
    \ 1\n    end\n  end\n  return n\nend", "  local nums = 0\n  for _, v in ipairs(arr)\
    \ do\n    nums = nums + v\n  end\n  return nums\nend", "    local count = {} --\
    \ Initialize count with 0\n    for i = 1, #arr do\n        if arr[i] > 0 then\n\
    \            table.insert(count, math.floor(math.log(arr[i], 10)))\n        end\n\
    \    end\n    table.sort(count)\n    return table.concat(count)\nend", "    local\
    \ sum = 0\n    local counts = {}", "  local n = 0\n  local sign = math.abs(arr[1])\n\
    \  \n  for i = 2, #arr do\n    local v = arr[i]\n    if sign == 0 then\n     \
    \ if v > 0 then n = n + 1 end\n    else\n      if v < 0 then n = n - 1 end\n \
    \   end\n    sign = math.abs(v)\n  end\n  return n\nend", "    local count = 0\n\
    \    local negative = arr[1] < 0\n    if negative then\n        arr[1] = -arr[1]\n\
    \    end\n    for i = 2, #arr do\n        local n = arr[i]\n        if n then\n\
    \            count = count + 1\n        end\n    end\n    if negative then\n \
    \       return count\n    end\n    for i = 1, #arr do\n        local n = arr[i]\n\
    \        if n > 0 then\n            count = count + 1\n        end\n    end\n\
    \    return count\nend", "  -- write your code!\n  -- hint: use an iterator\n\
    \  -- also hint: use array slicing\nend", "  -- We start with an empty sum, so\
    \ that we can add digits when adding\n  -- the numbers' digit.\n  local sum =\
    \ 0\n  -- Iterate over every number.\n  for i = 1, #arr do\n    -- Add the digits\
    \ to the sum, while avoiding negatives.\n    sum = sum + arr[i] % 10 + sum % 10\n\
    \    -- We need to divide by 10, so we remove that from the sum.\n    sum = sum\
    \ / 10\n    -- If the number is negative, its first digit will be negative.\n\
    \    -- So we can subtract that from the sum.\n    if arr[i] < 0 then\n      --\
    \ Negative numbers start with a negative sign.\n      -- Add the negative sign\
    \ to the sum.\n      sum = sum + arr[i] + sum\n      -- Divide by 10 to remove\
    \ the negative sign again.\n      sum = sum / 10\n    end\n  end\n  return sum\n\
    end", "  local count = 0\n  for i = 1, #arr do\n    count = count + 1\n    if\
    \ i >= 2 and is_positive(arr[i-2] + arr[i-1]) then\n      count = count + 1\n\
    \    end\n  end\n  return count\nend", "  if arr == nil then return 0 end\n  local\
    \ nums = 0\n  for i = 1, #arr do\n    local n = arr[i]\n    local first_digit\
    \ = math.abs(math.floor(n))\n    if first_digit > 0 then\n      -- Check each\
    \ digit for > 0 using abs() and floor().\n      if first_digit > 9 then\n    \
    \    return nil\n      end\n      if n < 0 then\n        first_digit = -first_digit\n\
    \      end\n      -- Store the count of the digit in the nums variable.\n    \
    \  nums = nums + (first_digit - math.floor(first_digit))\n    end\n  end\n  return\
    \ nums\nend", "  -- The map function will take the array and return a table\n\
    \  -- of values where the first value is true (truthy) and the second is\n  --\
    \ false (falsy).\n  -- Then you can ask if the truthy value is true (truthy),\
    \ or false (falsy).\n  -- The second return value is how many values it contains\
    \ (the count).\n  return #(\n    -- If the array is empty, return zero (0).\n\
    \    not arr or -- If it is only a nil, return one.\n    not arr[1] or\n    --\
    \ Otherwise, we need to loop through all of the numbers in the array.\n    for\
    \ i = 2, #arr do\n    -- If the current number is positive, then add it to the\
    \ sum\n    -- and continue to the next value.\n    if arr[i] < 0 then\n      arr[i]\
    \ = -arr[i]\n      break\n    end\n    -- If the current number is negative, then\
    \ subtract it from the\n    -- sum and continue to the next value.\n    if arr[i]\
    \ >= 0 then\n      arr[i] = -arr[i]\n      break\n    end\n    -- If the current\
    \ number is zero, continue to the next value.\n    arr[i] = nil\n    -- Otherwise,\
    \ continue to the next value.\n    arr[i - 1]\n  ) > 0 end", "    local count\
    \ = 0\n    for i = 1, #arr do\n        if math.abs(arr[i]) > 0 then\n        \
    \    count = count + 1\n        end\n    end\n    return count\nend", "\tlocal\
    \ count = 0\n\tfor _, v in ipairs(arr) do\n\t\tcount = count + count_digits(v)\n\
    \tend\n\treturn count\nend", "  if #arr == 0 then return 0 end\n  local counts\
    \ = { }\n  for i = 1, #arr do\n    local nums = count_nums(arr:sub(1, i))\n  \
    \  if nums == 0 then return 0 end\n    counts[i] = nums\n  end\n  for i = 1, #counts\
    \ do\n    if counts[i] ~= 0 then\n      return i + 1\n    end\n  end\n  return\
    \ 0\nend", "  if #arr == 0 then\n    return 0\n  elseif #arr == 1 then\n    return\
    \ arr[1]\n  else\n    local first_digit = arr[1]\n    local count = 1\n    for\
    \ i = 2, #arr do\n      if arr[i] > first_digit then\n        return count --\
    \ Found a number\n      end\n      count = count + arr[i] - first_digit\n    \
    \  first_digit = arr[i]\n    end\n    return count -- Did not find a number\n\
    \  end\nend", "  local count = 0\n  for i = 1, #arr do\n    count = count + arr[i]:gsub(\"\
    %d+$\",\"\")\n  end\n  return count\nend", "  local count = 0\n  for i = 1, #arr\
    \ do\n    count = count + count_digits(arr[i]) * pow(10, #arr-1)\n  end\n  return\
    \ count\nend", "    local count = 0\n    for i, v in ipairs(arr) do\n        if\
    \ v >= 0 then\n            count = count + 1\n        else\n            count\
    \ = count + v\n        end\n    end\n    return count\nend", "  local count =\
    \ 0\n  for i = 1, #arr do\n    if arr[i] > 0 then\n      count = count + 1\n \
    \   end\n  end\n  return count\nend", "   local cnt = 0\n   for i = 1, #arr do\n\
    \      cnt = cnt + arr[i]\n      if cnt > 0 then\n         return cnt\n      end\n\
    \   end\n   return 0\nend", "  if #arr == 0 then return 0 end\n  local result\
    \ = 0\n  for i = 1, #arr do\n    local num = tostring(arr[i])\n    if num:sub(1,\
    \ -1) ~= '-' then\n      result = result + 1\n    end\n  end\n  return result\n\
    end", "    local count = 0\n    for i=1,#arr do\n        if arr[i] > 0 then\n\
    \            count = count + 1\n        end\n    end\n    return count\nend",
  "  if #arr < 0 then\n    arr[1] = -arr[1]\n    arr[#arr + 1] = -arr[#arr + 1]\n\
    \  end", "  local count = 0\n  -- A number is positive if it has at least one\
    \ non-zero digit:\n  for i = 1, #arr do\n    if arr[i] ~= 0 then\n      count\
    \ = count + 1\n    end\n  end\n  return count\nend", "  local num_found = 0\n\
    \  for i, v in ipairs(arr) do\n    if v < 0 then\n      v = -v\n    end\n    if\
    \ v ~= 0 then\n      num_found = num_found + 1\n    end\n  end\n  return num_found\n\
    end", "  local count = 0\n  for _,v in ipairs(arr) do\n    if v < 0 then\n   \
    \   v = -v\n    end\n    count = count + math.floor(math.abs(v))\n  end\n  return\
    \ count\nend", "  -- TODO: Use bit-wise AND\n  -- https://stackoverflow.com/questions/17771038/how-to-count-numbers-in-array\n\
    \  local count = 0\n  for _, x in ipairs(arr) do\n    if x > 0 then\n      count\
    \ = count + 1\n    end\n  end\n  return count\nend", "  local count = 0\n  for\
    \ i = 1, #arr do\n    if arr[i] > 0 then\n      count = count + 1\n    end\n \
    \ end\n  return count\nend", "    local count = 0\n    for i = 1, #arr do\n  \
    \      count = count + 1\n        if arr[i] > 0 then\n            count = count\
    \ + count_nums(get_signed_digits(arr[i]))\n        end\n    end\n    return count\n\
    end", "  -- If the array is empty then return 0.\n  if #arr == 0 then\n    return\
    \ 0\n  end\n  -- If there are less than two then return 0.\n  if #arr < 2 then\n\
    \    return 0\n  end\n  -- Count the positive numbers. This is easy\n  -- since\
    \ we know that the sum of first two\n  -- is greater than 0.\n  local count =\
    \ 0\n  local first = 0\n  local last\n  -- If the first element has a negative\
    \ sign,\n  -- then its first signed digit will be negative:\n  -- e.g. -123 has\
    \ signed digits -1, 2, and 3.\n  if arr[1] < 0 then\n    first = arr[1]\n  else\n\
    \    -- Otherwise the number is positive.\n    first = 0\n  end\n  -- Add the\
    \ first and second digits.\n  last = first + arr[2]\n  -- Now we go through the\
    \ array subtracting the last digit\n  -- from the next number until we get a number\
    \ with\n  -- a positive sum.\n  for i = 2, #arr do\n    last = last - arr[i]\n\
    \    if last > 0 then\n      count = count + 1\n    end\n  end\n  return count\n\
    end", "  -- The array is guaranteed to be positive (or zero) length.\n  -- Also\
    \ assumes array is not empty or all numbers are < 10.\n  local n = 0\n  local\
    \ sum = 0\n  for i = 1, #arr do\n    local x = arr[i]\n    if x >= 10 then\n \
    \     -- Number is negative and has at least one digit lower than zero.\n    \
    \  -- Add this to the sum and then continue with next number.\n      sum = sum\
    \ + x - 10 -- Add the negative sign if needed.\n      n = n + 1\n      -- If all\
    \ numbers are less than 10, then we can exit the loop.\n      -- We can also exit\
    \ the loop as soon as we reach the end of the array.\n      if i == #arr then\n\
    \        break\n      end\n    end\n  end\n  return n, sum\nend", "  local n =\
    \ 0\n  for i = 1, #arr do\n    local j = i\n    while j > 0 do\n      if arr[i]\
    \ < 0 then\n        j = j - 1\n      else\n        j = j - 1\n        break\n\
    \      end\n    end\n    n = n + 1\n  end\n  return n\nend", "  local count =\
    \ 0\n  for i=1,#arr do\n    local digits = tonumber(string.format(\"%0*d\", i,\
    \ arr[i]))\n    if digits then\n      if digits > 0 then\n        count = count\
    \ + 1\n      else\n        if digits < 0 then\n          count = count + 1\n \
    \         arr[i] = -arr[i]\n        else\n          arr[i] = -digits\n       \
    \ end\n      end\n    end\n  end\n  return count\nend", "  -- Handle the case\
    \ where there are no elements in the array.\n  if #arr == 0 then return 0 else\
    \ return 1 end\n  -- Handle the case where there is only one element.\n  if #arr\
    \ == 1 then return 1 end\n  -- Find the first negative number by finding the first\
    \ element with a\n  -- negative sign and subtracting that from the first element:\
    \ -1 -2\n  -- = 2. The first negative number is the one we are looking for.\n\
    \  local first_negative_num = math.abs(arr[1] - arr[1])\n  -- Handle the case\
    \ where the first element is negative.\n  if first_negative_num <= 0 then return\
    \ count_nums(arr[#arr + 1 : end]) end\n  -- Find the second negative number and\
    \ subtract that from the second\n  -- element: -1 2 -2 = -1. The second negative\
    \ number is the one we\n  -- are looking for.\n  local second_negative_num = math.abs(arr[2]\
    \ - arr[2])\n  -- Handle the case where the second element is negative.\n  if\
    \ second_negative_num <= 0 then return count_nums(arr[#arr + 2 : end]) end\n \
    \ -- Subtract the first negative number from the second element and add\n  --\
    \ the result. -1 2 - 1 + 1 = 0.\n  return count_nums(arr[#arr + 1 : end]) - (first_negative_num\
    \ + second_negative_num)\nend", "    local total = 0\n    for i = 1, #arr do\n\
    \        total = total + (arr[i]:gsub(\"%d+\", function(digit)\n            return\
    \ digit > 0 and digit < 10 ? digit : 0\n        end)):tonum()\n    end\n    return\
    \ total\nend", "  local result = 0\n  for i = 1, #arr do\n    local sum = 0\n\
    \    for j = 1, #arr do\n      if arr[i] >= 0 and arr[j] >= 0 and arr[i] + arr[j]\
    \ == 0 then\n        sum = sum + 1\n      end\n    end\n    if sum > 0 then\n\
    \      result = result + 1\n    end\n  end\n  return result\nend", "  local count\
    \ = 0\n  for i = 1, #arr do\n    count = count + count_num(arr[i])\n  end\n  return\
    \ count\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=arrays,lua,recursion dscore=2\
    \ |>\nHere's another recursive solution:\n<code>", "  -- Return 0 if we have no\
    \ digits, else return number of positive digits.\n  if #arr == 0 then return 0\
    \ else return #arr + #arr[1]\nend", "  local n = 0\n  for i = 1, #arr do\n   \
    \ local t = arr[i]\n    if t > 0 then\n      n = n + math.floor(t)\n    elseif\
    \ t < 0 then\n      n = n + math.ceil(t) * -1\n    end\n  end\n  return n\nend",
  "    local counts = {}\n    local negatives = { }", "    local count = 0\n    for\
    \ _, b in ipairs(arr) do\n        if b > 0 then\n            count = count + 1\n\
    \        end\n    end\n    return count\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
