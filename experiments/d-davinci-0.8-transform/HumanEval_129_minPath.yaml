name: HumanEval_129_minPath
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Given a grid with N rows\
  \ and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains\
  \ a value. Every integer in the range [1, N * N]\n    inclusive appears exactly\
  \ once on the cells of the grid.\n\n    You have to find the minimum path of length\
  \ k in the grid. You can start\n    from any cell, and in each step you can move\
  \ to any of the neighbor cells,\n    in other words, you can go to cells which share\
  \ an edge with you current\n    cell.\n    Please note that a path of length k means\
  \ visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off\
  \ the grid.\n    A path A (of length k) is considered less than a path B (of length\
  \ k) if\n    after making the ordered lists of the values on the cells that A and\
  \ B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically\
  \ less\n    than lst_B, in other words, there exist an integer index i (1 <= i <=\
  \ k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n   \
  \ lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return\
  \ an ordered list of the values on the cells that the minimum path go through.\n\
  \n    Examples:    \n    >>> minPath([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]],\
  \ 3L)\n    [1L, 2L, 1L]\n\n    >>> minPath([[5L, 9L, 3L], [4L, 1L, 6L], [7L, 8L,\
  \ 2L]], 1L)\n    [1L]\n    \n*/\nlong[] minPath(long[][] grid, long k) \n"
tests: "unittest\n{\n    alias candidate = minPath;\n\n    assert(candidate([[1L,\
  \ 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]], 3L) == [1L, 2L, 1L]);\n    assert(candidate([[5L,\
  \ 9L, 3L], [4L, 1L, 6L], [7L, 8L, 2L]], 1L) == [1L]);\n    assert(candidate([[1L,\
  \ 2L, 3L, 4L], [5L, 6L, 7L, 8L], [9L, 10L, 11L, 12L], [13L, 14L, 15L, 16L]], 4L)\
  \ == [1L, 2L, 1L, 2L]);\n    assert(candidate([[6L, 4L, 13L, 10L], [5L, 7L, 12L,\
  \ 1L], [3L, 16L, 11L, 15L], [8L, 14L, 9L, 2L]], 7L) == [1L, 10L, 1L, 10L, 1L, 10L,\
  \ 1L]);\n    assert(candidate([[8L, 14L, 9L, 2L], [6L, 4L, 13L, 15L], [5L, 7L, 1L,\
  \ 12L], [3L, 10L, 11L, 16L]], 5L) == [1L, 7L, 1L, 7L, 1L]);\n    assert(candidate([[11L,\
  \ 8L, 7L, 2L], [5L, 16L, 14L, 4L], [9L, 3L, 15L, 6L], [12L, 13L, 10L, 1L]], 9L)\
  \ == [1L, 6L, 1L, 6L, 1L, 6L, 1L, 6L, 1L]);\n    assert(candidate([[12L, 13L, 10L,\
  \ 1L], [9L, 3L, 15L, 6L], [5L, 16L, 14L, 4L], [11L, 8L, 7L, 2L]], 12L) == [1L, 6L,\
  \ 1L, 6L, 1L, 6L, 1L, 6L, 1L, 6L, 1L, 6L]);\n    assert(candidate([[2L, 7L, 4L],\
  \ [3L, 1L, 5L], [6L, 8L, 9L]], 8L) == [1L, 3L, 1L, 3L, 1L, 3L, 1L, 3L]);\n    assert(candidate([[6L,\
  \ 1L, 5L], [3L, 8L, 9L], [2L, 7L, 4L]], 8L) == [1L, 5L, 1L, 5L, 1L, 5L, 1L, 5L]);\n\
  \    assert(candidate([[1L, 2L], [3L, 4L]], 10L) == [1L, 2L, 1L, 2L, 1L, 2L, 1L,\
  \ 2L, 1L, 2L]);\n    assert(candidate([[1L, 3L], [3L, 2L]], 10L) == [1L, 3L, 1L,\
  \ 3L, 1L, 3L, 1L, 3L, 1L, 3L]);\n}\nvoid main(){}"
completions: []
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
