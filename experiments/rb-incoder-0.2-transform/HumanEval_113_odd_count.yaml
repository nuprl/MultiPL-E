name: HumanEval_113_odd_count
language: rb
prompt: "# Given a list of strings, where each string consists of only digits, return\
  \ a list.\n# Each element i of the output should be \"the number of odd elements\
  \ in the\n# string i of the input.\" where all the i's should be replaced by the\
  \ number\n# of odd digits in the i'th string of the input.\n# >>> odd_count.call([\"\
  1234567\"])\n# [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n\
  # >>> odd_count.call([\"3\", \"11111111\"])\n# [\"the number of odd elements 1n\
  \ the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of\
  \ the 8nput.\"]\ndef odd_count(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_odd_count\n\
  \    candidate = method(:odd_count)\n    assert_equal([\"the number of odd elements\
  \ 4n the str4ng 4 of the 4nput.\"], candidate.call([\"1234567\"]))\n    assert_equal([\"\
  the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd\
  \ elements 8n the str8ng 8 of the 8nput.\"], candidate.call([\"3\", \"11111111\"\
  ]))\n    assert_equal([\"the number of odd elements 2n the str2ng 2 of the 2nput.\"\
  , \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of\
  \ odd elements 2n the str2ng 2 of the 2nput.\"], candidate.call([\"271\", \"137\"\
  , \"314\"]))\n  end\nend\n"
completions: ["  lst.map!{|s| s.split(\"\").map{|c| c.to_i}}\n  lst.map!{|s| s.map{|c|\
    \ c%2 == 0 ? 1 : 0}}\n  lst.map!{|s| s.inject(0){|sum, e| sum + e}}\n  lst.map!{|s|\
    \ s.inject(0){|sum, e| sum + 1 if e % 2 == 1}}\n  lst.map!{|s| s.inject(0){|sum,\
    \ e| sum + 1 if e % 2 == 0}}\n  lst.map!{|s| s.inject(0){|sum, e| sum + 1 if e\
    \ % 2 == 1}}\n  lst.map!{|s| s.inject(0){|sum, e| sum + 1 if e % 2 == 0}}\n  lst.map!{|s|\
    \ s.inject(0){|sum, e| sum + 1 if e % 2 == 1}}\n  lst.map!{|s| s.inject(0){|sum,\
    \ e| sum + 1 if e % 2 == 0}}\n  lst.map!{|s| s.inject(0){|sum, e| sum + 1 if e\
    \ % 2 == 1}}\n  lst.map!{|s| s.inject(0){|sum, e| sum + 1 if e % 2 == 0}}\n  lst.map!{|s|\
    \ s.inject(0){|sum, e| sum + 1 if e % 2 == 1}}\n  lst.map!{|s| s.inject(0){|sum,\
    \ e| sum + 1 if e % 2 == 0}}\n  lst.map!{|s| s.inject(0){|sum, e| sum + 1 if e\
    \ % 2 == 1}}\n  lst.map!{|s| s.inject(0){|sum, e| sum + 1 if e % 2 == 0}}\n  lst.map!{|s|\
    \ s.inject(0){|sum, e| sum + 1 if e % 2 == 1}}\n  lst.map!{|s| s.inject(0){|sum,\
    \ e| sum + 1 if e % 2 == 0}}\n  lst.map!{|s| s.inject(0){|sum, e| sum + 1 if e\
    \ % 2 == 1}}\n  lst.map!{|s| s.inject(0){|sum, e| sum + 1 if ", "  lst.map { |s|\
    \ s.chars.map(&:to_i).reduce(:+) }\nend", "  lst.map { |s| s.chars.map { |c| c.to_i.odd?\
    \ ? 1 : 0 }.sum }\nend", "  lst.map { |x| x.to_s.split(\"\").map { |y| y.to_i\
    \ }.inject(:+) }\nend", "  lst.map { |s| s.chars.map(&:to_i).reduce(:+) }\nend",
  "  lst.map {|s| s.chars.map(&:to_i).reduce(:+).odd? ? s.size : nil}.compact\nend",
  "  lst.map {|s| s.chars.map(&:to_i).reduce(:+).odd? ? s.size : nil}.compact\nend",
  "  lst.map { |x| x.to_s.split(\"\").map { |y| y.to_i.odd? ? 1 : 0 }.inject(:+) }\n\
    end", "  lst.map { |s| s.chars.map(&:to_i).reduce(:+) }\nend", "  lst.map { |s|\
    \ s.chars.map(&:to_i).reduce(:+) }\nend", "  lst.map { |s| s.chars.map(&:to_i).reduce(:+)\
    \ }\nend", "  lst.map { |s| s.chars.map { |c| c.to_i.odd? ? 1 : 0 }.inject(:+)\
    \ }\nend", "  lst.map { |s| s.chars.map(&:to_i).reduce(:+) }\nend", "  lst.map\
    \ { |s| s.chars.map(&:to_i).reduce(:+) }\nend", "  lst.map { |s| s.split(//).count\
    \ { |x| x.odd? } }\nend", "  lst.map { |x| x.to_s.split(\"\").map(&:odd?).reduce(:+)\
    \ }\nend", "  lst.map { |s| s.chars.map(&:to_i).reduce(:+) }\nend", "  lst.map\
    \ { |s| s.chars.map(&:to_i).reduce(:+) }\nend", "  lst.map { |s| s.chars.map(&:to_i).reduce(:+)\
    \ }\nend", "  lst.map { |s| s.chars.map(&:to_i).reduce(:+) }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
