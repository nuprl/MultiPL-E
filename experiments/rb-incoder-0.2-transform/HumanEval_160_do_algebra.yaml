name: HumanEval_160_do_algebra
language: rb
prompt: "# Given two lists operator, and operand. The first list has basic algebra\
  \ operations, and \n# the second list is a list of integers. Use the two given lists\
  \ to build the algebric \n# expression and return the evaluation of this expression.\n\
  # The basic algebra operations:\n# Addition ( + ) \n# Subtraction ( - ) \n# Multiplication\
  \ ( * ) \n# Floor division ( // ) \n# Exponentiation ( ** ) \n# Example:\n# operator['+',\
  \ '*', '-']\n# array = [2, 3, 4, 5]\n# result = 2 + 3 * 4 - 5\n# => result = 9\n\
  # Note:\n# The length of operator list is equal to the length of operand list minus\
  \ one.\n# Operand is a list of of non-negative integers.\n# Operator list has at\
  \ least one operator, and operand list has at least two operands.\ndef do_algebra(operator,\
  \ operand)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_do_algebra\n\
  \    candidate = method(:do_algebra)\n    assert_equal(37, candidate.call([\"**\"\
  , \"*\", \"+\"], [2, 3, 4, 5]))\n    assert_equal(9, candidate.call([\"+\", \"*\"\
  , \"-\"], [2, 3, 4, 5]))\n    assert_equal(8, candidate.call([\"//\", \"*\"], [7,\
  \ 3, 4]))\n  end\nend\n"
completions: ["  result = operand[0]\n  for i in 1..operand.length - 1\n    result\
    \ *= operand[i]\n  end\n  for i in 0..operator.length - 1\n    result *= operator[i]\n\
    \  end\n  result\nend", "  result = 0\n  operator.each do |op|\n    result +=\
    \ (operand.last == op) ? operand.pop : 0\n  end\n  result\nend", "  result = 0\n\
    \  for i in 0..operand.length-1\n    result += (operand[i] * operator[i]) unless\
    \ operand[i] == 0\n  end\n  result\nend", "  result = 0\n  operator.each_with_index\
    \ do |op, i|\n    result += (operand[i] - operand[i - 1]) * op\n  end\n  return\
    \ result\nend", "  result = 0\n  i = 0\n  while i < operand.length\n    operator\
    \ = operator[i]\n    operand = operand[i]\n    case operator\n    when '+' then\
    \ result += operand\n    when '-' then result -= operand\n    when '*' then result\
    \ *= operand\n    when '//' then result /= operand\n    when '**' then result\
    \ **= operand\n    end\n    i += 1\n  end\n  result\nend", "  result = 0\n  for\
    \ i in 0..(operand.length - 1)\n    result += (operand[i] * operator[i]) \n  end\n\
    \  return result\nend", "  result = 0\n  operator.each_with_index do |op, i|\n\
    \    result += operand[i] * operand[i - 1]\n  end\n  result\nend", "  result =\
    \ 0\n  operator.each do |op|\n    result += (operand.index(op) != operand.length\
    \ - 1) ? operand.index(op) * operand.index(op) + operand.index(op) + 1 : operand.index(op)\
    \ * operand.index(op)\n  end\n  result\nend", "  result = 0\n  operator.each do\
    \ |op|\n    result += (operand.last == op) ? operand.pop : 0\n  end\n  result\n\
    end", "  result = 0\n  operand.each do |i|\n    result += (operators.index(operator[0])\
    \ * operand.index(i))\n  end\n  result\nend", "  result = 0\n  for i in 0..operand.length-1\n\
    \    result += (operand[i] * operator[i]) unless operator[i] == '*'\n    result\
    \ /= operand[i] unless operator[i] == '/'\n    result **= operand[i] unless operator[i]\
    \ == '**'\n  end\n  result\nend", "  result = 0\n  operator.each do |op|\n   \
    \ result += (operand.last == op) ? operand.pop : 0\n  end\n  result\nend", " \
    \ result = 0\n  i = 0\n  while i < operand.length\n    operator = operator[i]\n\
    \    operand = operand[i]\n    i += 1\n    case operator\n    when '+' then result\
    \ += operand\n    when '-' then result -= operand\n    when '*' then result *=\
    \ operand\n    when '//' then result /= operand\n    when '**' then result **=\
    \ operand\n    end\n  end\n  result\nend", "  result = 0\n  operand.each do |i|\n\
    \    result += (i if operator.include?(i))\n  end\n  result\nend", "  result =\
    \ 0\n  operator.each do |op|\n    result += (operand.last == op) ? operand.pop\
    \ : 0\n  end\n  result\nend", "  result = 0\n  operator.each_with_index do |op,\
    \ i|\n    result += (operand[i] - operand[i - 1]) * op\n  end\n  result\nend",
  "  result = 0\n  for i in 0...operand.length-1\n    result += (operand[i] * operator[operand.length\
    \ - 1 - i])\n  end\n  result\nend", "  result = nil\n  operator.each do |op|\n\
    \    operand.each do |num|\n      result = num.send(op) result\n    end\n  end\n\
    \  result\nend", "  result = 0\n  for i in 0...operand.length-1\n    result +=\
    \ (operand[i] * operator[operand.length-i-1]) \n  end\n  result\nend", "  result\
    \ = 0\n  for i in 0..(operand.length - 1)\n    result += (operand[i] * operator[operand.length\
    \ - 1 - i]).to_i\n  end\n  result\nend", "  result = 0\n  operator.each do |op|\n\
    \    result += (operand.pop * operand.pop).send(op)\n  end\n  result\nend", " \
    \ result = 0\n  \n  for i in 0..(operand.length-1)\n    result += (operand[i]\
    \ * operator[i])\n  end\n  \n  return result\nend", "  result = 0\n  operand.each\
    \ do |i|\n    result += (operators.index(operator[0]) * operand.index(i))\n  end\n\
    \  result\nend", "  result = 0\n  for i in 0...operand.length-1\n    result +=\
    \ (operand[i] * operator[i])\n  end\n  result\nend", "  result = 0\n  for i in\
    \ 0..operand.length-1\n    result += (operand[i] * operator[operand.length-i-1])\
    \ \n  end\n  result\nend", "  result = 0\n  operand.each do |i|\n    result +=\
    \ (operators.index(operator) + 1) * i\n  end\n  result\nend", "  result = operand[0]\n\
    \  operator.each do |op|\n    result =~ /^#{op}/ ? result *= operand.shift : result\
    \ -= operand.shift\n  end\n  result\nend", "  result = 0\n  for i in 0..operand.length-1\n\
    \    result += (operand[i] * operator[operand.length - 1 - i]).to_i\n  end\n \
    \ result\nend", "  result = 0\n  for i in 0...operand.length-1\n    result +=\
    \ (operand[i] * operator[operand.length - 1 - i]).to_i\n  end\n  result\nend",
  "  result = 0\n  operand.each_with_index do |value, index|\n    result += (index\
    \ == 0) ? value : operator[operator[operand[index-1], operand[index]]]\n  end\n\
    \  result\nend", "  result = 0\n  operator.each do |op|\n    result += (operand.index(op)\
    \ + 1) * (operand.index(op) + 1)\n  end\n  result\nend", "  result = 0\n  i =\
    \ 0\n  while i < operand.length\n    operator = operator[i]\n    operand = operand[i]\n\
    \    i += 1\n    case operator\n    when '+' then result += operand\n    when\
    \ '-' then result -= operand\n    when '*' then result *= operand\n    when '//'\
    \ then result /= operand\n    when '**' then result **= operand\n    end\n  end\n\
    \  result\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n<| c |>\nThis doesn't work.\
    \ `operator` should be an array of symbols. `operand` should be an array of integers.\
    \ `operator[i]` should be `operator[operator.index(i)]`. `operand[i]` should be\
    \ `operand[operand.index(i)]`. `operator` should be `['+','-','*','//','**']`.\
    \ `operand` should be `[2,3,4,5]`.\n<|/ c |>\n<| c |>\nThanks for pointing that\
    \ out. I fixed the code accordingly.\n<|/ c |>\n<| c |>\nThis doesn't work. `operator`\
    \ should be an array of symbols. `operand` should be an array of integers. `operator[i]`\
    \ should be `operator[operator.index(i)]`. `operand[i]` should be `operand[operand.index(i)]`.\
    \ `operator` should be `['+','-','*','//','**']`. `operand` should be `[2,3,4,5]`.\n\
    <|/ c |>\n<| c |>\nI fixed the code accordingly.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work. `operator` should be an array of symbols. `operand` should be an array\
    \ of integers. `operator[i]` should be `operator[operator.index(i)]`. `operand[i]`\
    \ should be `operand[operand.index(i)]`. `operator` should be `['+','-','*','//','**']`.\
    \ `operand` should be `[2,3,4,5]`.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  result\
    \ = 0\n  operator.each do |op|\n    result += (operand.index(op) + 1) * (operand.index(op)\
    \ + 1)\n  end\n  result\nend", "  result = 0\n  for i in 0..operand.length-1\n\
    \    result += (operand[i] * operator[operand.length - 1 - i])\n  end\n  return\
    \ result\nend", "  result = 0\n  i = 0\n  while i < operand.length - 1\n    operator\
    \ = operator[i]\n    operand1 = operand[i]\n    operand2 = operand[i + 1]\n  \
    \  if operator == '+'\n      result = result + operand1 + operand2\n    elsif\
    \ operator == '-'\n      result = result - operand1 - operand2\n    elsif operator\
    \ == '*'\n      result = result * operand1 * operand2\n    elsif operator == '//'\n\
    \      result = result // operand1 / operand2\n    elsif operator == '**'\n  \
    \    result = result ** operand1\n    end\n    i += 1\n  end\n  result\nend",
  "  result = 0\n  for i in 0...operand.length\n    result += (operand[i] * operator[operand.length\
    \ - 1 - i])\n  end\n  return result\nend", "  result = 0\n  operand.each do |i|\n\
    \    result += (operators.index(operator) + 1) * i\n  end\n  result\nend", " \
    \ result = 0\n  \n  # Loop through each operator in operator list\n  operator.each\
    \ do |op|\n    # Loop through each operand in operand list\n    operand.each do\
    \ |operand|\n      # Evaluate expression\n      result = result + eval(op)\n \
    \   end\n  end\n  \n  return result\nend", "  result = 0\n  operand.each do |i|\n\
    \    result += (operators.index(operator[0]) * operand.index(i))\n  end\n  result\n\
    end", "  result = 0\n  operand.each do |i|\n    result += (operators.index(operator[0])\
    \ * operand.index(i))\n  end\n  return result\nend", "  result = 0\n  for i in\
    \ 0..operand.length-1\n    result += (operand[i] * operator[operand.length - 1\
    \ - i])\n  end\n  return result\nend", "  result = 0\n  operand.each do |i|\n\
    \    result += (operators.index(operator) + 1) * i\n  end\n  result\nend", " \
    \ result = 0\n  operator.each do |op|\n    result += (operand.last == op) ? operand.pop\
    \ : 0\n  end\n  result\nend", "  result = 0\n  i = 0\n  while i < operand.length\n\
    \    operator = operator[i]\n    operand = operand[i]\n    i += 1\n    case operator\n\
    \    when '+' then result += operand\n    when '-' then result -= operand\n  \
    \  when '*' then result *= operand\n    when '//' then result /= operand\n   \
    \ when '**' then result **= operand\n    end\n  end\n  result\nend", "  result\
    \ = 0\n  operator.each do |op|\n    result += (operand.last == op) ? operand.pop\
    \ : 0\n  end\n  result\nend", "  result = 0\n  operator.each do |op|\n    result\
    \ += (operand.last == op) ? operand.pop : 0\n  end\n  result\nend", "  result\
    \ = 0\n  operator.each do |op|\n    result += (operand.last == op) ? operand.pop\
    \ : 0\n  end\n  result\nend", "  result = 0\n  operator.each do |op|\n    result\
    \ += (operand.last == op) ? operand.pop : 0\n  end\n  result\nend", "  result\
    \ = 0\n  i = 0\n  while i < operand.length\n    operator = operator[i]\n    operand\
    \ = operand[i]\n    i += 1\n    case operator\n    when '+' then result = result\
    \ + operand\n    when '-' then result = result - operand\n    when '*' then result\
    \ = result * operand\n    when '//' then result = result // operand\n    when\
    \ '**' then result = result ** operand\n    end\n  end\n  return result\nend",
  "  result = 0\n  operator.each do |op|\n    result += (operand.last == op) ? operand.pop\
    \ : 0\n  end\n  result\nend", "  result = 0\n  for i in 0..operand.length-1\n\
    \    result += (operand[i] * operator[operator.length-i-1]) \n  end\n  result\n\
    end", "  result = 0\n  operator.each do |op|\n    result += operand.map { |i|\
    \ eval(\"#{op}(i)\") }.reduce(:+)\n  end\n  result\nend", "  result = 0\n  operator.each\
    \ do |op|\n    result += (operand.last == op) ? operand.pop : 0\n  end\n  result\n\
    end", "  result = 0\n  i = 0\n  while i < operand.length\n    operator = operator[i]\n\
    \    operand = operand[i]\n    i += 1\n    if operator == '+'\n      result =\
    \ result + operand\n    elsif operator == '-'\n      result = result - operand\n\
    \    elsif operator == '*'\n      result = result * operand\n    elsif operator\
    \ == '//'\n      result = result // operand\n    elsif operator == '**'\n    \
    \  result = result ** operand\n    end\n  end\n  result\nend", "  result = 0\n\
    \  operand.each do |x|\n    result += (x.to_i * operator[operator.length-1].to_i)\
    \ * operand[operand.length-1].to_i\n  end\n  return result\nend", "  result =\
    \ 0\n  operator.each do |op|\n    result += (operand.pop * operand.pop).send(op)\n\
    \  end\n  result\nend", "  result = 0\n  for i in 0...operand.length\n    result\
    \ += (operand[i] * operator[operand.length - 1 - i])\n  end\n  result\nend", " \
    \ result = 0\n  operator.each do |op|\n    result += (operand.last == op) ? operand.pop\
    \ : 0\n  end\n  result\nend", "  result = 0\n  for i in 0..operand.length-1\n\
    \    result += (operand[i] * operator[i])\n  end\n  return result\nend", "  result\
    \ = 0\n  for i in 0..operand.length-1\n    result += (operand[i] * operator[operand.length\
    \ - 1 - i])\n  end\n  result\nend", "  result = 0\n  operator.each do |op|\n \
    \   result += (operand.last == op) ? operand.pop : 0\n  end\n  result\nend", " \
    \ result = 0\n  operator.each do |op|\n    result += (operand.last == op) ? operand.pop\
    \ : 0\n  end\n  result\nend", "  result = 0\n  \n  for i in 0...operand.length-1\n\
    \    result += (operand[i] * operator[i])\n  end\n  \n  return result\nend", " \
    \ result = 0\n  operator.each do |op|\n    result += (operand.pop * operand.pop).send(op)\n\
    \  end\n  result\nend", "  result = 0\n  i = 0\n  while i < operand.length\n \
    \   operator = operator[i]\n    operand = operand[i]\n    i += 1\n    case operator\n\
    \    when '+' then result += operand\n    when '-' then result -= operand\n  \
    \  when '*' then result *= operand\n    when '//' then result /= operand\n   \
    \ when '**' then result **= operand\n    end\n  end\n  result\nend", "  result\
    \ = 0\n  operator.each do |op|\n    result += (operand.last == op) ? operand.pop\
    \ : 0\n  end\n  result\nend", "  result = 0\n  for i in 0..operand.length-1\n\
    \    result += (operand[i] * operator[i])\n  end\n  result\nend", "  result =\
    \ 0\n  for i in 0...operand.length-1\n    result += (operand[i] * operator[i])\n\
    \  end\n  result\nend", "  result = 0\n  for i in 0..(operand.length-1)\n    result\
    \ += (operand[i] * operator[i])\n  end\n  result\nend", "  result = 0\n  for i\
    \ in 0..operand.length-1\n    result += (operand[i] * operator[operand.length\
    \ - 1 - i]).to_i\n  end\n  result\nend", "  result = 0\n  for i in 0..operand.length-1\n\
    \    result += (operand[i] * operator[i])\n  end\n  result\nend", "  result =\
    \ 0\n  for i in 0..operand.length-1\n    result += (operand[i] * operator[operand.length\
    \ - 1 - i])\n  end\n  return result\nend", "  result = 0\n  operand.each do |operand|\n\
    \    result += (operand.to_f * operator[0]).to_i\n    operator.shift\n  end\n\
    \  result\nend", "  result = 0\n  operator.each do |op|\n    result += (operand.last\
    \ == op) ? operand.pop : 0\n  end\n  result\nend", "  result = 0\n  operator.each\
    \ do |op|\n    result += (operand.index(op) + 1) * (operand.index(op) + 1)\n \
    \ end\n  return result\nend", "  result = 0\n  operator.each do |op|\n    result\
    \ += operand.map { |i| eval(\"#{op}#{i}\") }\n  end\n  result\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
