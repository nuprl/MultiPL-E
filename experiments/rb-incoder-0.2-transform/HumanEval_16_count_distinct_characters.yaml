name: HumanEval_16_count_distinct_characters
language: rb
prompt: "# Given a string, find out how many distinct characters (regardless of case)\
  \ does it consist of\n# >>> count_distinct_characters.call(\"xyzXYZ\")\n# 3\n# >>>\
  \ count_distinct_characters.call(\"Jerry\")\n# 4\ndef count_distinct_characters(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_distinct_characters\n\
  \    candidate = method(:count_distinct_characters)\n    assert_equal(0, candidate.call(\"\
  \"))\n    assert_equal(5, candidate.call(\"abcde\"))\n    assert_equal(5, candidate.call(\"\
  abcdecadeCADE\"))\n    assert_equal(1, candidate.call(\"aaaaAAAAaaaa\"))\n    assert_equal(5,\
  \ candidate.call(\"Jerry jERRY JeRRRY\"))\n  end\nend\n"
completions: ["  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n\
    \  string.gsub(/[^a-z]+/, \"\").length\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\n\
    end", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |c| c.ord }\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\n\
    end", "  string.downcase!\n  string.gsub(/[^a-z]/i, '')\n    .count\nend", " \
    \ string.downcase!\n  string.gsub(/[[:alpha:]]/) { |char| char.ord }\n  string.scan(/[[:alpha:]]/).uniq.size\n\
    end", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n\
    \  string.gsub(/[^a-z]+/, '').length\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend",
  "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| string.count(c) }\nend",
  "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |char| char.ord }.uniq.size\n\
    end", "  string.split(\"\").uniq.size\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/).size\n\
    end", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n\
    \  string.gsub(/[^a-z]+/, \"\").length\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/).length\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend",
  "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |char| char.ord }\n  string.scan(/[[:alpha:]]/).uniq.size\n\
    end", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n\
    \  string.gsub(/[^a-z]/i, '').length\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/)\
    \ { |c| c.length }\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this solution,\
    \ but I wonder if there is a way to make it more efficient? It seems like a lot\
    \ of unnecessary work to me. Maybe I'm missing something, but this solution seems\
    \ to require a lot of extra memory to store the hash. Is there a way to do this\
    \ without storing the hash?\n<|/ c |>\n<| c |>\n: I doubt that there's a way to\
    \ do this without storing the hash. `Hash#count` has to iterate over the entire\
    \ string and count the characters. If you don't need the count for anything else,\
    \ just use `Hash#length` instead. `Hash#length` doesn't iterate over the entire\
    \ string, so it's more efficient.\n<|/ c |>\n<| c |>\n: I added a more efficient\
    \ solution that doesn't require storing the hash.\n<|/ c |>\n<| c |>\n: I added\
    \ a more efficient solution that doesn't require storing the hash.\n<|/ c |>\n\
    <| c |>\n: I added a more efficient solution that doesn't require storing the\
    \ hash.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend",
  "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend", "  string.downcase!\n\
    \  string.gsub(/[^a-z]/i).length\nend", "  string.split(\"\").uniq.size\nend",
  "  string.downcase!\n  string.gsub(/[[:alpha:]]/).uniq.size\nend", "  string.downcase!\n\
    \  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\n\
    end", "  string.downcase!\n  string.gsub(/[^a-z]/i, '').length\nend", "  string.split(\"\
    \").uniq.size\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend",
  "  string.downcase!\n  string.gsub(/[[:upper:]]/).length\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend", "  string.split(\"\").uniq.size\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend",
  "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/)\
    \ { |c| c.ord }\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.ord }\nend", " \
    \ string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/).length\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nI like your solution, but I believe it can\
    \ be made more efficient by not using gsub and instead using each_char and counting\
    \ each char's length. Also, since you're using each_char, you don't need to downcase\
    \ your string before counting distinct characters.\n<|/ c |>\n<| c |>\n: Yes,\
    \ I agree that `each_char` is more efficient. I'll edit my answer to include your\
    \ suggestions.\n<|/ c |>\n<| c |>\nI like your solution, but I believe it can\
    \ be made more efficient by not using gsub and instead using each_char and counting\
    \ each char's length. Also, since you're using each_char, you don't need to downcase\
    \ your string before counting distinct characters.\n<|/ c |>\n<| c |>\n: Yes,\
    \ I agree that `each_char` is more efficient. I'll edit my answer to include your\
    \ suggestions.\n<|/ c |>\n<| c |>\n: I added a benchmark test to my answer. Your\
    \ solution is about twice as fast as mine.\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.ord }.length\nend", " \
    \ string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.ord }\n  string.scan(/[[:alpha:]]/).uniq.size\n\
    end", "  string.downcase!\n  string.gsub(/[^a-z]+/, \"\").length\nend", "  string.downcase!\n\
    \  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/)\
    \ { |c| c.ord }\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |char| char.ord }\n\
    \  string.scan(/[[:alpha:]]/).size\nend\n</code>\n<|/ a tags=ruby,string,regex\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to do it without\
    \ using gsub. I'm thinking about using scan, but I'm not sure how to do it.\n\
    <|/ c |>\n<| c |>\n: I added a solution without `gsub`.\n<|/ c |>\n<| c |>\n:\
    \ I added a solution without `gsub`.\n<|/ c |>\n<| c |>\n: I added a solution\
    \ without `gsub`.\n<|/ c |>\n<| c |>\n: I added a solution without `gsub`.\n<|/\
    \ c |>\n<| a tags=ruby,string,regex |>\n<code>", "  string.split(\"\").uniq.size\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend",
  "  string.downcase!\n  string.gsub(/[[:alpha:]]/).size\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/).length\nend", "  string.downcase!\n\
    \  string.gsub(/[^a-z]/i, '')\nend", "  string.downcase!\n  string.gsub(/[^a-z]+/,\
    \ \"\").length\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend",
  "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "  string.downcase!\n  string.gsub(/[[:alpha:]]/).length\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.ord }\n  string.scan(/[[:alpha:]]/).uniq.size\n\
    end", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThis doesn't work if there are multiple consecutive spaces.\n<|/ c |>\n\
    <| c |>\n: Yes, it does. I tested it before posting. Did you try it?\n<|/ c |>\n\
    <| c |>\nI did, and it doesn't work. Try it on \"abc def\".\n<|/ c |>\n<| c |>\n\
    : I tested it again and it works. I added a test case to my answer.\n<|/ c |>\n\
    <| c |>\nI tested it again and it works. I added a test case to my answer.\n<|/\
    \ c |>\n<| a tags=ruby,string |>\n<code>", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\n\
    end", "  string.downcase!\n  string.gsub(/[^a-z]/i, '')\n    .size\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis doesn't answer the question. OP\
    \ asked for a way to count the number of distinct characters in a string. Your\
    \ solution counts how many distinct characters are in a string.\n<|/ c |>\n<|\
    \ c |>\nI guess I misunderstood the question. I'll leave this here in case it\
    \ helps someone else.\n<|/ c |>\n<| c |>\nThis doesn't answer the question. OP\
    \ asked for a way to count the number of distinct characters in a string. Your\
    \ solution counts how many distinct characters are in a string.\n<|/ c |>\n<|\
    \ c |>\nThis doesn't answer the question. OP asked for a way to count the number\
    \ of distinct characters in a string. Your solution counts how many distinct characters\
    \ are in a string.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/)\
    \ { |c| c.length }\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nI like your\
    \ use of downcase and gsub. Very clever!\n<|/ c |>\n<| c |>\nI like your use of\
    \ downcase and gsub. Very clever!\n<|/ c |>\n<| c |>\nI like your use of downcase\
    \ and gsub. Very clever!\n<|/ c |>\n<| c |>\nI like your use of downcase and gsub.\
    \ Very clever!\n<|/ c |>\n<| c |>\nI like your use of downcase and gsub. Very\
    \ clever!\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  string.downcase!\n  string.gsub(/[[:alpha:]]/)\
    \ { |char| char.ord }\n  string.scan(/[[:alpha:]]/).size\nend", "  string.downcase!\n\
    \  string.gsub(/[[:upper:]]/, '')\n  string.gsub(/[[:lower:]]/, '')\n  string.count('a')\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI like your solution, but I believe\
    \ it would be better to use a `Hash` rather than a `Set`.  It would also make\
    \ sense to cache the `downcase` result in a local variable rather than repeatedly\
    \ calling `downcase` on the string.\n<|/ c |>\n<| c |>\nI agree that caching the\
    \ `downcase` result would be better. I'll update the answer.\n<|/ c |>\n<| c |>\n\
    I agree that caching the `downcase` result would be better. I'll update the answer.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  string.split(\"\").uniq.size\nend", " \
    \ string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.ord }\n  string.scan(/[[:alpha:]]/).uniq.size\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nI like this solution, but I\
    \ wonder if there is a way to make it more efficient. For example, `string.gsub(/[[:alpha:]]/)\
    \ { |c| c.ord }` will create a temporary array and iterate over it twice, once\
    \ to count the characters, and once to convert the characters to their ordinals.\
    \ Is there a way to avoid the temporary array?\n<|/ c |>\n<| c |>\n: I doubt it.\
    \ I would expect `gsub` to return a new string with the substitution performed,\
    \ so I doubt it would be possible to avoid the temporary array.\n<|/ c |>\n<|\
    \ c |>\n: I added a version that doesn't use temporary arrays. I doubt it's any\
    \ more efficient.\n<|/ c |>\n<| c |>\n: I added a version that doesn't use temporary\
    \ arrays. I doubt it's any more efficient.\n<|/ c |>\n<| a dscore=3 |>\n<code>",
  "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend", "  string.downcase!\n\
    \  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/)\
    \ { |char| char.ord }\n  string.scan(/[[:alpha:]]/).uniq.size\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/).uniq.size\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/).uniq.size\n\
    end", "  string.downcase!\n  string.gsub(/[^a-z]/i, '')\nend", "  string.downcase!\n\
    \  string.gsub(/[^a-z]/i, '')\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like\
    \ this solution, but I believe it would be more efficient to just use `.count`\
    \ instead of `.length` since you're not actually using the `length` method anywhere.\n\
    <|/ c |>\n<| c |>\nI agree with you, `count` would be more efficient, but I wanted\
    \ to keep it simple and easy to understand. Also, I think it's easier to understand\
    \ than `length` :)\n<|/ c |>\n<| c |>\nI agree, `count` is more efficient, but\
    \ I wanted to keep it simple and easy to understand. Also, I think it's easier\
    \ to understand than `length` :)\n<|/ c |>\n<| c |>\nI agree, `count` is more\
    \ efficient, but I wanted to keep it simple and easy to understand. Also, I think\
    \ it's easier to understand than `length` :)\n<|/ c |>\n<| c |>\nI agree, `count`\
    \ is more efficient, but I wanted to keep it simple and easy to understand. Also,\
    \ I think it's easier to understand than `length` :)\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  string.split(\"\").uniq.size\nend", "  string.split(\"\").uniq.size\n\
    end", "  string.split(\"\").uniq.size\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/)\
    \ { |c| c.length }\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) {\
    \ |c| c.length }\nend", "  string.split(\"\").uniq.size\nend", "  string.downcase!\n\
    \  string.gsub(/[^a-z]/i).length\nend", "  string.split(\"\").uniq.size\nend",
  "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| string.count(c) }\nend",
  "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/)\
    \ { |c| c.length }\nend", "  string.split(\"\").uniq.size\nend", "  string.downcase!\n\
    \  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/)\
    \ { |c| c.length }\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i, '')\n\
    \    .count\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nI like your\
    \ solution, however I believe it can be improved by using `.count` instead of\
    \ `.length`\n<|/ c |>\n<| c |>\nI agree, `.count` would be more efficient. I've\
    \ updated my answer.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |c| c.ord }.length\nend", "  string.downcase!\n\
    \  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/)\
    \ { |c| c.length }\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) {\
    \ |c| c.length }\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=ruby,string |>\n<code>", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/).length\nend", "  string.downcase!\n  string.gsub(/[^a-z]+/,\
    \ \"\").length\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/).uniq.size\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |char| char.ord }\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/).uniq.size\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |c| c.ord }\nend", "  string.split(\"\").uniq.size\n\
    end", "  string.split(\"\").uniq.size\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/).length\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend",
  "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n\
    \  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n  string.gsub(/[^a-z]+/).length\n\
    end", "  string.downcase!\n  string.gsub(/[^a-z]/i, '').length\nend", "  string.downcase!\n\
    \  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i,\
    \ '')\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.split(\"\
    \").uniq.size\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.ord\
    \ }\n  string.scan(/[[:alpha:]]/).uniq.size\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i,\
    \ '').length\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.length\
    \ }\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.length }\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis doesn't seem to work. `count_distinct_characters.call(\"\
    Jerry\")` returns `4` instead of `3`.\n<|/ c |>\n<| c |>\n: I tested it and it\
    \ works fine for me. Are you sure you copied it correctly? I tested it with `ruby\
    \ 1.9.2p290 (2011-07-09 revision 32553) [x86_64-darwin10.8.0]`.\n<|/ c |>\n<|\
    \ c |>\n: I updated my answer with a more complete solution that also works with\
    \ Ruby 1.8.7.\n<|/ c |>\n<| c |>\n: I updated my answer with a more complete solution\
    \ that also works with Ruby 1.8.7.\n<|/ c |>\n<| c |>\n: I updated my answer with\
    \ a more complete solution that also works with Ruby 1.8.7.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.length\
    \ }\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/).length\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\n\
    end", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.split(\"\
    \").uniq.size\nend", "  string.split(\"\").uniq.size\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/).length\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/)\
    \ { |c| string.count(c) }\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/)\
    \ { |c| string.count(c) }\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ work if there are multiple consecutive uppercase letters.\n<|/ c |>\n<| c |>\n\
    : Yes, it does. Try it out with `\"AaBbCc\"`.\n<|/ c |>\n<| c |>\nAh, I missed\
    \ that. Sorry.\n<|/ c |>\n<| c |>\n: No worries, I added a version that works\
    \ with multiple consecutive uppercase letters.\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |c| c.ord }\n  string.scan(/[[:alpha:]]/).size\n\
    end", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.split(\"\
    \").uniq.size\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend",
  "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |c| c.ord }\n  string.scan(/[[:alpha:]]/).uniq.size\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,string |>\n<code>", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/).uniq.size\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/)\
    \ { |c| c.ord }\n  string.scan(/[[:alpha:]]/).uniq.size\nend", "  string.downcase!\n\
    \  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/)\
    \ { |c| c.ord }\n  string.scan(/[[:alpha:]]/).uniq.size\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |char| char.ord }\n\
    \  string.scan(/[[:alpha:]]/).uniq.size\nend", "  string.split(\"\").uniq.size\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/).uniq.size\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |c| c.size }\nend", "  string.split(\"\").uniq.size\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend",
  "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend", "  string.split(\"\
    \").uniq.size\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/).uniq.size\n\
    end", "  string.downcase!\n  string.gsub(/[^a-z]/i, '')\n    .count\nend", " \
    \ string.downcase!\n  string.gsub(/[[:alpha:]]/).length\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |c| c.size }\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend\n\
    </code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis doesn't work for strings with\
    \ multiple repeated characters. For example, `count_distinct_characters.call(\"\
    abcabc\") => 3` but should be `2`.\n<|/ c |>\n<| c |>\n: I agree. My answer was\
    \ meant as a starting point for OP to build on and to show that he can use Ruby\
    \ methods to solve his problem. He can then improve the method and make it more\
    \ robust. He can then improve it further and make it even more robust. He can\
    \ then improve it further and make it even more robust. He can then improve it\
    \ further and make it even more robust. He can then improve it further and make\
    \ it even more robust. He can then improve it further and make it even more robust.\
    \ He can then improve it further and make it even more robust. He can then improve\
    \ it further and make it even more robust. He can then improve it further and\
    \ make it even more robust. He can then improve it further and make it even more\
    \ robust. He can then improve it further and make it even more robust. He can\
    \ then improve it further and make it even more robust. He can then improve it\
    \ further and make it even more robust. He can then improve it further and make\
    \ it even more robust. He can then improve it further and make it even more robust.\
    \ He can then improve it further and make it even more robust. He can then improve\
    \ it further and make it even more robust. He can then improve it further and\
    \ make it even more robust. He can then improve it further and make it even more\
    \ robust. He can then improve it further and make it even more robust. He can\
    \ then improve it further and make it even more robust. He can then improve it\
    \ further and make it even more robust. He can then improve it further and make\
    \ it even more robust. He can then improve it further and make it even more robust.\
    \ He can then improve it further and make it even more robust. He can then improve\
    \ it further and make it even more robust. He can then improve it further and\
    \ make it even more robust. He can then improve it further and make it even more\
    \ robust. He can then improve it ", "  string.downcase!\n  string.gsub(/[[:alpha:]]/).length\n\
    end", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend\n</code>\n<|/ a tags=ruby,regex\
    \ |>\n<| c |>\nI like your solution, but I wonder why you used `gsub` instead\
    \ of `scan`? I thought `scan` was more efficient than `gsub`?\n<|/ c |>\n<| c\
    \ |>\n`scan` will match all occurrences of `[[:alpha:]]` whereas `gsub` will only\
    \ match the first occurrence. `scan` will also return an array of the matched\
    \ characters. `gsub` will return the number of matched characters. I used `gsub`\
    \ because I wanted to return the number of distinct characters instead of an array\
    \ of matched characters. I used `gsub` because I wanted to return the number of\
    \ distinct characters instead of an array of matched characters. I used `gsub`\
    \ because I wanted to return the number of distinct characters instead of an array\
    \ of matched characters. I used `gsub` because I wanted to return the number of\
    \ distinct characters instead of an array of matched characters. I used `gsub`\
    \ because I wanted to return the number of distinct characters instead of an array\
    \ of matched characters.\n<|/ c |>\n<| c |>\nI see. Thanks for the explanation!\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| string.count(c)\
    \ }\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i, '')\n    .count\nend",
  "  string.downcase!\n  string.gsub(/[[:alpha:]]/) { |char| char.ord }\nend", " \
    \ string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend", "  string.downcase!\n\
    \  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/).uniq.size\n\
    end", "  string.downcase!\n  string.gsub(/[^a-z]+/, \"\").length\nend", "  string.downcase!\n\
    \  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i,\
    \ '')\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/)\
    \ { |c| c.ord }\n  string.scan(/[[:alpha:]]/).size\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i,\
    \ '')\n    .size\nend", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\n\
    end", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |char| char.ord }\nend", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/).length\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/)\
    \ { |c| c.length }\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/).length\n\
    end", "  string.split(\"\").uniq.size\nend", "  string.downcase!\n  string.gsub(/[[:upper:]]/,\
    \ '')\n  string.gsub(/[[:lower:]]/, '')\n  string.count('a')\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nI like the idea of using downcase and gsub to remove\
    \ all uppercase letters. I didn't know about that method.\n<|/ c |>\n<| c |>\n\
    I added a version that uses `downcase` and `gsub` as well.\n<|/ c |>\n<| c |>\n\
    I added a version that uses `downcase` and `gsub` as well.\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  string.split(\"\").uniq.size\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/).uniq.size\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your answer! I really appreciate\
    \ it. I was wondering if there is a way to do this without using regular expressions?\
    \ I understand that they are very powerful, but I wanted to know if there was\
    \ a way to do this without them.\n<|/ c |>\n<| c |>\nI added a solution without\
    \ regular expressions.\n<|/ c |>\n<| c |>\nThanks for your answer! I really appreciate\
    \ it. I was wondering if there is a way to do this without using regular expressions?\
    \ I understand that they are very powerful, but I wanted to know if there was\
    \ a way to do this without them.\n<|/ c |>\n<| c |>\nI added a solution without\
    \ regular expressions.\n<|/ c |>\n<| c |>\nThanks for your answer! I really appreciate\
    \ it. I was wondering if there is a way to do this without using regular expressions?\
    \ I understand that they are very powerful, but I wanted to know if there was\
    \ a way to do this without them.\n<|/ c |>\n<| a |>\n<code>", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |char| char.ord }\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| c |>\nThis doesn't work for me. `count_distinct_characters.call(\"xyzXYZ\"\
    )` returns `3` instead of `2`.\n<|/ c |>\n<| c |>\n: I tested it and it works.\
    \ Are you sure you copied the code correctly?\n<|/ c |>\n<| c |>\nYes, I copied\
    \ it exactly. I'm running Rails 3.2.13. Maybe it's an issue with Rails 3.2.13?\n\
    <|/ c |>\n<| c |>\n: I tested it on Rails 3.2.13 and it works. Are you sure you\
    \ copied the code correctly?\n<|/ c |>\n<| c |>\nYes, I copied it exactly. I'm\
    \ running Rails 3.2.13. Maybe it's an issue with Rails 3.2.13?\n<|/ c |>\n<| a\
    \ |>\n<code>", "  string.downcase!\n  string.gsub(/[^a-z]/i).length\nend", " \
    \ string.downcase!\n  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend\n</code>\n\
    <|/ a |>\n<| c |>\nI like your solution, however it only works for ASCII characters.\
    \ If you try `count_distinct_characters.call(\"\xC4\")` it returns `1` instead\
    \ of `2`.\n<|/ c |>\n<| c |>\n: Yes, I noticed that too. I've updated my answer\
    \ to account for that case. Thanks!\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  string.downcase!\n\
    \  string.gsub(/[[:alpha:]]/) { |c| c.length }\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/).size\n\
    end", "  string.downcase!\n  string.gsub(/[[:alpha:]]/).uniq.size\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nI like this solution, but I wonder\
    \ if there's a way to do this without having to call `downcase` on the string.\
    \ Maybe `downcase!` would be a better name?\n<|/ c |>\n<| c |>\nI agree, `downcase!`\
    \ would be a better name. I will update my answer.\n<|/ c |>\n<| c |>\nI like\
    \ your solution, however it seems like it would be more efficient to just use\
    \ `string.gsub(/[[:alpha:]]/).uniq.size` instead of `string.downcase!; string.gsub(/[[:alpha:]]/).uniq.size`\n\
    <|/ c |>\n<| c |>\nI agree, `downcase!` would be a better name. I will update\
    \ my answer.\n<|/ c |>\n<| c |>\nI like your solution, however it seems like it\
    \ would be more efficient to just use `string.gsub(/[[:alpha:]]/).uniq.size` instead\
    \ of `string.downcase!; string.gsub(/[[:alpha:]]/).uniq.size`\n<|/ c |>\n<| a\
    \ tags=ruby,ruby-on-rails |>\n<code>", "  string.split(\"\").uniq.size\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
