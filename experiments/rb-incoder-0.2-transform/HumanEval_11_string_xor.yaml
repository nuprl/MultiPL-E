name: HumanEval_11_string_xor
language: rb
prompt: "# Input are two strings a and b consisting only of 1s and 0s.\n# Perform\
  \ binary XOR on these inputs and return result also as a string.\n# >>> string_xor.call(\"\
  010\", \"110\")\n# \"100\"\ndef string_xor(a, b)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_xor\n\
  \    candidate = method(:string_xor)\n    assert_equal(\"010010\", candidate.call(\"\
  111000\", \"101010\"))\n    assert_equal(\"0\", candidate.call(\"1\", \"1\"))\n\
  \    assert_equal(\"0101\", candidate.call(\"0101\", \"0000\"))\n  end\nend\n"
completions: ["  a.each_byte { |b| b ^= b }\n  a.join\nend", "  a = a.to_s\n  b =\
    \ b.to_s\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte\
    \ { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n\
    \  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c|\
    \ b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte\
    \ { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n\
    \  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c|\
    \ b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte\
    \ { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n\
    \  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c|\
    \ b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte\
    \ { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n\
    \  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c|\
    \ b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte\
    \ { |c| a << c }\n  b.each_byte { |c| b ", "  a.to_i(2).xor(b.to_i(2)).to_s(2)\n\
    end", "  a.each_byte { |c| b << c }\n  b.each_byte { |c| a << c }\n  a.join\n\
    end", "  a.to_i(2) ^ b.to_i(2) \nend", "  a.unpack('C*').pack('C*').unpack('C*').pack('C*')\
    \ ^ b.unpack('C*').pack('C*').unpack('C*').pack('C*')\nend", "  a = a.to_s\n \
    \ b = b.to_s\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte\
    \ { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n\
    \  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c|\
    \ b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte\
    \ { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n\
    \  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c|\
    \ b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte\
    \ { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n\
    \  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c|\
    \ b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte\
    \ { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n\
    \  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c|\
    \ b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte\
    \ { |c| a << c }\n  b.each_byte { |c| b ", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n\
    \  xor = Array.new(a_bin.length)\n  a_bin.each_index do |i|\n    xor[i] = a_bin[i]\
    \ ^ b_bin[i]\n  end\n  xor.to_s(2)\nend", "  a = a.to_s\n  b = b.to_s\n  result\
    \ = \"\"\n  for i in 0..(b.length-1)\n    result << a[i] ^ b[i]\n  end\n  result\n\
    end", "  a = a.to_s\n  b = b.to_s\n  xor = a.xor(b)\n  xor = xor.to_s\n  return\
    \ xor\nend", "  result = \"\"\n  a.each_byte do |x|\n    result << x ^ b.byte(0)\
    \ unless x == 0\n  end\n  result\nend", "  a.unpack('C*').inject(:^)\nend", " \
    \ a = a.to_s\n  b = b.to_s\n  xor = a.xor(b)\n  xor = xor.to_s\n  return xor\n\
    end", "  result = \"\"\n  a.each_byte { |b| result << b ^ b.to_s(2) }\n  b.each_byte\
    \ { |a| result << a ^ a.to_s(2) }\n  result\nend", "  a.unpack('C*').inject(:^)\n\
    end", "  a = a.to_s\n  b = b.to_s\n  result = \"\"\n  a.each_byte { |c| result\
    \ << c ^ b.shift }\n  result\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n\
    This doesn't work for strings with more than 2 characters. For example, `string_xor.call(\"\
    010\", \"110\")` returns `\"010\"`.\n<|/ c |>\n<| c |>\nYes, it does. I tested\
    \ it before posting. Try it yourself.\n<|/ c |>\n<| c |>\nOh, I see. My mistake.\
    \ Sorry. :)\n<|/ c |>\n<| c |>\nI tested it again and it works. I must have had\
    \ a typo when I first tested it.\n<|/ c |>\n<| c |>\nI tested it again and it\
    \ works. I must have had a typo when I first tested it.\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  a_bin = a.to_s(2).split(//).map(&:to_i)\n  b_bin = b.to_s(2).split(//).map(&:to_i)\n\
    \  result = []\n  a_bin.each do |x|\n    result << x ^ b_bin.pop\n  end\n  result.join\n\
    end\n</code>\n<|/ a tags=ruby,bit-manipulation,algorithm |>\n<| c |>\nI like this\
    \ solution, but I wonder if it can be made more efficient by using a lookup table\
    \ instead of `pop` on each iteration.\n<|/ c |>\n<| c |>\nI added a lookup table\
    \ version. Not sure if it can be made more efficient.\n<|/ c |>\n<| c |>\nI added\
    \ a lookup table version. Not sure if it can be made more efficient.\n<|/ c |>\n\
    <| c |>\nI added a lookup table version. Not sure if it can be made more efficient.\n\
    <|/ c |>\n<| c |>\nI added a lookup table version. Not sure if it can be made\
    \ more efficient.\n<|/ c |>\n<| a tags=ruby,bit-manipulation,algorithm |>\nHere's\
    \ a solution that uses recursion:\n<code>", "  a.each_char.with_index do |x, i|\n\
    \    b.each_char.with_index do |y, j|\n      xor x[i], y[j]\n    end\n  end\n\
    end", "  a.unpack('C*').pack('C*') ^ b.unpack('C*').pack('C*')\nend", "  a.each_byte\
    \ { |b| a << b }\n  b.each_byte { |a| a << b }\n  a.join\nend", "  a.each_char.with_index\
    \ do |char, index|\n    b.each_char.with_index do |char2, index2|\n      result[index]\
    \ ^= char2[index]\n    end\n  end\n  result.join\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nThis doesn't work if `a` and `b` are both empty strings. `xor`\
    \ returns an empty string in this case.\n<|/ c |>\n<| c |>\n: Yes, I noticed that\
    \ and fixed it.\n<|/ c |>\n<| c |>\n: I added a version that works with empty\
    \ strings as well.\n<|/ c |>\n<| c |>\n: I added a version that works with empty\
    \ strings as well.\n<|/ c |>\n<| c |>\n: I added a version that works with empty\
    \ strings as well.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  a.to_i(2).xor(b.to_i(2)).to_s(2)\n\
    end", "  a.each_byte { |c| b << c }\n  b.each_byte { |c| a << c }\n  a.join\n\
    end", "  a.each_char do |c|\n    b << c ^ a\n  end\n  b.join\nend", "  a.each_byte\
    \ { |b| b ^= b }\n  a.join\nend", "  a = a.to_s\n  b = b.to_s\n  result = \"\"\
    \n  a.each_byte do |x|\n    result << x ^ b\n  end\n  result\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThis doesn't work for strings with more than 2 characters. Try\
    \ it with `string_xor(\"010\", \"110\")`.\n<|/ c |>\n<| c |>\nThanks for pointing\
    \ that out. I've updated the answer to include a solution for strings with more\
    \ than 2 characters.\n<|/ c |>\n<| c |>\nThis doesn't work for strings with more\
    \ than 2 characters. Try it with `string_xor(\"010\", \"110\")`.\n<|/ c |>\n<|\
    \ c |>\nThanks for pointing that out. I've updated the answer to include a solution\
    \ for strings with more than 2 characters.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ for strings with more than 2 characters. Try it with `string_xor(\"010\", \"\
    110\")`.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  result = \"\"\n  a.each_byte\
    \ do |x|\n    result << x ^ b.byte\n  end\n  result\nend", "  a = a.to_s\n  b\
    \ = b.to_s\n  xor = a.unpack(\"C*\").inject(:^)\n  xor = xor.to_s(2)\n  xor =\
    \ xor.gsub(/(.)(.)/, '\\1\\2')\n  xor = xor.gsub(/(.)(.)/, '\\1\\2')\n  xor =\
    \ xor.gsub(/(.)(.)/, '\\1\\2')\n  xor = xor.gsub(/(.)(.)/, '\\1\\2')\n  xor =\
    \ xor.gsub(/(.)(.)/, '\\1\\2')\n  xor = xor.gsub(/(.)(.)/, '\\1\\2')\n  xor =\
    \ xor.gsub(/(.)(.)/, '\\1\\2')\n  xor = xor.gsub(/(.)(.)/, '\\1\\2')\n  xor =\
    \ xor.gsub(/(.)(.)/, '\\1\\2')\n  xor = xor.gsub(/(.)(.)/, '\\1\\2')\n  xor =\
    \ xor.gsub(/(.)(.)/, '\\1\\2')\n  xor = xor.gsub(/(.)(.)/, '\\1\\2')\n  xor =\
    \ xor.gsub(/(.)(.)/, '\\1\\2')\n  xor = xor.gsub(/(.)(.)/, '\\1\\2')\n  xor =\
    \ xor.gsub(/(.)(.)/, '\\1\\2')\n  xor = xor.gsub(/(.)(.)/, '\\1\\2')\n  xor =\
    \ xor.gsub(/(.)(.)/, '\\1\\2')\n  xor = xor.gsub(/(.)(.)/, '\\1\\2')\n  xor =\
    \ xor.gsub(/(.)(.)/, '\\1\\2')\n  xor = xor.gsub(/(.)(.)/, '\\1\\2')\n  xor =\
    \ xor.gsub(/(.)(.)/, '\\1\\2')\n  xor = xor.gsub(/(.)(.)/, '\\1\\2')\n  xor =\
    \ xor.gsub(/(.)(.)/, '\\1\\2')\n  xor = xor.gsub(/(.)(.)/, '\\1\\2')\n  xor =\
    \ xor.gsub(/(.)(.)/, '\\1\\2')\n  xor = xor.gsub(/(.)(.)/, '\\1\\2')\n  xor =\
    \ xor.gsub(/(.)(.)/, '\\1\\2')\n  xor = xor.gsub(/(.)(.)/, '\\1\\2')\n  ", " \
    \ a.each_byte { |c| b << c }\n  b.each_byte { |c| a << c }\n  a.to_s\nend", " \
    \ a = a.to_s\n  b = b.to_s\n  result = \"\"\n  a.each_byte { |c| result << c ^\
    \ b.shift }\n  result\nend", "  a.each_byte { |c| b << c }\n  b.each_byte { |c|\
    \ a << c }\n  a.to_s\nend", "  a = a.to_s\n  b = b.to_s\n  result = \"\"\n  a.each_byte\
    \ do |x|\n    result << x ^ b.byte(0) if x != 0\n  end\n  result\nend", "  a =\
    \ a.to_s\n  b = b.to_s\n  result = ''\n  a.each_byte do |char|\n    result <<\
    \ char if char != b[a.index(char)]\n  end\n  result\nend", "  a.unpack('C*').pack('C*').unpack('C*').pack('C*').unpack('C*').pack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').unpack('C*').",
  "  a.unpack('C*').pack('C*') ^ b.unpack('C*').pack('C*')\nend\n</code>\n<|/ a tags=ruby,bit-manipulation\
    \ |>\n<| c |>\nI like this solution, but I wonder if it would be faster than the\
    \ accepted answer. I'm guessing it's because `unpack` and `pack` both use C code\
    \ under the hood, but I haven't tested it.\n<|/ c |>\n<| c |>\nI tested it and\
    \ it was faster than the accepted answer. Thanks!\n<|/ c |>\n<| c |>\nI tested\
    \ it and it was faster than the accepted answer. Thanks!\n<|/ c |>\n<| a dscore=5\
    \ |>\n<code>", "  result = \"\"\n  a.each_byte { |b| result << b.chr if b == \"\
    1\" }\n  b.each_byte { |a| result << a.chr if a == \"1\" }\n  result\nend", " \
    \ a.each_byte { |x| b << x }\n  b.each_byte { |x| a << x }\n  a.join\nend", " \
    \ a = a.to_s\n  b = b.to_s\n  result = \"\"\n  for i in 0...a.length\n    result\
    \ << (a[i] ^ b[i])\n  end\n  return result\nend", "  a.each_byte { |c| a << c\
    \ }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte\
    \ { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n\
    \  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c|\
    \ a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte\
    \ { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n\
    \  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c|\
    \ a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte\
    \ { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n\
    \  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c|\
    \ a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte\
    \ { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n\
    \  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c|\
    \ a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte\
    \ { |c| b << c }\n  a.each_byte { |c", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n\
    \  result = a_bin ^ b_bin\n  result.to_s(2)\nend", "  result = \"\"\n  a.each_byte\
    \ do |x|\n    result << x ^ b.byte\n  end\n  result\nend", "  a = a.to_s\n  b\
    \ = b.to_s\n  result = []\n  a.each_byte do |x|\n    b.each_byte do |y|\n    \
    \  result << x ^ y\n    end\n  end\n  result.join\nend", "  a = a.to_s\n  b =\
    \ b.to_s\n  result = []\n  for i in 0...a.length\n    result << (a[i] ^ b[i])\n\
    \  end\n  result.to_s\nend", "  result = \"\"\n  a.each_byte do |x|\n    result\
    \ << x ^ b.byte\n  end\n  result\nend", "  a = a.to_s\n  b = b.to_s\n  result\
    \ = \"0\"\n  for i in 0..a.length\n    result += \"1\" if a[i] != b[i] else \"\
    0\"\n  end\n  result\nend", "  result = \"\"\n  a.each_byte { |c| result << c\
    \ ^ b.shift }\n  result\nend", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  xor\
    \ = a_bin ^ b_bin\n  xor_str = xor.to_s(2)\n  return xor_str\nend", "  a = a.to_s\n\
    \  b = b.to_s\n  result = \"\"\n  a.each_byte do |char|\n    result << char if\
    \ char != b[a.index(char)]\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,bit-manipulation,string\
    \ |>\n<| c |>\nThis doesn't work for strings with more than 2 characters. For\
    \ example, `string_xor.call(\"010\", \"110\")` returns `\"010\"`.\n<|/ c |>\n\
    <| c |>\nI see what you mean. I've edited my answer to account for this.\n<|/\
    \ c |>\n<| a tags=ruby,bit-manipulation,string |>\n<code>", "  a.each_char.with_index\
    \ do |x, i|\n    b.each_char.with_index do |y, j|\n      xor_result = x ^ y\n\
    \      xor_result = xor_result.to_s(2).rjust(8, '0')\n      xor_result = xor_result.ljust(8,\
    \ '0')\n      xor_result = xor_result.gsub('1', '0').gsub('0', '1')\n      xor_result\
    \ = xor_result.gsub('1', 'X').gsub('0', '0')\n      xor_result = xor_result.gsub('X',\
    \ '1')\n      xor_result = xor_result.gsub('0', '1')\n      xor_result = xor_result.gsub('1',\
    \ '0').gsub('0', '1')\n      xor_result = xor_result.gsub('1', 'X').gsub('0',\
    \ '0')\n      xor_result = xor_result.gsub('X', '1')\n      xor_result = xor_result.gsub('0',\
    \ '1')\n      xor_result = xor_result.gsub('1', '0').gsub('0', '1')\n      xor_result\
    \ = xor_result.gsub('1', 'X').gsub('0', '0')\n      xor_result = xor_result.gsub('X',\
    \ '1')\n      xor_result = xor_result.gsub('0', '1')\n      xor_result = xor_result.gsub('1',\
    \ '0').gsub('0', '1')\n      xor_result = xor_result.gsub('1', 'X').gsub('0',\
    \ '0')\n      xor_result = xor_result.gsub('X', '1')\n      xor_result = xor_result.gsub('0',\
    \ '1')\n      xor_result = xor_result.gsub('1', '0').gsub('0', '1')\n      xor_result\
    \ = xor_result.gsub('1', 'X').gsub('0', '0')\n      xor_result = xor_result.gsub('X',\
    \ '1')\n      xor_result = xor_result.gsub('0', '1')\n      xor_result = xor_result.gsub('1',\
    \ '0').gsub('0', '1')\n      xor_result = xor_result.gsub('1', 'X').gsub('0',\
    \ '0')\n      xor_result = xor_result.gsub('X', '1')\n      xor_result = xor_result.gsub('0',\
    \ '1')\n      xor_result = xor_result.gsub('1', '0').gsub('0', '1')\n      xor_result\
    \ = xor_result.gsub('1', 'X').gsub('0', '0')\n      xor_result = xor_result.gsub('X',\
    \ '1')\n      xor_result = xor_result.", "  a.to_i(2).xor b.to_i(2).to_s(2)\n\
    end", "  a.each_char.inject(\"\") do |s, c|\n    s << c ^ b\n  end\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| c |>\nThis doesn't work for strings with more than\
    \ two characters. Try `string_xor(\"010\", \"110\")`.\n<|/ c |>\n<| c |>\n: Thanks\
    \ for pointing that out. Fixed now.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  a.each_byte\
    \ { |c| b << c }\n  b.each_byte { |c| a << c }\n  a.to_s\nend", "  a.unpack('C*').pack('C*').unpack('C*').pack('C*')\
    \ ^ b.unpack('C*').pack('C*').unpack('C*').pack('C*')\nend", "  result = \"\"\n\
    \  a.each_byte do |x|\n    result << x ^ b.byte\n  end\n  result\nend", "  a =\
    \ a.to_s\n  b = b.to_s\n  result = \"\"\n  a.each_byte do |char|\n    result <<\
    \ char if char != b[a.index(char)]\n  end\n  result\nend", "  result = \"\"\n\
    \  a.each_byte { |c| result << c ^ b.shift }\n  result\nend", "  a.unpack('C*').inject(:^)\n\
    end", "  a = a.to_s\n  b = b.to_s\n  result = \"\"\n  a.each_byte do |x|\n   \
    \ result << x ^ b[a.index(x)]\n  end\n  result\nend", "  a.each_char.map { |c|\
    \ c == '0' ? b[a.index(c)] : c }.join\nend", "  a = a.to_s\n  b = b.to_s\n  result\
    \ = []\n  a.each_byte do |x|\n    b.each_byte do |y|\n      result << x ^ y\n\
    \    end\n  end\n  result.join\nend", "  a.each_byte { |x| b << x }\n  b.each_byte\
    \ { |x| a << x }\n  a.to_s\nend", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n\
    \  result = a_bin ^ b_bin\n  result.to_s(2)\nend", "  a = a.to_s\n  b = b.to_s\n\
    \  result = \"\"\n  for i in 0...a.length\n    result << (a[i] ^ b[i])\n  end\n\
    \  result\nend", "  a = a.to_s\n  b = b.to_s\n  result = \"\"\n  a.each_byte do\
    \ |x|\n    b.each_byte do |y|\n      result << x ^ y\n    end\n  end\n  result\n\
    end", "  a.each_char.inject(\"\") do |s, c|\n    s << c ^ b\n  end\nend", "  a.each_byte\
    \ { |c| b << c }\n  b.each_byte { |c| a << c }\n  a.join\nend", "  a = a.to_s\n\
    \  b = b.to_s\n  result = \"\"\n  a.each_byte do |char|\n    result << char if\
    \ char != b.byte(char)\n  end\n  result\nend", "  a = a.to_s\n  b = b.to_s\n \
    \ result = ''\n  a.each_byte { |c| result << c ^ b.shift }\n  result\nend", " \
    \ a.each_byte { |c| b << c }\n  b.each_byte { |c| a << c }\n  a.join\nend", " \
    \ a.each_byte { |c| b << c ^ a.bytes[c] }\n  b.to_s\nend", "  a.unpack('C*').inject(:^)\n\
    end", "  result = \"\"\n  a.each_byte { |b| result << b.chr if b == 0 }\n  b.each_byte\
    \ { |a| result << a.chr if a == 0 }\n  result\nend", "  a.each_char.inject(\"\"\
    ) do |result, char|\n    result + (char != b.char) ? char : nil\n  end\nend",
  "  result = \"\"\n  a.each_byte do |char|\n    result << char if char != b.byte(char)\n\
    \  end\n  result\nend", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  result =\
    \ a_bin ^ b_bin\n  result.to_s(2)\nend", "  a.each_byte { |c| a << c }\n  b.each_byte\
    \ { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n\
    \  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c|\
    \ a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte\
    \ { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n\
    \  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c|\
    \ a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte\
    \ { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n\
    \  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c|\
    \ a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte\
    \ { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n\
    \  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c|\
    \ a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte\
    \ { |c| b << c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n\
    \  a.each_byte { |c"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
