name: HumanEval_42_incr_list
language: rb
prompt: "# Return list with elements incremented by 1.\n# >>> incr_list.call([1, 2,\
  \ 3])\n# [2, 3, 4]\n# >>> incr_list.call([5, 3, 5, 2, 3, 3, 9, 0, 123])\n# [6, 4,\
  \ 6, 3, 4, 4, 10, 1, 124]\ndef incr_list(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_incr_list\n\
  \    candidate = method(:incr_list)\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([4, 3, 2], candidate.call([3, 2, 1]))\n    assert_equal([6, 3,\
  \ 6, 3, 4, 4, 10, 1, 124], candidate.call([5, 2, 5, 2, 3, 3, 9, 0, 123]))\n  end\n\
  end\n"
completions: ["  l.each do |x|\n    x += 1\n  end\n  l\nend", "  l.each do |e|\n \
    \   e += 1\n  end\n  l\nend", "  l.each do |x|\n    x += 1\n  end\n  l\nend",
  "  l.each do |e|\n    e += 1\n  end\n  l\nend", "  l.each_with_index do |e, i|\n\
    \    l[i] = l[i] + 1\n  end\n  l\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI\
    \ like your solution, but I wonder if there is a way to avoid the extra `each`\
    \ call. Something like `l.each_with_index.with_index { |(l, i), j| l[i] = l[i]\
    \ + 1 }`\n<|/ c |>\n<| c |>\nYes, that would work. `each_with_index` returns an\
    \ enumerator that yields two values: the element and the index. `with_index` then\
    \ yields the element and the index. `with_index` also returns an enumerator that\
    \ yields two values: the element and the index. `with_index` then yields the element\
    \ and the index. `with_index` then yields the element and the index. `with_index`\
    \ then yields the element and the index. `with_index` then yields the element\
    \ and the index. `with_index` then yields the element and the index. `with_index`\
    \ then yields the element and the index. `with_index` then yields the element\
    \ and the index. `with_index` then yields the element and the index. `with_index`\
    \ then yields the element and the index. `with_index` then yields the element\
    \ and the index. `with_index` then yields the element and the index. `with_index`\
    \ then yields the element and the index. `with_index` then yields the element\
    \ and the index. `with_index` then yields the element and the index. `with_index`\
    \ then yields the element and the index. `with_index` then yields the element\
    \ and the index. `with_index` then yields the element and the index. `with_index`\
    \ then yields the element and the index. `with_index` then yields the element\
    \ and the index. `with_index` then yields the element and the index. `with_index`\
    \ then yields the element and the index. `with_index` then yields the element\
    \ and the index. `with_index` then yields the element and the index. `with_index`\
    \ then yields the element and the index. `with_index` then yields the element\
    \ and the index. `with_index` then yields the element and the index. `with_index`\
    \ then yields the element and the index. `with_index` then yields the element\
    \ and the index. `with_index` then yields the element and the index. `with_index`\
    \ then yields the element and the index. `with_index` then yields the element\
    \ and the index. `with_index` then yields the element and the index. `with_index`\
    \ then yields the element and the index. `with", "  l.each do |x|\n    x += 1\n\
    \  end\n  l\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work\
    \ if you have a list of hashes with an attribute that is a hash. For example,\
    \ `[{:a => 1, :b => 2}, {:a => 3, :b => 4}]` will give `[{:a => 2, :b => 3}, {:a\
    \ => 4, :b => 5}]` instead of `[{:a => 2, :b => 3}, {:a => 3, :b => 4}, {:a =>\
    \ 4, :b => 5}]`.\n<|/ c |>\n<| c |>\n: I didn't notice that requirement. I've\
    \ updated my answer to account for that.\n<|/ c |>\n<| c |>\nI like your solution,\
    \ it's very elegant.\n<|/ c |>\n<| c |>\n: I like your solution, it's very elegant.\n\
    <|/ c |>\n<| c |>\nI like your solution, it's very elegant.\n<|/ c |>\n<| a dscore=5\
    \ |>\n<code>\na = [1, 2, 3, 4]\na.map! {|x| x + 1}\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis doesn't work if you have a list of hashes with an attribute\
    \ that is a hash. For example, `[{:a => 1, :b => 2}, {:a => 3, :b => 4}]` will\
    \ give `[{:a => 2, :b => 3}, {:a => 4, :b => 5}]` instead of `[{:a => 2, :b =>\
    \ 3}, {:a => 3, :b => 4}, {:a => 4, :b => 5}]`.\n<|/ c |>\n<| c |>\n: I didn't\
    \ notice that requirement. I've updated my answer to account for that.\n<|/ c\
    \ |>\n<| c |>\nI like your solution, it's very elegant.\n<|/ c |>\n<| c |>\nI\
    \ like your solution, it's very elegant.\n<|/ c |>\n<| c |>\nI like your solution,\
    \ it's very elegant.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>\na = [1, 2, 3,\
    \ 4]\na.map! {|x| x + 1}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work\
    \ if you have a list of hashes with an attribute that is a hash. For example,\
    \ `[{:a => 1, :", "  l.each do |x|\n    x += 1\n  end\n  l\nend", "  l.each do\
    \ |x|\n    x += 1\n  end\n  l\nend", "  l.each do |x|\n    x += 1\n  end\n  l\n\
    end", "  l.each_with_index do |e, i|\n    l[i] = l[i] + 1\n  end\n  l\nend", " \
    \ l.each do |x|\n    x += 1\n  end\n  l\nend", "  l.each_with_index do |e, i|\n\
    \    l[i] = l[i] + 1\n  end\n  l\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>",
  "  l.each do |x|\n    x += 1\n  end\n  l\nend", "  l.each_with_index do |e, i|\n\
    \    l.insert(i, i + 1)\n  end\nend", "  l.each_with_index do |e, i|\n    l[i]\
    \ = l[i] + 1\n  end\n  l\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  l.each do |x|\n    x += 1\n  end\n  l\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nI like your use of inject, very elegant.\n<|/ c |>\n<| c |>\nI\
    \ like your use of inject, very elegant.\n<|/ c |>\n<| c |>\nI like your use of\
    \ inject, very elegant.\n<|/ c |>\n<| c |>\nI like your use of inject, very elegant.\n\
    <|/ c |>\n<| c |>\nI like your use of inject, very elegant.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  l.each do |x|\n    x += 1\n  end\n  l\nend", "  l.each do |x|\n\
    \    x += 1\n  end\n  l\nend", "  l.each_with_index do |e, i|\n    l[i] = l[i]\
    \ + 1\n  end\n  l\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like your answer,\
    \ but I think it would be better to use a `while` loop to avoid the unnecessary\
    \ array copying.\n<|/ c |>\n<| c |>\nI agree, `while` would be better. I've updated\
    \ my answer.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  l.each do |x|\n    x +=\
    \ 1\n  end\n  l\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
