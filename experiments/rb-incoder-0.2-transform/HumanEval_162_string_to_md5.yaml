name: HumanEval_162_string_to_md5
language: rb
prompt: "# Given a string 'text', return its md5 hash equivalent string.\n# If 'text'\
  \ is an empty string, return None.\n# >>> string_to_md5.call(\"Hello world\")\n\
  # \"3e25960a79dbc69b674cd4ec67a72c62\"\ndef string_to_md5(text)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_to_md5\n\
  \    candidate = method(:string_to_md5)\n    assert_equal(\"3e25960a79dbc69b674cd4ec67a72c62\"\
  , candidate.call(\"Hello world\"))\n    assert_equal(nil, candidate.call(\"\"))\n\
  \    assert_equal(\"0ef78513b0cb8cef12743f5aeb35f888\", candidate.call(\"A B C\"\
  ))\n    assert_equal(\"5f4dcc3b5aa765d61d8327deb882cf99\", candidate.call(\"password\"\
  ))\n  end\nend\n"
completions: ["  Digest::MD5.hexdigest(text)\nend", "  md5 = Digest::MD5.new\n  md5.update(text.to_s)\n\
    \  md5.digest\nend", "  digest = Digest::MD5.digest(text)\n  digest.strip!\n \
    \ digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend",
  "  text = text.to_s\n  if text.empty?\n    text.nil?\n  else\n    Digest::MD5.hexdigest(text)\n\
    \  end\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n\
    \  digest.strip!\n  digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  md5.digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest =\
    \ md5.digest\n  digest.slice!(0, 16)\n  digest\nend", "  md5 = Digest::MD5.new\n\
    \  md5.update(text)\n  digest = md5.digest\n  return digest.unpack(\"H*\")[0]\
    \ if digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text.to_s)\n  digest = md5.digest\n\
    \  digest.bytes.to_a.join\nend", "  md5 = Digest::MD5.new\n  md5.update(text.to_s)\n\
    \  md5.digest\nend", "  digest = Digest::MD5.digest(text)\n  digest.strip!\n \
    \ digest\nend", "  digest = Digest::MD5.digest(text)\n  return Digest::MD5.hexdigest(digest)\
    \ if digest\nend", "  text = text.to_s\n  return Digest::MD5.hexdigest(text)\n\
    end", "  digest = Digest::MD5.digest(text)\n  return Digest::MD5.hexdigest(digest)\
    \ if digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n\
    \  digest.strip!\n  digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  digest = md5.digest\n  digest.strip!\n  digest\nend", "  md5 = Digest::MD5.new\n\
    \  md5.update(text)\n  digest = md5.digest\n  digest.strip!\n  digest\nend", " \
    \ digest = Digest::MD5.digest(text)\n  return nil if digest.nil?\n  digest.unpack(\"\
    H*\").first\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n\
    \  digest.strip!\n  digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  digest = md5.digest\n  digest.strip!\n  digest\nend", "  Digest::MD5.hexdigest(text)\n\
    end", "  return Digest::MD5.hexdigest(text)\nend", "  md5 = Digest::MD5.new\n\
    \  md5.update(text)\n  digest = md5.digest\n  digest.slice!(0, 16)\n  digest.slice!(0,\
    \ 4)\n  digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest =\
    \ md5.digest\n  digest.strip!\n  digest\nend", "  digest = Digest::MD5.digest(text)\n\
    \  digest.strip!\n  digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  digest = md5.digest\n  digest.strip!\n  digest\nend", "  md5 = Digest::MD5.new\n\
    \  md5.update(text)\n  digest = md5.digest\n  digest.slice!(0, 16)\n  digest\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n  digest.strip!\n\
    \  digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n\
    \  return digest.unpack(\"H*\")[0] if digest\nend", "  digest = Digest::MD5.digest(text)\n\
    \  digest.strip!\n  digest\nend", "  Digest::MD5.hexdigest(text)\nend", "  md5\
    \ = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n  digest.slice!(0,\
    \ 16)\n  digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n  digest.strip!\n\
    \  digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n\
    \  digest.strip!\n  digest\nend", "  return Digest::MD5.hexdigest(text)\nend",
  "  md5 = Digest::MD5.new\n  md5.update(text)\n  return md5.digest\nend", "  md5\
    \ = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n  digest.strip!\n\
    \  return digest\nend", "  digest = Digest::MD5.digest(text)\n  digest.strip!\n\
    \  digest\nend", "  digest = Digest::MD5.hexdigest(text)\n  digest.downcase!\n\
    \  digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text.to_s)\n  md5.digest\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n  digest.strip!\n\
    \  digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n\
    \  digest.strip!\n  digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  digest = md5.digest\n  digest.slice!(0, 16)\n  digest\nend", "  md5 = Digest::MD5.new\n\
    \  md5.update(text)\n  digest = md5.digest\n  digest.strip!\n  digest\nend", " \
    \ digest = Digest::MD5.hexdigest(text)\n  digest.nil? ? nil : digest\nend", " \
    \ digest = Digest::MD5.digest(text)\n  digest.strip!\n  digest\nend", "  md5 =\
    \ Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend", "  digest = Digest::MD5.digest(text)\n\
    \  digest.strip!\n  digest\nend", "  return Digest::MD5.hexdigest(text)\nend",
  "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n  digest.strip!\n\
    \  digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n\
    \  digest.strip!\n  digest\nend", "  digest = Digest::MD5.hexdigest(text)\n  digest.empty?\
    \ ? nil : digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text.to_s)\n  md5.digest\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n  digest.strip!\n\
    \  digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text.to_s)\n  digest =\
    \ md5.digest\n  digest.slice!(0, 16)\n  digest\nend", "  md5 = Digest::MD5.new\n\
    \  md5.update(text)\n  digest = md5.digest\n  digest.strip!\n  digest\nend", " \
    \ Digest::MD5.hexdigest(text)\nend", "  digest = Digest::MD5.digest(text)\n  digest.strip!\n\
    \  return digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  return\
    \ md5.digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n  return\
    \ digest.unpack(\"H*\")[0] if digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  digest = md5.digest\n  return digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  digest = md5.digest\n  digest.strip!\n  digest\nend", "  digest = Digest::MD5.digest(text)\n\
    \  digest.strip!\n  return digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  md5.digest\nend", "  digest = Digest::MD5.digest(text)\n  digest.strip!\n \
    \ digest\nend", "  digest = Digest::MD5.digest(text)\n  digest.strip!\n  digest\n\
    end", "  digest = Digest::MD5.digest(text)\n  digest.strip!\n  digest\nend", " \
    \ md5 = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n  digest.strip!\n\
    \  digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n\
    \  digest.slice!(0, 16)\n  digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  digest = md5.digest\n  digest.strip!\n  digest\nend", "  digest = Digest::MD5.digest(text)\n\
    \  digest.strip!\n  digest\nend", "  digest = Digest::MD5.digest(text)\n  digest.strip!\n\
    \  digest\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
