name: HumanEval_89_encrypt
language: rb
prompt: "# Create a function encrypt that takes a string as an argument and\n# returns\
  \ a string encrypted with the alphabet being rotated. \n# The alphabet should be\
  \ rotated in a manner such that the letters \n# shift down by two multiplied to\
  \ two places.\n# For example:\n# >>> encrypt.call(\"hi\")\n# \"lm\"\n# >>> encrypt.call(\"\
  asdfghjkl\")\n# \"ewhjklnop\"\n# >>> encrypt.call(\"gf\")\n# \"kj\"\n# >>> encrypt.call(\"\
  et\")\n# \"ix\"\ndef encrypt(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encrypt\n\
  \    candidate = method(:encrypt)\n    assert_equal(\"lm\", candidate.call(\"hi\"\
  ))\n    assert_equal(\"ewhjklnop\", candidate.call(\"asdfghjkl\"))\n    assert_equal(\"\
  kj\", candidate.call(\"gf\"))\n    assert_equal(\"ix\", candidate.call(\"et\"))\n\
  \    assert_equal(\"jeiajeaijeiak\", candidate.call(\"faewfawefaewg\"))\n    assert_equal(\"\
  lippsqcjvmirh\", candidate.call(\"hellomyfriend\"))\n    assert_equal(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
  , candidate.call(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"))\n    assert_equal(\"\
  e\", candidate.call(\"a\"))\n  end\nend\n"
completions: ["  s.chars.map { |c| c.ord % 26 + 2 }.join\nend", "  s.chars.map { |c|\
    \ c.ord % 26 + 2 }.join\nend", "  s.chars.map { |c| c.ord % 26 + 2 }.join\nend",
  "  s.chars.map do |c|\n    alphabet[alphabet.index(c) + 1]\n  end.join\nend", " \
    \ s.chars.map { |c| c.ord % 26 + 2 }.join\nend", "  s.chars.map { |c| c.ord %\
    \ 26 + 2 }.join\nend", "  s.chars.map { |c| c.ord % 26 + 2 }.join\nend", "  s.chars.each_with_index\
    \ do |char, index|\n    next if index == 0\n    next if char == char.upcase\n\
    \    next if char == char.downcase\n    next if char == char.capitalize\n    next\
    \ if char == char.swapcase\n    char.upcase!\n  end\n  s\nend", "  s.chars.map\
    \ { |c| c.ord % 26 }.sort.map { |c| c.chr + c.chr * 2 }.join\nend", "  s.chars.map\
    \ { |c| c.ord % 26 }.sort.map { |c| c.chr }.join\nend", "  s.chars.map { |c| c.ord\
    \ % 26 + 2 }.join\nend", "  s.chars.map { |c| c.ord % 26 }.sort.map { |c| c.to_s.ord\
    \ }.join\nend", "  s.chars.map { |c| c.ord % 26 }.rotate(2).join\nend", "  s.chars.map\
    \ do |c|\n    alphabet[alphabet.index(c) + 1]\n  end.join\nend", "  s.chars.each_with_index\
    \ do |char, index|\n    next if index == 0\n    next if char == chars.last\n \
    \   chars.rotate(index).first\n  end.join\nend", "  s.gsub(/./) do |c|\n    alphabet\
    \ = c.to_s.split('')\n    alphabet.rotate(2).map{|c| c.to_s}.join\n  end\nend",
  "  s.chars.each_with_index do |char, i|\n    next if char == \" \"\n    char.upcase!\n\
    \    char.rotate!\n    char.downcase!\n    char.rotate!\n    char.upcase!\n  \
    \  char.rotate!\n  end\n  s\nend", "  s.chars.map { |c| c.ord % 26 + 2 }.join\n\
    end", "  s.chars.map { |c| c.ord % 26 + 2 }.join\nend", "  alphabet = %w[a b c\
    \ d e f g h i j k l m n o p q r s t u v w x y z]\n  s.chars.map { |c| alphabet.index(c.upcase)\
    \ }.inject(:*)\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
