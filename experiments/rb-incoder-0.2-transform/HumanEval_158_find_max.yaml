name: HumanEval_158_find_max
language: rb
prompt: "# Write a function that accepts a list of strings.\n# The list contains different\
  \ words. Return the word with maximum number\n# of unique characters. If multiple\
  \ strings have maximum number of unique\n# characters, return the one which comes\
  \ first in lexicographical order.\n# >>> find_max.call([\"name\", \"of\", \"string\"\
  ])\n# \"string\"\n# >>> find_max.call([\"name\", \"enam\", \"game\"])\n# \"enam\"\
  \n# >>> find_max.call([\"aaaaaaa\", \"bb\", \"cc\"])\n# \"aaaaaaa\"\ndef find_max(words)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n\
  \    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"\
  name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\"\
  , \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
  , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
  ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
  , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"\
  are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\"\
  , \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
  this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"\
  ]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
  \  end\nend\n"
completions: ["  words.sort.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n", "  words.sort.reverse.uniq.first\n\
    end", "  words.each_with_object(Hash.new(0)) { |word, counts| counts[word] +=\
    \ 1 }.max_by { |word, counts| counts[word] }[1]\nend", "  words.inject(Hash.new(0))\
    \ { |h, word| h[word] += 1; h }.max_by { |k, v| v }[0]\nend", "  words.sort_by\
    \ { |word| word.chars.uniq.size }\n  words.max_by { |word| word.chars.uniq.size\
    \ }\nend", "  words.sort.reverse.uniq.length.first\nend", "  words.sort.reverse!\n\
    \  words.uniq!\n  words.first\nend", "  words.uniq.sort.first\nend", "  words.sort.reverse.map\
    \ { |word| word.chars.uniq.size }.max\nend", "  words.each_with_object(Hash.new(0))\
    \ { |w, h| h[w] += 1 }.max_by { |w, v| v }[0]\nend\n</cell>\n<cell>", "  words.sort.reverse.uniq.first\n\
    end", "  words.each_with_object(Hash.new(0)) { |word, counts| counts[word] +=\
    \ 1 }.max_by { |word, counts| counts[word] }[1]\nend", "  words.sort.reverse.uniq.first\n\
    end", "  words.sort.reverse.uniq.first\nend", "  words.inject(Hash.new(0)) { |memo,\
    \ word| memo[word] += 1; memo }.values.max\nend", "  words.inject(Hash.new(0))\
    \ { |memo, word| memo[word] += 1; memo }.values.max_by { |word| word.size }\n\
    end", "  words.sort.reverse.uniq.first\nend", "  words.sort.reverse.find { |word|\
    \ word.chars.uniq.size == words.uniq.size }\nend", "  words.inject([]) do |uniques,\
    \ word|\n    uniques << word if uniques.count(word) < uniques.count(word).max\n\
    \    uniques\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays |>\n\
    <code>", "  words.sort.reverse.first\nend", "  words.sort.reverse.uniq.first\n\
    end", "  words.inject([]) do |memo, word|\n    memo << word\n    memo.uniq.size\
    \ if memo.uniq.size >= memo.size \n  end\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=0 |>\n<code>", "  words.sort!\n  max_word = words[0]\n  max_count =\
    \ 0\n  words.each do |word|\n    count = word.count(\"a\")\n    if count > max_count\n\
    \      max_count = count\n      max_word = word\n    end\n  end\n  max_word\n\
    end", "  words.sort.reverse.uniq.first\nend", "  words.sort.reverse.uniq.length.first\n\
    end", "  words.sort.reverse.uniq.first\nend", "  words.inject([]) do |max, word|\n\
    \    max.length < word.length ? max : word\n  end\nend", "  words.each_with_object(Hash.new(0))\
    \ { |word, counts| counts[word] += 1 }\n    .max_by { |word, counts| -counts[word]\
    \ }\nend", "  words.uniq.sort!\n  words.uniq.count!\n  words.uniq.first!\nend",
  "  words.sort!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.", "  words.sort.reverse.inject(\"\"\
    ) do |max, word|\n    max = word.length if word.length >= max.length\n    max\n\
    \  end\nend", "  words.sort_by { |word| word.chars.uniq.size }\n  words.max_by\
    \ { |word| word.chars.uniq.size }\nend", "  words.sort.reverse.first\nend", " \
    \ words.sort.reverse.uniq.first\nend", "  words.each_with_object(Hash.new(0))\
    \ { |w, h| h[w] += 1 }.max_by { |k, v| v }[0]\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This solution doesn't work if there are multiple words with the same number of\
    \ unique characters. For example, `find_max.call([\"aaaaaaa\", \"bb\", \"cc\"\
    ])` returns `\"aaaaaaa\"` instead of `\"cc\"`.\n<|/ c |>\n<| c |>\n: I added a\
    \ solution that does that.\n<|/ c |>\n<| c |>\n: Thanks for the heads up. I added\
    \ a solution that does that.\n<|/ c |>\n<| c |>\n: Thanks for the heads up. I\
    \ added a solution that does that.\n<|/ c |>\n<| c |>\n: Thanks for the heads\
    \ up. I added a solution that does that.\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  "  words.sort.reverse.first\nend", "  words.group_by { |w| w.length }.max_by { |k,\
    \ v| v.size }.first\nend", "  words.group_by { |word| word.chars.uniq.size }.max_by\
    \ { |word, count| count }\nend", "  words.sort.reverse.first\nend", "  words.sort.reverse.map\
    \ {|word| word.chars.uniq.size}.max\nend", "  words.sort_by { |word| word.chars.uniq.size\
    \ }\n  words.max_by { |word| word.chars.uniq.size }\nend", "  words.sort.reverse.first\n\
    end", "  words.group_by{|w| w.length}.max_by{|k, v| v.length}\nend", "  words.sort.reverse!\n\
    \  words.uniq!\n  words.first\nend", "  words.sort.reverse.inject(\"\") do |max,\
    \ word|\n    max = word.length if word.length >= max.length\n    max\n  end\n\
    end", "  words.sort.reverse.uniq.first\nend", "  words.each_with_object(Hash.new(0))\
    \ { |w, h| h[w] += 1 }.max_by { |w, v| v }[0]\nend", "  words.sort.reverse.first\n\
    end", "  words.sort.reverse.uniq.first\nend", "  words.inject(Hash.new(0)) { |memo,\
    \ word| memo[word] += 1; memo }.values.max_by { |word| word.length }\nend", " \
    \ words.sort_by { |word| word.chars.uniq.size }\n  words.first\nend", "  words.sort.reverse.find\
    \ { |word| word.chars.uniq.size == words.uniq.size }\nend", "  words.inject(Hash.new(0))\
    \ { |m, s| m[s] = m[s].succ if m[s].nil? || m[s].succ == s.length }.max_by { |k,\
    \ v| v }\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThanks so much! I\
    \ didn't know about inject. I'm going to have to look into it more to understand\
    \ how it works. Thanks again!\n<|/ c |>\n<| c |>\n`inject` will iterate through\
    \ each element in the array and pass it into the block. `Hash.new(0)` will initialize\
    \ a hash with the default value of 0. Then `m[s]` will return the value associated\
    \ with that key in the hash. `m[s].succ` will increment the value associated with\
    \ that key by 1. Finally, `max_by` will return the key with the highest value.\n\
    <|/ c |>\n<| c |>\nThanks so much! I didn't know about inject. I'm going to have\
    \ to look into it more to understand how it works. Thanks again!\n<|/ c |>\n<|\
    \ a |>\n<code>", "  words.inject(Hash.new(0)) { |h, word| h[word] += 1; h }.max_by\
    \ { |k, v| v }[0]\nend", "  words.each_with_index.inject(0) {|memo, word| memo\
    \ += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0) {|memo, word|\
    \ memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0) {|memo,\
    \ word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.char", "  words.sort.reverse.uniq.first\nend", " \
    \ words.each_with_object(Hash.new(0)) { |w, h| h[w] += 1 }.max_by { |w, v| v }[0]\n\
    end", "  words.uniq.sort!\n  words.uniq.first\nend", "  words.each_with_object(Hash.new(0))\
    \ { |word, counts| counts[word] += 1 }.max_by { |word, counts| counts[word] }[1]\n\
    end", "  words.group_by{|word| word.chars.uniq.size}.max_by{|word, count| count}\n\
    end", "  words.sort_by { |word| word.size }.reverse.first\nend", "  words.uniq.sort!\n\
    \  words.uniq.size\nend", "  words.each_with_index.inject(0) { |max, (word, index)|\
    \ max < word.length ? max : word.length }\nend", "  words.sort.reverse.uniq.first\n\
    end", "  words.sort.reverse.first\nend", "  words.uniq.sort!\n  words.uniq.max_by\
    \ { |word| word.size }\nend", "  words.inject([]) do |max, word|\n    max.length\
    \ < word.length ? max : word\n  end\nend", "  words.sort.reverse.uniq.first\n\
    end", "  words.sort.reverse.uniq.first\nend", "  words.sort!\n  word = nil\n \
    \ count = 0\n  words.each do |word|\n    count += word.count(\"a\")\n    count\
    \ += word.count(\"e\")\n    count += word.count(\"i\")\n    count += word.count(\"\
    o\")\n    count += word.count(\"u\")\n  end\n  return word if count == words.uniq.size\n\
    \  return words[0] if count == words.uniq.size-1\nend", "  words.sort.reverse!\n\
    \  words.uniq!\n  words.first\nend", "  words.sort.reverse.inject(0) do |max,\
    \ word|\n    max = word.length if max.zero?\n    max = word.length if word.chars.uniq.size\
    \ == max.chars.uniq.size\n    max\n  end\nend", "  words.inject([]) do |uniques,\
    \ word|\n    uniques << word if uniques.count(word) == words.count(word)\n   \
    \ uniques\n  end\nend", "  words.sort.reverse.uniq.length.first\nend", "  words.sort.reverse.uniq.first\n\
    end", "  words.group_by{|word| word.chars.uniq.size}.max_by{|word, count| count}\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
