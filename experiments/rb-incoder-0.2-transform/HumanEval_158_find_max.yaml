name: HumanEval_158_find_max
language: rb
prompt: "# Write a function that accepts a list of strings.\n# The list contains different\
  \ words. Return the word with maximum number\n# of unique characters. If multiple\
  \ strings have maximum number of unique\n# characters, return the one which comes\
  \ first in lexicographical order.\n# >>> find_max.call([\"name\", \"of\", \"string\"\
  ])\n# \"string\"\n# >>> find_max.call([\"name\", \"enam\", \"game\"])\n# \"enam\"\
  \n# >>> find_max.call([\"aaaaaaa\", \"bb\", \"cc\"])\n# \"aaaaaaa\"\ndef find_max(words)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_max\n\
  \    candidate = method(:find_max)\n    assert_equal(\"string\", candidate.call([\"\
  name\", \"of\", \"string\"]))\n    assert_equal(\"enam\", candidate.call([\"name\"\
  , \"enam\", \"game\"]))\n    assert_equal(\"aaaaaaa\", candidate.call([\"aaaaaaa\"\
  , \"bb\", \"cc\"]))\n    assert_equal(\"abc\", candidate.call([\"abc\", \"cba\"\
  ]))\n    assert_equal(\"footbott\", candidate.call([\"play\", \"this\", \"game\"\
  , \"of\", \"footbott\"]))\n    assert_equal(\"gonna\", candidate.call([\"we\", \"\
  are\", \"gonna\", \"rock\"]))\n    assert_equal(\"nation\", candidate.call([\"we\"\
  , \"are\", \"a\", \"mad\", \"nation\"]))\n    assert_equal(\"this\", candidate.call([\"\
  this\", \"is\", \"a\", \"prrk\"]))\n    assert_equal(\"b\", candidate.call([\"b\"\
  ]))\n    assert_equal(\"play\", candidate.call([\"play\", \"play\", \"play\"]))\n\
  \  end\nend\n"
completions: ["  words.sort.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n", "  words.sort.reverse.uniq.first\n\
    end", "  words.each_with_object(Hash.new(0)) { |word, counts| counts[word] +=\
    \ 1 }.max_by { |word, counts| counts[word] }[1]\nend", "  words.inject(Hash.new(0))\
    \ { |h, word| h[word] += 1; h }.max_by { |k, v| v }[0]\nend", "  words.sort_by\
    \ { |word| word.chars.uniq.size }\n  words.max_by { |word| word.chars.uniq.size\
    \ }\nend", "  words.sort.reverse.uniq.length.first\nend", "  words.sort.reverse!\n\
    \  words.uniq!\n  words.first\nend", "  words.uniq.sort.first\nend", "  words.sort.reverse.map\
    \ { |word| word.chars.uniq.size }.max\nend", "  words.each_with_object(Hash.new(0))\
    \ { |w, h| h[w] += 1 }.max_by { |w, v| v }[0]\nend\n</cell>\n<cell>", "  words.sort.reverse.uniq.first\n\
    end", "  words.each_with_object(Hash.new(0)) { |word, counts| counts[word] +=\
    \ 1 }.max_by { |word, counts| counts[word] }[1]\nend", "  words.sort.reverse.uniq.first\n\
    end", "  words.sort.reverse.uniq.first\nend", "  words.inject(Hash.new(0)) { |memo,\
    \ word| memo[word] += 1; memo }.values.max\nend", "  words.inject(Hash.new(0))\
    \ { |memo, word| memo[word] += 1; memo }.values.max_by { |word| word.size }\n\
    end", "  words.sort.reverse.uniq.first\nend", "  words.sort.reverse.find { |word|\
    \ word.chars.uniq.size == words.uniq.size }\nend", "  words.inject([]) do |uniques,\
    \ word|\n    uniques << word if uniques.count(word) < uniques.count(word).max\n\
    \    uniques\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays |>\n\
    <code>", "  words.sort.reverse.first\nend", "  words.sort.reverse.uniq.first\n\
    end", "  words.inject([]) do |memo, word|\n    memo << word\n    memo.uniq.size\
    \ if memo.uniq.size >= memo.size \n  end\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=0 |>\n<code>", "  words.sort!\n  max_word = words[0]\n  max_count =\
    \ 0\n  words.each do |word|\n    count = word.count(\"a\")\n    if count > max_count\n\
    \      max_count = count\n      max_word = word\n    end\n  end\n  max_word\n\
    end", "  words.sort.reverse.uniq.first\nend", "  words.sort.reverse.uniq.length.first\n\
    end", "  words.sort.reverse.uniq.first\nend", "  words.inject([]) do |max, word|\n\
    \    max.length < word.length ? max : word\n  end\nend", "  words.each_with_object(Hash.new(0))\
    \ { |word, counts| counts[word] += 1 }\n    .max_by { |word, counts| -counts[word]\
    \ }\nend", "  words.uniq.sort!\n  words.uniq.count!\n  words.uniq.first!\nend",
  "  words.sort!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.", "  words.sort.reverse.inject(\"\"\
    ) do |max, word|\n    max = word.length if word.length >= max.length\n    max\n\
    \  end\nend", "  words.sort_by { |word| word.chars.uniq.size }\n  words.max_by\
    \ { |word| word.chars.uniq.size }\nend", "  words.sort.reverse.first\nend", " \
    \ words.sort.reverse.uniq.first\nend", "  words.each_with_object(Hash.new(0))\
    \ { |w, h| h[w] += 1 }.max_by { |k, v| v }[0]\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This solution doesn't work if there are multiple words with the same number of\
    \ unique characters. For example, `find_max.call([\"aaaaaaa\", \"bb\", \"cc\"\
    ])` returns `\"aaaaaaa\"` instead of `\"cc\"`.\n<|/ c |>\n<| c |>\n: I added a\
    \ solution that does that.\n<|/ c |>\n<| c |>\n: Thanks for the heads up. I added\
    \ a solution that does that.\n<|/ c |>\n<| c |>\n: Thanks for the heads up. I\
    \ added a solution that does that.\n<|/ c |>\n<| c |>\n: Thanks for the heads\
    \ up. I added a solution that does that.\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  "  words.sort.reverse.first\nend", "  words.group_by { |w| w.length }.max_by { |k,\
    \ v| v.size }.first\nend", "  words.group_by { |word| word.chars.uniq.size }.max_by\
    \ { |word, count| count }\nend", "  words.sort.reverse.first\nend", "  words.sort.reverse.map\
    \ {|word| word.chars.uniq.size}.max\nend", "  words.sort_by { |word| word.chars.uniq.size\
    \ }\n  words.max_by { |word| word.chars.uniq.size }\nend", "  words.sort.reverse.first\n\
    end", "  words.group_by{|w| w.length}.max_by{|k, v| v.length}\nend", "  words.sort.reverse!\n\
    \  words.uniq!\n  words.first\nend", "  words.sort.reverse.inject(\"\") do |max,\
    \ word|\n    max = word.length if word.length >= max.length\n    max\n  end\n\
    end", "  words.sort.reverse.uniq.first\nend", "  words.each_with_object(Hash.new(0))\
    \ { |w, h| h[w] += 1 }.max_by { |w, v| v }[0]\nend", "  words.sort.reverse.first\n\
    end", "  words.sort.reverse.uniq.first\nend", "  words.inject(Hash.new(0)) { |memo,\
    \ word| memo[word] += 1; memo }.values.max_by { |word| word.length }\nend", " \
    \ words.sort_by { |word| word.chars.uniq.size }\n  words.first\nend", "  words.sort.reverse.find\
    \ { |word| word.chars.uniq.size == words.uniq.size }\nend", "  words.inject(Hash.new(0))\
    \ { |m, s| m[s] = m[s].succ if m[s].nil? || m[s].succ == s.length }.max_by { |k,\
    \ v| v }\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThanks so much! I\
    \ didn't know about inject. I'm going to have to look into it more to understand\
    \ how it works. Thanks again!\n<|/ c |>\n<| c |>\n`inject` will iterate through\
    \ each element in the array and pass it into the block. `Hash.new(0)` will initialize\
    \ a hash with the default value of 0. Then `m[s]` will return the value associated\
    \ with that key in the hash. `m[s].succ` will increment the value associated with\
    \ that key by 1. Finally, `max_by` will return the key with the highest value.\n\
    <|/ c |>\n<| c |>\nThanks so much! I didn't know about inject. I'm going to have\
    \ to look into it more to understand how it works. Thanks again!\n<|/ c |>\n<|\
    \ a |>\n<code>", "  words.inject(Hash.new(0)) { |h, word| h[word] += 1; h }.max_by\
    \ { |k, v| v }[0]\nend", "  words.each_with_index.inject(0) {|memo, word| memo\
    \ += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0) {|memo, word|\
    \ memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0) {|memo,\
    \ word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.chars.uniq.size; memo}\n  words.each_with_index.inject(0)\
    \ {|memo, word| memo += word.char", "  words.sort.reverse.uniq.first\nend", " \
    \ words.each_with_object(Hash.new(0)) { |w, h| h[w] += 1 }.max_by { |w, v| v }[0]\n\
    end", "  words.uniq.sort!\n  words.uniq.first\nend", "  words.each_with_object(Hash.new(0))\
    \ { |word, counts| counts[word] += 1 }.max_by { |word, counts| counts[word] }[1]\n\
    end", "  words.group_by{|word| word.chars.uniq.size}.max_by{|word, count| count}\n\
    end", "  words.sort_by { |word| word.size }.reverse.first\nend", "  words.uniq.sort!\n\
    \  words.uniq.size\nend", "  words.each_with_index.inject(0) { |max, (word, index)|\
    \ max < word.length ? max : word.length }\nend", "  words.sort.reverse.uniq.first\n\
    end", "  words.sort.reverse.first\nend", "  words.uniq.sort!\n  words.uniq.max_by\
    \ { |word| word.size }\nend", "  words.inject([]) do |max, word|\n    max.length\
    \ < word.length ? max : word\n  end\nend", "  words.sort.reverse.uniq.first\n\
    end", "  words.sort.reverse.uniq.first\nend", "  words.sort!\n  word = nil\n \
    \ count = 0\n  words.each do |word|\n    count += word.count(\"a\")\n    count\
    \ += word.count(\"e\")\n    count += word.count(\"i\")\n    count += word.count(\"\
    o\")\n    count += word.count(\"u\")\n  end\n  return word if count == words.uniq.size\n\
    \  return words[0] if count == words.uniq.size-1\nend", "  words.sort.reverse!\n\
    \  words.uniq!\n  words.first\nend", "  words.sort.reverse.inject(0) do |max,\
    \ word|\n    max = word.length if max.zero?\n    max = word.length if word.chars.uniq.size\
    \ == max.chars.uniq.size\n    max\n  end\nend", "  words.inject([]) do |uniques,\
    \ word|\n    uniques << word if uniques.count(word) == words.count(word)\n   \
    \ uniques\n  end\nend", "  words.sort.reverse.uniq.length.first\nend", "  words.sort.reverse.uniq.first\n\
    end", "  words.group_by{|word| word.chars.uniq.size}.max_by{|word, count| count}\n\
    end", "  words.sort.reverse.uniq.first\nend", "  words.sort.reverse.first\nend",
  "  words.sort.reverse.uniq.length.first\nend", "  words.inject(Hash.new(0)) { |h,\
    \ word| h[word] += 1; h }.max_by { |k, v| v }[0]\nend", "  words.group_by { |word|\
    \ word.chars.uniq.size }.max_by { |word, count| count }\nend", "  words.inject(Hash.new(0))\
    \ { |memo, word| memo[word] += 1; memo }.values.max_by { |word| word.size }\n\
    end", "  words.sort.reverse!\n  words.uniq!\n  words.first\nend", "  words.sort.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.first\nend", "  words.sort.reverse.uniq.first\n\
    end", "  words.sort.reverse.find { |word| word.chars.uniq.size == words.uniq.size\
    \ }\nend", "  words.inject(Hash.new(0)) { |m, word| m[word] += 1; m }.max_by {\
    \ |k, v| v }[0]\nend", "  words.sort.reverse.uniq.first\nend", "  words.sort!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.", "  words.sort.reverse.uniq.length.first\nend", "  words.sort_by\
    \ { |word| word.size }.reverse.first\nend", "  words.sort.reverse.first\nend",
  "  words.sort.reverse.uniq.first\nend", "  words.sort.reverse.uniq.first\nend",
  "  words.sort.reverse.uniq.first\nend", "  words.sort.reverse!\n  words.uniq.length.max\n\
    end", "  words.sort.reverse.first\nend", "  words.inject(Hash.new(0)) { |m, s|\
    \ m[s] += 1; m }\n  words.max_by { |s| m[s] }\nend", "  words.sort_by { |word|\
    \ word.size }.reverse.first\nend", "  words.each_with_object(Hash.new(0)) { |w,\
    \ h| h[w] += 1 }.max_by { |k, v| v }[0]\nend", "  words.sort.reverse!\n  words.uniq!\n\
    \  words.first\nend", "  words.each_with_index.inject(0) { |max, (word, index)|\
    \ max < word.length ? max : word.length }\nend", "  words.sort.reverse!\n  words.uniq!\n\
    \  words.first\nend", "  words.sort.reverse.uniq.first\nend", "  words.group_by\
    \ { |word| word.chars.uniq.size }.max_by { |_, v| v }[0]\nend", "  words.sort.reverse.uniq.first\n\
    end", "  words.inject(Hash.new(0)) { |h, word| h[word] += 1; h }.max_by { |k,\
    \ v| v }[0]\nend", "  words.inject(Hash.new(0)) { |h, word| h[word] += 1; h }.max_by\
    \ { |k, v| v }[0]\nend", "  words.uniq.max_by { |word| word.chars.size }\nend",
  "  words.sort.reverse.uniq.length.first\nend", "  words.inject(Hash.new(0)) { |acc,\
    \ word| acc[word] += 1; acc }.max_by { |k, v| v.size }[0]\nend", "  words.inject([])\
    \ do |memo, word|\n    memo << word.chars.uniq.size if memo.empty?\n    memo.max_by\
    \ { |s| s.size }\n  end\nend", "  words.inject(Hash.new(0)) { |h, word| h[word]\
    \ += 1; h }.max_by { |word, count| count }[0]\nend", "  words.sort!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.", "  words.sort.reverse!\n  words.uniq!\n  words.first\nend", "  words.each_with_object(Hash.new(0))\
    \ { |word, counts| counts[word] += 1 }.max_by { |word, counts| counts[word] }[0]\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work if the word\
    \ has more than one unique character. For example, `find_max.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"])` returns `\"aaaaaaa\"` instead of `\"cc\"`.\n<|/ c |>\n<| c\
    \ |>\nI believe that `find_max.call([\"aaaaaaa\", \"bb\", \"cc\"])` returns `\"\
    aaaaaaa\"` because `\"cc\"` comes first in lexicographical order. `\"aaaaaaa\"\
    ` comes first because `\"aaaaaaa\"` has more unique characters than `\"cc\"`.\n\
    <|/ c |>\n<| c |>\nYes, you're right. I misunderstood the question. Sorry about\
    \ that.\n<|/ c |>\n<| a |>\n<code>", "  words.sort.reverse.uniq.first\nend", " \
    \ words.sort.reverse.first\nend", "  words.sort.reverse.uniq.length.first\nend",
  "  words.sort.reverse.first\nend", "  words.sort.reverse.uniq.first\nend", "  words.inject(Hash.new(0))\
    \ { |memo, word| memo[word] += 1; memo }.values.max\nend", "  words.sort.reverse.first\n\
    end", "  words.sort.reverse.first\nend", "  words.inject([]) do |memo, word|\n\
    \    memo << word.length if memo.length < word.length\n    memo\n  end\nend",
  "  words.uniq.sort!\n  words.uniq.max_by { |word| word.chars.uniq.size }\nend",
  "  words.group_by { |word| word.chars.uniq.size }.max_by { |word, count| count }[0]\n\
    end", "  words.sort.reverse.uniq.first\nend", "  words.sort.reverse!\n  words.uniq!\n\
    \  words.first\nend", "  words.each_with_object(Hash.new(0)) { |word, counts|\
    \ counts[word] += 1 }\n    .max_by { |word, counts| -counts[word] }\nend", " \
    \ words.inject(Hash.new(0)) { |h, word| h[word] += 1; h }.max_by { |k, v| v }[1]\n\
    end", "  words.group_by{|word| word.chars.uniq.size}.max_by{|k, v| k}\nend", " \
    \ words.each_with_object(Hash.new(0)) { |word, counts| counts[word] += 1 }.max_by\
    \ { |word, counts| counts[word] }[1]\nend", "  words.sort.reverse.inject(:+)\n\
    end", "  words.sort.reverse.first\nend", "  words.sort.reverse.uniq.first\nend",
  "  words.sort!\n  words.size!\n  words.uniq!\n  words.first!\nend", "  words.sort_by\
    \ { |word| word.size }\n  words.max_by { |word| word.size }\nend", "  words.sort.reverse.find\
    \ { |word| word.chars.uniq.size == words.uniq.size }\nend", "  words.sort.reverse.first\n\
    end", "  words.sort.reverse!\n  words.uniq!\n  words.reverse!\n  words.first\n\
    end", "  words.each_with_object(Hash.new(0)) { |word, counts| counts[word] +=\
    \ 1 }\n    .max_by { |word, counts| counts[word] }\n    .first\nend", "  words.uniq.sort!\n\
    \  words.uniq.max_by { |word| word.size }\nend", "  words.group_by{|word| word.chars.uniq.size}.max_by{|word,\
    \ count| count}\nend", "  words.inject(Hash.new(0)) { |h, word| h[word] += 1;\
    \ h }.max_by { |k, v| v }[0]\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=1\
    \ |>\n<code>", "  words.sort.reverse.find { |word| word.chars.uniq.size == words.uniq.size\
    \ }\nend", "  words.inject(Hash.new(0)) { |h, word| h[word] += 1; h }.max_by {\
    \ |k, v| v.size }[0]\nend", "  words.sort.reverse.map { |word| word.chars.uniq.size\
    \ }.max\nend", "  words.sort.reverse.uniq.first\nend", "  words.sort.reverse!\n\
    \  words.uniq!\n  words.first\nend", "  words.inject(Hash.new(0)) { |memo, word|\
    \ memo[word] += 1; memo }.values.max_by { |word| word.length }\nend", "  words.uniq.sort!\n\
    \  words.uniq.count!\n  words.uniq.first\nend", "  words.sort.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n\
    \  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n\
    \  words.uniq!\n  words.reverse!\n  words.uniq!\n  words.reverse!\n  words.uniq!\n",
  "  words.sort.reverse.uniq.length.first\nend", "  words.group_by { |word| word.chars.uniq.size\
    \ }.max_by { |word,count| count }\nend", "  words.sort.reverse.inject(\"\") do\
    \ |max, word|\n    max += word.chars.uniq.size\n    max > word.length ? word :\
    \ max\n  end\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis doesn't work\
    \ if the word has repeated characters. For example, `find_max.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"])` returns `\"aaaaaaa\"` instead of `\"cc\"`.\n<|/ c |>\n<| c\
    \ |>\n: Yes, you are right. I fixed the code. Thanks.\n<|/ c |>\n<| c |>\nI like\
    \ your solution, but I wonder if it can be done without `inject`? It seems quite\
    \ inefficient.\n<|/ c |>\n<| c |>\n: I added a solution without `inject`.\n<|/\
    \ c |>\n<| a |>\n<code>", "  words.sort.reverse.uniq.first\nend", "  words.sort.reverse.find\
    \ {|word| word.chars.uniq.size == words.uniq.size }\nend", "  words.group_by{|w|\
    \ w.length}.max_by{|k, v| v.length}\nend", "  words.uniq.max_by { |word| word.size\
    \ }\nend", "  words.uniq.sort!\n  words.uniq.max_by { |word| word.size }\nend",
  "  words.uniq.sort!\n  words.uniq.count!\n  words.uniq.first!\nend", "  words.inject([])\
    \ do |max, word|\n    chars = word.split(//).uniq.size\n    max.length < chars\
    \ ? max << word : max\n  end\nend", "  words.sort.reverse.inject(\"\") do |max,\
    \ word|\n    max = word.length if word.length >= max.length\n    max\n  end\n\
    end", "  words.inject([]) do |memo, word|\n    memo << word.length if memo.length\
    \ < word.length\n    memo\n  end\nend", "  words.inject([]) do |max, word|\n \
    \   max = word.length if max.length < word.length\n    max > word.length ? max\
    \ : word\n  end\nend", "  words.sort.reverse.inject(\"\") do |max, word|\n   \
    \ max += word.chars.uniq.size\n    max < word.length ? max : word\n  end\nend",
  "  words.sort.reverse.uniq.first\nend", "  words.sort.reverse.uniq.first\nend",
  "  words.sort.reverse.uniq.length.first\nend", "  words.inject([]) do |max, word|\n\
    \    chars = word.chars.uniq.length\n    max.length < chars ? max : word\n  end\n\
    end", "  words.sort.reverse.uniq.first\nend", "  words.group_by{|word| word.chars.uniq.size}.max_by{|k,\
    \ v| k}\nend", "  words.sort.reverse.uniq.first\nend", "  words.inject([]) do\
    \ |max, word|\n    max << word.chars.uniq.size if max.empty? || max.max.chars.uniq.size\
    \ < word.chars.uniq.size\n    max\n  end\nend", "  words.sort.reverse!\n  words.uniq!\n\
    \  words.first\nend", "  words.sort.reverse.uniq.first\nend", "  words.inject(Hash.new(0))\
    \ { |h, word| h[word] += 1; h }.max_by { |k, v| v.size }[0]\nend", "  words.uniq.sort!\n\
    \  words.uniq.max_by { |word| word.chars.uniq.size }\nend", "  words.sort.reverse.find\
    \ { |word| word.chars.uniq.size == words.uniq.size }\nend", "  words.inject(Hash.new(0))\
    \ { |h, word| h[word] += 1; h }.max_by { |k, v| v.size }[0]\nend", "  words.sort.reverse.inject(\"\
    \") do |max, word|\n    max += word.chars.uniq.size\n    max\n  end\nend", " \
    \ words.sort_by { |word| word.size }.reverse.first\nend", "  words.sort!\n  max_word\
    \ = words[0]\n  max_count = 0\n  max_index = -1\n  words.each do |word|\n    count\
    \ = word.length\n    if count > max_count\n      max_count = count\n      max_word\
    \ = word\n      max_index = words.index(word)\n    end\n  end\n  max_word\nend\n\
    </code>\n<|/ a tags=ruby,string,arrays |>\n<| c |>\nThis solution doesn't work\
    \ for strings with repeated characters. For example, `find_max.call([\"aaaaaaa\"\
    , \"bb\", \"cc\"])` returns `\"aaaaaaa\"` instead of `\"cc\"`.\n<|/ c |>\n<| c\
    \ |>\nYes, you are right. I didn't notice that case. Thanks for pointing out.\
    \ I've updated the answer.\n<|/ c |>\n<| a tags=ruby,string,arrays |>\n<code>",
  "  words.inject([]) do |max, word|\n    chars = word.chars.uniq.length\n    max.length\
    \ < chars ? max : word\n  end\nend", "  words.each_with_object(Hash.new(0)) {\
    \ |w, h| h[w] += 1 }.max_by { |k, v| v.size }[0]\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nI like your solution, but I wonder how it compares to other solutions\
    \ posted here?\n<|/ c |>\n<| c |>\nI like your solution, but I wonder how it compares\
    \ to other solutions posted here?\n<|/ c |>\n<| c |>\nI like your solution, but\
    \ I wonder how it compares to other solutions posted here?\n<|/ c |>\n<| c |>\n\
    I like your solution, but I wonder how it compares to other solutions posted here?\n\
    <|/ c |>\n<| c |>\nI like your solution, but I wonder how it compares to other\
    \ solutions posted here?\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  words.group_by{|word|\
    \ word.chars.uniq.size}.max_by{|k, v| k}\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nThanks so much for this. I really appreciate it. I will definitely look\
    \ into this and try to understand it.\n<|/ c |>\n<| c |>\nI added some comments\
    \ to the code so you can understand how it works.\n<|/ c |>\n<| a tags=ruby,arrays,string\
    \ |>\n<code>", "  words.each_with_object(Hash.new(0)) { |w, h| h[w] += 1 }.max_by\
    \ { |w, v| v }[0]\nend", "  words.sort.reverse.uniq.length.first\nend", "  words.each_with_object(Hash.new(0))\
    \ { |word, counts| counts[word] += 1 }\n    .max_by { |word, counts| -counts[word]\
    \ }\nend", "  words.sort.reverse.uniq.first\nend", "  words.uniq.sort!\n  words.uniq.max_by\
    \ { |word| word.size }\nend", "  words.sort.reverse.uniq.first\nend", "  words.sort.reverse.inject(\"\
    \") do |max, word|\n    max << word.length if max.length < word.length\n    max\n\
    \  end\nend", "  words.group_by { |word| word.chars.uniq.size }.max_by { |word,\
    \ count| count }[0]\nend", "  words.each_with_object(Hash.new(0)) { |w, h| h[w]\
    \ += 1 }.max_by { |w, v| v }[0]\nend\n</cell>\n<cell>", "  words.inject({}) do\
    \ |memo, word|\n    memo[word] = word.length if memo.has_key?(word)\n    memo\n\
    \  end.values.sort.last\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if\
    \ there are multiple words with the same number of unique characters. For example,\
    \ `find_max.call([\"aaaaaaa\", \"bb\", \"cc\"])` returns `\"aaaaaaa\"` instead\
    \ of `\"cc\"`.\n<|/ c |>\n<| c |>\n, thanks for pointing that out. I've updated\
    \ my answer accordingly.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  words.sort.reverse.inject(:+)\n\
    end", "  words.group_by{|word| word.chars.uniq.size}.max_by{|_, v| v}\nend", " \
    \ words.sort_by { |word| word.chars.uniq.size }.reverse.first\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
