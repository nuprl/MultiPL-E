name: HumanEval_128_prod_signs
language: rb
prompt: "# You are given an array arr of integers and you need to return\n# sum of\
  \ magnitudes of integers multiplied by product of all signs\n# of each number in\
  \ the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n\
  # >>> prod_signs.call([1, 2, 2, -4])\n# 9\n# >>> prod_signs.call([0, 1])\n# 0\n\
  # >>> prod_signs.call([])\n# nil\ndef prod_signs(arr)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
  \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2,\
  \ 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1,\
  \ 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20,\
  \ candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1,\
  \ 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0,\
  \ candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
completions: ["  arr.inject(0) { |sum, el| sum + el * el.sign.abs }\nend", "  arr.inject(0)\
    \ { |sum, el| sum + el * el.abs }\nend", "  arr.inject(0) {|sum, e| sum + e *\
    \ sign(e) }\nend", "  arr.inject(0) {|sum, el| sum + el * el.abs}\nend", "  arr.inject(0)\
    \ { |sum, e| sum + e * e.sign }\nend", "  arr.inject(0) { |sum, el| sum + el *\
    \ el.sign.abs }\nend", "  return nil if arr.empty?\n  arr.inject(0) {|sum, el|\
    \ sum + el * el.abs }\nend", "  arr.inject(0) { |sum, e| sum + e * e.sign }\n\
    end", "  arr.inject(0) {|sum, el| sum + el * el.abs}\nend", "  return nil if arr.empty?\n\
    \  arr.inject(0) {|sum, el| sum + el * el.abs }\nend", "  arr.inject(0) { |sum,\
    \ el| sum + el * el.sign.abs }\nend", "  arr.inject(0) {|sum, el| sum + el * el.abs}\n\
    end", "  return nil if arr.empty?\n  arr.inject(0) {|sum, e| sum + e.abs * (e.negative?\
    \ ? -1 : 1) }\nend", "  return nil if arr.empty?\n  arr.inject(0) {|sum, el| sum\
    \ + el * el.abs}\nend", "  return nil if arr.empty?\n  arr.inject(0) {|sum, e|\
    \ sum + e * e.sign.abs}\nend", "  arr.inject(0) { |sum, el| sum + el * el.sign.abs\
    \ }\nend", "  arr.inject(0) {|sum, el| sum + el * el.abs}\nend", "  arr.inject(0)\
    \ { |sum, el| sum + el * el.abs }\nend", "  return nil if arr.empty?\n  arr.inject(0)\
    \ {|sum, el| sum + el * el.abs}\nend", "  arr.inject(0) {|sum, el| sum + el *\
    \ el.abs}\nend", "  arr.inject(0) {|sum, el| sum + el * el.abs}\nend", "  arr.inject(0)\
    \ {|sum, el| sum + el * el.abs}\nend", "  arr.inject(0) { |sum, el| sum + el *\
    \ el.sign.abs }\nend", "  arr.inject(0) {|sum, el| sum + el * el.abs}\nend", " \
    \ return nil if arr.empty?\n  arr.inject(0) {|sum, el| sum + el.abs * el.sign}\n\
    end", "  arr.inject(0) { |sum, el| sum + el * el.sign.abs }\nend", "  return nil\
    \ if arr.empty?\n  signs = arr.map { |x| x == 0 ? 1 : x == -1 ? -1 : 0 }\n  signs.inject(:*)\n\
    end", "  arr.inject(0) { |sum, e| sum + e * e.sign.abs }\nend", "  arr.inject(0)\
    \ {|sum, el| sum + el * el.abs}\nend", "  arr.inject(0) {|sum, el| sum + el *\
    \ el.abs}\nend", "  arr.inject(0) {|sum, el| sum + el * el.abs}\nend", "  arr.inject(0)\
    \ { |s, x| s * x }\nend", "  return nil if arr.empty?\n  arr.inject(0) {|sum,\
    \ e| sum + e.abs * e.sign}\nend", "  return nil if arr.empty?\n  arr.inject(0)\
    \ {|sum, e| sum + e.abs * e.sign}\nend", "  arr.inject(0) {|sum, e| sum + e.abs\
    \ * e.sign}\nend", "  arr.inject(0) {|sum, el| sum + el * el.abs}\nend", "  return\
    \ nil if arr.empty?\n  arr.inject(0) {|sum, el| sum + el.abs * el.sign}\nend",
  "  arr.inject(0) { |sum, el| sum + el * el.sign.abs }\nend", "  return nil if arr.empty?\n\
    \  arr.inject(0) {|sum, e| sum + e * e.sign}\nend", "  arr.inject(0) {|sum, el|\
    \ sum + el * el.abs}\nend", "  arr.inject(0) {|sum, el| sum + el * el.abs}\nend",
  "  arr.inject(0) {|sum, el| sum + el * el.abs}\nend", "  arr.inject(0) {|sum, el|\
    \ sum + el * el.abs}\nend", "  arr.inject(0) {|sum, e| sum + e * sign(e) }\nend",
  "  return nil if arr.empty?\n  product = arr.inject(1){|product, el| product * el}\n\
    \  signs = arr.map { |el| el > 0 ? 1 : el < 0 ? -1 : 0 }\n  signs.inject(product){|product,\
    \ sign| product * sign}\nend", "  return nil if arr.empty?\n  arr.inject(0) {|sum,\
    \ el| sum + el * el.abs }\nend", "  arr.inject(0) { |sum, el| sum + el * el.sign\
    \ }\nend", "  arr.inject(0) {|sum, el| sum + el * el.abs}\nend", "  return nil\
    \ if arr.empty?\n  signs = arr.map { |x| x == 0 ? 1 : x == 1 ? -1 : 0 }\n  signs.inject(:*)\n\
    end", "  return nil if arr.empty?\n  arr.inject(0) {|sum, el| sum + el * el.abs\
    \ }\nend", "  return nil if arr.empty?\n  sign = arr[0]\n  arr.shift\n  arr.each\
    \ do |x|\n    sign *= x if x > 0\n    sign *= -x if x < 0\n  end\n  sign\nend",
  "  arr.inject(0) {|sum, el| sum + el * el.abs}\nend", "  arr.inject(0) { |sum, e|\
    \ sum + e * e.sign }\nend", "  return nil if arr.empty?\n  arr.inject(0) {|sum,\
    \ el| sum + el * el.abs }\nend", "  arr.inject(0) { |sum, el| sum + el * el.abs\
    \ }\nend", "  arr.inject(0) {|sum, el| sum + el * el.abs}\nend", "  arr.inject(0)\
    \ { |sum, el| sum + el * el.sign.abs }\nend", "  arr.inject(0) {|sum, el| sum\
    \ + el * el.abs}\nend", "  return nil if arr.empty?\n  arr.inject(0) {|sum, el|\
    \ sum + el * el.sign.abs}\nend", "  arr.inject(0) {|sum, el| sum + el * el.abs}\n\
    end", "  arr.inject(0) {|sum, el| sum + el * el.abs}\nend", "  arr.inject(0) {\
    \ |sum, el| sum + el * el.abs }\nend", "  arr.inject(0) { |sum, el| sum + el *\
    \ el.sign.abs }\nend", "  arr.inject(0) {|sum, el| sum + el * el.abs }\nend",
  "  return nil if arr.empty?\n  arr.inject(0) {|sum, el| sum + el.abs * el.sign}\n\
    end", "  arr.inject(0) { |sum, el| sum + el * el.abs }\nend", "  arr.inject(0)\
    \ {|sum, el| sum + el * el.abs}\nend", "  return nil if arr.empty?\n  arr.inject(0)\
    \ {|sum, el| sum + el * el.abs }\nend", "  arr.inject(0) { |sum, el| sum + el\
    \ * el.sign.abs }\nend", "  arr.inject(0) {|sum, e| sum + e.abs * e.sign}\nend",
  "  arr.inject(0) {|sum, e| sum + e * e.sign.abs }\nend", "  arr.inject(0) { |sum,\
    \ el| sum + el * el.sign.abs }\nend", "  return nil if arr.empty?\n  arr.inject(0)\
    \ {|sum, el| sum + el * el.sign.abs }\nend", "  arr.inject(0) { |sum, el| sum\
    \ + el * el.abs }\nend", "  arr.inject(0) {|sum, el| sum + el * el.abs}\nend",
  "  arr.inject(0) {|sum, el| sum + el * el.abs }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
