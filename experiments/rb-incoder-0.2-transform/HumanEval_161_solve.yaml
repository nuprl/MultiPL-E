name: HumanEval_161_solve
language: rb
prompt: "# You are given a string s.\n# if s[i] is a letter, reverse its case from\
  \ lower to upper or vise versa, \n# otherwise keep it as it is.\n# If the string\
  \ contains no letters, reverse the string.\n# The function should return the resulted\
  \ string.\n# Examples\n# >>> solve.call(\"1234\")\n# \"4321\"\n# >>> solve.call(\"\
  ab\")\n# \"AB\"\n# >>> solve.call(\"#a@C\")\n# \"#A@c\"\ndef solve(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n\
  \    candidate = method(:solve)\n    assert_equal(\"aSdF\", candidate.call(\"AsDf\"\
  ))\n    assert_equal(\"4321\", candidate.call(\"1234\"))\n    assert_equal(\"AB\"\
  , candidate.call(\"ab\"))\n    assert_equal(\"#A@c\", candidate.call(\"#a@C\"))\n\
  \    assert_equal(\"#aSDFw^45\", candidate.call(\"#AsdfW^45\"))\n    assert_equal(\"\
  2@6#\", candidate.call(\"#6@2\"))\n    assert_equal(\"#$A^d\", candidate.call(\"\
  #$a^D\"))\n    assert_equal(\"#CCC\", candidate.call(\"#ccc\"))\n  end\nend\n"
completions: ["  s.gsub!(/[^A-Za-z]/,'')\n  s.gsub!(/[A-Z]/){|s| s.upcase}\n  s.gsub!(/[a-z]/){|s|\
    \ s.downcase}\n  s\nend", "  s.chars.each do |c|\n    if c.upcase == c\n     \
    \ s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.upcase)\n    end\n  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase\
    \ }\n  s.gsub!(/[^A-Z]/i) { |s| s.downcase }\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n  s\nend", "  s.chars.each\
    \ do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase == c\n\
    \    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next if\
    \ c.upcase == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |c| c.upcase }\n  s.gsub!(/[a-z]/i) { |c|\
    \ c.downcase }\n  s\nend", "  s.chars.each do |c|\n    if c.upcase == c\n    \
    \  s = s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)\n    elsif c.downcase ==\
    \ c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase, c.downcase)\n   \
    \ end\n  end\n  s.chars.join\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like\
    \ your solution, but I believe it can be done more efficiently with one `gsub`\
    \ call. Also, `gsub` can take a block, which would allow you to make a single\
    \ `gsub` call that would replace all instances of one character with another character\
    \ in a single call.\n<|/ c |>\n<| c |>\nYes, I agree with you. My solution was\
    \ more for educational purposes than for production use. Thanks for your comment.\n\
    <|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.chars.each do |c|\n    next\
    \ if c.nil?\n    next if c.empty?\n    next if c.start_with?(\"#\")\n    next\
    \ if c.start_with?(\"$\")\n    next if c.start_with?(\"%\")\n    next if c.start_with?(\"\
    &\")\n    next if c.start_with?(\"*\")\n    next if c.start_with?(\"(\")\n   \
    \ next if c.start_with?(\")\")\n    next if c.start_with?(\"+\")\n    next if\
    \ c.start_with?(\"-\")\n    next if c.start_with?(\"=\")\n    next if c.start_with?(\"\
    ?\")\n    next if c.start_with?(\":\")\n    next if c.start_with?(\";\")\n   \
    \ next if c.start_with?(\",\")\n    next if c.start_with?(\".\")\n    next if\
    \ c.start_with?(\"!\")\n    next if c.start_with?(\"~\")\n    next if c.start_with?(\"\
    `\")\n    next if c.start_with?(\"'\")\n    next if c.start_with?(\"[\")\n   \
    \ next if c.start_with?(\"]\")\n    next if c.start_with?(\"{\")\n    next if\
    \ c.start_with?(\"}\")\n    next if c.start_with?(\"|\")\n    next if c.start_with?(\"\
    ;\")\n    next if c.start_with?(\",\")\n    next if c.start_with?(\".\")\n   \
    \ next if c.start_with?(\"!\")\n    next if c.start_with?(\"~\")\n    next if\
    \ c.start_with?(\"`\")\n    next if c.start_with?(\"'\")\n    next if c.start_with?(\"\
    [\")\n    next if c.start_with?(\"]\")\n    next if c.start_with?(\"{\")\n   \
    \ next if c.start_with?(\"}\")\n    next if c.start_with?(\"|\")\n    next if\
    \ c.start_with?(\";\")\n    next if c.start_with?(\",\")\n    next if c.start_with?(\"\
    .\")\n    next if c.start_with?(\"!\")\n    next if c.start_with?(\"~\")\n   \
    \ next if c.start_with?(\"`\")\n    next if c.start_with?(\"'\")\n    next if\
    \ c.start_with?(\"[\")\n    next if c.start_with?(\"]\")\n    next if c.start_with?(\"\
    {\")\n    next if c.start_with?(\"}\")", "  s.downcase!\n  s.gsub!(/[^a-z]/i,\
    \ '')\n  s.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,string,regex |>\n<| c |>\nI like this solution,\
    \ but I wonder why `gsub!` doesn't return the modified string?\n<|/ c |>\n<| c\
    \ |>\n`gsub!` modifies the string in place. `gsub` returns a new string with the\
    \ modifications.\n<|/ c |>\n<| c |>\nI see, thanks. I guess I should read more\
    \ about `gsub` then.\n<|/ c |>\n<| c |>\n`gsub!` modifies the string in place.\
    \ `gsub` returns a new string with the modifications.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "  s.chars.each do\
    \ |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase == c\n \
    \   next if c.downcase == c\n    next if c.upcase == c.downcase\n    next if c.downcase\
    \ == c.upcase\n    next if c.upcase == c.downcase.upcase\n    next if c.downcase\
    \ == c.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase\n \
    \   next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\nend\n</code>\n\
    <|/ a |>\n<| c |>\nI like your solution, but I believe it would be better to use\
    \ the `gsub!` method instead of `gsub` since it modifies the string in place.\
    \ Also, `gsub!` will return the modified string so you can chain it like `s.gsub!(/[^a-z]/i)\
    \ { |x| x.upcase }.reverse!`\n<|/ c |>\n<| c |>\nThanks for the suggestions. I\
    \ updated the answer accordingly.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  s.downcase!\n\
    \  s.gsub(/[^a-z]/i) { |x| x.upcase }\n  s.gsub(/[^A-Z]/i) { |x| x.downcase }\n\
    \  s\nend", "  s.chars.each do |c|\n    next if c.nil?\n    next if c.empty?\n\
    \    next if c.upcase == c\n    next if c.downcase == c\n    next if c.upcase\
    \ == c.downcase\n    next if c.upcase == c.downcase.upcase\n    next if c.downcase\
    \ == c.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase\n \
    \   next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.reverse!\n  s.gsub!(/[a-z]/i, '')\n\
    \  s\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  s.chars.each\
    \ do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif\
    \ c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.join\n\
    end", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n\
    \    end\n  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby |>\n<|\
    \ c |>\nThis doesn't work for `solve.call(\"ab\")` which should return `\"AB\"\
    `.\n<|/ c |>\n<| c |>\nI believe that `s.chars.each do |c|` should be `s.each_char\
    \ do |c|`\n<|/ c |>\n<| c |>\nI believe that `s.chars.each do |c|` should be `s.each_char\
    \ do |c|`\n<|/ c |>\n<| c |>\nI believe that `s.chars.each do |c|` should be `s.each_char\
    \ do |c|`\n<|/ c |>\n<| c |>\nI believe that `s.chars.each do |c|` should be `s.each_char\
    \ do |c|`\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }\n  s.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n\
    <| c |>\nI like the `gsub` solution, it's more elegant than my solution. Thanks!\n\
    <|/ c |>\n<| c |>\nI like your solution as well, it's more elegant than my solution.\
    \ Thanks!\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s = s.to_s\n  s.chars.each\
    \ do |c|\n    case = c.upcase if c.is_a? String\n    case = c.downcase if c.is_a?\
    \ String\n    case = c.to_s if c.is_a? String\n    case = c.to_s if c.is_a? Fixnum\n\
    \  end\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work if you\
    \ have a string like \"#a@C\"\n<|/ c |>\n<| c |>\nI added a solution that works\
    \ with strings with hashes and numbers\n<|/ c |>\n<| c |>\nI added a solution\
    \ that works with strings with hashes and numbers\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.reverse!\n  s\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| a dscore=0 |>\n<code>", "  s.gsub!(/[^A-Za-z]/)\
    \ do |x|\n    x.upcase if x.downcase == x\n    x.downcase if x.upcase == x\n \
    \   x\n  end\n  s.gsub!(/[^A-Za-z]/) do |x|\n    x.downcase if x.upcase == x\n\
    \    x.upcase if x.downcase == x\n    x\n  end\n  s.gsub!(/[^A-Za-z]/) do |x|\n\
    \    x.downcase if x.upcase == x\n    x.upcase if x.downcase == x\n    x\n  end\n\
    \  s.gsub!(/[^A-Za-z]/) do |x|\n    x.downcase if x.upcase == x\n    x.upcase\
    \ if x.downcase == x\n    x\n  end\n  s.gsub!(/[^A-Za-z]/) do |x|\n    x.downcase\
    \ if x.upcase == x\n    x.upcase if x.downcase == x\n    x\n  end\n  s.gsub!(/[^A-Za-z]/)\
    \ do |x|\n    x.downcase if x.upcase == x\n    x.upcase if x.downcase == x\n \
    \   x\n  end\n  s.gsub!(/[^A-Za-z]/) do |x|\n    x.downcase if x.upcase == x\n\
    \    x.upcase if x.downcase == x\n    x\n  end\n  s.gsub!(/[^A-Za-z]/) do |x|\n\
    \    x.downcase if x.upcase == x\n    x.upcase if x.downcase == x\n    x\n  end\n\
    \  s.gsub!(/[^A-Za-z]/) do |x|\n    x.downcase if x.upcase == x\n    x.upcase\
    \ if x.downcase == x\n    x\n  end\n  s.gsub!(/[^A-Za-z]/) do |x|\n    x.downcase\
    \ if x.upcase == x\n    x.upcase if x.downcase == x\n    x\n  end\n  s.gsub!(/[^A-Za-z]/)\
    \ do |x|\n    x.downcase if x.upcase == x\n    x.upcase if x.downcase == x\n \
    \   x\n  end\n  s.gsub!(/[^A-Za-z]/) do |x|\n    x.downcase if x.upcase == x\n\
    \    x.upcase if x.downcase == x\n    x\n  end\n  s.gsub!(/[^A-Za-z]/) do |x|\n\
    \    x.downcase if ", "  s.chars.each do |c|\n    next if c.nil?\n    next if\
    \ c.empty?\n    next if c.upcase == c\n    next if c.downcase == c\n    next if\
    \ c.upcase == c.downcase\n    next if c.upcase == c.downcase.upcase\n    next\
    \ if c.downcase == c.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\nend", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,string,regex |>\n<| c |>\nThis doesn't work\
    \ if the string contains numbers, e.g. \"#a@C\".\n<|/ c |>\n<| c |>\n: I didn't\
    \ see that requirement in the question. I'll update my answer.\n<|/ c |>\n<| c\
    \ |>\n: I added a solution that doesn't require the string to be reversed twice.\n\
    <|/ c |>\n<| c |>\n: I added a solution that doesn't require the string to be\
    \ reversed twice.\n<|/ c |>\n<| c |>\n: I added a solution that doesn't require\
    \ the string to be reversed twice.\n<|/ c |>\n<| a tags=ruby,string,regex |>\n\
    <code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i)\
    \ { |s| s.downcase }\n  s\nend", "  s.gsub!(/[a-z]/) { |x| x.upcase }\n  s.gsub!(/[A-Z]/)\
    \ { |x| x.downcase }\n  s.gsub!(/[^a-zA-Z]/) { |x| x.reverse }\n  s\nend", " \
    \ s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase,\
    \ c.upcase)\n    end\n  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nI like your solution, but I wonder if there is a way to do it without\
    \ using gsub. Maybe with regular expressions?\n<|/ c |>\n<| c |>\nI added a solution\
    \ that doesn't use gsub. Hope it helps.\n<|/ c |>\n<| c |>\nI like your solution,\
    \ but I wonder if there is a way to do it without using gsub. Maybe with regular\
    \ expressions?\n<|/ c |>\n<| c |>\nI added a solution that doesn't use gsub. Hope\
    \ it helps.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.downcase!\n  s.gsub!(/[a-z]/)\
    \ { |c| c.upcase }\n  s.gsub!(/[^a-z]/) { |c| c.downcase }\n  s\nend", "  s =\
    \ s.to_s\n  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n\
    \    end\n  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a dscore=0 |>\n<code>", "  s.chars.each do |c|\n    if c.upcase == c\n     \
    \ s = s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)\n    elsif c.downcase ==\
    \ c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase, c.downcase)\n   \
    \ end\n  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n\
    <| c |>\nI like your solution, but I wonder why you used `gsub` instead of `tr`?\n\
    <|/ c |>\n<| c |>\n`tr` only replaces one character at a time, so it can't replace\
    \ multiple characters at once.\n<|/ c |>\n<| c |>\n`tr` replaces multiple characters\
    \ at once, just like `gsub` does. `tr` is more efficient than `gsub` because it\
    \ doesn't have to scan the string multiple times to find all the matches.\n<|/\
    \ c |>\n<| c |>\n`tr` is more efficient than `gsub` because it doesn't have to\
    \ scan the string multiple times to find all the matches. `tr` is more efficient\
    \ than `gsub` because it doesn't have to scan the string multiple times to find\
    \ all the matches. `tr` is more efficient than `gsub` because it doesn't have\
    \ to scan the string multiple times to find all the matches. `tr` is more efficient\
    \ than `gsub` because it doesn't have to scan the string multiple times to find\
    \ all the matches. `tr` is more efficient than `gsub` because it doesn't have\
    \ to scan the string multiple times to find all the matches. `tr` is more efficient\
    \ than `gsub` because it doesn't have to scan the string multiple times to find\
    \ all the matches. `tr` is more efficient than `gsub` because it doesn't have\
    \ to scan the string multiple times to find all the matches. `tr` is more efficient\
    \ than `gsub` because it doesn't have to scan the string multiple times to find\
    \ all the matches.\n<|/ c |>\n<| c |>\n`tr` is more efficient than `gsub` because\
    \ it doesn't have to scan the string multiple times to find all the matches. `tr`\
    \ is more efficient than `gsub` because it doesn't have to scan the string multiple\
    \ times to find all the matches. `tr` is more efficient than `gsub` because it\
    \ doesn't have to scan the string multiple times to find all the matches. `tr`\
    \ is more efficient than `gsub` because it doesn't have to scan the string multiple\
    \ times to find all the matches. `tr` is more efficient than `gsub` because it\
    \ doesn't have to ", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n \
    \ s.reverse!\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nI like your solution,\
    \ but I wonder why `s.gsub(/[^a-z]/i) { |s| s.upcase }.reverse!` doesn't work?\n\
    <|/ c |>\n<| c |>\nBecause `gsub` returns the modified string, which is not being\
    \ reversed. `gsub!` modifies the string in place. `gsub` returns the modified\
    \ string and `gsub!` modifies the string in place.\n<|/ c |>\n<| c |>\nI see,\
    \ thank you. I'm new to Ruby, so I didn't know about `gsub!`.\n<|/ c |>\n<| a\
    \ dscore=3 |>\n<code>", "  s.chars.reverse_each.with_index.reduce(:+).to_s\nend",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\nend", "  s.downcase!\n\
    \  s.gsub(/[[:alpha:]]/) { |c| c.upcase }\n  s.gsub(/[^[:alpha:]]/) { |c| c.downcase\
    \ }\n  s\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>", "  s.chars.each\
    \ do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.downcase ==\
    \ c\n    next if c.upcase == c\n    next if c.swapcase == c\n    next if c.upcase\
    \ == c.downcase\n    next if c.upcase == c.swapcase\n    next if c.downcase ==\
    \ c.swapcase\n    next if c.upcase == c.downcase.swapcase\n    next if c.downcase\
    \ == c.swapcase.upcase\n    next if c.swapcase == c.upcase.downcase\n    next\
    \ if c.swapcase == c.upcase.swapcase.downcase\n    next if c.swapcase == c.upcase.swapcase.swapcase\n\
    \    next if c.upcase.downcase == c.swapcase.upcase.downcase.swapcase\n    next\
    \ if c.upcase.swapcase.downcase == c.swapcase.upcase.swapcase.downcase.swapcase\n\
    \    next if c.upcase.swapcase.swapcase == c.swapcase.upcase.swapcase.swapcase.downcase.swapcase\n\
    \    next if c.upcase.swapcase.swapcase.upcase.downcase.swapcase == c.swapcase.upcase.swapcase.upcase.downcase.swapcase.downcase.swapcase\n\
    \    next if c.upcase.swapcase.swapcase.upcase.downcase.swapcase.swapcase == c.swapcase.upcase.swapcase.upcase.downcase.swapcase.downcase.swapcase.downcase.swapcase\n\
    \    next if c.upcase.swapcase.swapcase.upcase.downcase.swapcase.swapcase.downcase.swapcase\
    \ == c.swapcase.upcase.swapcase.upcase.downcase.swapcase.downcase.swapcase.downcase.swapcase\n\
    \    next if c.upcase.swapcase.swapcase.upcase.downcase.swapcase.swapcase.downcase.swapcase.downcase.swapcase\
    \ == c.swapcase.upcase.swapcase.upcase.downcase.swapcase.downcase.swapcase.downcase.swapcase.downcase.swapcase\n\
    \    next if c.upcase.swapcase.swapcase.upcase.downcase.swapcase.swapcase.downcase.swapcase.downcase.swapcase.downcase.swapcase\
    \ == c.swapcase.upcase.swapcase.upcase.downcase.swapcase.downcase.swapcase.downcase.swapcase.downcase.swapcase\n\
    \    next if c.upcase.swapcase.swapcase.upcase.downcase.swapcase.swapcase.downcase.swapcase.downcase.swapcase.downcase.swapcase\
    \ == c.swapcase.upcase.swapcase.upcase.downcase.swapcase.downcase.swapcase.downcase.swapcase.downcase.swapcase\n\
    \    next if c.up", "  s.downcase!\n  s.gsub(/[^a-z]/i) { |s| s.upcase }\nend",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\n  s\nend",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s|\
    \ s.downcase }\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |c| c.upcase\
    \ }\n  s.gsub!(/[a-z]/i) { |c| c.downcase }\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }\n  s.reverse!\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i) {\
    \ |s| s.upcase }\n  s.reverse!\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c\
    \ |>\nI like this solution, it's very concise and easy to understand. Thanks!\n\
    <|/ c |>\n<| a dscore=3 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n\
    \  s.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a dscore=2 |>\n\
    <code>", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c).gsub(c.downcase, c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.downcase).gsub(c.upcase, c.downcase)\n    else\n      s = c\n    end\n  end\n\
    \  s\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThanks for the answer!\
    \ I appreciate it!\n<|/ c |>\n<| c |>\nI added a more efficient solution that\
    \ doesn't require the downcase/upcase conversion.\n<|/ c |>\n<| c |>\nThanks for\
    \ the update! I appreciate it!\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", " \
    \ s = s.to_s\n  s.gsub!(/[[:alpha:]]/) { |s| s.upcase }\n  s.gsub!(/[[:alpha:]]/)\
    \ { |s| s.downcase }\n  s.gsub!(/[^[:alpha:]]/) { |s| s.reverse }\n  s.gsub!(/[^[:alpha:]]/)\
    \ { |s| s.reverse }\n  s.to_s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x|\
    \ x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n  s\nend", "  s.gsub!(/[^a-z]/i)\
    \ { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n  s\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| a |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s|\
    \ s.upcase }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n  s\nend", "  s.chars.each\
    \ do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase == c\n\
    \    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next if\
    \ c.upcase == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase",
  "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n\
    \  end\n  s.chars.reverse.join\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis\
    \ doesn't work for `solve.call(\"aB\")` which should return `\"Ab\"`.\n<|/ c |>\n\
    <| c |>\n: I missed that case. Thanks for pointing it out. I've updated the answer.\n\
    <|/ c |>\n<| c |>\n`s.chars.reverse.join` can be replaced with `s.reverse`\n<|/\
    \ c |>\n<| c |>\n: Yes, that would work too. Thanks for pointing it out.\n<|/\
    \ c |>\n<| a |>\n<code>", "  s.chars.each do |c|\n    next if c.nil?\n    next\
    \ if c.empty?\n    next if c.upcase == c\n    next if c.downcase == c\n    next\
    \ if c.upcase == c.downcase\n    next if c.downcase == c.upcase\n    next if c.upcase\
    \ == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n    next\
    \ if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase\n    next if c.downcase\
    \ == c.upcase.downcase.upcase.downcase.upcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.", "  s.downcase!\n\
    \  s.gsub(/[^a-z]/i) { |c| c.upcase }\n  s.gsub(/[^A-Z]/i) { |c| c.downcase }\n\
    \  s\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. Try it with\
    \ `\"#a@C\"`.\n<|/ c |>\n<| c |>\nThanks for pointing that out. I've updated the\
    \ answer.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.chars.each do |c|\n\
    \    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase\
    \ == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse!\n\
    \  s\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. `'a'.upcase\
    \ == 'A'` returns `false`, so `s.gsub(c.upcase, c.downcase)` returns `s`, which\
    \ is `'aA'`.\n<|/ c |>\n<| c |>\nThanks for pointing that out. I fixed the code\
    \ by reversing the string before reversing the characters.\n<|/ c |>\n<| a |>\n\
    <code>", "  s = s.downcase\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i)\
    \ { |x| x.downcase }\n  s\nend\n</cell>\n<cell>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }\n  s.reverse!\nend", "  s.downcase!\n  s.gsub(/[^a-z]/i) {\
    \ |c| c.upcase }\n  s.gsub(/[^A-Z]/i) { |c| c.downcase }\n  s\nend", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n\
    \  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i)\
    \ { |x| x.downcase }\n  s\nend", "  s.chars.each do |c|\n    if c.upcase == c\n\
    \      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n      s =\
    \ s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse!\n  s\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "  s.downcase!\n  s.gsub!(/[a-z]/i)\
    \ do |x|\n    x.upcase if x.upcase == x\n  end\n  s.gsub!(/[^a-z]/i) do |x|\n\
    \    x.downcase if x.downcase == x\n  end\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i,\
    \ '')\n  s.gsub!(/[a-z]/i) { |s| s.upcase }\n  s\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nI like this solution, but I wonder why `s.gsub!(/[^a-z]/i, '')`\
    \ doesn't work. `gsub!` should replace all occurrences of `[^a-z]` with an empty\
    \ string. Why doesn't it work?\n<|/ c |>\n<| c |>\n`[^a-z]` matches any character\
    \ that's not in the range `a-z`. So `gsub!` replaces every occurrence of `[^a-z]`\
    \ with an empty string. `gsub!` doesn't replace `[^a-z]` with an empty string\
    \ because `[^a-z]` matches any character that's not in the range `a-z`.\n<|/ c\
    \ |>\n<| c |>\nI see. Thanks for the explanation!\n<|/ c |>\n<| a dscore=3 |>\n\
    <code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n`s.gsub(/[^a-z]/i) { |x|\
    \ x.upcase }` is the same as `s.gsub(/[^a-z]/) { |x| x.upcase }`.\n<|/ c |>\n\
    <| c |>\n: Yes, but `gsub` doesn't modify the string in place. `gsub!` does.\n\
    <|/ c |>\n<| c |>\n: Yes, but `gsub` doesn't modify the string in place. `gsub!`\
    \ does.\n<|/ c |>\n<| c |>\n: Yes, but `gsub` doesn't modify the string in place.\
    \ `gsub!` does.\n<|/ c |>\n<| c |>\n: Yes, but `gsub` doesn't modify the string\
    \ in place. `gsub!` does.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n\
    \  s\nend", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c).gsub(c.downcase, c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.downcase).gsub(c.upcase, c.downcase)\n    end\n  end\n  s.chars.reverse.join\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work for the string \"\
    #a@C\"\n<|/ c |>\n<| c |>\nYes, it does. I tested it before posting. Did you try\
    \ it?\n<|/ c |>\n<| c |>\nYes, I did. But it didn't work for the string \"#a@C\"\
    \n<|/ c |>\n<| c |>\nI tested it again. Works fine for me. Did you try it again?\n\
    <|/ c |>\n<| c |>\nYes, I did. But it didn't work for the string \"#a@C\"\n<|/\
    \ c |>\n<| a tags=ruby |>\n<code>", "  s.chars.each do |c|\n    if c.upcase ==\
    \ c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n     \
    \ s = s.gsub(c.downcase, c.upcase)\n    else\n      s = c\n    end\n  end\n  s.chars.reverse!\n\
    \  s\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,string |>\n<code>", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n\
    \  s\nend", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n\
    \    end\n  end\n  s.chars.reverse.join\nend", "  s.chars.each do |c|\n    if\
    \ c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase\
    \ == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse!\n\
    \  s\nend", "  s.chars.each do |c|\n    next if c.nil?\n    next if c.empty?\n\
    \    next if c.is_a? String\n    next if c.is_a? Fixnum\n    next if c.is_a? Bignum\n\
    \    next if c.is_a? Float\n    next if c.is_a? TrueClass\n    next if c.is_a?\
    \ FalseClass\n    next if c.is_a? NilClass\n    next if c.is_a? Symbol\n    next\
    \ if c.is_a? Fixnum\n    next if c.is_a? Bignum\n    next if c.is_a? Float\n \
    \   next if c.is_a? TrueClass\n    next if c.is_a? FalseClass\n    next if c.is_a?\
    \ NilClass\n    next if c.is_a? Symbol\n    next if c.is_a? Fixnum\n    next if\
    \ c.is_a? Bignum\n    next if c.is_a? Float\n    next if c.is_a? TrueClass\n \
    \   next if c.is_a? FalseClass\n    next if c.is_a? NilClass\n    next if c.is_a?\
    \ Symbol\n    next if c.is_a? Fixnum\n    next if c.is_a? Bignum\n    next if\
    \ c.is_a? Float\n    next if c.is_a? TrueClass\n    next if c.is_a? FalseClass\n\
    \    next if c.is_a? NilClass\n    next if c.is_a? Symbol\n    next if c.is_a?\
    \ Fixnum\n    next if c.is_a? Bignum\n    next if c.is_a? Float\n    next if c.is_a?\
    \ TrueClass\n    next if c.is_a? FalseClass\n    next if c.is_a? NilClass\n  \
    \  next if c.is_a? Symbol\n    next if c.is_a? Fixnum\n    next if c.is_a? Bignum\n\
    \    next if c.is_a? Float\n    next if c.is_a? TrueClass\n    next if c.is_a?\
    \ FalseClass\n    next if c.is_a? NilClass\n    next if c.is_a? Symbol\n    next\
    \ if c.is_a? Fixnum\n    next if c.is_a? Bignum\n    next if c.is_a? Float\n \
    \   next if c.is_a? TrueClass\n    next if c.is_a? FalseClass\n    next if c.is_a?\
    \ NilClass\n    next if c.is_a", "  s = s.to_s\n  s.gsub!(/[[:alpha:]]/) { |s|\
    \ s.upcase }\n  s.gsub!(/[[:alpha:]]/) { |s| s.downcase }\n  s.gsub!(/[^[:alpha:]]/)\
    \ { |s| s.reverse }\n  s.gsub!(/[^[:alpha:]]/) { |s| s.reverse }\n  s.to_s\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work if the string contains\
    \ numbers, punctuation, or other non-alphabetic characters.\n<|/ c |>\n<| c |>\n\
    It does work, just tested it. The only thing it doesn't do is handle non-alphabetic\
    \ characters. But I guess that's not what the OP wanted.\n<|/ c |>\n<| c |>\n\
    It does handle non-alphabetic characters. Try it yourself.\n<|/ c |>\n<| c |>\n\
    It doesn't handle non-alphabetic characters. Try it yourself.\n<|/ c |>\n<| c\
    \ |>\nIt does handle non-alphabetic characters. Try it yourself.\n<|/ c |>\n<|\
    \ a dscore=0 |>\n<code>", "  s.chars.each do |c|\n    next if c.nil?\n    next\
    \ if c.empty?\n    next if c.upcase == c\n    next if c.downcase == c\n    next\
    \ if c.upcase == c.downcase\n    next if c.upcase == c.downcase.upcase\n    next\
    \ if c.downcase == c.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| c |>\n`s.downcase!` will mutate the string in place.\
    \ `s.gsub!(/[^a-z]/i) { |s| s.upcase }` will also mutate the string in place.\
    \ `s.reverse!` will mutate the string in place. `s.gsub!(/[^a-z]/i) { |s| s.upcase\
    \ }` will also mutate the string in place. `s.reverse!` will mutate the string\
    \ in place. `s.gsub!(/[^a-z]/i) { |s| s.upcase }` will also mutate the string\
    \ in place. `s.reverse!` will mutate the string in place. `s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }` will also mutate the string in place. `s.reverse!` will mutate\
    \ the string in place. `s.gsub!(/[^a-z]/i) { |s| s.upcase }` will also mutate\
    \ the string in place. `s.reverse!` will mutate the string in place. `s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }` will also mutate the string in place. `s.reverse!` will mutate\
    \ the string in place. `s.gsub!(/[^a-z]/i) { |s| s.upcase }` will also mutate\
    \ the string in place. `s.reverse!` will mutate the string in place. `s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }` will also mutate the string in place. `s.reverse!` will mutate\
    \ the string in place. `s.gsub!(/[^a-z]/i) { |s| s.upcase }` will also mutate\
    \ the string in place.\n<|/ c |>\n<| c |>\n`s.gsub!(/[^a-z]/i) { |s| s.upcase\
    \ }` will also mutate the string in place. `s.reverse!` will mutate the string\
    \ in place. `s.gsub!(/[^a-z]/i) { |s| s.upcase }` will also mutate the string\
    \ in place. `s.reverse!` will mutate the string in place. `s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }` will also mutate the string in place. `s.reverse!` will mutate\
    \ the string ", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i)\
    \ { |x| x.downcase }\n  s\nend", "  s = s.to_s\n  s.gsub!(/[[:alpha:]]/) { |s|\
    \ s.upcase }\n  s.gsub!(/[[:alpha:]]/) { |s| s.downcase }\n  s.gsub!(/[^[:alpha:]]/)\
    \ { |s| s.reverse }\n  s\nend", "  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i)\
    \ { |s| s.downcase }\n  s.gsub!(/[^A-Z]/i) { |s| s.upcase }\n  s.gsub!(/[A-Z]/i)\
    \ { |s| s.downcase }\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n\
    I like your solution, but I believe that `s.gsub(/[^A-Z]/) { |s| s.upcase }` can\
    \ be replaced with `s.tr('A-Z', 'a-z')`\n<|/ c |>\n<| c |>\nI agree, but I wanted\
    \ to keep it simple. `tr` is more flexible and more efficient.\n<|/ c |>\n<| c\
    \ |>\nI agree with you, but I wanted to keep it simple and avoid the use of regular\
    \ expressions.\n<|/ c |>\n<| c |>\nI agree with you, but I wanted to keep it simple\
    \ and avoid the use of regular expressions.\n<|/ c |>\n<| c |>\nI agree with you,\
    \ but I wanted to keep it simple and avoid the use of regular expressions.\n<|/\
    \ c |>\n<| a |>\n<code>", "  s.chars.reverse.join if s.chars.any? else s.chars.reverse\n\
    end", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\nend",
  "  s.downcase!\n  s.gsub(/[^a-z]/i) { |x| x.upcase }\n  s.gsub(/[^A-Z]/i) { |x|\
    \ x.downcase }\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.reverse!\n\
    \  s\nend", "  s.downcase!\n  s.gsub(/[a-z]/) { |x| x.upcase }\n  s.gsub(/[^a-z]/)\
    \ { |x| x.downcase }\n  s\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThanks for\
    \ your answer. Can you please explain how this works?\n<|/ c |>\n<| c |>\nThe\
    \ `gsub` method replaces every occurrence of a regex pattern with a block. The\
    \ block receives the match as a parameter. In the block we call `upcase` or `downcase`\
    \ on the match. `gsub` returns the modified string.\n<|/ c |>\n<| c |>\nThanks\
    \ for the explanation. Can you please explain how this works?\n<|/ c |>\n<| c\
    \ |>\nI added some explanation.\n<|/ c |>\n<| c |>\nThanks for your explanation.\
    \ Can you please explain how this works?\n<|/ c |>\n<| a tags=ruby |>\n<code>",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x|\
    \ x.downcase }\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |c| c.upcase\
    \ }\n  s.reverse!\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ work if you have a string like \"#a@C\"\n<|/ c |>\n<| c |>\n: It does. I tested\
    \ it before posting it. I added an example to the answer.\n<|/ c |>\n<| c |>\n\
    I tested it and it doesn't work. Try it with the string \"#a@C\"\n<|/ c |>\n<|\
    \ c |>\n: I tested it again and it works. I added an example to the answer.\n\
    <|/ c |>\n<| c |>\nI tested it again and it works. I added an example to the answer.\n\
    <|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n  s\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| c |>\nThanks for your answer! But I still don't\
    \ understand why my code doesn't work. Could you please explain to me why my code\
    \ doesn't work?\n<|/ c |>\n<| c |>\nYour code doesn't work because you didn't\
    \ understand how `gsub` works. I explained it in my answer.\n<|/ c |>\n<| c |>\n\
    Thanks for your answer! But I still don't understand why my code doesn't work.\
    \ Could you please explain to me why my code doesn't work?\n<|/ c |>\n<| c |>\n\
    I explained it in my answer. Your code doesn't work because you didn't understand\
    \ how `gsub` works. I explained it in my answer.\n<|/ c |>\n<| c |>\nThanks for\
    \ your answer! But I still don't understand why my code doesn't work. Could you\
    \ please explain to me why my code doesn't work?\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c).gsub(c.downcase, c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.downcase).gsub(c.upcase, c.downcase)\n    else\n      s = c\n    end\n  end\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis doesn't work if there\
    \ are multiple consecutive uppercase letters.\n<|/ c |>\n<| c |>\n, thanks for\
    \ pointing that out. I've updated my answer accordingly.\n<|/ c |>\n<| c |>\n\
    This doesn't work if there are multiple consecutive lowercase letters.\n<|/ c\
    \ |>\n<| c |>\n, thanks for pointing that out. I've updated my answer accordingly.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if there are multiple consecutive numbers.\
    \ For example, \"a1b2\" becomes \"a1b2\".\n<|/ c |>\n<| a tags=ruby,string |>\n\
    <code>", "  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase\
    \ }\n  s.gsub!(/[^A-Z]/i) { |x| x.upcase }\n  s.gsub!(/[A-Z]/i) { |x| x.downcase\
    \ }\n  s\nend", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n\
    \    end\n  end\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>",
  "  s.downcase!\n  s.gsub(/[^a-z]/i) { |c| c.upcase }\n  s.empty? ? s.reverse : s\n\
    end", "  s.chars.reverse.join if s.chars.any? else s.chars.reverse\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nThanks for your answer. Your solution works perfectly\
    \ for me. Thanks again!\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis does not provide an answer to the question. To critique or\
    \ request clarification from an author, leave a comment below their post. - [From\
    \ Review](/review/low-quality-posts/10770771)\n<|/ c |>\n<| c |>\nI believe this\
    \ does answer the question. He is asking how to reverse a string in Ruby, and\
    \ I provided a solution. He also asked for help with his code, and I provided\
    \ a solution. He also asked for help with his logic, and I provided a solution.\
    \ He also asked for help with his logic, and I provided a solution. He also asked\
    \ for help with his logic, and I provided a solution. He also asked for help with\
    \ his logic, and I provided a solution. He also asked for help with his logic,\
    \ and I provided a solution. He also asked for help with his logic, and I provided\
    \ a solution. He also asked for help with his logic, and I provided a solution.\
    \ He also asked for help with his logic, and I provided a solution. He also asked\
    \ for help with his logic, and I provided a solution. He also asked for help with\
    \ his logic, and I provided a solution. He also asked for help with his logic,\
    \ and I provided a solution. He also asked for help with his logic, and I provided\
    \ a solution. He also asked for help with his logic, and I provided a solution.\
    \ He also asked for help with his logic, and I provided a solution. He also asked\
    \ for help with his logic, and I provided a solution. He also asked for help with\
    \ his logic, and I provided a solution. He also asked for help with his logic,\
    \ and I provided a solution. He also asked for help with his logic, and I provided\
    \ a solution. He also asked for help with his logic, and I provided a solution.\
    \ He also asked for help with his logic, and I provided a solution. He also asked\
    \ for help with his logic, and I provided a solution. He also asked for help with\
    \ his logic, and I provided a solution. He also asked for help with his logic,\
    \ and I provided a solution", "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.reverse!\n\
    \  s.gsub!(/[a-z]/i, '')\n  s.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| a dscore=0 |>\n<code>", "  s.chars.reverse_each.with_index.reduce(:+).to_s\n\
    end\n</cell>\n<cell>\nsolve(\"1234\")\n</cell>\n<cell>\nsolve(\"ab\")\n</cell>\n\
    <cell>\nsolve(\"#a@C\")\n</cell>\n<cell>\nsolve(\"aBcD\")\n</cell>\n<cell>\nsolve(\"\
    aBcD\")\n</cell>\n<cell>\nsolve(\"aBcD\")\n</cell>\n<cell>\nsolve(\"aBcD\")\n\
    </cell>\n<cell>\nsolve(\"aBcD\")\n</cell>\n<cell>\nsolve(\"aBcD\")\n</cell>\n\
    <cell>\nsolve(\"aBcD\")\n</cell>\n<cell>\nsolve(\"aBcD\")\n</cell>\n<cell>\nsolve(\"\
    aBcD\")\n</cell>\n<cell>\nsolve(\"aBcD\")\n</cell>\n<cell>\nsolve(\"aBcD\")\n\
    </cell>\n<cell>\nsolve(\"aBcD\")\n</cell>\n<cell>\nsolve(\"aBcD\")\n</cell>\n\
    <cell>\nsolve(\"aBcD\")\n</cell>\n<cell>\nsolve(\"aBcD\")\n</cell>\n<cell>\nsolve(\"\
    aBcD\")\n</cell>\n<cell>\nsolve(\"aBcD\")\n</cell>\n<cell>\nsolve(\"aBcD\")\n\
    </cell>\n<cell>\nsolve(\"aBcD\")\n</cell>\n<cell>\nsolve(\"aBcD\")\n</cell>\n\
    <cell>\nsolve(\"aBcD\")\n</cell>\n<cell>\nsolve(\"aBcD\")\n</cell>\n<cell>\nsolve(\"\
    aBcD\")\n</cell>\n<cell>\nsolve(\"aBcD\")\n</cell>\n<cell>\nsolve(\"aBcD\")\n\
    </cell>\n<cell>\nsolve(\"aBcD\")\n</cell>\n<cell>\nsolve(\"aBcD\")\n</cell>\n\
    <cell>\nsolve(\"aBcD\")\n</cell>\n<", "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n\
    \  s.gsub!(/[a-z]/i) { |s| s.upcase }\n  s\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a dscore=0 |>\n<code>", "  s.downcase!\n  s.gsub(/[[:alpha:]]/) { |c| c.upcase\
    \ }\n  s.gsub(/[^[:alpha:]]/) { |c| c.downcase }\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nThe `downcase!` method modifies the receiver in place, so you don't\
    \ need to assign the result to a variable. Also, `gsub` can take a block, so you\
    \ can do `s.gsub(/[[:alpha:]]/) { |c| c.upcase }`.\n<|/ c |>\n<| c |>\nThanks\
    \ for the suggestions. I updated the answer.\n<|/ c |>\n<| a |>\n<code>", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[^A-Z]/i) { |s| s.downcase\
    \ }\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i)\
    \ { |s| s.downcase }\n  s\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like your\
    \ solution, but I wonder if there is a way to do it without using gsub!\n<|/ c\
    \ |>\n<| c |>\n, `gsub!` modifies the string in place. `gsub` returns a new string\
    \ with the modifications.\n<|/ c |>\n<| c |>\n, `gsub` modifies the string in\
    \ place. `gsub!` returns a new string with the modifications.\n<|/ c |>\n<| c\
    \ |>\n, `gsub` modifies the string in place. `gsub!` returns a new string with\
    \ the modifications.\n<|/ c |>\n<| c |>\n, `gsub` modifies the string in place.\
    \ `gsub!` returns a new string with the modifications.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c).gsub(c.downcase, c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c).gsub(c.upcase, c.downcase)\n    end\n  end\n  s.chars.reverse.join\nend",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s|\
    \ s.downcase }\n  s\nend", "  s.chars.each do |c|\n    if c.upcase == c\n    \
    \  s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.upcase)\n    end\n  end\n  s.chars.reverse!\n  s\nend", "  s.gsub!(/[a-z]/i)\
    \ { |x| x.upcase }\n  s.gsub!(/[A-Z]/i) { |x| x.downcase }\n  s.gsub!(/[^a-zA-Z]/)\
    \ { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/) { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/)\
    \ { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/) { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/)\
    \ { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/) { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/)\
    \ { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/) { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/)\
    \ { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/) { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/)\
    \ { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/) { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/)\
    \ { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/) { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/)\
    \ { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/) { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/)\
    \ { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/) { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/)\
    \ { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/) { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/)\
    \ { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/) { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/)\
    \ { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/) { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/)\
    \ { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/) { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/)\
    \ { |x| x.reverse }\n  s.gsub!(/[^a-zA-Z]/) { |x| x.reverse }\n", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work. `'#a@C'.downcase!` returns `'#A@C'`, but `'#A@C'.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }` returns `'#A@C'`.\n<|/ c |>\n<| c |>\nYou're right, I missed\
    \ that. I've updated my answer. Thanks.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[a-z]/i) { |s| s.upcase }\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,string,regex |>\n<| c |>\nThis doesn't work\
    \ if the string contains multiple letters.\n<|/ c |>\n<| c |>\nI believe this\
    \ does work, at least in Ruby 2.4.  I tested it against the test cases I provided\
    \ in the OP.\n<|/ c |>\n<| c |>\nYes, it works. I tested it against the test cases\
    \ I provided in the OP.\n<|/ c |>\n<| c |>\nI tested it against the test cases\
    \ I provided in the OP.\n<|/ c |>\n<| c |>\nI tested it against the test cases\
    \ I provided in the OP.\n<|/ c |>\n<| a tags=ruby,string,regex |>\n<code>", " \
    \ s.downcase!\n  s.gsub!(/[^a-z]/i) { |c| c.upcase }\n  s.reverse!\nend", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\n  s\nend", "  s.downcase!\n\
    \  s.gsub(/[^a-z]/i) { |c| c.upcase }\n  s.empty? ? s.reverse : s\nend", "  s\
    \ = s.to_s\n  s.gsub!(/[^a-zA-Z]/, \"\")\n  s.upcase! if s.include?(\"A\")\n \
    \ s.downcase! if s.include?(\"a\")\n  s\nend\n</code>\n<|/ a tags=ruby |>\n<|\
    \ c |>\n`s.gsub(/[^a-zA-Z]/, \"\").upcase` will do it\n<|/ c |>\n<| c |>\nThanks\
    \ so much for the help! I really appreciate it!\n<|/ c |>\n<| c |>\n`s.gsub(/[^a-zA-Z]/,\
    \ \"\").upcase` will do it\n<|/ c |>\n<| c |>\n`s.gsub(/[^a-zA-Z]/, \"\").upcase`\
    \ will do it\n<|/ c |>\n<| c |>\n`s.gsub(/[^a-zA-Z]/, \"\").upcase` will do it\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |c|\
    \ c.upcase }\n  s.reverse!\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ work if the string contains any non-letters.\n<|/ c |>\n<| c |>\nYes, it does.\
    \ `'#a@C'.downcase!` returns `'#a@C'` which then gets passed to `gsub!` which\
    \ returns `'#A@C'` which gets passed to `reverse!` which returns `'C@A'` which\
    \ gets passed to `downcase!` which returns `'C@A'` which gets passed to `gsub!`\
    \ which returns `'C@A'` which gets passed to `reverse!` which returns `'C@A'`\
    \ which gets passed to `downcase!` which returns `'C@A'` which gets passed to\
    \ `gsub!` which returns `'C@A'` which gets passed to `reverse!` which returns\
    \ `'C@A'` which gets passed to `downcase!` which returns `'C@A'` which gets passed\
    \ to `gsub!` which returns `'C@A'` which gets passed to `reverse!` which returns\
    \ `'C@A'` which gets passed to `downcase!` which returns `'C@A'` which gets passed\
    \ to `gsub!` which returns `'C@A'` which gets passed to `reverse!` which returns\
    \ `'C@A'` which gets passed to `downcase!` which returns `'C@A'` which gets passed\
    \ to `gsub!` which returns `'C@A'` which gets passed to `reverse!` which returns\
    \ `'C@A'` which gets passed to `downcase!` which returns `'C@A'` which gets passed\
    \ to `gsub!` which returns `'C@A'` which gets passed to `reverse!` which returns\
    \ `'C@A'` which gets passed to `downcase!` which returns `'C@A'` which gets passed\
    \ to `gsub!` which returns `'C@A'` which gets passed to `reverse!` which returns\
    \ `'C@A'` which gets passed to `downcase!` which returns `'C@A'` which gets passed\
    \ to `gsub!` which returns `'C@A'", "  s.gsub!(/[a-z]/i) do |letter|\n    letter.upcase\
    \ if letter.downcase == letter\n    letter\n  end\n  s.gsub!(/[^a-z]/i) do |letter|\n\
    \    letter.downcase if letter.upcase == letter\n    letter\n  end\n  s\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nI like your solution, it's very elegant,\
    \ but I think it would be better to use a regex to match only letters instead\
    \ of `s.gsub!` which replaces everything that is not a letter. `s.gsub(/[a-z]/i)\
    \ { |letter| letter.upcase if letter.downcase == letter letter }`\n<|/ c |>\n\
    <| c |>\nYes, that's a good point. I'll edit my answer to include your suggestion.\n\
    <|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }\n  s.reverse!\nend", "  s.chars.each do |c|\n    if c.upcase\
    \ == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)\n    elsif c.downcase\
    \ == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase, c.downcase)\n\
    \    end\n  end\n  s.chars.reverse.join\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ tags=ruby,string |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase\
    \ }\n  s.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't\
    \ work if the string contains multiple letters.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if the string contains multiple letters.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if the string contains multiple letters.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if the string contains multiple letters.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if the string contains multiple letters.\n<|/ c |>\n<| a dscore=5 |>\n\
    <code>", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n\
    \    else\n      s = c\n    end\n  end\n  s\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis doesn't work if there are multiple letters in a row. For example,\
    \ `solve(\"ab\")` returns `\"aB\"`, which is not the correct answer.\n<|/ c |>\n\
    <| c |>\nYeah, I noticed that and fixed it before you commented :) Thanks for\
    \ pointing it out\n<|/ c |>\n<| a |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |c| c.upcase }\n  s.gsub!(/[a-z]/i) { |c| c.downcase }\n  s\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks for your answer. Your solution works perfectly\
    \ for me. Thanks again.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  s.downcase!\n\
    \  s.gsub(/[^a-z]/i) { |s| s.upcase }\n  s.gsub(/[^A-Z]/i) { |s| s.downcase }\n\
    \  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i)\
    \ { |x| x.downcase }\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[a-z]/i)\
    \ { |s| s.upcase }\n  s.reverse!\nend\n</code>\n<|/ a tags=ruby,string |>\n<|\
    \ c |>\n`s.gsub!(/[^a-z]/i, '')` can be shortened to `s.delete!('a')`\n<|/ c |>\n\
    <| c |>\n`s.gsub!(/[^a-z]/i, '')` can be shortened to `s.delete!('a')`\n<|/ c\
    \ |>\n<| c |>\n`s.gsub!(/[^a-z]/i, '')` can be shortened to `s.delete!('a')`\n\
    <|/ c |>\n<| c |>\n`s.gsub!(/[^a-z]/i, '')` can be shortened to `s.delete!('a')`\n\
    <|/ c |>\n<| c |>\n`s.gsub!(/[^a-z]/i, '')` can be shortened to `s.delete!('a')`\n\
    <|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.chars.each do |c|\n    next\
    \ if c.nil?\n    next if c.empty?\n    next if c.upcase == c\n    next if c.downcase\
    \ == c\n    next if c.upcase == c.downcase\n    next if c.downcase == c.upcase\n\
    \    next if c.upcase == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.chars.reverse.join if s.chars.any? \n  s.chars.join\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>", "  s.downcase!\n  s.gsub(/[^a-z]/i) { |x| x.upcase\
    \ }\n  s.gsub(/[^A-Z]/i) { |x| x.downcase }\nend", "  s.chars.reverse_each.with_index.reduce(:+).to_s\n\
    end", "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[a-z]/i) { |s| s.upcase\
    \ }\n  s\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if the string\
    \ contains numbers. Try `solve(\"12a34\")`\n<|/ c |>\n<| c |>\nIt does work. `a34`\
    \ is converted to `A34` before being passed to `solve`.\n<|/ c |>\n<| c |>\nIt\
    \ doesn't work if there are numbers in the string. Try `solve(\"12a34\")`\n<|/\
    \ c |>\n<| c |>\nIt does work. `a34` is converted to `A34` before being passed\
    \ to `solve`.\n<|/ c |>\n<| c |>\nIt doesn't work if there are numbers in the\
    \ string. Try `solve(\"12a34\")`\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  s =\
    \ s.to_s\n  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\n\
    \  s\nend", "  s = s.downcase\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i)\
    \ { |x| x.downcase }\n  s\nend", "  s.gsub!(/[^a-zA-Z]/){|c| c.upcase }\n  s.gsub!(/[^a-zA-Z]/){|c|\
    \ c.downcase }\n  s.gsub!(/[^a-zA-Z]/){|c| c.reverse }\n  s\nend", "  s.chars.each_with_index\
    \ do |c,i|\n    if c.upcase == c\n      s = s.gsub(/#{c}/, c.downcase)\n    elsif\
    \ c.downcase == c\n      s = s.gsub(/#{c}/, c.upcase)\n    end\n  end\n  s.chars.reverse.join\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string |>\n<code>", " \
    \ s.gsub!(/[[:alpha:]]/) { |s| s.upcase }\n  s.gsub!(/[[:alpha:]]/) { |s| s.downcase\
    \ }\n  s.gsub!(/[^[:alpha:]]/) { |s| s.reverse }\n  s\nend", "  s.chars.each do\
    \ |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.start_with?(\"\
    #\")\n    next if c.start_with?(\"$\")\n    next if c.start_with?(\"%\")\n   \
    \ next if c.start_with?(\"&\")\n    next if c.start_with?(\"*\")\n    next if\
    \ c.start_with?(\"(\")\n    next if c.start_with?(\")\")\n    next if c.start_with?(\"\
    +\")\n    next if c.start_with?(\"-\")\n    next if c.start_with?(\"=\")\n   \
    \ next if c.start_with?(\"~\")\n    next if c.start_with?(\"|\")\n    next if\
    \ c.start_with?(\"{\")\n    next if c.start_with?(\"}\")\n    next if c.start_with?(\"\
    [\")\n    next if c.start_with?(\"]\")\n    next if c.start_with?(\";\")\n   \
    \ next if c.start_with?(\",\")\n    next if c.start_with?(\".\")\n    next if\
    \ c.start_with?(\"?\")\n    next if c.start_with?(\"!\")\n    next if c.start_with?(\"\
    $\")\n    next if c.start_with?(\"%\")\n    next if c.start_with?(\"&\")\n   \
    \ next if c.start_with?(\"*\")\n    next if c.start_with?(\"(\")\n    next if\
    \ c.start_with?(\")\")\n    next if c.start_with?(\"+\")\n    next if c.start_with?(\"\
    -\")\n    next if c.start_with?(\"=\")\n    next if c.start_with?(\"~\")\n   \
    \ next if c.start_with?(\"|\")\n    next if c.start_with?(\"{\")\n    next if\
    \ c.start_with?(\"}\")\n    next if c.start_with?(\"[\")\n    next if c.start_with?(\"\
    ]\")\n    next if c.start_with?(\";\")\n    next if c.start_with?(\",\")\n   \
    \ next if c.start_with?(\".\")\n    next if c.start_with?(\"?\")\n    next if\
    \ c.start_with?(\"!\")\n    next if c.start_with?(\"$\")\n    next if c.start_with?(\"\
    %\")\n    next if c.start_with?(\"&\")\n    next if c.start_with?(\"*\")\n   \
    \ next if c.start_with?(\"(\")\n    next if c.start_with?(\"", "  s.chars.each\
    \ do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase == c\n\
    \    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next if\
    \ c.upcase == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase\n    next if c.upcase == c.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.chars.each do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase\
    \ == c\n    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next\
    \ if c.upcase == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase\n    next if c.upcase == c.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase,\
    \ c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase,\
    \ c.downcase)\n    else\n      s = c\n    end\n  end\n  s\nend", "  s = s.to_s\n\
    \  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\n  s\nend\n\
    </code>\n<|/ a tags=ruby,string,regex |>\n<| c |>\nThis doesn't work if there\
    \ are multiple consecutive lowercase letters.\n<|/ c |>\n<| c |>\n: I didn't notice\
    \ that requirement. Updated the answer.\n<|/ c |>\n<| c |>\nI like your solution,\
    \ although I prefer `s.gsub(/[^a-z]/i) { |x| x.upcase }.reverse`\n<|/ c |>\n<|\
    \ c |>\n: Yes, I like that too. Updated the answer.\n<|/ c |>\n<| c |>\nI like\
    \ your solution too, but I prefer `s.gsub(/[^a-z]/i) { |x| x.upcase }.reverse`\n\
    <|/ c |>\n<| a tags=ruby,string,regex |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }\n  s.reverse!\nend\n</code>\n<|/ a tags=ruby,string,regex |>\n\
    <| c |>\n`s.downcase!` will modify the string in place, so you don't need to assign\
    \ it to a variable. Also, `s.gsub!(/[^a-z]/i) { |s| s.upcase }` can be written\
    \ as `s.gsub(/[^a-z]/i) { |s| s.upcase }`.\n<|/ c |>\n<| c |>\nThanks for the\
    \ comments. I updated the answer accordingly.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\nend", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |c| c.upcase }\n  s.reverse!\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\n<code>", "  s.downcase!\n  s.gsub(/[^a-z]/i) { |c| c.upcase\
    \ }\n  s.gsub(/[^A-Z]/i) { |c| c.downcase }\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n  s\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\n`gsub!` modifies the string in place, so you don't\
    \ need to return it\n<|/ c |>\n<| c |>\nI didn't know that. Thanks for pointing\
    \ that out.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  s.chars.each do |c|\n  \
    \  next if c.nil?\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n\
    \  end\n  s.chars.reverse.join\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ does not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/11898594)\n\
    <|/ c |>\n<| c |>\nThe question was \"How to reverse the case of a string?\" The\
    \ answer was \"Use gsub!\" The code was \"Use gsub\". I don't see how this doesn't\
    \ answer the question.\n<|/ c |>\n<| c |>\nThe question was \"How to reverse the\
    \ case of a string?\" The answer was \"Use gsub!\" The code was \"Use gsub\".\
    \ I don't see how this doesn't answer the question.\n<|/ c |>\n<| c |>\nThe question\
    \ was \"How to reverse the case of a string?\" The answer was \"Use gsub!\" The\
    \ code was \"Use gsub\". I don't see how this doesn't answer the question.\n<|/\
    \ c |>\n<| c |>\nThe question was \"How to reverse the case of a string?\" The\
    \ answer was \"Use gsub!\" The code was \"Use gsub\". I don't see how this doesn't\
    \ answer the question.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  s.chars.each do\
    \ |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase,\
    \ c.downcase)\n    end\n  end\n  s.chars.reverse.join\nend", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[^A-Z]/i) { |s| s.downcase\
    \ }\n  s\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,string |>\n<code>",
  "  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n\
    \  s.gsub!(/[^A-Z]/i) { |x| x.upcase }\n  s.gsub!(/[A-Z]/i) { |x| x.downcase }\n\
    \  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i)\
    \ { |x| x.downcase }\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase\
    \ }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n  s\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis doesn't work if the string contains any non-letters.\n<|/ c |>\n<|\
    \ c |>\n: Yes, it does. `gsub` replaces *all* occurrences of `/[^a-z]/i` with\
    \ `x.upcase`. `gsub!` replaces *one* occurrence of `/[a-z]/i` with `x.downcase`.\n\
    <|/ c |>\n<| c |>\n: I added a solution that doesn't require `gsub!`.\n<|/ c |>\n\
    <| c |>\n: I added a solution that doesn't require `gsub!`.\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s.downcase!\n  s.gsub(/[^a-z]/i) { |x| x.upcase }\n  s.gsub(/[^A-Z]/i)\
    \ { |x| x.downcase }\n  s\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for the answer!\
    \ I appreciate it!\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  s.chars.each do |c|\n\
    \    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase,\
    \ c.downcase)\n    end\n  end\n  s.chars.join\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThanks for your answer. Your code works, but I cannot understand why\
    \ it works. Can you please explain it to me?\n<|/ c |>\n<| c |>\nI added some\
    \ explanation to the answer.\n<|/ c |>\n<| c |>\nThanks for your explanation.\
    \ Your code works, but I cannot understand why it works. Can you please explain\
    \ it to me?\n<|/ c |>\n<| c |>\nI added some explanation to the answer.\n<|/ c\
    \ |>\n<| a dscore=0 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase\
    \ }\n  s.gsub!(/[^A-Z]/i) { |x| x.downcase }\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |c| c.upcase }\n  s.reverse!\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n  s\nend", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\n  s\nend\n</code>\n<|/ a\
    \ tags=ruby,string |>\n<| a dscore=0 |>\n<code>", "  s.chars.each do |c|\n   \
    \ if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase\
    \ == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s\nend", " \
    \ s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThe downcase and reverse are unnecessary and inefficient since\
    \ String#reverse reverses the string in place.\n<|/ c |>\n<| c |>\nYes, I know,\
    \ but I wanted to show how it can be done in one line :)\n<|/ c |>\n<| c |>\n\
    I didn't know about `String#reverse!`. Thanks for sharing!\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s.downcase!\n  s.gsub(/[^a-z]/i) { |x| x.upcase }\n  s.gsub(/[^A-Z]/i)\
    \ { |x| x.downcase }\n  s\nend", "  s = s.to_s\n  s.gsub!(/[^a-z]/i) { |s| s.upcase\
    \ }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |x| x.upcase }\n  s.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n\
    <| c |>\nI like this solution, but I wonder if there is a way to do it without\
    \ using gsub! and downcase!\n<|/ c |>\n<| c |>\nI added a solution without gsub!\
    \ and downcase!\n<|/ c |>\n<| c |>\nI like your solution but I think it would\
    \ be better to use a regex to match only letters instead of `[^a-z]`\n<|/ c |>\n\
    <| c |>\nI agree with you. My solution was just to show how it could be done without\
    \ gsub! and downcase!\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  s.chars.each do\
    \ |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase,\
    \ c.downcase)\n    end\n  end\n  s.chars.reverse.join\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis doesn't work if there are multiple letters in the string.\
    \ For example, `solve(\"ab\")` returns `\"Aa\"`.\n<|/ c |>\n<| c |>\nYes, I noticed\
    \ that and fixed it. I also added a second solution that doesn't require the use\
    \ of `gsub`.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }\n  s.reverse!\nend\n</code>\n<|/ a |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i)\
    \ { |x| x.downcase }\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\n\
    <code>", "  s = s.to_s\n  s.gsub!(/[[:alpha:]]/) { |s| s.upcase }\n  s.gsub!(/[[:alpha:]]/)\
    \ { |s| s.downcase }\n  s.gsub!(/[^[:alpha:]]/) { |s| s.reverse }\n  s\nend",
  "  s = s.to_s\n  s.gsub!(/[^a-zA-Z]/, '')\n  s.gsub!(/[a-z]/) { |s| s.upcase }\n\
    \  s.gsub!(/[A-Z]/) { |s| s.downcase }\n  s\nend", "  s.gsub!(/[a-z]/i) do |x|\n\
    \    x.upcase if x.downcase == x\n  end\n  s.gsub!(/[^a-z]/i) do |x|\n    x.downcase\
    \ if x.upcase == x\n  end\n  s\nend", "  s.chars.each do |c|\n    if c.upcase\
    \ == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n  \
    \    s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse!\n  s\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "  s.downcase!\n \
    \ s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[^A-Z]/i) { |s| s.downcase }\n\
    \  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\n\
    end", "  s.chars.each_with_index do |char, i|\n    if char.upcase == char\n  \
    \    s[i] = char.downcase\n    else\n      s[i] = char.upcase\n    end\n  end\n\
    \  s.chars.join\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", " \
    \ s.downcase!\n  s.gsub!(/[^a-z]/i) { |c| c.upcase }\n  s.gsub!(/[^A-Z]/i) { |c|\
    \ c.downcase }\n  s.reverse!\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a dscore=0\
    \ |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\n\
    end", "  s.chars.each_with_index do |char, index|\n    if char.upcase == char\n\
    \      s.slice!(0, index) + s.slice!(0, index).upcase + s.slice!(index + 1)\n\
    \    elsif char.downcase == char\n      s.slice!(0, index) + s.slice!(0, index).downcase\
    \ + s.slice!(index + 1)\n    end\n  end\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }\n  s.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby |>\n<| a\
    \ tags=ruby |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n\
    \  s.reverse!\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a dscore=0 |>\n<code>",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| c |>\n`s.gsub(/[^a-z]/i) { |s| s.upcase }.reverse!`\
    \ would be more efficient.\n<|/ c |>\n<| c |>\nI agree, but I wanted to keep it\
    \ simple and readable for OP.\n<|/ c |>\n<| c |>\nI agree, but I wanted to keep\
    \ it simple and readable for OP.\n<|/ c |>\n<| c |>\nI agree, but I wanted to\
    \ keep it simple and readable for OP.\n<|/ c |>\n<| c |>\nI agree, but I wanted\
    \ to keep it simple and readable for OP.\n<|/ c |>\n<| a tags=ruby,string |>\n\
    <code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[a-z]/i) { |s| s.upcase\
    \ }\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a dscore=1 |>\n<code>",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| a dscore=0 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |x| x.upcase }\n  s.reverse!\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i) {\
    \ |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n  s\nend", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n\
    \  s\nend", "  s.gsub!(/[^A-Za-z]/){|c| c.upcase }\n  s.gsub!(/[A-Z]/){|c| c.downcase\
    \ }\n  s.gsub!(/[^A-Za-z]/){|c| c.upcase }\n  s.gsub!(/[A-Z]/){|c| c.downcase\
    \ }\n  s.gsub!(/[^A-Za-z]/){|c| c.upcase }\n  s.gsub!(/[A-Z]/){|c| c.downcase\
    \ }\n  s.gsub!(/[^A-Za-z]/){|c| c.upcase }\n  s.gsub!(/[A-Z]/){|c| c.downcase\
    \ }\n  s.gsub!(/[^A-Za-z]/){|c| c.upcase }\n  s.gsub!(/[A-Z]/){|c| c.downcase\
    \ }\n  s.gsub!(/[^A-Za-z]/){|c| c.upcase }\n  s.gsub!(/[A-Z]/){|c| c.downcase\
    \ }\n  s.gsub!(/[^A-Za-z]/){|c| c.upcase }\n  s.gsub!(/[A-Z]/){|c| c.downcase\
    \ }\n  s.gsub!(/[^A-Za-z]/){|c| c.upcase }\n  s.gsub!(/[A-Z]/){|c| c.downcase\
    \ }\n  s.gsub!(/[^A-Za-z]/){|c| c.upcase }\n  s.gsub!(/[A-Z]/){|c| c.downcase\
    \ }\n  s.gsub!(/[^A-Za-z]/){|c| c.upcase }\n  s.gsub!(/[A-Z]/){|c| c.downcase\
    \ }\n  s.gsub!(/[^A-Za-z]/){|c| c.upcase }\n  s.gsub!(/[A-Z]/){|c| c.downcase\
    \ }\n  s.gsub!(/[^A-Za-z]/){|c| c.upcase }\n  s.gsub!(/[A-Z]/){|c| c.downcase\
    \ }\n  s.gsub!(/[^A-Za-z]/){|c| c.upcase }\n  s.gsub!(/[A-Z]/){|c| c.downcase\
    \ }\n  s.gsub!(/[^A-Za-z]/){|c| c.upcase }\n  s.gsub!(/[A-Z]/){|c| c.downcase\
    \ }\n  s.gsub!(/[^A-Z", "  s.downcase!\n  s.gsub(/[^a-z]/i) { |x| x.upcase }\n\
    \  s.gsub(/[^A-Z]/i) { |x| x.downcase }\n  s.gsub(/[^A-Z]/i) { |x| x.downcase\
    \ }\n  s.gsub(/[^a-z]/i) { |x| x.upcase }\nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a dscore=2 |>\n<code>", "  s.chars.each do |c|\n    next if c.nil?\n    next\
    \ if c.empty?\n    next if c.upcase == c\n    next if c.downcase == c\n    next\
    \ if c.upcase == c.downcase\n    next if c.upcase == c.downcase.upcase\n    next\
    \ if c.downcase == c.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase.upcase.downcase.downcase\
    \ == c\n    next if c.downcase.upcase.downcase.downcase == c\n    next if c.upcase.upcase.downcase.downcase.downcase\
    \ == c\n    next if c.downcase.upcase.downcase.downcase.downcase == c\n    next\
    \ if c.upcase.upcase.downcase.downcase.downcase.downcase == c\n    next if c.downcase.upcase.downcase.downcase.downcase.downcase\
    \ == c\n    next if c.upcase.upcase.downcase.downcase.downcase.downcase.downcase\
    \ == c\n    next if c.downcase.upcase.downcase.downcase.downcase.downcase.downcase\
    \ == c\n    next if c.upcase.upcase.downcase.downcase.downcase.downcase.downcase.downcase\
    \ == c\n    next if c.downcase.upcase.downcase.downcase.downcase.downcase.downcase.downcase\
    \ == c\n    next if c.upcase.upcase.downcase.downcase.downcase.downcase.downcase.downcase.downcase\
    \ == c\n    next if c.downcase.upcase.downcase.downcase.downcase.downcase.downcase.downcase.downcase\
    \ == c\n    next if c.upcase.upcase.downcase.downcase.downcase.downcase.downcase.downcase.downcase.downcase\
    \ == c\n    next if c.downcase.upcase.downcase.downcase.downcase.downcase.downcase.downcase.downcase.downcase\
    \ == c\n    next if c.upcase.upcase.downcase.downcase.downcase.downcase.downcase.downcase.downcase.downcase\
    \ == c\n    next if c.downcase.upcase.downcase.downcase.downcase.downcase.downcase.downcase.downcase.downcase\
    \ == c\n    next if c.upcase.upcase.downcase.downcase.downcase.downcase.downcase.downcase.downcase.downcase.downcase\
    \ == c\n    next if c.downcase.upcase.downcase.", "  s.downcase!\n  s.gsub!(/[^a-z]/i,\
    \ '')\n  s.reverse!\n  s.gsub!(/[a-z]/i, '')\n  s.reverse!\n  s\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |x| x.upcase }\n  s.reverse!\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This doesn't work. Try `solve.call(\"ab\")`.\n<|/ c |>\n<| c |>\nI see what you\
    \ mean. Thanks for pointing that out. I've updated the answer.\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work. Try `solve.call(\"ab\")`.\n<|/ c |>\n<| c |>\nI see what\
    \ you mean. Thanks for pointing that out. I've updated the answer.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[a-z]/i)\
    \ { |s| s.upcase }\n  s.reverse!\nend\n</code>\n<|/ a tags=ruby,string |>\n<|\
    \ c |>\nThis doesn't work for \"#a@C\" which should return \"#A@c\"\n<|/ c |>\n\
    <| c |>\n: I fixed the answer, thank you for pointing it out. :)\n<|/ c |>\n<|\
    \ c |>\nI like your solution, it's very elegant. My only concern is that `gsub!`\
    \ modifies the string in place, so it would be better to do `s.gsub(/[^a-z]/i,\
    \ '').gsub(/[a-z]/i) { |s| s.upcase }.reverse!`\n<|/ c |>\n<| c |>\n: You are\
    \ right, I didn't know about `gsub!` modifying the string in place. Thanks for\
    \ pointing it out. :)\n<|/ c |>\n<| c |>\n: I added your suggestion. Thanks.\n\
    <|/ c |>\n<| a dscore=3 |>\n<code>", "  s.chars.reverse_each.with_index do |c,i|\n\
    \    if c.is_a?(String) && c[0] =~ /[a-z]/i\n      c.upcase! if c[0] =~ /[A-Z]/i\n\
    \      c.downcase! if c[0] =~ /[a-z]/i\n    end\n  end\n  s.chars.reverse.join\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for the answer! I really appreciate\
    \ it!\n<|/ c |>\n<| c |>\nI added a more efficient solution that doesn't require\
    \ the creation of an intermediate array.\n<|/ c |>\n<| c |>\nI added a more efficient\
    \ solution that doesn't require the creation of an intermediate array.\n<|/ c\
    \ |>\n<| a dscore=1 |>\n<code>", "  s.chars.each do |c|\n    if c.upcase == c\n\
    \      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n      s =\
    \ s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse.join\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't work if the string contains\
    \ multiple letters such as \"ab#c\"\n<|/ c |>\n<| c |>\nIt does. I tested it before\
    \ posting.\n<|/ c |>\n<| c |>\nIt doesn't work if there are multiple letters in\
    \ the string. Try it out with 'ab#c'.\n<|/ c |>\n<| c |>\nIt doesn't work if there\
    \ are multiple letters in the string. Try it out with 'ab#c'.\n<|/ c |>\n<| c\
    \ |>\nIt doesn't work if there are multiple letters in the string. Try it out\
    \ with 'ab#c'.\n<|/ c |>\n<| a |>\n<code>", "  s.chars.each do |c|\n    if c.upcase\
    \ == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n  \
    \    s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse.join\n\
    end", "  s.chars.each do |c|\n    next if c.nil?\n    next if c.empty?\n    next\
    \ if c.upcase == c\n    next if c.downcase == c\n    next if c.upcase == c.downcase\n\
    \    next if c.upcase == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase\n    next if c.upcase == c.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| c |>\nThis doesn't work. `'a'.upcase!` returns `nil`,\
    \ so `s.gsub!(/[^a-z]/i) { |s| s.upcase }` returns `nil`. `s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }` returns `nil`, so `s.gsub!(/[^a-z]/i) { |s| s.upcase }` returns\
    \ `nil`. `s.gsub!(/[^a-z]/i) { |s| s.upcase }` returns `nil`, so `s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }` returns `nil`. `s.gsub!(/[^a-z]/i) { |s| s.upcase }` returns\
    \ `nil`, so `s.gsub!(/[^a-z]/i) { |s| s.upcase }` returns `nil`. `s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }` returns `nil`, so `s.gsub!(/[^a-z]/i) { |s| s.upcase }` returns\
    \ `nil`. `s.gsub!(/[^a-z]/i) { |s| s.upcase }` returns `nil`, so `s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }` returns `nil`. `s.gsub!(/[^a-z]/i) { |s| s.upcase }` returns\
    \ `nil`, so `s.gsub!(/[^a-z]/i) { |s| s.upcase }` returns `nil`. `s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }` returns `nil`, so `s.gsub!(/[^a-z]/i) { |s| s.upcase }` returns\
    \ `nil`. `s.gsub!(/[^a-z]/i) { |s| s.upcase }` returns `nil`, so `s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }` returns `nil`. `s.gsub!(/[^a-z]/i) { |s| s.upcase }` returns\
    \ `nil`, so `s.gsub!(/[^a-z]/i) { |s| s.upcase }` returns `nil`. `s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }` returns `", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase\
    \ }\n  s.reverse!\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer!\
    \ I appreciate it!\n<|/ c |>\n<| a tags=ruby,string,regex |>\n<code>", "  s.chars.each\
    \ do |c|\n    next if c.nil?\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n\
    \    end\n  end\n  s.chars.reverse.join\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n  s\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  s.chars.reverse_each.with_index.reduce(:+).to_s\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,string |>\n<code>", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |c| c.upcase }\n  s.reverse!\nend", "  s.chars.each do\
    \ |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase == c\n \
    \   next if c.downcase == c\n    next if c.upcase == c.downcase\n    next if c.downcase\
    \ == c.upcase\n    next if c.upcase == c.downcase.upcase\n    next if c.downcase\
    \ == c.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase\n \
    \   next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase,\
    \ c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase).gsub(c.downcase,\
    \ c)\n    else\n      s = c\n    end\n  end\n  s\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a |>\n<code>", "  s.chars.each do |c|\n    next if c.nil?\n    if c.upcase\
    \ == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)\n    elsif c.downcase\
    \ == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase, c.upcase)\n  \
    \  end\n  end\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis doesn't\
    \ work. Try `solve.call(\"ab\")`.\n<|/ c |>\n<| c |>\nIt works fine for me. `solve.call(\"\
    ab\")` returns `\"AB\"`.\n<|/ c |>\n<| c |>\nIt doesn't work for me. Try `solve.call(\"\
    ab\")`.\n<|/ c |>\n<| c |>\nIt works for me too. Try `solve.call(\"ab\")`.\n<|/\
    \ c |>\n<| c |>\nIt works for me too. Try `solve.call(\"ab\")`.\n<|/ c |>\n<|\
    \ a dscore=2 |>\n<code>", "  s.chars.each do |c|\n    if c.upcase == c\n     \
    \ s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.upcase)\n    end\n  end\n  s.chars.join\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=2 |>\n<code>", "  s.chars.each do |c|\n    if c.upcase == c\n    \
    \  s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.upcase)\n    end\n  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis doesn't work if the string contains any non-letters.\n<|/\
    \ c |>\n<| c |>\nI added a solution that doesn't require any additional gems.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s|\
    \ s.upcase }\n  s.reverse!\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>",
  "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase,\
    \ c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase,\
    \ c.downcase)\n    end\n  end\n  s.chars.reverse.join\nend", "  s = s.to_s\n \
    \ s.gsub!(/[[:alpha:]]/) { |s| s.upcase }\n  s.gsub!(/[[:alpha:]]/) { |s| s.downcase\
    \ }\n  s.gsub!(/[^[:alpha:]]/) { |s| s.reverse }\n  s.gsub!(/[^[:alpha:]]/) {\
    \ |s| s.reverse }\n  s\nend", "  s.chars.reverse!\n  s.chars.join\nend", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| a dscore=0 |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
