name: HumanEval_161_solve
language: rb
prompt: "# You are given a string s.\n# if s[i] is a letter, reverse its case from\
  \ lower to upper or vise versa, \n# otherwise keep it as it is.\n# If the string\
  \ contains no letters, reverse the string.\n# The function should return the resulted\
  \ string.\n# Examples\n# >>> solve.call(\"1234\")\n# \"4321\"\n# >>> solve.call(\"\
  ab\")\n# \"AB\"\n# >>> solve.call(\"#a@C\")\n# \"#A@c\"\ndef solve(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n\
  \    candidate = method(:solve)\n    assert_equal(\"aSdF\", candidate.call(\"AsDf\"\
  ))\n    assert_equal(\"4321\", candidate.call(\"1234\"))\n    assert_equal(\"AB\"\
  , candidate.call(\"ab\"))\n    assert_equal(\"#A@c\", candidate.call(\"#a@C\"))\n\
  \    assert_equal(\"#aSDFw^45\", candidate.call(\"#AsdfW^45\"))\n    assert_equal(\"\
  2@6#\", candidate.call(\"#6@2\"))\n    assert_equal(\"#$A^d\", candidate.call(\"\
  #$a^D\"))\n    assert_equal(\"#CCC\", candidate.call(\"#ccc\"))\n  end\nend\n"
completions: ["  s.gsub!(/[^A-Za-z]/,'')\n  s.gsub!(/[A-Z]/){|s| s.upcase}\n  s.gsub!(/[a-z]/){|s|\
    \ s.downcase}\n  s\nend", "  s.chars.each do |c|\n    if c.upcase == c\n     \
    \ s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.upcase)\n    end\n  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase\
    \ }\n  s.gsub!(/[^A-Z]/i) { |s| s.downcase }\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n  s\nend", "  s.chars.each\
    \ do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase == c\n\
    \    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next if\
    \ c.upcase == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |c| c.upcase }\n  s.gsub!(/[a-z]/i) { |c|\
    \ c.downcase }\n  s\nend", "  s.chars.each do |c|\n    if c.upcase == c\n    \
    \  s = s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)\n    elsif c.downcase ==\
    \ c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase, c.downcase)\n   \
    \ end\n  end\n  s.chars.join\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like\
    \ your solution, but I believe it can be done more efficiently with one `gsub`\
    \ call. Also, `gsub` can take a block, which would allow you to make a single\
    \ `gsub` call that would replace all instances of one character with another character\
    \ in a single call.\n<|/ c |>\n<| c |>\nYes, I agree with you. My solution was\
    \ more for educational purposes than for production use. Thanks for your comment.\n\
    <|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.chars.each do |c|\n    next\
    \ if c.nil?\n    next if c.empty?\n    next if c.start_with?(\"#\")\n    next\
    \ if c.start_with?(\"$\")\n    next if c.start_with?(\"%\")\n    next if c.start_with?(\"\
    &\")\n    next if c.start_with?(\"*\")\n    next if c.start_with?(\"(\")\n   \
    \ next if c.start_with?(\")\")\n    next if c.start_with?(\"+\")\n    next if\
    \ c.start_with?(\"-\")\n    next if c.start_with?(\"=\")\n    next if c.start_with?(\"\
    ?\")\n    next if c.start_with?(\":\")\n    next if c.start_with?(\";\")\n   \
    \ next if c.start_with?(\",\")\n    next if c.start_with?(\".\")\n    next if\
    \ c.start_with?(\"!\")\n    next if c.start_with?(\"~\")\n    next if c.start_with?(\"\
    `\")\n    next if c.start_with?(\"'\")\n    next if c.start_with?(\"[\")\n   \
    \ next if c.start_with?(\"]\")\n    next if c.start_with?(\"{\")\n    next if\
    \ c.start_with?(\"}\")\n    next if c.start_with?(\"|\")\n    next if c.start_with?(\"\
    ;\")\n    next if c.start_with?(\",\")\n    next if c.start_with?(\".\")\n   \
    \ next if c.start_with?(\"!\")\n    next if c.start_with?(\"~\")\n    next if\
    \ c.start_with?(\"`\")\n    next if c.start_with?(\"'\")\n    next if c.start_with?(\"\
    [\")\n    next if c.start_with?(\"]\")\n    next if c.start_with?(\"{\")\n   \
    \ next if c.start_with?(\"}\")\n    next if c.start_with?(\"|\")\n    next if\
    \ c.start_with?(\";\")\n    next if c.start_with?(\",\")\n    next if c.start_with?(\"\
    .\")\n    next if c.start_with?(\"!\")\n    next if c.start_with?(\"~\")\n   \
    \ next if c.start_with?(\"`\")\n    next if c.start_with?(\"'\")\n    next if\
    \ c.start_with?(\"[\")\n    next if c.start_with?(\"]\")\n    next if c.start_with?(\"\
    {\")\n    next if c.start_with?(\"}\")", "  s.downcase!\n  s.gsub!(/[^a-z]/i,\
    \ '')\n  s.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,string,regex |>\n<| c |>\nI like this solution,\
    \ but I wonder why `gsub!` doesn't return the modified string?\n<|/ c |>\n<| c\
    \ |>\n`gsub!` modifies the string in place. `gsub` returns a new string with the\
    \ modifications.\n<|/ c |>\n<| c |>\nI see, thanks. I guess I should read more\
    \ about `gsub` then.\n<|/ c |>\n<| c |>\n`gsub!` modifies the string in place.\
    \ `gsub` returns a new string with the modifications.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "  s.chars.each do\
    \ |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase == c\n \
    \   next if c.downcase == c\n    next if c.upcase == c.downcase\n    next if c.downcase\
    \ == c.upcase\n    next if c.upcase == c.downcase.upcase\n    next if c.downcase\
    \ == c.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase\n \
    \   next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\nend\n</code>\n\
    <|/ a |>\n<| c |>\nI like your solution, but I believe it would be better to use\
    \ the `gsub!` method instead of `gsub` since it modifies the string in place.\
    \ Also, `gsub!` will return the modified string so you can chain it like `s.gsub!(/[^a-z]/i)\
    \ { |x| x.upcase }.reverse!`\n<|/ c |>\n<| c |>\nThanks for the suggestions. I\
    \ updated the answer accordingly.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  s.downcase!\n\
    \  s.gsub(/[^a-z]/i) { |x| x.upcase }\n  s.gsub(/[^A-Z]/i) { |x| x.downcase }\n\
    \  s\nend", "  s.chars.each do |c|\n    next if c.nil?\n    next if c.empty?\n\
    \    next if c.upcase == c\n    next if c.downcase == c\n    next if c.upcase\
    \ == c.downcase\n    next if c.upcase == c.downcase.upcase\n    next if c.downcase\
    \ == c.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase\n \
    \   next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.reverse!\n  s.gsub!(/[a-z]/i, '')\n\
    \  s\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  s.chars.each\
    \ do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif\
    \ c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.join\n\
    end", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n\
    \    end\n  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby |>\n<|\
    \ c |>\nThis doesn't work for `solve.call(\"ab\")` which should return `\"AB\"\
    `.\n<|/ c |>\n<| c |>\nI believe that `s.chars.each do |c|` should be `s.each_char\
    \ do |c|`\n<|/ c |>\n<| c |>\nI believe that `s.chars.each do |c|` should be `s.each_char\
    \ do |c|`\n<|/ c |>\n<| c |>\nI believe that `s.chars.each do |c|` should be `s.each_char\
    \ do |c|`\n<|/ c |>\n<| c |>\nI believe that `s.chars.each do |c|` should be `s.each_char\
    \ do |c|`\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }\n  s.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n\
    <| c |>\nI like the `gsub` solution, it's more elegant than my solution. Thanks!\n\
    <|/ c |>\n<| c |>\nI like your solution as well, it's more elegant than my solution.\
    \ Thanks!\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s = s.to_s\n  s.chars.each\
    \ do |c|\n    case = c.upcase if c.is_a? String\n    case = c.downcase if c.is_a?\
    \ String\n    case = c.to_s if c.is_a? String\n    case = c.to_s if c.is_a? Fixnum\n\
    \  end\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work if you\
    \ have a string like \"#a@C\"\n<|/ c |>\n<| c |>\nI added a solution that works\
    \ with strings with hashes and numbers\n<|/ c |>\n<| c |>\nI added a solution\
    \ that works with strings with hashes and numbers\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
