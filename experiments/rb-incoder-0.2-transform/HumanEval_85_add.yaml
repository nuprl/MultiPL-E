name: HumanEval_85_add
language: rb
prompt: "# Given a non-empty list of integers lst. add the even elements that are\
  \ at odd indices..\n# Examples:\n# >>> add.call([4, 2, 6, 7])\n# 2\ndef add(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add\n\
  \    candidate = method(:add)\n    assert_equal(88, candidate.call([4, 88]))\n \
  \   assert_equal(122, candidate.call([4, 5, 6, 7, 2, 122]))\n    assert_equal(0,\
  \ candidate.call([4, 0, 6, 7]))\n    assert_equal(12, candidate.call([4, 4, 6, 8]))\n\
  \  end\nend\n"
completions: ["  even = 0\n  odd = 1\n  for i in lst\n    if i % 2 == 0\n      even\
    \ += i\n    else\n      odd += i\n  end\n  return even+odd\nend", "  even = lst.select\
    \ { |x| x % 2 == 0 }\n  odd = lst.select { |x| x % 2 != 0 }\n  even.inject(0)\
    \ { |sum, e| sum + e }\nend", "  even = lst.select { |x| x % 2 == 0 }\n  even.inject(0)\
    \ { |sum, e| sum + e }\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>",
  "  even = lst.select { |x| x % 2 == 0 }\n  odd = lst.select { |x| x % 2 != 0 }\n\
    \  even.inject(0) { |sum, el| sum + el }\nend\n</code>\n<|/ a tags=ruby |>\n<|\
    \ c |>\nI like this solution, but I wonder if it would be more efficient to just\
    \ do `even.inject(0) { |sum, el| sum + el }`.\n<|/ c |>\n<| c |>\n: Yes, that\
    \ would be more efficient.\n<|/ c |>\n<| c |>\n: I added your suggestion to the\
    \ answer.\n<|/ c |>\n<| c |>\n: I added your suggestion to the answer.\n<|/ c\
    \ |>\n<| a dscore=1 |>\n<code>", "  even = []\n  odd = []\n  for i in lst\n  \
    \  if i.odd?\n      odd << i\n    else\n      even << i\n    end\n  end\n  even.inject(:+)\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,arrays |>\n<code>", "  even =\
    \ lst.select { |x| x % 2 == 0 }\n  even.inject(0) { |sum, e| sum + e }\nend",
  "  even = lst.select { |x| x % 2 == 0 }\n  odd = lst.select { |x| x % 2 != 0 }\n\
    \  even.inject(0) { |sum, el| sum + el }\nend", "  even = []\n  odd = []\n  for\
    \ i in lst\n    if i.odd?\n      odd << i\n    else\n      even << i\n    end\n\
    \  end\n  even.inject(:+)\nend", "  even = []\n  odd = []\n  for i in lst\n  \
    \  if i % 2 == 0\n      even << i\n    else\n      odd << i\n  end\n  even.inject(:+)\n\
    end", "  even = lst.select { |x| x % 2 == 0 }\n  even.inject(0) { |sum, el| sum\
    \ + el }\nend", "  even = []\n  odd = []\n  for i in lst\n    if i.odd?\n    \
    \  odd << i\n    else\n      even << i\n    end\n  end\n  even.inject(:+)\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nI like your solution, but I wouldn't call\
    \ it \"the Ruby way\". It's more of a \"Ruby way\" than a Ruby way. Ruby has lots\
    \ of ways to do things, and some are more idiomatic than others. Your solution\
    \ is more idiomatic in Ruby than in other languages, because it uses Ruby's idioms.\n\
    <|/ c |>\n<| c |>\nI agree with you, my solution is more idiomatic in Ruby than\
    \ in other languages. I only wanted to point out that there are other ways to\
    \ do it.\n<|/ c |>\n<| c |>\nI agree with you, my solution is more idiomatic in\
    \ Ruby than in other languages. I only wanted to point out that there are other\
    \ ways to do it.\n<|/ c |>\n<| c |>\nI agree with you, my solution is more idiomatic\
    \ in Ruby than in other languages. I only wanted to point out that there are other\
    \ ways to do it.\n<|/ c |>\n<| c |>\nI agree with you, my solution is more idiomatic\
    \ in Ruby than in other languages. I only wanted to point out that there are other\
    \ ways to do it.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  even = lst.select {\
    \ |x| x % 2 == 0 }\n  odd = lst.select { |x| x % 2 != 0 }\n  even.inject(0) {\
    \ |sum, e| sum + e }\nend", "  even = []\n  odd = []\n  for i in lst\n    if i.odd?\n\
    \      odd << i\n    else\n      even << i\n    end\n  end\n  even.inject(:+)\
    \ + odd.inject(:+)\nend", "  even = 0\n  odd = 0\n  for i in lst\n    if i % 2\
    \ == 0\n      even = even + i\n    else\n      odd = odd + i\n  end\n  return\
    \ even\nend", "  even = lst.select { |x| x % 2 == 0 }\n  odd = lst.select { |x|\
    \ x % 2 != 0 }\n  even.inject(0) { |sum, el| sum + el }\nend", "  even = 0\n \
    \ odd = 1\n  for i in lst\n    if i % 2 == 0\n      even += i\n    else\n    \
    \  odd += i\n  return even+odd\nend", "  even = lst.select { |x| x % 2 == 0 }\n\
    \  odd = lst.select { |x| x % 2 != 0 }\n  even.inject(0) { |sum, e| sum + e }\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis answer doesn't explain\
    \ why `inject` works the way it does.\n<|/ c |>\n<| c |>\nIt does. `inject` works\
    \ by iterating over the array and adding the current value to the accumulator\
    \ for each element in the array. `inject` will return the accumulator at the end.\
    \ `inject` works by iterating over the array and adding the current value to the\
    \ accumulator for each element in the array. `inject` will return the accumulator\
    \ at the end. `inject` works by iterating over the array and adding the current\
    \ value to the accumulator for each element in the array. `inject` will return\
    \ the accumulator at the end. `inject` works by iterating over the array and adding\
    \ the current value to the accumulator for each element in the array. `inject`\
    \ will return the accumulator at the end. `inject` works by iterating over the\
    \ array and adding the current value to the accumulator for each element in the\
    \ array. `inject` will return the accumulator at the end.\n<|/ c |>\n<| c |>\n\
    `inject` works by iterating over the array and adding the current value to the\
    \ accumulator for each element in the array. `inject` will return the accumulator\
    \ at the end. `inject` works by iterating over the array and adding the current\
    \ value to the accumulator for each element in the array. `inject` will return\
    \ the accumulator at the end. `inject` works by iterating over the array and adding\
    \ the current value to the accumulator for each element in the array. `inject`\
    \ will return the accumulator at the end. `inject` works by iterating over the\
    \ array and adding the current value to the accumulator for each element in the\
    \ array. `inject` will return the accumulator at the end.\n<|/ c |>\n<| c |>\n\
    `inject` works by iterating over the array and adding the current value to the\
    \ accumulator for each element in the array. `inject` will return the accumulator\
    \ at the end. `inject` works by iterating over the array and adding the current\
    \ value to the accumulator for each element in the array. `inject` will return\
    \ the accumulator at the end. `inject` works by iterating over the array and adding\
    \ the current value to the accumulator for each element in the array. `inject`\
    \ will return the accumulator at the end. `inject` works by iterating over the\
    \ array and adding the current value to the accumulator for each element in the\
    \ array. `inject", "  even = lst.select { |x| x % 2 == 0 }\n  odd = lst.select\
    \ { |x| x % 2 != 0 }\n  even.inject(0) { |sum, el| sum + el }\nend", "  even =\
    \ lst.select { |x| x % 2 == 0 }\n  odd = lst.select { |x| x % 2 != 0 }\n  even.inject(0)\
    \ { |sum, e| sum + e }\nend", "  even = []\n  odd = []\n  for i in lst\n    if\
    \ i % 2 == 0\n      even << i\n    else\n      odd << i\n    end\n  end\n  even.inject(:+)\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
