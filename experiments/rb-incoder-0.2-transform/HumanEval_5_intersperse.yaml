name: HumanEval_5_intersperse
language: rb
prompt: "# Insert a number 'delimeter' between every two consecutive elements of input\
  \ list `numbers'\n# >>> intersperse.call([], 4)\n# []\n# >>> intersperse.call([1,\
  \ 2, 3], 4)\n# [1, 4, 2, 4, 3]\ndef intersperse(numbers, delimeter)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersperse\n\
  \    candidate = method(:intersperse)\n    assert_equal([], candidate.call([], 7))\n\
  \    assert_equal([5, 8, 6, 8, 3, 8, 2], candidate.call([5, 6, 3, 2], 8))\n    assert_equal([2,\
  \ 2, 2, 2, 2], candidate.call([2, 2, 2], 2))\n  end\nend\n"
completions: ["  numbers.inject([]) do |result, number|\n    result << number\n  \
    \  result << delimeter\n    result\n  end\nend", "  numbers = numbers.dup\n  numbers.shift\n\
    \  numbers.map! do |number|\n    number + delimeter + number\n  end\n  numbers\n\
    end", "  numbers = numbers.dup\n  numbers.each_with_index do |number, i|\n   \
    \ numbers[i + 1] = delimeter if i > 0 && numbers[i + 1] == number\n  end\n  numbers\n\
    end", "  numbers.each_with_index do |number, index|\n    numbers[index] = delimeter\
    \ if index != 0\n    numbers[index + 1] = number\n  end\nend", "  numbers.each_cons(2).with_index\
    \ do |(first, second), i|\n    numbers.insert(i, delimeter)\n  end\nend", "  numbers\
    \ = numbers.dup\n  numbers.each_with_index do |n, i|\n    numbers[i + 1] = delimeter\
    \ if i > 0 && numbers[i + 1] == n\n  end\n  numbers\nend", "  numbers.each_cons(2)\
    \ do |numbers|\n    numbers.unshift(delimeter)\n    numbers.shift\n  end\nend",
  "  numbers.each_cons(2).with_index do |(number, index), i|\n    numbers[index +\
    \ i] = delimeter + number\n  end\nend", "  numbers[0, 2] = numbers[0, 2].join(delimeter)\n\
    \  numbers[1, 2] = numbers[1, 2].join(delimeter)\n  numbers[2, 2] = numbers[2,\
    \ 2].join(delimeter)\n  numbers[0, 2] = numbers[0, 2].split(delimeter)\n  numbers[1,\
    \ 2] = numbers[1, 2].split(delimeter)\n  numbers[2, 2] = numbers[2, 2].split(delimeter)\n\
    \  numbers[0, 2] = numbers[0, 2].join(delimeter)\n  numbers[1, 2] = numbers[1,\
    \ 2].join(delimeter)\n  numbers[2, 2] = numbers[2, 2].join(delimeter)\n  numbers[0,\
    \ 2] = numbers[0, 2].split(delimeter)\n  numbers[1, 2] = numbers[1, 2].split(delimeter)\n\
    \  numbers[2, 2] = numbers[2, 2].split(delimeter)\n  numbers[0, 2] = numbers[0,\
    \ 2].join(delimeter)\n  numbers[1, 2] = numbers[1, 2].join(delimeter)\n  numbers[2,\
    \ 2] = numbers[2, 2].join(delimeter)\n  numbers[0, 2] = numbers[0, 2].split(delimeter)\n\
    \  numbers[1, 2] = numbers[1, 2].split(delimeter)\n  numbers[2, 2] = numbers[2,\
    \ 2].split(delimeter)\n  numbers[0, 2] = numbers[0, 2].join(delimeter)\n  numbers[1,\
    \ 2] = numbers[1, 2].join(delimeter)\n  numbers[2, 2] = numbers[2, 2].join(delimeter)\n\
    \  numbers[0, 2] = numbers[0, 2].split(delimeter)\n  numbers[1, 2] = numbers[1,\
    \ 2].split(delimeter)\n  numbers[2, 2] = numbers[2, 2].split(delimeter)\n  numbers[0,\
    \ 2] = numbers[0, 2].join(delimeter)\n  numbers[1, 2] = numbers[1, 2].join(delimeter)\n\
    \  numbers[2, 2] = numbers[2, 2].join(delimeter)\n  numbers[0, 2] = numbers[0,\
    \ 2].split(delimeter)\n  numbers[1, 2] = numbers[1, 2].split(delimeter)\n  numbers[2,\
    \ 2] = numbers[2, 2].split(delimeter)\n  numbers[0, 2] = numbers[0, 2].join(delimeter)\n\
    \  numbers[1, 2] = numbers[1, 2].join(delimeter)\n  numbers[2, 2] = numbers[2,\
    \ 2].join(delimeter)\n  numbers[0, 2] = numbers[0, 2].split(delimeter)\n  numbers[1,\
    \ 2] = numbers[1, 2].split(delimeter)\n  numbers[2, 2] = numbers[2, 2].split(delimeter)\n\
    \  numbers[0, 2] = numbers[0, ", "  numbers.each_cons(2).with_index do |(first,\
    \ second), i|\n    numbers.insert(i, delimeter)\n  end\nend", "  numbers.each_cons(2).with_index\
    \ do |(first, second), index|\n    yield(first, delimeter, second, index)\n  end\n\
    end", "  numbers.each_with_index do |number, index|\n    yield(number) if index\
    \ == 0\n    yield(delimeter) if index != 0\n    yield(number)\n  end\nend", " \
    \ numbers[0, 2] = delimeter\n  numbers.slice(1, numbers.length).each do |number|\n\
    \    numbers[0, 2] = number\n    numbers.shift\n  end\n  numbers\nend", "  numbers\
    \ = numbers.dup\n  numbers.each_index do |i|\n    numbers[i + 1] = delimeter.call(numbers[i\
    \ + 1])\n  end\n  numbers\nend", "  numbers.each_cons(2) do |numbers|\n    numbers.unshift(delimeter)\n\
    \  end\nend", "  numbers.each_cons(2) do |a, b|\n    a.unshift(b)\n  end\n  numbers\n\
    end", "  numbers.each_cons(2).with_index do |(first, second), index|\n    first.insert(index,\
    \ delimeter)\n    second.insert(index, delimeter)\n  end\nend", "  numbers = numbers.dup\n\
    \  numbers.each do |number|\n    numbers.shift if numbers.empty?\n    numbers.unshift(number)\n\
    \  end\n  numbers\nend", "  numbers[0..-2].zip(numbers[1..-1]).map { |x, y| x\
    \ + delimeter + y }\nend", "  numbers = numbers.dup\n  numbers.shift\n  numbers.map!\
    \ { |n| n.to_s }\n  numbers.map! { |n| n.to_s.insert(delimeter, n) }\n  numbers.compact!\n\
    \  numbers\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
