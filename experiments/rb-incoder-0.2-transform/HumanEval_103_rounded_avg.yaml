name: HumanEval_103_rounded_avg
language: rb
prompt: "# You are given two positive integers n and m, and your task is to compute\
  \ the\n# average of the integers from n through m (including n and m). \n# Round\
  \ the answer to the nearest integer and convert that to binary.\n# If n is greater\
  \ than m, return -1.\n# Example:\n# >>> rounded_avg.call(1, 5)\n# \"0b11\"\n# >>>\
  \ rounded_avg.call(7, 5)\n# -1\n# >>> rounded_avg.call(10, 20)\n# \"0b1111\"\n#\
  \ >>> rounded_avg.call(20, 33)\n# \"0b11010\"\ndef rounded_avg(n, m)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rounded_avg\n\
  \    candidate = method(:rounded_avg)\n    assert_equal(\"0b11\", candidate.call(1,\
  \ 5))\n    assert_equal(\"0b1010\", candidate.call(7, 13))\n    assert_equal(\"\
  0b1111001010\", candidate.call(964, 977))\n    assert_equal(\"0b1111100100\", candidate.call(996,\
  \ 997))\n    assert_equal(\"0b1011000010\", candidate.call(560, 851))\n    assert_equal(\"\
  0b101101110\", candidate.call(185, 546))\n    assert_equal(\"0b110101101\", candidate.call(362,\
  \ 496))\n    assert_equal(\"0b1001110010\", candidate.call(350, 902))\n    assert_equal(\"\
  0b11010111\", candidate.call(197, 233))\n    assert_equal(-1, candidate.call(7,\
  \ 5))\n    assert_equal(-1, candidate.call(5, 1))\n    assert_equal(\"0b101\", candidate.call(5,\
  \ 5))\n  end\nend\n"
completions: ["  avg = n/m\n  avg = ((avg*10).to_i).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n\
    \  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n\
    \  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n\
    \  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n\
    \  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n\
    \  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n\
    \  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n\
    \  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n\
    \  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n\
    \  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n\
    \  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n\
    \  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n\
    \  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n\
    \  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n  avg = avg.to_i(2).to_s(2)\n\
    \  avg = avg.to_i(2).to_s(2)", "  avg = ((n..m).inject(:+) / m).round\n  binary\
    \ = []\n  while n <= m\n    binary.push(n % 2)\n    n /= 2\n  end\n  binary.reverse!\n\
    \  binary.inject(:+).to_s(2)\nend\n</cell>\n<cell>\nrounded_avg.call(1, 5)\n</cell>\n\
    <cell>\nrounded_avg.call(7, 5)\n</cell>\n<cell>\nrounded_avg.call(10, 20)\n</cell>\n\
    <cell>\nrounded_avg.call(20, 33)\n</cell>\n<cell>\nrounded_avg.call(30, 33)\n\
    </cell>\n<cell>\nrounded_avg.call(40, 33)\n</cell>\n<cell>\nrounded_avg.call(50,\
    \ 33)\n</cell>\n<cell>\nrounded_avg.call(60, 33)\n</cell>\n<cell>\nrounded_avg.call(70,\
    \ 33)\n</cell>\n<cell>\nrounded_avg.call(80, 33)\n</cell>\n<cell>\nrounded_avg.call(90,\
    \ 33)\n</cell>\n<cell>\nrounded_avg.call(100, 33)\n</cell>\n<cell>\nrounded_avg.call(110,\
    \ 33)\n</cell>\n<cell>\nrounded_avg.call(120, 33)\n</cell>\n<cell>\nrounded_avg.call(130,\
    \ 33)\n</cell>\n<cell>\nrounded_avg.call(140, 33)\n</cell>\n<cell>\nrounded_avg.call(150,\
    \ 33)\n</cell>\n<cell>\nrounded_avg.call(160, 33)\n</cell>\n<cell>\nrounded_avg.call(170,\
    \ 33)\n</cell>\n<cell>\nrounded_avg.call(180, 33)\n</cell>\n<cell>\nrounded_avg.call(190,\
    \ 33)\n</cell>\n<cell>\nrounded_avg.call(200, 33)\n</cell>\n<cell>\nrounded_avg.call(210,\
    \ 33)\n</cell>\n<cell>\nrounded_avg.call(220, 33)\n</cell>\n<cell>\nrounded_avg.call(230,\
    \ 33)\n</cell>\n<cell>\nrounded_avg.call(240, 33)\n</cell", "  avg = n/m\n  avg\
    \ = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n\
    \  avg = avg.to_s(2)\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = av", " \
    \ avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(8, '0')\n\
    end", "  avg = ((n..m).inject(:+) / m).round\n  avg.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).",
  "  avg = ((n..m).sum / m).round\n  binary = []\n  while n <= m\n    binary.push\
    \ n.to_s(2)\n    n += 1\n  end\n  binary.push m.to_s(2)\n  binary.push avg.to_s(2)\n\
    \  binary.join\nend", "  n = n.to_i\n  m = m.to_i\n  return n.upto(m).inject(:+).to_s(2)\
    \ if n <= m\n  -1\nend", "  avg = ((n..m).inject(:+) / m).round\n  binary = []\n\
    \  while n <= m\n    binary.push(n % 2)\n    n /= 2\n  end\n  binary.push(avg)\n\
    \  binary.join\nend", "  avg = ((n..m).sum.to_f / m.to_f).round\n  binary = []\n\
    \  while n <= m\n    binary.push(n.to_s(2))\n    n += 1\n  end\n  binary.reverse.each\
    \ do |b|\n    next if b.length < 2\n    binary.push(b[0, b.length - 1])\n  end\n\
    \  binary.join\nend", "  n = n.to_i\n  m = m.to_i\n  if n <= m\n    avg = ((n\
    \ - m) / n).round\n    binary = []\n    binary.push((n / m).to_s(2))\n    binary.push((avg\
    \ / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n\
    \    binary.push((avg / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n    binary.push((avg\
    \ / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n\
    \    binary.push((avg / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n    binary.push((avg\
    \ / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n\
    \    binary.push((avg / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n    binary.push((avg\
    \ / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n\
    \    binary.push((avg / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n    binary.push((avg\
    \ / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n\
    \    binary.push((avg / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n    binary.push((avg\
    \ / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n\
    \    binary.push((avg / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n    binary.push((avg\
    \ / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n\
    \    binary.push((avg / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n    binary.push((avg\
    \ / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n    binary.push((avg / 2).to_s(2))\n\
    \    binary.push((avg / 2).to_s(", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n\
    \  avg.to_i(2).to_s(2)\nend\n</cell>\n<cell>\nrounded_avg(7, 5)\n</cell>\n<cell>\n\
    rounded_avg(7, 0)\n</cell>\n<cell>\nrounded_avg(7, 1)\n</cell>\n<cell>\nrounded_avg(7,\
    \ 2)\n</cell>\n<cell>\nrounded_avg(7, 3)\n</cell>\n<cell>\nrounded_avg(7, 4)\n\
    </cell>\n<cell>\nrounded_avg(7, 5)\n</cell>\n<cell>\nrounded_avg(7, 6)\n</cell>\n\
    <cell>\nrounded_avg(7, 7)\n</cell>\n<cell>\nrounded_avg(7, 8)\n</cell>\n<cell>\n\
    rounded_avg(7, 9)\n</cell>\n<cell>\nrounded_avg(7, 10)\n</cell>\n<cell>\nrounded_avg(7,\
    \ 11)\n</cell>\n<cell>\nrounded_avg(7, 12)\n</cell>\n<cell>\nrounded_avg(7, 13)\n\
    </cell>\n<cell>\nrounded_avg(7, 14)\n</cell>\n<cell>\nrounded_avg(7, 15)\n</cell>\n\
    <cell>\nrounded_avg(7, 16)\n</cell>\n<cell>\nrounded_avg(7, 17)\n</cell>\n<cell>\n\
    rounded_avg(7, 18)\n</cell>\n<cell>\nrounded_avg(7, 19)\n</cell>\n<cell>\nrounded_avg(7,\
    \ 20)\n</cell>\n<cell>\nrounded_avg(7, 21)\n</cell>\n<cell>\nrounded_avg(7, 22)\n\
    </cell>\n<cell>\nrounded_avg(7, 23)\n</cell>\n<cell>\nrounded_avg(7, 24)\n</cell>\n\
    <cell>\nrounded_avg(7, 25)\n</cell>\n<cell>\nrounded_avg(7, 26)\n</cell>\n<cell>\n\
    rounded_avg(7, 27)\n</cell>\n<cell>\nrounded_avg(7, 28)\n</cell>\n<cell>\nrounded_avg(7,\
    \ 29)\n</cell>\n<cell>\nrounded_avg", "  avg = n/m\n  avg = Math.ceil(avg)\n \
    \ avg = avg * Math.pow(2,Float.log(avg,2))\n  return \"0b\" + avg.to_s(2)\nend",
  "  avg = ((n..m).sum / m).round\n  binary = []\n  while n <= m\n    binary.push(n.to_s(2))\n\
    \    n += 1\n  end\n  binary.push(m.to_s(2))\n  binary.reverse\n  binary.join\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for negative numbers. `rounded_avg.call(-5,\
    \ 5)` returns `\"-0b11\"` instead of `\"0b11\"`.\n<|/ c |>\n<| a tags=ruby,binary,math\
    \ |>\n<code>", "  avg = n/m\n  avg = avg * 2\n  avg = avg + 1 if avg > m else\
    \ avg\n  avg = avg / 2\n  avg = bin(avg)\n  avg = avg.lstrip(\"0b\")\n  avg =\
    \ avg.rstrip(\"0\")\n  return avg\nend", "  sum = 0\n  while n <= m\n    sum +=\
    \ n\n    n += 1\n  end\n  sum.to_s(2)\nend", "  avg = n/m\n  avg = ((avg*10).to_i).to_s(2)\n\
    \  avg.reverse!\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n\
    \  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg\
    \ << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n\
    \  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg\
    \ << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n\
    \  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg\
    \ << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n\
    \  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg\
    \ << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n\
    \  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg\
    \ << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n\
    \  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg\
    \ << 1\n  avg << 1\n  avg << 1\n  avg << 1\n  avg << 1", "  avg = n/m\n  avg =\
    \ avg * 10\n  avg = avg / 10\n  avg = avg.to_s(2)\n  avg = avg.ljust(4, \"0\"\
    )\n  return avg\nend", "  avg = ((n..m).sum.to_f / m.to_f).round\n  binary = []\n\
    \  while n <= m\n    binary.push((n.to_s(2))[-1,1])\n    n += 1\n  end\n  binary.join\n\
    end", "  avg = ((n..m).sum.to_f / m.to_f).round\n  binary = []\n  while n <= m\n\
    \    binary.push(n.to_s(2))\n    n += 1\n  end\n  binary.push(m.to_s(2))\n  binary.reverse.join\
    \ # reverse the binary array and join it into a string\nend", "  avg = ((n..m).inject(:+)\
    \ / m).round\n  binary = []\n  while n <= m\n    binary.push(n % 2)\n    n /=\
    \ 2\n  end\n  binary.reverse\n  binary.join\nend\n</code>\n<|/ a tags=ruby,binary,math\
    \ |>\n<| c |>\nI like your solution, but I feel like it would be more efficient\
    \ to just do `n.to_s(2)` instead of `n.to_s(2).reverse`\n<|/ c |>\n<| c |>\nI\
    \ agree, that would be more efficient. I was just trying to keep it simple.\n\
    <|/ c |>\n<| c |>\nI like your solution, but I feel like it would be more efficient\
    \ to just do `n.to_s(2)` instead of `n.to_s(2).reverse`\n<|/ c |>\n<| c |>\nI\
    \ like your solution, but I feel like it would be more efficient to just do `n.to_s(2)`\
    \ instead of `n.to_s(2).reverse`\n<|/ c |>\n<| c |>\nI like your solution, but\
    \ I feel like it would be more efficient to just do `n.to_s(2)` instead of `n.to_s(2).reverse`\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>", "  avg = ((n..m).reduce(:+) / m).round\n\
    \  binary = []\n  while n <= m\n    binary.push((n & m).to_s(2))\n    n += 1\n\
    \  end\n  binary.reverse\n  binary.join\nend", "  avg = ((n..m).sum.to_f / m.to_f).round\n\
    \  binary = []\n  while n <= m\n    binary.push(n.to_s(2))\n    n += 1\n  end\n\
    \  binary.reverse!\n  binary.push(\"0b\" + binary.join)\n  binary.pop\nend\n</cell>\n\
    <code language=julia-1.4>\nrounded_avg.call(1, 5)\n</cell>\n<code language=julia-1.4>\n\
    rounded_avg.call(7, 5)\n</cell>\n<code language=julia-1.4>\nrounded_avg.call(10,\
    \ 20)\n</cell>\n<code language=julia-1.4>\nrounded_avg.call(20, 33)\n</cell>\n\
    <code language=julia-1.4>\nrounded_avg.call(10, 20)\n</cell>\n<code language=julia-1.4>\n\
    rounded_avg.call(20, 33)\n</cell>\n<code language=julia-1.4>\nrounded_avg.call(10,\
    \ 20)\n</cell>\n<code language=julia-1.4>\nrounded_avg.call(20, 33)\n</cell>\n\
    <code language=julia-1.4>\nrounded_avg.call(10, 20)\n</cell>\n<code language=julia-1.4>\n\
    rounded_avg.call(20, 33)\n</cell>\n<code language=julia-1.4>\nrounded_avg.call(10,\
    \ 20)\n</cell>\n<code language=julia-1.4>\nrounded_avg.call(20, 33)\n</cell>\n\
    <code language=julia-1.4>\nrounded_avg.call(10, 20)\n</cell>\n<code language=julia-1.4>\n\
    rounded_avg.call(20, 33)\n</cell>\n<code language=julia-1.4>\nrounded_avg.call(10,\
    \ 20)\n</cell>\n<code language=julia-1.4>\nrounded_avg.call(20, 33)\n</cell>\n\
    <code language=julia-1.4>\nrounded_avg.call(10, 20)\n</cell>\n<code language=julia-1.4>\n\
    rounded_avg.call(20, 33)\n</cell>\n<code language=julia-1.4>\nrounded_avg.call(10,\
    \ 20)\n</cell>\n<code language=julia-1.4>\nrounded_avg.call(20, 33)\n</cell>\n\
    <code language=julia-1.4>\nrounded_avg.call(10, 20)\n</cell>\n<code language=julia-1.4>\n\
    rounded_avg.call(20, 33)\n</cell>\n<code language=julia-1.4>\nrounded_avg.call(10,\
    \ 20)\n</cell>\n<code language=julia-1.4>\nrounded_avg.call(20, 33)\n", "  avg\
    \ = n/m\n  avg = avg * 2\n  avg = avg / 2\n  avg = avg.to_s(2)\n  avg = avg.ljust(8,\
    \ '0')\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg =\
    \ avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = ", "  n = n.to_i\n  m = m.to_i\n  if n > m\n    -1\n  else\n    n.upto(m).inject(:+).to_s(2).to_i(2).to_s(2)\n\
    \  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>", "  sum = 0\n\
    \  while n <= m\n    sum += n\n    n += 1\n  sum.to_s(2)\nend", "  avg = n/m\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg", "  avg = n/m\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n\
    \  return \"0b\" + avg.to_s(2)\nend", "  avg = ((n..m).sum.to_f / m.to_f).round\n\
    \  binary = []\n  while n <= m\n    binary.push((n.to_s(2))[-1,1])\n    n += 1\n\
    \  end\n  binary.reverse.join # reverse the array and join it into a string\n\
    end", "  avg = ((n..m).reduce(:+) / m).round\n  binary = []\n  while n <= m\n\
    \    binary.push(n.to_s(2))\n    n += 1\n  end\n  binary.reverse.each do |b|\n\
    \    next if b == \"0\"\n    break if b == \"1\"\n    break if b == \"10\"\n \
    \   break if b == \"11\"\n    break if b == \"100\"\n    break if b == \"101\"\
    \n    break if b == \"110\"\n    break if b == \"111\"\n    break if b == \"1000\"\
    \n    break if b == \"1001\"\n    break if b == \"1010\"\n    break if b == \"\
    1011\"\n    break if b == \"1100\"\n    break if b == \"1101\"\n    break if b\
    \ == \"1110\"\n    break if b == \"1111\"\n  end\n  binary.join\nend", "  avg\
    \ = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2)\nend", "  avg = ((n..m).reduce(:+)\
    \ / m).to_s(2)\n  avg.to_i(2).to_s(2)\nend", "  avg = ((n..m).reduce(:+) / m).round\n\
    \  binary = avg.to_s(2)\n  binary[-(binary.length-1)] = \"0\"\n  return binary\n\
    end", "  avg = ((n..m).inject(:+) / m).round\n  binary = []\n  while n <= m\n\
    \    binary.push((n & m).to_s(2))\n    n += 1\n  end\n  binary.reverse\n  binary.join\n\
    end", "  n = n.to_i\n  m = m.to_i\n  return n.upto(m).inject(:+).to_s(2).to_i(2).to_s(2)\n\
    end", "  avg = ((n..m).reduce(:+) / m).round\n  binary = []\n  while n <= m\n\
    \    binary.push((n & m).to_s(2))\n    n += 1\n  end\n  binary.reverse\n  binary.join\n\
    end", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(8,\
    \ '0')\nend", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(8,\
    \ '0')\nend\n</cell>\n<code language=julia-1.5>\n@assert rounded_avg.call(1, 5)\
    \ == \"0b11\"\n@assert rounded_avg.call(7, 5) == -1\n@assert rounded_avg.call(10,\
    \ 20) == \"0b1111\"\n@assert rounded_avg.call(20, 33) == \"0b11010\"\n</cell>\n\
    <text>\nExercise 2\nWrite a function that computes the factorial of a given integer.\
    \ \nThe factorial of a non-negative integer n, denoted by n!, is the product of\
    \ all positive integers less than or equal to n.\nFor example, 5! = 5 \xD7 4 \xD7\
    \ 3 \xD7 2 \xD7 1 = 120.\nWrite a recursive function factorial(n) that computes\
    \ the factorial of n.", "  avg = ((n..m).inject(:+) / m).round\n  binary = []\n\
    \  while n <= m\n    binary.push((n & m).to_s(2))\n    n += 1\n  end\n  binary.reverse\n\
    \  binary.join\nend", "  avg = n/m\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n  return\
    \ \"0b\" + avg.to_s(2)\nend", "  avg = ((n..m).sum / m).round\n  binary = []\n\
    \  while n <= m\n    binary.push((n..m).sum.to_s(2).reverse)\n    n += 1\n  end\n\
    \  binary.push((n..m).sum.to_s(2).reverse)\n  binary.reverse\n  binary.join\n\
    end", "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n  while n <= m\n  \
    \  binary.push((n.to_s(2))[-1,1])\n    n += 1\n  binary.join\nend", "  avg = ((n..m).reduce(:+)\
    \ / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(32, '0')\nend", "  avg = n/m\n  avg\
    \ = ((avg*10).to_i).to_s(2)\n  avg = avg.gsub(\"0\", \"\")\n  avg = (\"0b\" +\
    \ avg).gsub(\"1\", \"\")\n  if n > m\n    -1\n  else\n    avg\n  end\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis doesn't work. `rounded_avg.call(1, 5)` returns\
    \ `\"0b11\"`, not `\"0b111\"`.\n<|/ c |>\n<| c |>\nI fixed the bug and added a\
    \ test case. Thanks for pointing it out.\n<|/ c |>\n<| c |>\nI added a test case\
    \ to my answer. Thanks for pointing it out.\n<|/ c |>\n<| c |>\nI added a test\
    \ case to my answer. Thanks for pointing it out.\n<|/ c |>\n<| a dscore=1 |>\n\
    <code>", "  avg = ((n..m).reduce(:+) / m).round\n  binary = ((n / m) * \"0b\"\
    \ + avg).to_s(2)\n  binary.gsub!(/0b/, \"\")\n  binary.gsub!(/0/, \"b\")\n  binary.gsub!(/1/,\
    \ \"b\")\n  binary.gsub!(/2/, \"b\")\n  binary.gsub!(/3/, \"b\")\n  binary.gsub!(/4/,\
    \ \"b\")\n  binary.gsub!(/5/, \"b\")\n  binary.gsub!(/6/, \"b\")\n  binary.gsub!(/7/,\
    \ \"b\")\n  binary.gsub!(/8/, \"b\")\n  binary.gsub!(/9/, \"b\")\n  binary.gsub!(/a/,\
    \ \"b\")\n  binary.gsub!(/0/, \"b\")\n  binary.gsub!(/1/, \"b\")\n  binary.gsub!(/2/,\
    \ \"b\")\n  binary.gsub!(/3/, \"b\")\n  binary.gsub!(/4/, \"b\")\n  binary.gsub!(/5/,\
    \ \"b\")\n  binary.gsub!(/6/, \"b\")\n  binary.gsub!(/7/, \"b\")\n  binary.gsub!(/8/,\
    \ \"b\")\n  binary.gsub!(/9/, \"b\")\n  binary.gsub!(/a/, \"b\")\n  binary.gsub!(/0/,\
    \ \"b\")\n  binary.gsub!(/1/, \"b\")\n  binary.gsub!(/2/, \"b\")\n  binary.gsub!(/3/,\
    \ \"b\")\n  binary.gsub!(/4/, \"b\")\n  binary.gsub!(/5/, \"b\")\n  binary.gsub!(/6/,\
    \ \"b\")\n  binary.gsub!(/7/, \"b\")\n  binary.gsub!(/8/, \"b\")\n  binary.gsub!(/9/,\
    \ \"b\")\n  binary.gsub!(/a/, \"b\")\n  binary.gsub!(/0/, \"b\")\n  binary.gsub!(/1/,\
    \ \"b\")\n  binary.gsub!(/2/, \"b\")\n  binary.gsub!(/3/, \"b\")\n  binary.gsub!(/4/,\
    \ \"b\")\n  binary.gsub!(/5/, \"b\")\n  binary.gsub!(/6/, \"b\")\n  binary.gsub!(/7/,\
    \ \"b\")\n  binary.gsub!(/8/, \"b\")\n  binary.gsub", "  avg = ((n..m).sum / m).round\n\
    \  binary = []\n  while n <= m\n    binary.push((n..m).to_s(2).reverse.gsub(/../).reverse)\n\
    \    n += 1\n  end\n  binary.each do |b|\n    if b.to_s.reverse.to_i(2) < avg\n\
    \      return -1\n    end\n  end\n  return binary.reverse.join\nend", "  avg =\
    \ ((n..m).sum.to_f / m).round\n  binary = []\n  while n <= m\n    binary.push((n..m).sum.to_s(2))\n\
    \    n += 1\n  end\n  binary.reverse.each do |b|\n    next if b.length < 2\n \
    \   binary.pop\n  end\n  binary.join\nend\n</code>\n<|/ a tags=ruby,binary,math,algorithm\
    \ |>\n<| a tags=ruby,binary,math,algorithm |>\n<code>", "  avg = ((n..m).reduce(:+)\
    \ / m).round\n  binary = []\n  while n != 0\n    binary.unshift(n % 2)\n    n\
    \ /= 2\n  end\n  binary.unshift(avg)\n  binary.join\nend", "  avg = ((n..m).reduce(:+)\
    \ / m).to_s(2)\n  avg.to_i(2).to_s(2)\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby\
    \ |>\n<code>", "  sum = 0\n  while n <= m\n    sum += n\n    n += 1\n  end\n \
    \ sum.to_s(2).to_i(2).to_s(2)\nend", "  sum = 0\n  while n <= m\n    sum += n\n\
    \    n += 1\n  sum.to_s(2)\nend", "  avg = ((n..m).inject(:+) / m).round\n  binary\
    \ = []\n  while n <= m\n    binary.push((n & m).to_s(2))\n    n += 1\n  end\n\
    \  binary.reverse\n  binary.join\nend", "  avg = n/m\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float::MANT_DIG)\n  avg = Math.bin(avg)\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.", "  avg = ((n..m).sum.to_f\
    \ / m).round\n  binary = []\n  while n <= m\n    binary.push(n.to_s(2))\n    n\
    \ += 1\n  end\n  binary.reverse.each do |b|\n    next if b.length < 2\n    next\
    \ if b.length == 2\n    next if b.length == 3\n    next if b.length == 4\n   \
    \ next if b.length == 5\n    next if b.length == 6\n    next if b.length == 7\n\
    \    next if b.length == 8\n    next if b.length == 9\n    next if b.length ==\
    \ 10\n    next if b.length == 11\n    next if b.length == 12\n    next if b.length\
    \ == 13\n    next if b.length == 14\n    next if b.length == 15\n    next if b.length\
    \ == 16\n    next if b.length == 17\n    next if b.length == 18\n    next if b.length\
    \ == 19\n    next if b.length == 20\n    next if b.length == 21\n    next if b.length\
    \ == 22\n    next if b.length == 23\n    next if b.length == 24\n    next if b.length\
    \ == 25\n    next if b.length == 26\n    next if b.length == 27\n    next if b.length\
    \ == 28\n    next if b.length == 29\n    next if b.length == 30\n    next if b.length\
    \ == 31\n    next if b.length == 32\n    next if b.length == 33\n    next if b.length\
    \ == 34\n    next if b.length == 35\n    next if b.length == 36\n    next if b.length\
    \ == 37\n    next if b.length == 38\n    next if b.length == 39\n    next if b.length\
    \ == 40\n    next if b.length == 41\n    next if b.length == 42\n    next if b.length\
    \ == 43\n    next if b.length == 44\n    next if b.length == 45\n    next if b.length\
    \ == 46\n    next if b.length == 47\n    next if b.length == 48\n    next if b.length\
    \ == 49\n    next if b.length == 50\n    next if b.length == 51\n    next if b.length\
    \ == 52\n    next if b.length == 53\n    next if b.length == 54\n    next if b.length\
    \ == 55\n    next if b.length == 56\n    next if b.length == 57\n    next if b.length\
    \ == 58\n    next if b.length == 59\n    next if b.", "  avg = ((n..m).reduce(:+)\
    \ / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(8, '0')\nend", "  avg = ((n..m).sum.to_f\
    \ / m.to_f).round\n  binary = []\n  while n <= m\n    binary.push((n..m).sum.to_s(2))\n\
    \    n += 1\n  end\n  binary.reverse.each do |b|\n    next if b.length < 2\n \
    \   binary.push(\"#{b}0\")\n  end\n  binary.join\nend\n</code>\n<|/ a tags=ruby,binary,math,algorithm\
    \ |>\n<| c |>\nThis doesn't work if n is greater than m. Try it out with n = 5\
    \ and m = 10. Your code returns \"0b111111\" instead of \"0b111110\".\n<|/ c |>\n\
    <| c |>\nYes, I noticed that and fixed it.  Thanks for pointing it out!\n<|/ c\
    \ |>\n<| a |>\n<code>", "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n\
    \  while n <= m\n    binary.push(\"#{n}b\")\n    n += 1\n  end\n  binary.push(\"\
    #{m}b\")\n  binary.join(\",\")\nend", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n\
    \  avg.to_i(2).to_s(2).rjust(8, '0')\nend", "  avg = n/m\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(10, Math.ceil(Math.log10(avg)))\n  return \"0b\" + avg.to_s(2)\n\
    end", "  sum = 0\n  while n <= m\n    sum += n\n    n += 1\n  end\n  return sum.to_s(2).reverse.rjust(8,\
    \ '0')\nend\n</cell>\n<code language=julia-1.0>\n@test rounded_avg(1, 5) == \"\
    0b11\"\n@test rounded_avg(7, 5) == -1\n@test rounded_avg(10, 20) == \"0b1111\"\
    \n@test rounded_avg(20, 33) == \"0b11010\"\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that returns the number of times a given value appears in a given\
    \ array.", "  avg = ((n..m).reduce(:+) / m).round\n  binary = []\n  while n <=\
    \ m\n    binary.push((n & m).to_s(2))\n    n += 1\n  end\n  binary.reverse\n \
    \ binary.join\nend", "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n  while\
    \ n <= m\n    binary.push((n..m).sum.to_s(2))\n    n += 1\n  end\n  binary.reverse.each\
    \ do |b|\n    next if b.length < 2\n    binary.push(b[0, b.length - 1])\n  end\n\
    \  binary.join\nend", "  avg = ((n..m).sum.to_f / m.to_f).round\n  binary = []\n\
    \  while n <= m\n    binary.push(n.to_s(2))\n    n += 1\n  end\n  binary.reverse!\n\
    \  binary.join\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,binary,math |>\n\
    <code>", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(8,\
    \ '0')\nend", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2)\n\
    end", "  avg = ((n..m).reduce(:+) / m).round\n  binary = []\n  while n <= m\n\
    \    binary.unshift(n.to_s(2))\n    n += 1\n  end\n  binary.unshift(avg.to_s(2))\n\
    \  binary.join\nend", "  avg = ((n..m).inject(:+) / m).round\n  binary = []\n\
    \  while n <= m\n    binary.unshift(n.to_s(2))\n    n += 1\n  end\n  binary.unshift(avg.to_s(2))\n\
    \  binary.join\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\n<code>", " \
    \ avg = ((n..m).sum.to_f / m).round\n  binary = []\n  while n <= m\n    binary.push((n..m).sum.to_s(2))\n\
    \    n += 1\n  end\n  binary.reverse.each do |x|\n    x.reverse!\n  end\n  binary.join\n\
    end", "  avg = ((n..m).sum / m).round\n  binary = []\n  while n <= m\n    binary.push(\"\
    #{n}b\")\n    n += 1\n  end\n  binary.push(\"#{avg}b\")\n  binary.join\nend",
  "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(8, '0')\n\
    end", "  avg = ((n..m).inject(:+) / m).round\n  avg.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).",
  "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(32, '0')\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI like your solution, but I believe it can be\
    \ simplified a bit. `((n..m).reduce(:+) / m).to_s(2)` can be replaced with `(n..m).reduce(:+)\
    \ / m`\n<|/ c |>\n<| c |>\nI agree with you, thank you. I've updated the answer.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n\
    \  avg.to_i(2).to_s(2)\nend", "  avg = n/m\n  avg = Math.ceil(avg)\n  avg = avg\
    \ * Math.pow(2,Float.log(avg,2))\n  avg = Math.bin(avg)\n  avg = avg.reverse\n\
    \  avg = avg.to_i(2).to_s(2)\n  return avg\nend", "  avg = ((n..m).reduce(:+)\
    \ / m).to_s(2)\n  avg.to_i(2).to_s(2)\nend", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n\
    \  avg.to_i(2).to_s(2).rjust(32, \"0\")\nend", "  avg = n/m\n  avg = Math.ceil(avg)\n\
    \  avg = Math.pow(2,avg)\n  avg = avg.to_s(2)\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = av", "  avg = ((n..m).reduce(:+)\
    \ / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(8, '0')\nend\n</cell>\n<code language=julia-0.6>\n\
    @time rounded_avg(1000000, 1000000)\n</cell>\n<code language=julia-0.6>\n@time\
    \ rounded_avg(1000000, 1000000)\n</cell>\n<code language=julia-0.6>\n@time rounded_avg(1000000,\
    \ 1000000)\n</cell>\n<code language=julia-0.6>\n@time rounded_avg(1000000, 1000000)\n\
    </cell>\n<code language=julia-0.6>\n@time rounded_avg(1000000, 1000000)\n</cell>\n\
    <code language=julia-0.6>\n@time rounded_avg(1000000, 1000000)\n</cell>\n<code\
    \ language=julia-0.6>\n@time rounded_avg(1000000, 1000000)\n</cell>\n<code language=julia-0.6>\n\
    @time rounded_avg(1000000, 1000000)\n</cell>\n<code language=julia-0.6>\n@time\
    \ rounded_avg(1000000, 1000000)\n</cell>\n<code language=julia-0.6>\n@time rounded_avg(1000000,\
    \ 1000000)\n</cell>\n<code language=julia-0.6>\n@time rounded_avg(1000000, 1000000)\n\
    </cell>\n<code language=julia-0.6>\n@time rounded_avg(1000000, 1000000)\n</cell>\n\
    <code language=julia-0.6>\n@time rounded_avg(1000000, 1000000)\n</cell>\n<code\
    \ language=julia-0.6>\n@time rounded_avg(1000000, 1000000)\n</cell>\n<code language=julia-0.6>\n\
    @time rounded_avg(1000000, 1000000)\n</cell>\n<code language=julia-0.6>\n@time\
    \ rounded_avg(1000000, 1000000)\n</cell>\n<code language=julia-0.6>\n@time rounded_avg(1000000,\
    \ 1000000)\n</cell>\n<code language=julia-0.6>\n@time rounded_avg(1000000, 1000000)\n\
    </cell>\n<code language=julia-0.6>\n@time rounded_avg(1000000, 1000000)\n</cell>\n\
    <code language=julia-0.6>\n@time rounded_avg(1000000, 1000000)\n</cell>\n<code\
    \ language=julia-0.6>\n@time rounded_avg(1000000, 1000000)\n</cell>\n<code language=julia-0.6>\n\
    @time rounded_avg(1000000, 1000000)\n</cell>\n<code language=julia-0.6>\n@time\
    \ rounded_avg", "  avg = ((n..m).reduce(:+) / m).round\n  binary = []\n  while\
    \ n != 0\n    binary.unshift(n % 2)\n    n /= 2\n  end\n  binary.unshift(avg)\n\
    \  binary.join\nend", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2)\n\
    end", "  n = n.to_i\n  m = m.to_i\n  if n > m\n    -1\n  else\n    n.upto(m).inject(:+).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\n\
    \  end\nend", "  sum = 0\n  for i in (n..m)\n    sum += i\n  return sum.to_s(2).reverse.chr.to_i(2)\
    \ if sum > m then -1 else sum.to_s(2).reverse.chr.to_i(2) \nend\nputs rounded_avg(7,\
    \ 5)\nputs rounded_avg(10, 20)\nputs rounded_avg(20, 33)\nputs rounded_avg(100,\
    \ 200)\nputs rounded_avg(1000, 2000)\nputs rounded_avg(10000, 20000)\nputs rounded_avg(100000,\
    \ 200000)\nputs rounded_avg(1000000, 2000000)\nputs rounded_avg(10000000, 20000000)\n\
    puts rounded_avg(100000000, 200000000)\nputs rounded_avg(1000000000, 2000000000)\n\
    puts rounded_avg(10000000000, 20000000000)\nputs rounded_avg(100000000000, 200000000000)\n\
    puts rounded_avg(1000000000000, 2000000000000)\nputs rounded_avg(10000000000000,\
    \ 20000000000000)\nputs rounded_avg(100000000000000, 200000000000000)\nputs rounded_avg(1000000000000000,\
    \ 2000000000000000)\nputs rounded_avg(10000000000000000, 2000000000000000) \n\
    puts rounded_avg(100000000000000000, 20000000000000000)\nputs rounded_avg(1000000000000000000,\
    \ 200000000000000000) \nputs rounded_avg(10000000000000000000, 2000000000000000000)\
    \ \nputs rounded_avg(100000000000000000000, 20000000000000000000) \nputs rounded_avg(1000000000000000000000,\
    \ 200000000000000000000) \nputs rounded_avg(10000000000000000000000, 20000000000000000000000)\
    \ \nputs rounded_avg(100000000000000000000000, 200000000000000000000000) \nputs\
    \ rounded_avg(1000000000000000000000000, 2000000000000000000000000) \nputs rounded_avg(10000000000000000000000000,\
    \ 20000000000000000000000000) \nputs rounded_avg(100000000000000000000000000,\
    \ 200000000000000000000000000) \nputs rounded_avg(1000000000000000000000000000,\
    \ 2000000000000000000000000000) \nputs rounded_avg(10000000000000000000000000000,\
    \ 20000000000000000000000000000) \nputs rounded_avg(100000000000000000000000000000,\
    \ 200000000000000000000000000000) \nputs rounded_avg(1000000000000000000000000000000,\
    \ 2000000000000000000000000000000) \nputs rounded_avg(10000000000000000000000000000000,\
    \ 20000000000000000000000000000000) \nputs rounded_avg(100000000000000000000000000000000,\
    \ 200000000000000000000000000000000) ", "  avg = ((n..m).reduce(:+) / m).round\n\
    \  \n  case avg\n  when 0...n\n    \"0\"\n  when n...m\n    \"1\"\n  when m...n\n\
    \    \"-1\"\n  else\n    -1\n  end\nend\n</cell>\n<code language=julia-1.5>\n\
    @test rounded_avg(1, 5) == \"0b11\"\n@test rounded_avg(7, 5) == -1\n@test rounded_avg(10,\
    \ 20) == \"0b1111\"\n@test rounded_avg(20, 33) == \"0b11010\"\n</cell>\n<text>\n\
    Exercise 3\nWrite a function that takes an integer and returns the number of bits\
    \ it takes to represent that integer. \nFor example, 32 is represented as \"0b100\"\
    , and 8 is represented as \"0b1000\".\nWrite a second function that takes an integer\
    \ and returns the number of bits it takes to represent that integer in binary.\n\
    For example, 32 is represented as \"0b100\", and 8 is represented as \"0b1000\"\
    .\nWrite a third function that takes an integer and returns the number of bits\
    \ it takes to represent that integer in hexadecimal.\nFor example, 32 is represented\
    \ as \"0x100\", and 8 is represented as \"0x1000\".\nWrite a fourth function that\
    \ takes an integer and returns the number of bits it takes to represent that integer\
    \ in octal.\nFor example, 32 is represented as \"0o100\", and 8 is represented\
    \ as \"0o1000\".\nWrite a fifth function that takes an integer and returns the\
    \ number of bits it takes to represent that integer in decimal.\nFor example,\
    \ 32 is represented as \"10\", and 8 is represented as \"8\".", "  avg = ((n..m).inject(:+)\
    \ / m).round\n  avg.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).",
  "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(8, '0')\n\
    end", "  avg = ((n + m) / 2).round\n  binary = []\n  while n <= m\n    binary.push(\"\
    #{n}b\")\n    n += 1\n  end\n  binary.push(\"#{m}b\")\n  binary.join(\",\")\n\
    end", "  avg = n/m\n  avg = ((avg*10).to_i).to_s(2)\n  avg = avg.reverse\n  avg\
    \ = avg.gsub(/(.{1})/, '0\\1')\n  avg = avg.reverse\n  avg = avg.gsub(/(.{2})/,\
    \ '0\\1')\n  avg = avg.reverse\n  avg = avg.gsub(/(.{3})/, '0\\1')\n  avg = avg.reverse\n\
    \  avg = avg.gsub(/(.{4})/, '0\\1')\n  avg = avg.reverse\n  avg = avg.gsub(/(.{5})/,\
    \ '0\\1')\n  avg = avg.reverse\n  avg = avg.gsub(/(.{6})/, '0\\1')\n  avg = avg.reverse\n\
    \  avg = avg.gsub(/(.{7})/, '0\\1')\n  avg = avg.reverse\n  avg = avg.gsub(/(.{8})/,\
    \ '0\\1')\n  avg = avg.reverse\n  avg = avg.gsub(/(.{9})/, '0\\1')\n  avg = avg.reverse\n\
    \  avg = avg.gsub(/(.{10})/, '0\\1')\n  avg = avg.reverse\n  avg = avg.gsub(/(.{11})/,\
    \ '0\\1')\n  avg = avg.reverse\n  avg = avg.gsub(/(.{12})/, '0\\1')\n  avg = avg.reverse\n\
    \  avg = avg.gsub(/(.{13})/, '0\\1')\n  avg = avg.reverse\n  avg = avg.gsub(/(.{14})/,\
    \ '0\\1')\n  avg = avg.reverse\n  avg = avg.gsub(/(.{15})/, '0\\1')\n  avg = avg.reverse\n\
    \  avg = avg.gsub(/(.{16})/, '0\\1')\n  avg = avg.reverse\n  avg = avg.gsub(/(.{17})/,\
    \ '0\\1')\n  avg = avg.reverse\n  avg = avg.gsub(/(.{18})/, '0\\1')\n  avg = avg.reverse\n\
    \  avg = avg.gsub(/(.{19})/, '0\\1')\n  avg = avg.reverse\n  avg = avg.gsub(/(.{20})/",
  "  n = n.to_i\n  m = m.to_i\n  return \"0b\" + n.to_s(2).reverse.gsub(/(.{1})(?=\\\
    d)/, '0$1').to_s(2)\nend", "  avg = ((n..m).reduce(:+) / m).round\n  binary =\
    \ []\n  while n != 0\n    binary.unshift(n % 2)\n    n /= 2\n  end\n  binary.unshift(avg)\n\
    \  binary.join\nend", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2)\n\
    end", "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n  while n <= m\n  \
    \  binary.push((n..m).sum.to_s(2))\n    n += 1\n  end\n  binary.push((n..m).sum.to_s(2))\n\
    \  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n\
    \  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n\
    \  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n\
    \  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n\
    \  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n\
    \  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n\
    \  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n\
    \  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n\
    \  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n\
    \  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n\
    \  binary.push((n..m).sum.to_s(2))\n  binary.push((n..m).sum.to_s(2))\n  binary.",
  "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n  while n <= m\n    binary.push((n..m).sum.to_s(2))\n\
    \    n += 1\n  end\n  binary.reverse.each do |b|\n    binary = b.to_i(2) if b.to_i(2).to_s(2).to_i(2)\
    \ < m\n  end\n  binary.join\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like\
    \ your solution, however it fails for `rounded_avg.call(1, 5)` which should return\
    \ `\"0b11\"` but instead returns `\"0b1\"`\n<|/ c |>\n<| c |>\nI fixed the bug.\
    \ Thanks for pointing it out.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  avg = ((n..m).sum.to_f\
    \ / m.to_f).round\n  binary = []\n  while n <= m\n    binary.push(n.to_s(2))\n\
    \    n += 1\n  end\n  binary.reverse!\n  binary.join\nend", "  avg = n/m\n  avg\
    \ = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n  avg\
    \ = Math.ceil(avg)\n  return \"0b\" + avg.to_s(2)\nend", "  avg = ((n..m).inject(:+)\
    \ / m).round\n  avg.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).",
  "  avg = ((n..m).sum.to_f / m.to_f).round\n  binary = []\n  while n <= m\n    binary.push((n..m).sum.to_s(2))\n\
    \    n += 1\n  end\n  binary.reverse.each do |i|\n    i = i.to_i\n    i = i.to_s(2)\n\
    \    i = i.to_i\n    i = i.to_s(2)\n    i = i.to_i\n    i = i.to_s(2)\n    i =\
    \ i.to_i\n    i = i.to_s(2)\n    i = i.to_i\n    i = i.to_s(2)\n    i = i.to_i\n\
    \    i = i.to_s(2)\n    i = i.to_i\n    i = i.to_s(2)\n    i = i.to_i\n    i =\
    \ i.to_s(2)\n    i = i.to_i\n    i = i.to_s(2)\n    i = i.to_i\n    i = i.to_s(2)\n\
    \    i = i.to_i\n    i = i.to_s(2)\n    i = i.to_i\n    i = i.to_s(2)\n    i =\
    \ i.to_i\n    i = i.to_s(2)\n    i = i.to_i\n    i = i.to_s(2)\n    i = i.to_i\n\
    \    i = i.to_s(2)\n    i = i.to_i\n    i = i.to_s(2)\n    i = i.to_i\n    i =\
    \ i.to_s(2)\n    i = i.to_i\n    i = i.to_s(2)\n    i = i.to_i\n    i = i.to_s(2)\n\
    \    i = i.to_i\n    i = i.to_s(2)\n    i = i.to_i\n    i = i.to_s(2)\n    i =\
    \ i.to_i\n    i = i.to_s(2)\n    i = i.to_i\n    i = i.to_s(2)\n    i = i.to_i\n\
    \    i = i.to_s(2)\n    i = i.to_i\n    i = i.to_s(2)\n    i = i.to_i\n    i =\
    \ i.to_s(2)\n    i = i.to_i\n    i = i.to_s(2)\n    i = i.to_i\n    i = i.to_s(2)\n\
    \    i = i.to_i\n    i = i.to_s(2)\n    i = i.to_i\n    i = i.to_s(2)\n    i =\
    \ i.to_i\n    i = i.to_s(2)\n    i = i.to_i\n    i = i.to_s(2)\n    i = i.to_i\n\
    \    i = i.to_s(2)\n    i = i.to_i\n    i = i.to_s(2)\n    i = i.to_i\n    i =\
    \ i.to_s(", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(m,\
    \ \"0\")\nend", "  sum = 0\n  while n <= m\n    sum += n\n    n += 1\n  sum.to_s(2)\n\
    end", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(8,\
    \ '0')\nend", "  avg = ((n..m).sum.to_f / m.to_f).round\n  binary = []\n  while\
    \ n <= m\n    binary.push(\"#{n}b\")\n    n += 1\n  end\n  binary.push(\"#{m}b\"\
    )\n  binary.join\nend", "  avg = ((n..m).reduce(:+) / m).round\n  binary = avg.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\n\
    \  binary.to_i(2).to_s(2)\nend", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2)\n\
    end", "  avg = ((n..m).sum.to_f / m.to_f).round\n  binary = []\n  while n <= m\n\
    \    binary.push((n.to_s(2))[-1,1])\n    n += 1\n  binary.push((m.to_s(2))[-1,1])\n\
    \  binary.join\nend", "  n = n.to_i\n  m = m.to_i\n  if n >= m\n    -1\n  else\n\
    \    n.upto(m).inject(:+).to_s(2).to_i(2).to_s(2)\n  end\nend", "  avg = ((n..m).reduce(:+)\
    \ / m).round\n  binary = []\n  while n <= m\n    binary.push((n & m).to_s(2))\n\
    \    n += 1\n  end\n  binary.reverse.join if binary.length == 1\n  binary\nend",
  "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2)\nend", "  sum =\
    \ 0\n  while n <= m\n    sum += n\n    n += 1\n  sum.to_s(2)\nend", "  avg = ((n..m).reduce(:+)\
    \ / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(32, '0')\nend", "  avg = ((n..m).sum.to_f\
    \ / m).round\n  binary = []\n  while n <= m\n    binary.push(\"#{n}b\")\n    n\
    \ += 1\n  end\n  binary.push(\"#{m}b\")\n  binary.join\nend", "  avg = n/m\n \
    \ avg = Math.ceil(avg)\n  avg = Math.ceil(avg)\n  avg = Math.bin(avg)\n  avg =\
    \ avg.reverse\n  avg = Math.bin(avg)\n  avg = avg.reverse\n  avg = Math.bin(avg)\n\
    \  avg = avg.reverse\n  avg = Math.bin(avg)\n  avg = avg.reverse\n  avg = Math.bin(avg)\n\
    \  avg = avg.reverse\n  avg = Math.bin(avg)\n  avg = avg.reverse\n  avg = Math.bin(avg)\n\
    \  avg = avg.reverse\n  avg = Math.bin(avg)\n  avg = avg.reverse\n  avg = Math.bin(avg)\n\
    \  avg = avg.reverse\n  avg = Math.bin(avg)\n  avg = avg.reverse\n  avg = Math.bin(avg)\n\
    \  avg = avg.reverse\n  avg = Math.bin(avg)\n  avg = avg.reverse\n  avg = Math.bin(avg)\n\
    \  avg = avg.reverse\n  avg = Math.bin(avg)\n  avg = avg.reverse\n  avg = Math.bin(avg)\n\
    \  avg = avg.reverse\n  avg = Math.bin(avg)\n  avg = avg.reverse\n  avg = Math.bin(avg)\n\
    \  avg = avg.reverse\n  avg = Math.bin(avg)\n  avg = avg.reverse\n  avg = Math.bin(avg)\n\
    \  avg = avg.reverse\n  avg = Math.bin(avg)\n  avg = avg.reverse\n  avg = Math.bin(avg)\n\
    \  avg = avg.reverse\n  avg = Math.bin(avg)\n  avg = avg.reverse\n  avg = Math.bin(avg)\n\
    \  avg = avg.reverse\n  avg = Math.bin(avg)\n  avg = avg.reverse\n  avg = Math.bin(avg)\n\
    \  avg = avg.reverse\n  avg = Math.bin(avg)\n  avg = avg.reverse\n  avg = Math.bin(avg)\n\
    \  avg = avg.reverse\n  avg = Math.bin(avg)\n  avg = avg.reverse\n  avg = Math.bin(avg)\n\
    \  avg = avg.reverse\n  avg = Math.bin(avg)\n  avg = avg.reverse\n  avg = Math.bin(avg)\n\
    \  ", "  avg = ((n..m).reduce(:+) / m).round\n  binary = ((n / m).to_s(2).split('').map\
    \ { |i| i.to_i(2) }.join)\n  binary.reverse! if n < m\n  binary += ['0'] * (m\
    \ - binary.length)\n  binary.reverse! if n < m\n  binary\nend", "  avg = ((n..m).inject(:+)\
    \ / m).round\n  binary = []\n  while n <= m\n    binary.push(n.to_s(2).reverse.chars.join.to_i(2))\n\
    \    n += 1\n  end\n  binary.reverse.inject(:+).to_s(2).reverse.chars.join.to_i(2)\n\
    end", "  avg = ((n..m).reduce(:+) / m).round\n  binary = []\n  while n <= m\n\
    \    binary.unshift(n.to_s(2))\n    n += 1\n  end\n  binary.unshift(avg.to_s(2))\n\
    \  binary.join\nend", "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n  while\
    \ n <= m\n    binary.push(n.to_s(2))\n    n += 1\n  end\n  binary.reverse.each\
    \ do |b|\n    next if b.length < 2\n    binary.push(b[0, b.length - 1])\n  end\n\
    \  binary.join\nend", "  avg = ((n..m).sum.to_f / m.to_f).round\n  binary = []\n\
    \  while n <= m\n    binary.push((n.to_s(2))[-1,1])\n    n += 1\n  end\n  binary.join\n\
    end\n</cell>\n<cell>\nrounded_avg.call(1, 5)\n</cell>\n<cell>\nrounded_avg.call(7,\
    \ 5)\n</cell>\n<cell>\nrounded_avg.call(10, 20)\n</cell>\n<cell>\nrounded_avg.call(20,\
    \ 33)\n</cell>\n<text>\nExercise 3\nWrite a function that takes in two integers\
    \ and returns the sum of the squares of the first two numbers. \nThe sum of the\
    \ squares of the first two numbers is defined as the sum of the squares of the\
    \ first two numbers of the following numbers:", "  avg = ((n..m).reduce(:+) /\
    \ m).round\n  binary = []\n  while n != 0\n    binary.unshift(n % 2)\n    n /=\
    \ 2\n  end\n  binary.unshift(avg)\n  binary.join\nend", "  avg = ((n..m).sum.to_f\
    \ / m).round\n  binary = []\n  while n <= m\n    binary.push(n.to_s(2))\n    n\
    \ += 1\n  end\n  binary.push(m.to_s(2))\n  binary.reverse\n  binary.join\nend",
  "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(32, '0')\n\
    end", "  avg = n/m\n  avg = ((avg*10).to_i).to_s(2)\n  avg = avg.reverse\n  avg\
    \ = avg.insert(0,\"0b\")\n  avg = avg.insert(avg.length-1,\"0\")\n  return avg\n\
    end", "  sum = 0\n  while n <= m\n    sum += n\n    n += 1\n  sum.to_s(2).reverse.rjust(8,\
    \ \"0\")\nend", "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n  while n\
    \ <= m\n    binary.push((n..m).sum.to_s(2))\n    n += 1\n  end\n  binary.reverse.each\
    \ do |b|\n    binary = b.to_i(2) if b.to_i(2).to_s(2).length < b.to_i(2).length\n\
    \  end\n  return -1 if binary.include?(\"1\")\n  binary.reverse.join # return\
    \ binary string\nend\n</code>\n<|/ a tags=ruby,binary,math |>\n<| c |>\nI like\
    \ your solution, but I believe it can be simplified a bit. `binary.reverse.each\
    \ { |b| return -1 if b.to_i(2).to_s(2).length < b.to_i(2).length }` can be replaced\
    \ with `return -1 if binary.include?(\"1\")`.\n<|/ c |>\n<| c |>\nThanks for pointing\
    \ that out. I've updated the answer accordingly.\n<|/ c |>\n<| a tags=ruby,binary,math\
    \ |>\n<code>", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2)\n\
    end", "  avg = ((n..m).reduce(:+) / m).round\n  \n  if avg > m\n    -1\n  else\n\
    \    avg.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).",
  "  sum = 0\n  for i in (n..m)\n    sum += i\n  end\n  sum.round\n  sum.to_s(2).to_i(2).to_s(2)\n\
    end", "  avg = n/m\n  avg = ((avg*10).to_i).to_s(2)\n  avg = avg.gsub(/0./, '').gsub(/1/,\
    \ '0').gsub(/0/, '1')\n  avg = avg.gsub(/1/, '1')\n  avg = avg.gsub(/0/, '0')\n\
    \  avg = avg.gsub(/1/, '1')\n  avg = avg.gsub(/0/, '0')\n  avg = avg.gsub(/1/,\
    \ '1')\n  avg = avg.gsub(/0/, '0')\n  avg = avg.gsub(/1/, '1')\n  avg = avg.gsub(/0/,\
    \ '0')\n  avg = avg.gsub(/1/, '1')\n  avg = avg.gsub(/0/, '0')\n  avg = avg.gsub(/1/,\
    \ '1')\n  avg = avg.gsub(/0/, '0')\n  avg = avg.gsub(/1/, '1')\n  avg = avg.gsub(/0/,\
    \ '0')\n  avg = avg.gsub(/1/, '1')\n  avg = avg.gsub(/0/, '0')\n  avg = avg.gsub(/1/,\
    \ '1')\n  avg = avg.gsub(/0/, '0')\n  avg = avg.gsub(/1/, '1')\n  avg = avg.gsub(/0/,\
    \ '0')\n  avg = avg.gsub(/1/, '1')\n  avg = avg.gsub(/0/, '0')\n  avg = avg.gsub(/1/,\
    \ '1')\n  avg = avg.gsub(/0/, '0')\n  avg = avg.gsub(/1/, '1')\n  avg = avg.gsub(/0/,\
    \ '0')\n  avg = avg.gsub(/1/, '1')\n  avg = avg.gsub(/0/, '0')\n  avg = avg.gsub(/1/,\
    \ '1')\n  avg = avg.gsub(/0/, '0')\n  avg = avg.gsub(/1/, '1')\n  avg = avg.gsub(/0/,\
    \ '0')\n  avg = avg.gsub(/1/, '1')\n  avg = avg.gsub(/0/, '0')\n  avg = avg.gsub(/1/,\
    \ '1')\n  avg = avg.gsub(/0/, '0')\n  avg = avg.gsub(/1/, '1')\n  avg = avg.gsub(/0/,\
    \ '0')\n  avg = avg.gsub(/1/", "  avg = n/m\n  avg = Math.ceil(avg)\n  avg = Math.ceil(avg)\n\
    \  avg = Math.bin(avg)\n  return avg\nend", "  avg = ((n..m).sum.to_f / m.to_f).round\n\
    \  binary = []\n  while n <= m\n    binary.push((n..m).sum.to_s(2))\n    n +=\
    \ 1\n  end\n  binary.reverse.each do |b|\n    binary = b.to_i(2) if b != \"0\"\
    \n  end\n  return -1 if binary.length == 0\n  return binary\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| a dscore=0 |>\n<code>", "  avg = n/m\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float.log(avg,2))\n  return \"0b\" + avg.to_s(2)\nend",
  "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n  while n <= m\n    binary.push(n.to_s(2))\n\
    \    n += 2\n  end\n  binary.reverse!\n  binary.push(\"0b\" + binary.join)\n \
    \ binary.pop\nend\n</code>\n<|/ a tags=ruby,binary,math |>\n<| a dscore=0 |>\n\
    <code>", "  avg = n/m\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg.to_s(2)\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = av", "  sum = 0\n  while n <= m\n    sum += n\n    n += 1\n  end\n  sum.to_s(2).to_i(2).to_s(2)\n\
    end", "  avg = n/m\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  avg = Math.ceil(avg", "  avg = n/m\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg\
    \ * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg\
    \ * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg\
    \ * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg\
    \ * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg\
    \ * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n", "  avg\
    \ = n/m\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(10, Math.ceil(Math.log10(avg)))\n\
    \  avg = Math.ceil(avg)\n  avg = Math.pow(10, Math.ceil(Math.log10(avg)))\n  avg\
    \ = Math.ceil(avg)\n  avg = Math.pow(10, Math.ceil(Math.log10(avg)))\n  avg =\
    \ Math.ceil(avg)\n  avg = Math.pow(10, Math.ceil(Math.log10(avg)))\n  avg = Math.ceil(avg)\n\
    \  avg = Math.pow(10, Math.ceil(Math.log10(avg)))\n  avg = Math.ceil(avg)\n  avg\
    \ = Math.pow(10, Math.ceil(Math.log10(avg)))\n  avg = Math.ceil(avg)\n  avg =\
    \ Math.pow(10, Math.ceil(Math.log10(avg)))\n  avg = Math.ceil(avg)\n  avg = Math.pow(10,\
    \ Math.ceil(Math.log10(avg)))\n  avg = Math.ceil(avg)\n  avg = Math.pow(10, Math.ceil(Math.log10(avg)))\n\
    \  avg = Math.ceil(avg)\n  avg = Math.pow(10, Math.ceil(Math.log10(avg)))\n  avg\
    \ = Math.ceil(avg)\n  avg = Math.pow(10, Math.ceil(Math.log10(avg)))\n  avg =\
    \ Math.ceil(avg)\n  avg = Math.pow(10, Math.ceil(Math.log10(avg)))\n  avg = Math.ceil(avg)\n\
    \  avg = Math.pow(10, Math.ceil(Math.log10(avg)))\n  avg = Math.ceil(avg)\n  avg\
    \ = Math.pow(10, Math.ceil(Math.log10(avg)))\n  avg = Math.ceil(avg)\n  avg =\
    \ Math.pow(10, Math.ceil(Math.log10(avg)))\n  avg = Math.ceil(avg)\n  avg = Math.pow(10,\
    \ Math.ceil(Math.log10(avg)))\n  avg = Math.ceil(avg)\n  avg = Math.pow(10, Math.ceil(Math.log10(avg)))\n\
    \  avg = Math.ceil(avg)\n  avg = Math.pow(10, Math.ceil(Math.log10(avg)))\n  avg\
    \ = Math.ceil(avg)\n  avg = Math.pow(10, Math.ceil(Math.log10(avg)))\n  avg =\
    \ Math.ceil(avg)\n  avg = Math.pow(10, Math.ceil(Math.log10(avg)))\n  avg = Math.ceil(avg)\n\
    \  avg = Math.pow(10, Math.ceil(Math.log10(avg)))\n  avg = Math.ceil(avg)\n  avg\
    \ = Math.pow(10, Math.ceil(Math.log10(avg)))\n  avg = Math.ceil(avg)\n  avg =\
    \ Math.pow(10, Math.ceil(Math.log10(avg", "  avg = n/m\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n  return \"0b\" + avg.to_s(2)\n\
    end", "  sum = 0\n  while n <= m\n    sum += n\n    n += 1\n  end\n  sum.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\n\
    end", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2)\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis doesn't work for negative numbers. Try `rounded_avg.call(-5,\
    \ 5)`.\n<|/ c |>\n<| c |>\nI added a solution for negative numbers. I hope it\
    \ helps.\n<|/ c |>\n<| c |>\nThis doesn't work for negative numbers. Try `rounded_avg.call(-5,\
    \ 5)`.\n<|/ c |>\n<| c |>\nI added a solution for negative numbers. I hope it\
    \ helps.\n<|/ c |>\n<| c |>\nThis doesn't work for negative numbers. Try `rounded_avg.call(-5,\
    \ 5)`.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  avg = n/m\n  avg = ((avg*10).to_s(2)).rjust(4,\"\
    0\")\n  avg = avg.to_i(2).to_s(2)\n  avg = ((avg*10).to_s(2)).rjust(4,\"0\")\n\
    \  avg = avg.to_i(2).to_s(2)\n  return avg\nend", "  avg = n/m\n  avg = ((avg*10).to_s(2)).rjust(8,\
    \ \"0\")\n  avg = avg.to_i(2).to_s(8)\n  avg = avg.to_s(8)\n  avg = avg.to_i(2).to_s(8)\n\
    \  avg = avg.to_s(8)\n  return avg\nend", "  avg = n/m\n  avg = Math.ceil(avg)\n\
    \  avg = Math.ceil(avg)\n  avg = Math.bin(avg)\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  avg = avg.reverse\n  avg = avg.", "  avg = ((n..m).sum.to_f\
    \ / m.to_f).round\n  binary = []\n  while n <= m\n    binary.push(n.to_s(2))\n\
    \    n += 2\n  end\n  binary.reverse!\n  binary.join\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a tags=ruby |>\n<code>", "  avg = ((n..m).reduce(:+) / m).round\n  binary\
    \ = []\n  while n <= m\n    binary.unshift(n.to_s(2))\n    n += 1\n  end\n  binary.unshift(avg.to_s(2))\n\
    \  binary.join\nend\n</code>\n<|/ a tags=ruby,binary,math |>\n<| a dscore=1 |>\n\
    <code>", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(8,\
    \ '0')\nend", "  avg = ((n..m).sum.to_f / m.to_f).round\n  binary = []\n  while\
    \ n <= m\n    binary.push(\"#{n}b\")\n    n += 1\n  end\n  binary.reverse.join\
    \ + avg\nend", "  avg = ((n..m).inject(:+) / m).round\n  binary = []\n  while\
    \ n <= m\n    binary.push((n & m).to_s(2))\n    n += 1\n  end\n  binary.reverse\n\
    \  binary.join\nend", "  avg = ((n..m).sum.to_f / m.to_f).round\n  binary = []\n\
    \  while n <= m\n    binary.push((n..m).sum.to_s(2))\n    n += 1\n  end\n  binary.reverse.each_with_index\
    \ do |digit, i|\n    digit = digit.chars.first\n    digit = digit.to_i(2) if digit\
    \ == 0\n    binary[i] = digit\n  end\n  binary.join\nend", "  avg = ((n..m).sum.to_f\
    \ / m).round\n  binary = []\n  while n <= m\n    binary.push(n.to_s(2))\n    n\
    \ += 2\n  end\n  binary.push(m.to_s(2))\n  binary.reverse\n  binary.join\nend",
  "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(8, '0')\n\
    end", "  avg = ((n..m).sum.to_f / m.to_f).round\n  binary = ((n..m).sum.to_s(2).to_i(2)).to_s(2).to_i(2).to_s(2)\n\
    \  binary.gsub!(/.{8}/, '0') \n  binary.gsub!(/.{4}/, '1') \n  binary.gsub!(/.{2}$/,\
    \ '0') \n  binary.gsub!(/.{1}/, '1') \n  binary.gsub!(/.{1}/, '0') \n  binary.gsub!(/.{1}/,\
    \ '1') \n  binary.gsub!(/.{1}/, '0') \n  binary.gsub!(/.{1}/, '1') \n  binary.gsub!(/.{1}/,\
    \ '0') \n  binary.gsub!(/.{1}/, '1') \n  binary.gsub!(/.{1}/, '0') \n  binary.gsub!(/.{1}/,\
    \ '1') \n  binary.gsub!(/.{1}/, '0') \n  binary.gsub!(/.{1}/, '1') \n  binary.gsub!(/.{1}/,\
    \ '0') \n  binary.gsub!(/.{1}/, '1') \n  binary.gsub!(/.{1}/, '0') \n  binary.gsub!(/.{1}/,\
    \ '1') \n  binary.gsub!(/.{1}/, '0') \n  binary.gsub!(/.{1}/, '1') \n  binary.gsub!(/.{1}/,\
    \ '0') \n  binary.gsub!(/.{1}/, '1') \n  binary.gsub!(/.{1}/, '0') \n  binary.gsub!(/.{1}/,\
    \ '1') \n  binary.gsub!(/.{1}/, '0') \n  binary.gsub!(/.{1}/, '1') \n  binary.gsub!(/.{1}/,\
    \ '0') \n  binary.gsub!(/.{1}/, '1') \n  binary.gsub!(/.{1}/, '0') \n  binary.gsub!(/.{1}/,\
    \ '1') \n  binary.gsub!(/.{1}/, '0') \n  binary.gsub!(/.{1}/, '1') \n  binary.gsub!(/.{1}/,\
    \ '0') \n  binary.gsub!(/.{", "  avg = ((n..m).sum.to_f / m).round\n  binary =\
    \ []\n  while n <= m\n    binary.push((n..m).sum.to_s(2))\n    n += 1\n  end\n\
    \  binary.reverse.each do |i|\n    i = i.to_i(2).to_s(2)\n    i = i.to_s(2)\n\
    \    i = i.insert(i[/1$/].length, \"0\")\n    i = i.insert(i[/2$/].length, \"\
    0\")\n    i = i.insert(i[/3$/].length, \"0\")\n    i = i.insert(i[/4$/].length,\
    \ \"0\")\n    i = i.insert(i[/5$/].length, \"0\")\n    i = i.insert(i[/6$/].length,\
    \ \"0\")\n    i = i.insert(i[/7$/].length, \"0\")\n    i = i.insert(i[/8$/].length,\
    \ \"0\")\n    i = i.insert(i[/9$/].length, \"0\")\n    i = i.insert(i[/10$/].length,\
    \ \"0\")\n    i = i.insert(i[/11$/].length, \"0\")\n    i = i.insert(i[/12$/].length,\
    \ \"0\")\n    i = i.insert(i[/13$/].length, \"0\")\n    i = i.insert(i[/14$/].length,\
    \ \"0\")\n    i = i.insert(i[/15$/].length, \"0\")\n    i = i.insert(i[/16$/].length,\
    \ \"0\")\n    i = i.insert(i[/17$/].length, \"0\")\n    i = i.insert(i[/18$/].length,\
    \ \"0\")\n    i = i.insert(i[/19$/].length, \"0\")\n    i = i.insert(i[/20$/].length,\
    \ \"0\")\n    i = i.insert(i[/21$/].length, \"0\")\n    i = i.insert(i[/22$/].length,\
    \ \"0\")\n    i = i.insert(i[/23$/].length, \"0\")\n    i = i.insert(i[/24$/].length,\
    \ \"0\")\n    i = i.insert(i[/25$/].length, \"0\")\n    i = i.insert(i[/26$/].length,\
    \ \"0\")\n    i = i.insert(i[/27$/].length, \"0\")\n    i = i.insert(i[/28$/].length,\
    \ \"0\")\n    i = i.insert(i[/29$/].length, \"0\")\n    i = i.insert(i[/30$/].length,\
    \ \"0\")\n    i = i.insert(i[/31$/].length, \"0\")\n    i = i.insert(i[/", " \
    \ avg = n/m\n  avg = ((avg*10).to_i).to_s(2)\n  avg = avg.reverse\n  avg = avg.insert(0,\
    \ \"0\")\n  avg = avg.reverse\n  avg = avg.insert(0, \"0\")\n  avg = avg.reverse\n\
    \  return avg\nend", "  avg = ((n..m).sum.to_f / m.to_f).round\n  binary = []\n\
    \  while n <= m\n    binary.push(n.to_s(2))\n    n += 1\n  end\n  binary.reverse.each\
    \ do |b|\n    next if b.length < 2\n    binary.push(b[0, b.length - 1])\n  end\n\
    \  binary.join\nend\n</cell>\n<cell>", "  sum = 0\n  for i in (n..m)\n    sum\
    \ += i\n  end\n  sum.to_s(2).to_i(2).to_s(2)\nend", "  avg = ((n..m).reduce(:+)\
    \ / m).to_s(2)\n  avg.to_i(2).to_s(2)\nend", "  avg = n/m\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(10, Math.ceil(Math.log2(avg)))\n  return \"0b\" + avg.to_s(2)\n\
    end", "  avg = ((n..m).reduce(:+) / m).round\n  binary = []\n  while n <= m\n\
    \    binary.unshift(n.to_s(2))\n    n += 1\n  end\n  binary.unshift(avg.to_s(2))\n\
    \  binary.join\nend", "  avg = n/m\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg)/Math.log(2))\n\
    \  return \"0b\" + avg.to_s(2)\nend", "  avg = ((n..m).inject(:+) / m).round\n\
    \  binary = []\n  while n <= m\n    binary.push((n & m).to_s(2))\n    n += 1\n\
    \  end\n  binary.reverse.join if binary.size > 0\nend", "  avg = n/m\n  avg =\
    \ Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n  return avg.to_s(2)\n\
    end", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2)\nend", " \
    \ avg = ((n..m).inject(:+) / m).round\n  binary = []\n  while n != 0\n    binary.unshift(n\
    \ % 2)\n    n /= 2\n  end\n  binary.unshift(avg)\n  binary.join\nend", "  avg\
    \ = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(8, '0')\nend",
  "  avg = n/m\n  avg = Math.ceil(avg)\n  avg = Math.pow(2,avg)\n  avg = Math.bin(avg)\n\
    \  return avg\nend", "  avg = ((n..m).inject(:+) / m).round\n  avg.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\n\
    end", "  avg = ((n..m).inject(:+) / m).round\n  binary = []\n  while n <= m\n\
    \    binary.push((n..m).inject(:+) / m)\n    n += 1\n  end\n  if n == m\n    binary.push(n)\n\
    \  end\n  binary.inject(:+).to_s(2)\nend\n</cell>\n<cell>", "  avg = ((n + m)\
    \ / 2).round\n  binary = []\n  while n <= m\n    binary.push((n & m).to_s(2))\n\
    \    n += 1\n    m -= 1\n  end\n  binary.reverse\n  binary.join\nend\n</code>\n\
    <|/ a tags=ruby,binary,math |>\n<| a tags=ruby,binary,math |>\n<code>", "  avg\
    \ = ((n..m).inject(:+) / m).round\n  avg.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\n\
    end\n</cell>\n<code language=julia-1.5>\n@assert rounded_avg(1, 5) == \"0b11\"\
    \n@assert rounded_avg(7, 5) == -1\n@assert rounded_avg(10, 20) == \"0b1111\"\n\
    @assert rounded_avg(20, 33) == \"0b11010\"\n</cell>\n<text>\nExercise 2\nWrite\
    \ a function that takes in a list of integers and returns the number of positive\
    \ integers in the list.", "  avg = ((n..m).inject(:+) / m).round\n  binary = []\n\
    \  while n <= m\n    binary.push((n & m).to_s(2))\n    n += 1\n  end\n  binary.reverse\n\
    \  binary.join\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like this solution,\
    \ but I wonder if there is a way to do it without using inject.\n<|/ c |>\n<|\
    \ c |>\nI added a solution without inject\n<|/ c |>\n<| a tags=ruby,binary,math\
    \ |>\nHere's a solution without inject:\n<code>", "  sum = 0\n  while n <= m\n\
    \    sum += n\n    n += 1\n  end\n  sum.to_s(2).reverse.rjust(8, \"0\")\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a |>\n<code>", "  avg = ((n..m).reduce(:+) / m).round\n\
    \  binary = []\n  while n <= m\n    binary.push(n.to_s(2))\n    n += 1\n  end\n\
    \  binary.reverse.each do |b|\n    next if b.length < 2\n    binary.push(b[0,\
    \ b.length - 1])\n  end\n  binary.join\nend\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\nThis doesn't work for negative numbers. `rounded_avg.call(-5, 5)` returns\
    \ `\"-0b11\"` instead of `\"0b11\"`.\n<|/ c |>\n<| c |>\nI added a fix for negative\
    \ numbers. Thanks!\n<|/ c |>\n<| c |>\nI added a fix for negative numbers. Thanks!\n\
    <|/ c |>\n<| c |>\nI added a fix for negative numbers. Thanks!\n<|/ c |>\n<| c\
    \ |>\nI added a fix for negative numbers. Thanks!\n<|/ c |>\n<| a tags=ruby |>\n\
    <code>", "  avg = ((n..m).sum.to_f / m).round\n  binary = ((n..m).sum.to_f / m).to_s(2)\n\
    \  binary.reverse!\n  binary.insert(0, \"0b\")\n  binary.insert(binary.length,\
    \ \"0\")\n  binary.insert(0, \"0b\")\n  binary.insert(binary.length, \"0\")\n\
    \  binary.insert(0, \"0b\")\n  binary.insert(binary.length, \"0\")\n  binary.insert(0,\
    \ \"0b\")\n  binary.insert(binary.length, \"0\")\n  binary.insert(0, \"0b\")\n\
    \  binary.insert(binary.length, \"0\")\n  binary.insert(0, \"0b\")\n  binary.insert(binary.length,\
    \ \"0\")\n  binary.insert(0, \"0b\")\n  binary.insert(binary.length, \"0\")\n\
    \  binary.insert(0, \"0b\")\n  binary.insert(binary.length, \"0\")\n  binary.insert(0,\
    \ \"0b\")\n  binary.insert(binary.length, \"0\")\n  binary.insert(0, \"0b\")\n\
    \  binary.insert(binary.length, \"0\")\n  binary.insert(0, \"0b\")\n  binary.insert(binary.length,\
    \ \"0\")\n  binary.insert(0, \"0b\")\n  binary.insert(binary.length, \"0\")\n\
    \  binary.insert(0, \"0b\")\n  binary.insert(binary.length, \"0\")\n  binary.insert(0,\
    \ \"0b\")\n  binary.insert(binary.length, \"0\")\n  binary.insert(0, \"0b\")\n\
    \  binary.insert(binary.length, \"0\")\n  binary.insert(0, \"0b\")\n  binary.insert(binary.length,\
    \ \"0\")\n  binary.insert(0, \"0b\")\n  binary.insert(binary.length, \"0\")\n\
    \  binary.insert(0, \"0b\")\n  binary.insert(binary.length, \"0\")\n  binary.insert(0,\
    \ \"0b\")\n  binary.insert(binary.length, \"0\")\n  binary.insert(0, \"0b\")\n\
    \  binary.insert(binary.length, \"0\")\n  binary.insert(0, \"0b\")\n  binary.insert(binary.length,\
    \ \"0\")\n  binary.insert(0, \"0b\")\n  binary.insert(binary.length, \"0\")\n\
    \  binary.insert(0, \"0b\")\n  binary.insert(binary.length, \"0\")\n  binary.insert(0,\
    \ \"0b\")\n  binary.insert(binary.length, \"0\")\n  binary.insert(0, \"0b\")\n\
    \  binary.insert(binary.length, \"0\")\n  binary.insert(0, \"0b\")\n  binary.insert(binary.length,\
    \ \"0\")\n  binary.insert(", "  avg = ((n..m).sum / m).round\n  binary = []\n\
    \  while n <= m\n    binary.push n.to_s(2)\n    n += 1\n  end\n  binary.push m.to_s(2)\n\
    \  binary.push avg.to_s(2)\n  binary.join\nend", "  avg = ((n..m).sum.to_f / m).round\n\
    \  binary = []\n  while n <= m\n    binary.push((n..m).sum.to_s(2))\n    n +=\
    \ 1\n  end\n  binary.reverse.inject(:+).to_s(2)\nend", "  avg = ((n..m).sum.to_f\
    \ / m).round\n  binary = []\n  while n <= m\n    binary.push((n..m).sum.to_s(2))\n\
    \    n += 1\n  end\n  binary.reverse.each do |x|\n    if x.to_i(2) < m\n     \
    \ return -1\n    end\n  end\n  binary.join\nend", "  avg = ((n..m).sum.to_f /\
    \ m).round\n  binary = []\n  while n <= m\n    binary.push((n..m).sum.to_s(2))\n\
    \    n += 1\n  end\n  binary.push((n..m).sum.to_s(2))\n  binary.reverse!\n  binary.join\n\
    end\n</code>\n<|/ a |>\n<| a tags=ruby,binary,math,algorithm |>\n<code>", "  avg\
    \ = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(8, '0')\nend",
  "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2)\nend", "  sum =\
    \ 0\n  while n <= m\n    sum += n\n    n += 1\n  sum.to_s(2)\nend", "  avg = ((n..m).reduce(:+)\
    \ / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(8, \"0\")\nend", "  avg = n/m\n  avg\
    \ = Math.ceil(avg)\n  avg = Math.pow(2,avg)\n  avg = avg.to_s(2)\n  avg = avg.reverse\n\
    \  avg = avg.reverse\n  return avg\nend", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n\
    \  avg.to_i(2).to_s(2)\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ work if m is greater than n\n<|/ c |>\n<| c |>\nI added a test case to show\
    \ that it does. I didn't want to assume that `m` was always greater than `n`.\n\
    <|/ c |>\n<| c |>\nI added a test case to show that it does. I didn't want to\
    \ assume that `m` was always greater than `n`.\n<|/ c |>\n<| c |>\nI added a test\
    \ case to show that it does. I didn't want to assume that `m` was always greater\
    \ than `n`.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  avg = ((n..m).sum.to_f /\
    \ m).round\n  binary = []\n  while n <= m\n    binary.push((n..m).sum.to_s(2))\n\
    \    n += 1\n  end\n  binary.reverse.each_with_index do |digit, index|\n    digit\
    \ = digit.to_i(2).to_s(2)\n    digit = digit.insert(index, \"0\")\n    binary.insert(index,\
    \ digit)\n  end\n  binary.join\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks\
    \ for your answer. I am not allowed to use any built-in methods. I am only allowed\
    \ to use loops, conditionals, arrays, strings and string manipulation. I am not\
    \ allowed to use any built-in methods. I am only allowed to use loops, conditionals,\
    \ arrays, strings and string manipulation. I am not allowed to use any built-in\
    \ methods. I am only allowed to use loops, conditionals, arrays, strings and string\
    \ manipulation. I am not allowed to use any built-in methods. I am only allowed\
    \ to use loops, conditionals, arrays, strings and string manipulation. I am not\
    \ allowed to use any built-in methods. I am only allowed to use loops, conditionals,\
    \ arrays, strings and string manipulation. I am not allowed to use any built-in\
    \ methods.\n<|/ c |>\n<| c |>\nI added a solution that uses only loops, conditionals,\
    \ arrays, strings and string manipulation. I am not allowed to use any built-in\
    \ methods. I am only allowed to use loops, conditionals, arrays, strings and string\
    \ manipulation. I am not allowed to use any built-in methods. I am only allowed\
    \ to use loops, conditionals, arrays, strings and string manipulation. I am not\
    \ allowed to use any built-in methods. I am only allowed to use loops, conditionals,\
    \ arrays, strings and string manipulation. I am not allowed to use any built-in\
    \ methods. I am only allowed to use loops, conditionals, arrays, strings and string\
    \ manipulation. I am not allowed to use any built-in methods.\n<|/ c |>\n<| c\
    \ |>\nI added a solution that uses only loops, conditionals, arrays, strings and\
    \ string manipulation. I am not allowed to use any built-in methods. I am only\
    \ allowed to use loops, conditionals, arrays, strings and string manipulation.\
    \ I am not allowed to use any built-in methods. I am only allowed to use loops,\
    \ conditionals, arrays, strings and string manipulation. I am not allowed to use\
    \ any built-in methods. I am only allowed to use loops, conditionals, arrays,\
    \ strings and string manipulation. I am not allowed to use any built-in methods.\
    \ I am only allowed to use loops, conditional", "  avg = ((n + m) / 2).round\n\
    \  binary = []\n  while n <= m\n    binary.push((n & m).to_s(2))\n    n += 1\n\
    \  end\n  binary.reverse\n  binary.join\nend", "  avg = ((n..m).sum.to_f / m).round\n\
    \  binary = []\n  while n <= m\n    binary.push(n.to_s(2))\n    n += 1\n  end\n\
    \  binary.reverse!\n  binary.join\nend", "  sum = 0\n  while n <= m\n    sum +=\
    \ n\n    n += 1\n  sum.to_s(2)\nend", "  avg = ((n..m).sum / m).round\n  binary\
    \ = []\n  while n != 0\n    binary.push(n % 2)\n    n /= 2\n  end\n  binary.reverse!\n\
    \  binary.join\nend", "  avg = ((n..m).reduce(:+) / m).round\n  binary = []\n\
    \  while n <= m\n    binary.push((n..m).reduce(:+) / m)\n    n += 1\n  end\n \
    \ binary.reverse.each do |i|\n    binary.unshift(i)\n  end\n  binary.reduce(:+).to_s(2)\n\
    end\n</cell>\n<cell>", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(8,\
    \ '0')\nend", "  avg = n/m\n  avg = Math.ceil(avg)\n  avg = Math.trunc(avg)\n\
    \  avg = bin(avg)\n  return avg\nend", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n\
    \  avg.to_i(2).to_s(2)\nend", "  avg = ((n..m).inject(:+) / m).round\n  binary\
    \ = []\n  while n <= m\n    binary.push((n & m).to_s(2))\n    n += 1\n  end\n\
    \  binary.reverse\n  binary.join\nend\n</code>\n<|/ a tags=ruby,binary,math |>\n\
    <| a tags=ruby,binary,math |>\n<code>", "  avg = n/m\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(10, Math.ceil(Math.log10(avg)))\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(10, Math.ceil(Math.log10(avg)))\n  return \"0b\" + avg.to_s(2)\n\
    end", "  avg = n/m\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg\
    \ * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg\
    \ * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg\
    \ * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg\
    \ * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg\
    \ * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n", "  avg\
    \ = n/m\n  avg = Math.ceil(avg)\n  avg = Math.pow(2,avg)\n  avg = Math.bin(avg)\n\
    \  avg = avg.reverse\n  avg = avg.to_s\n  return avg\nend", "  avg = n/m\n  avg\
    \ = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float::MANTISSA)\n  return \"0b\"\
    \ + avg.to_s(2)\nend", "  sum = 0\n  while n <= m\n    sum += n\n    n += 1\n\
    \  sum.to_s(2)\nend", "  avg = ((n + m) / 2).round\n  binary = []\n  while n <=\
    \ m\n    binary.push(n.to_s(2))\n    n += 1\n  end\n  binary.push(m.to_s(2))\n\
    \  binary.push(avg.to_s(2))\n  binary.join(\"0b\")\nend", "  avg = ((n..m).reduce(:+)\
    \ / m).to_s(2)\n  avg.to_i(2).to_s(2).rjust(8, '0')\nend", "  avg = ((n..m).inject(:+)\
    \ / m).round\n  binary = ((avg % 1).to_s(2)).rjust(8, '0')\n  \n  if n >= m\n\
    \    -1\n  else\n    binary\n  end\nend", "  avg = ((n..m).reduce(:+) / m).to_s(2)\n\
    \  avg.to_i(2).to_s(2).rjust(32, '0')\nend", "  avg = n/m\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg\
    \ * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg\
    \ * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg\
    \ * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg\
    \ * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg\
    \ * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n\
    \  avg = Math.ceil(avg)\n  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n\
    \  avg = avg * Math.pow(2,Float.log(avg,2))\n  avg = Math.ceil(avg)\n  avg = avg\
    \ * Math.pow(2,Float.log(avg,2))\n"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
