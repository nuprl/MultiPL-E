name: HumanEval_151_double_the_difference
language: rb
prompt: "# Given a list of numbers, return the sum of squares of the numbers\n# in\
  \ the list that are odd. Ignore numbers that are negative or not integers.\n# >>>\
  \ double_the_difference.call([1, 3, 2, 0])\n# 10\n# >>> double_the_difference.call([-1,\
  \ -2, 0])\n# 0\n# >>> double_the_difference.call([9, -2])\n# 81\n# >>> double_the_difference.call([0])\n\
  # 0\n# If the input list is empty, return 0.\ndef double_the_difference(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_double_the_difference\n\
  \    candidate = method(:double_the_difference)\n    assert_equal(0, candidate.call([]))\n\
  \    assert_equal(25, candidate.call([5.0, 4.0]))\n    assert_equal(0, candidate.call([0.1,\
  \ 0.2, 0.3]))\n    assert_equal(0, candidate.call([-10.0, -20.0, -30.0]))\n    assert_equal(0,\
  \ candidate.call([-1.0, -2.0, 8.0]))\n    assert_equal(34, candidate.call([0.2,\
  \ 3.0, 5.0]))\n    assert_equal(165, candidate.call([-9.0, -7.0, -5.0, -3.0, -1.0,\
  \ 1.0, 3.0, 5.0, 7.0, 9.0]))\n  end\nend\n"
completions: ["  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n    elsif\
    \ x.is_a?(Integer) && x < 0\n      0\n    else\n      x + x\n    end\n  end\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  lst.each do |x|\n\
    \    if x.is_a?(Integer) && x > 0\n      x\n    else\n      0\n    end\n  end\n\
    end", "  lst.each do |x|\n    next if x.is_a?(Numeric) or x.to_i.zero?\n    next\
    \ if x.is_a?(String) or x.to_i.zero?\n    next if x.is_a?(Fixnum) or x.to_i.zero?\n\
    \    next if x.is_a?(Bignum) or x.to_i.zero?\n    next if x.is_a?(TrueClass) or\
    \ x.to_i.zero?\n    next if x.is_a?(FalseClass) or x.to_i.zero?\n    next if x.is_a?(Object)\
    \ or x.to_i.zero?\n    next if x.is_a?(Array) or x.to_i.zero?\n    next if x.is_a?(Hash)\
    \ or x.to_i.zero?\n    next if x.is_a?(Proc)\n    next if x.is_a?(IO) or x.to_i.zero?\n\
    \    next if x.is_a?(StringIO) or x.to_i.zero?\n    next if x.is_a?(IO::NULL)\
    \ or x.to_i.zero?\n    next if x.is_a?(IO::STDERR) or x.to_i.zero?\n    next if\
    \ x.is_a?(IO::STDOUT) or x.to_i.zero?\n    next if x.is_a?(IO::STDIN) or x.to_i.zero?\n\
    \    next if x.is_a?(IO::File) or x.to_i.zero?\n    next if x.is_a?(IO::File::NULL)\
    \ or x.to_i.zero?\n    next if x.is_a?(IO::File::STDERR) or x.to_i.zero?\n   \
    \ next if x.is_a?(IO::File::STDOUT) or x.to_i.zero?\n    next if x.is_a?(IO::File::STDIN)\
    \ or x.to_i.zero?\n    next if x.is_a?(IO::File::File) or x.to_i.zero?\n    next\
    \ if x.is_a?(IO::File::File::NULL) or x.to_i.zero?\n    next if x.is_a?(IO::File::File::STDERR)\
    \ or x.to_i.zero?\n    next if x.is_a?(IO::File::File::STDOUT) or x.to_i.zero?\n\
    \    next if x.is_a?(IO::File::File::STDIN) or x.to_i.zero?\n    next if x.is_a?(IO::File::File::File)\
    \ or x.to_i.zero?\n    next if x.is_a?(IO::File::File::File::NULL) or x.to_i.zero?\n\
    \    next if x.is_a?", "  lst.inject(0) { |sum, item| sum + item if item % 2 ==\
    \ 1 }\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a dscore=0 |>\n<code>",
  "  lst.inject(0) { |sum, el| sum + el if el % 2 == 1 }\nend", "  lst.each do |x|\n\
    \    if x.is_a? Integer\n      x if x % 2 == 1\n    elsif x.is_a? Float\n    \
    \  x if x % 2 == 0\n    else\n      0\n    end\n  end.reduce(:+)\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nThis doesn't work if the list contains negative numbers.\
    \ Try `double_the_difference.call([-1, -2, 0])`.\n<|/ c |>\n<| c |>\nIt does work,\
    \ just tested it out. `double_the_difference.call([-1, -2, 0])` returns `0`.\n\
    <|/ c |>\n<| c |>\nYes, it does. But it also returns `0` for `double_the_difference.call([9,\
    \ -2])`.\n<|/ c |>\n<| c |>\nAh, I see what you mean. Yes, I see what you mean.\
    \ Thanks for pointing that out. I've updated my answer to fix it.\n<|/ c |>\n\
    <| c |>\nI see what you mean. Yes, I see what you mean. Thanks for pointing that\
    \ out. I've updated my answer to fix it.\n<|/ c |>\n<| a tags=ruby |>\n<code>",
  "  lst.each do |n|\n    if n.is_a?(Integer) && n > 0\n      n += n\n    end\n  end\n\
    \  lst.inject(0) {|sum, n| sum + n * n }\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nI like your solution, but I feel like it could be improved. For\
    \ example, why not just `lst.inject(0) {|sum, n| sum + n * n }` and then `return\
    \ sum if sum > 0` instead of `return sum if sum > 0` and `return 0 if sum < 0`?\n\
    <|/ c |>\n<| c |>\n: Because `inject` returns the original value if no block is\
    \ given. `inject` also returns the original value if the block returns `nil`.\n\
    <|/ c |>\n<| c |>\nAh I see. Thanks for the clarification.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  lst.each do |x|\n    if x.is_a? Integer\n      x % 2 == 0 ?\
    \ x * 2 : x\n    elsif x.is_a? Float\n      x % 2 == 0 ? x * 2 : x\n    else\n\
    \      0\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n\
    \    else\n      0\n    end\n  end\nend", "  lst.each do |x|\n    if x.is_a? Integer\n\
    \      x if x % 2 == 0\n    else\n      0\n    end\n  end.reduce(:+)\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis doesn't answer the question. He\
    \ wants to know why his code doesn't work, not how to fix it.\n<|/ c |>\n<| c\
    \ |>\nI agree with you. My answer was more of a \"why doesn't this work\" than\
    \ a \"how do I fix it\" type of answer. I'll edit my answer to include a more\
    \ \"how do I fix it\" type of answer.\n<|/ c |>\n<| c |>\nI appreciate your efforts,\
    \ but I believe that your answer doesn't answer the question. He wants to know\
    \ why his code doesn't work, not how to fix it.\n<|/ c |>\n<| c |>\nI agree with\
    \ you. My answer was more of a \"why doesn't this work\" than a \"how do I fix\
    \ it\" type of answer. I'll edit my answer to include a more \"how do I fix it\"\
    \ type of answer.\n<|/ c |>\n<| c |>\nI appreciate your efforts, but I believe\
    \ that your answer doesn't answer the question. He wants to know why his code\
    \ doesn't work, not how to fix it.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n\
    The problem is that the return value of each is nil when the block returns false.\
    \ \n<code>", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n \
    \   elsif x.is_a?(Integer) && x < 0\n      0\n    else\n      x * x\n    end\n\
    \  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>", "  lst.inject(0)\
    \ { |sum, el| sum + el if el % 2 == 1 }\nend", "  lst.each do |x|\n    if x.is_a?(Integer)\
    \ && x > 0\n      x\n    else\n      0\n    end\n  end\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis doesn't answer the question. He wants to know why his code\
    \ doesn't work. Your code doesn't do that.\n<|/ c |>\n<| c |>\nI agree with you.\
    \ I just wanted to show a way to solve the problem using Ruby without using any\
    \ loops. I didn't want to give a complete solution. :)\n<|/ c |>\n<| c |>\nI agree\
    \ with you. I just wanted to show a way to solve the problem using Ruby without\
    \ using any loops. I didn't want to give a complete solution. :)\n<|/ c |>\n<|\
    \ c |>\nI agree with you. I just wanted to show a way to solve the problem using\
    \ Ruby without using any loops. I didn't want to give a complete solution. :)\n\
    <|/ c |>\n<| c |>\nI agree with you. I just wanted to show a way to solve the\
    \ problem using Ruby without using any loops. I didn't want to give a complete\
    \ solution. :)\n<|/ c |>\n<| a |>\n<code>", "  lst.inject(0) { |sum, item| sum\
    \ + item if item % 2 == 1 }\nend", "  lst.each do |x|\n    if x.is_a? Integer\n\
    \      x if x % 2 == 1\n    else\n      0\n    end\n  end.reduce(:+)\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>", "  lst.each do |x|\n    if x.is_a?\
    \ Integer\n      x if x % 2 == 0\n    elsif x.is_a? Float\n      x if x.is_a?\
    \ Integer\n    else\n      x\n    end\n  end.reduce(:+)\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI like your solution, but I believe it would be more efficient\
    \ to just use `each_with_object` instead of `inject`.  Also, `each_with_object`\
    \ will return a `nil` value if the list is empty.\n<|/ c |>\n<| c |>\nI agree\
    \ with you. `each_with_object` would be more efficient. `inject` would also work,\
    \ but `each_with_object` would return `nil` if the list is empty. `inject` would\
    \ also return `nil` if the list contains `nil` values. `each_with_object` would\
    \ return `nil` if the list contains `nil` values.\n<|/ c |>\n<| c |>\n`each_with_object`\
    \ would return `nil` if the list contains `nil` values. `inject` would also return\
    \ `nil` if the list contains `nil` values.\n<|/ c |>\n<| c |>\n`inject` would\
    \ also return `nil` if the list contains `nil` values. `each_with_object` would\
    \ return `nil` if the list contains `nil` values.\n<|/ c |>\n<| c |>\n`inject`\
    \ would also return `nil` if the list contains `nil` values. `each_with_object`\
    \ would return `nil` if the list contains `nil` values.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  lst.each do |x|\n    next if x.is_a?(Integer) && x < 0\n   \
    \ next if x.is_a?(Float) && x < 0\n    sum += x * x\n  end\n  sum\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nI like your solution, however it seems to me that\
    \ `sum` should be initialized to `0` before the `each` loop. Otherwise the result\
    \ is `nil` if the input list is empty.\n<|/ c |>\n<| c |>\nI agree with you, however\
    \ I didn't want to change the OP's code too much. I'll edit my answer to include\
    \ your suggestion.\n<|/ c |>\n<| c |>\nI see your point. Thanks for your suggestion.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\
    \ && x > 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n\
    \      x + x\n    end\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work\
    \ if the list contains negative numbers. Try it with `[-2, -1, 0]`.\n<|/ c |>\n\
    <| c |>\nGood catch, thanks. I added a note to my answer.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x *=\
    \ 2\n    end\n  end\n  lst.inject(0) do |sum, item|\n    sum + item\n  end\nend",
  "  lst.each do |x|\n    if x.is_a?(Integer)\n      x if x % 2 == 1\n    else\n \
    \     x if x % 2 == 0\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nThis doesn't answer the question. OP wants to know how to do this\
    \ in Ruby, not Ruby on Rails.\n<|/ c |>\n<| c |>\nThe question was tagged with\
    \ `ruby-on-rails`, so I assumed that he was using Rails. I added a Rails solution\
    \ as well.\n<|/ c |>\n<| c |>\nI added a Rails solution as well.\n<|/ c |>\n<|\
    \ a dscore=0 |>\n<code>", "  lst.each do |i|\n    next if i.is_a?(Numeric) ||\
    \ i.is_a?(String)\n    next if i.negative?\n    next if i.zero?\n    next if i.to_i.zero?\n\
    \    sum += i.to_i ** 2\n  end\n  sum\nend", "  lst.each do |x|\n    if x.is_a?\
    \ Integer\n      x if x % 2 == 0\n    else\n      x if x < 0\n    end\n  end\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThanks for your answer. Your solution is very\
    \ similar to mine, but I wanted to know if there was a way to do it without using\
    \ .each or .map\n<|/ c |>\n<| c |>\nI added a solution without using .each\n<|/\
    \ c |>\n<| a |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\n      x\n\
    \    elsif x.is_a?(Float)\n      x\n    elsif x.is_a?(String)\n      x.to_i\n\
    \    else\n      0\n    end\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>", "  lst.each do |num|\n    if num.is_a? Integer\n      num\n   \
    \ elsif num.is_a? Float\n      num\n    else\n      num.odd?\n    end\n  end\n\
    end", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n    elsif\
    \ x.is_a?(Integer) && x < 0\n      0\n    else\n      x + x\n    end\n  end\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. Try it out with [1,2,3].\n\
    <|/ c |>\n<| c |>\nI see what you mean. Thanks for pointing that out. I fixed\
    \ it.\n<|/ c |>\n<| a |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\
    \ && x > 0\n      x\n    else\n      0\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| a tags=ruby,arrays |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\
    \ && x > 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n      0\n    elsif x.is_a?(Integer)\
    \ && x == 0\n      0\n    else\n      x + x\n    end\n  end\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nThis doesn't work. Try it with `double_the_difference.call([-1,\
    \ -2, 0])`\n<|/ c |>\n<| c |>\nThanks for pointing that out. I've fixed the code\
    \ now.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\n\
    \      x if x % 2 == 1\n    else\n      x if x % 2 == 0\n    end\n  end\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer. I am not allowed\
    \ to use any loops or conditionals. I only have one line of code which I posted\
    \ above. I am not allowed to use any loops or conditionals. I only have one line\
    \ of code which I posted above. I am not allowed to use any loops or conditionals.\
    \ I only have one line of code which I posted above. I am not allowed to use any\
    \ loops or conditionals. I only have one line of code which I posted above. I\
    \ am not allowed to use any loops or conditionals. I only have one line of code\
    \ which I posted above. I am not allowed to use any loops or conditionals. I only\
    \ have one line of code which I posted above. I am not allowed to use any loops\
    \ or conditionals. I only have one line of code which I posted above. I am not\
    \ allowed to use any loops or conditionals. I only have one line of code which\
    \ I posted above. I am not allowed to use any loops or conditionals. I only have\
    \ one line of code which I posted above. I am not allowed to use any loops or\
    \ conditionals. I only have one line of code which I posted above.\n<|/ c |>\n\
    <| c |>\nI updated my answer to include a solution that does not use any loops\
    \ or conditionals.\n<|/ c |>\n<| c |>\nThanks for your answer. I am not allowed\
    \ to use any loops or conditionals. I only have one line of code which I posted\
    \ above. I am not allowed to use any loops or conditionals. I only have one line\
    \ of code which I posted above. I am not allowed to use any loops or conditionals.\
    \ I only have one line of code which I posted above. I am not allowed to use any\
    \ loops or conditionals. I only have one line of code which I posted above. I\
    \ am not allowed to use any loops or conditionals. I only have one line of code\
    \ which I posted above. I am not allowed to use any loops or conditionals. I only\
    \ have one line of code which I posted above. I am not allowed to use any loops\
    \ or conditionals. I only have one line of code which I posted above. I am not\
    \ allowed to use any loops or conditionals. I only have one line of code which\
    \ I posted above. I am not allowed to use any loops or conditionals. I only have ",
  "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x *= 2\n    end\n  end\n\
    \  lst.inject(0) { |sum, x| sum + x }\nend\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\nI like your solution, but I wonder why you chose to write `lst.each do |x|`\
    \ instead of `lst.each { |x| ...`\n<|/ c |>\n<| c |>\nI like it too, but I wonder\
    \ why you chose to write `lst.each do |x|` instead of `lst.each { |x| ...`\n<|/\
    \ c |>\n<| c |>\nI like it too, but I wonder why you chose to write `lst.each\
    \ do |x|` instead of `lst.each { |x| ...`\n<|/ c |>\n<| c |>\nI like it too, but\
    \ I wonder why you chose to write `lst.each do |x|` instead of `lst.each { |x|\
    \ ...`\n<|/ c |>\n<| c |>\nI like it too, but I wonder why you chose to write\
    \ `lst.each do |x|` instead of `lst.each { |x| ...`\n<|/ c |>\n<| a dscore=5 |>\n\
    <code>", "  lst.each do |x|\n    if x.is_a? Integer\n      x % 2 == 0 ? x * 2\
    \ : x\n    else\n      0\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\
    \ && x > 0\n      x *= 2\n    end\n  end\n  lst.inject(0) { |sum, x| sum + x }\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer. I am not allowed\
    \ to use inject or reduce or map or any of those methods. I am only allowed to\
    \ use each, map, select, select!, collect, collect!, delete_if, delete_if!, delete_at,\
    \ delete_at!, delete_if, delete_at!, delete_if, delete_at!, delete_if, delete_at!,\
    \ delete_if, delete_at!, delete_if, delete_at!, delete_if, delete_at!, delete_if,\
    \ delete_at!, delete_if, delete_at!, delete_if, delete_at!, delete_if, delete_at!,\
    \ delete_if, delete_at!, delete_if, delete_at!, delete_if, delete_at!, delete_if,\
    \ delete_at!, delete_if, delete_at!, delete_if, delete_at!, delete_if, delete_at!,\
    \ delete_if, delete_at!, delete_if, delete_at!, delete_if, delete_at!, delete_if,\
    \ delete_at!, delete_if, delete_at!, delete_if, delete_at!, delete_if, delete_at!,\
    \ delete_if, delete_at!, delete_if, delete_at!, delete_if, delete_at!, delete_if,\
    \ delete_at!, delete_if, delete_at!, delete_if, delete_at!, delete_if, delete_at!,\
    \ delete_if, delete_at!, delete_if, delete_at!, delete_if, delete_at!, delete_if,\
    \ delete_at!, delete_if, delete_at!, delete_if, delete_at!, delete_if, delete_at!,\
    \ delete_if, delete_at!, delete_if, delete_at!, delete_if, delete_at!, delete_if,\
    \ delete_at!, delete_if, delete_at!, delete_if, delete_at!, delete_if, delete_at!,\
    \ delete_if, delete_at!, delete_if, delete_at!, delete_if, delete_at!, delete_if,\
    \ delete_at!, delete_if, delete_at!, delete_if, delete_at!, delete_if, delete_at!,\
    \ delete_if, delete_at!, delete_if, delete_at!, delete_if, delete_at!, delete_if,\
    \ delete_at!, delete_if, delete_at!, delete_if, ", "  lst.each do |n|\n    if\
    \ n.is_a? Integer\n      n += n\n    elsif n.is_a? Float\n      n += n\n    elsif\
    \ n.is_a? String\n      n += n\n    elsif n.is_a? Array\n      n += n\n    elsif\
    \ n.is_a? Hash\n      n += n\n    elsif n.is_a? NilClass\n      n += n\n    elsif\
    \ n.is_a? TrueClass\n      n += n\n    elsif n.is_a? FalseClass\n      n += n\n\
    \    elsif n.is_a? Nil\n      n += n\n    end\n  end\n  lst.inject(0) { |sum,\
    \ n| sum + n }\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like your solution.\
    \ Very concise and easy to understand. Thanks!\n<|/ c |>\n<| c |>\nI like your\
    \ solution. Very concise and easy to understand. Thanks!\n<|/ c |>\n<| c |>\n\
    I like your solution. Very concise and easy to understand. Thanks!\n<|/ c |>\n\
    <| c |>\nI like your solution. Very concise and easy to understand. Thanks!\n\
    <|/ c |>\n<| c |>\nI like your solution. Very concise and easy to understand.\
    \ Thanks!\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  lst.inject(0) { |sum, item|\
    \ sum + item if item % 2 == 1 }\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI\
    \ like your use of inject to solve this problem. Thanks!\n<|/ c |>\n<| c |>\n\
    I like your use of inject to solve this problem. Thanks!\n<|/ c |>\n<| c |>\n\
    I like your use of inject to solve this problem. Thanks!\n<|/ c |>\n<| c |>\n\
    I like your use of inject to solve this problem. Thanks!\n<|/ c |>\n<| c |>\n\
    I like your use of inject to solve this problem. Thanks!\n<|/ c |>\n<| a dscore=5\
    \ |>\n<code>", "  lst.inject(0) { |sum, e| sum + e * e }\nend", "  lst.each do\
    \ |x|\n    next if x.is_a?(Numeric)\n    next if x.is_a?(Fixnum)\n    next if\
    \ x.is_a?(String)\n    next if x.is_a?(Array)\n    next if x.is_a?(Hash)\n   \
    \ next if x.is_a?(Range)\n    next if x.is_a?(IO)\n    next if x.is_a?(File)\n\
    \    next if x.is_a?(Time)\n    next if x.is_a?(Enumerator)\n    next if x.is_a?(Proc)\n\
    \    next if x.is_a?(Thread)\n    next if x.is_a?(Process)\n    next if x.is_a?(Socket)\n\
    \    next if x.is_a?(IO::WaitReadable)\n    next if x.is_a?(IO::WaitWritable)\n\
    \    next if x.is_a?(IO::WaitHandle)\n    next if x.is_a?(IO::WaitForever)\n \
    \   next if x.is_a?(IO::WaitError)\n    next if x.is_a?(IO::WaitTimeout)\n   \
    \ next if x.is_a?(IO::WaitWrite)\n    next if x.is_a?(IO::WaitRead)\n    next\
    \ if x.is_a?(IO::WaitClose)\n    next if x.is_a?(IO::WaitForever)\n    next if\
    \ x.is_a?(IO::WaitError)\n    next if x.is_a?(IO::WaitTimeout)\n    next if x.is_a?(IO::WaitWrite)\n\
    \    next if x.is_a?(IO::WaitRead)\n    next if x.is_a?(IO::WaitClose)\n    next\
    \ if x.is_a?(IO::WaitForever)\n    next if x.is_a?(IO::WaitError)\n    next if\
    \ x.is_a?(IO::WaitTimeout)\n    next if x.is_a?(IO::WaitWrite)\n    next if x.is_a?(IO::WaitRead)\n\
    \    next if x.is_a?(IO::WaitClose)\n    next if x.is_a?(IO::WaitForever)\n  \
    \  next if x.is_a?(IO::WaitError)\n    next if x.is_a?(IO::WaitTimeout)\n    next\
    \ if x.is_a?(IO::WaitWrite)\n    next if x.is_a?(IO::WaitRead)\n    next if x.is_a?(IO::WaitClose)\n\
    \    next if x.is_a?(IO::WaitForever)\n    next ", "  lst.each do |x|\n    if\
    \ x.is_a?(Integer)\n      x if x % 2 == 1\n    else\n      x if x % 2 == 0\n \
    \   end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>", " \
    \ lst.each do |i|\n    next if i.is_a?(Numeric) || i.is_a?(Float)\n    next if\
    \ i.to_i.negative?\n    next if i.to_i.zero?\n    sum += i.to_i\n  end\n  sum\n\
    end", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n    else\n\
    \      0\n    end\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\n\
    <code>", "  lst.each do |x|\n    if x.is_a? Integer\n      x if x % 2 == 1\n \
    \   elsif x.is_a? Float\n      x if x % 2 == 0\n    else\n      0\n    end\n \
    \ end.reduce(:+)\nend\n</code>\n<|/ a |>\n<| c |>\nI like your solution, but I\
    \ believe it can be simplified a bit. `lst.each do |x|` can be replaced with `lst.select{|x|\
    \ x.is_a? Integer}`.\n<|/ c |>\n<| c |>\nI agree, that is a better solution. Thanks.\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<code>", "  lst.each\
    \ do |x|\n    if x.is_a?(Integer)\n      x\n    elsif x.is_a?(Float)\n      x\n\
    \    elsif x.is_a?(String)\n      x.to_i\n    else\n      0\n    end\n  end\n\
    end", "  lst.inject(0) { |sum, el| sum + el if el % 2 == 1 }\nend", "  lst.each\
    \ do |x|\n    if x.is_a?(Integer) && x > 0\n      x *= 2\n    elsif x.is_a?(Integer)\
    \ && x < 0\n      x /= 2\n    end\n  end\n  lst.inject(0) { |sum, x| sum + x }\n\
    end", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n    elsif\
    \ x.is_a?(Integer) && x < 0\n      0\n    else\n      x + x\n    end\n  end\n\
    end", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n    elsif\
    \ x.is_a?(Integer) && x < 0\n      0\n    else\n      x + x\n    end\n  end\n\
    end\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>", "  lst.each do |x|\n    if\
    \ x.is_a?(Integer) && x > 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n  \
    \    0\n    else\n      x + x\n    end\n  end\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=ruby |>\n<code>", "  lst.each do |x|\n    if x.is_a? Integer\n     \
    \ x % 2 == 0 ? x * 2 : x\n    else\n      0\n    end\n  end\nend\n</cell>\n<cell>",
  "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n    elsif x.is_a?(Integer)\
    \ && x < 0\n      0\n    else\n      x + x\n    end\n  end\nend\n</code>\n<|/\
    \ a tags=ruby,ruby-on-rails |>\n<| c |>\n`lst.inject(0, :+).to_i`\n<|/ c |>\n\
    <| c |>\nI like your solution, but I believe it can be simplified even more. `lst.inject(0)\
    \ { |sum, el| sum + el if el.class == Integer && el > 0 }`\n<|/ c |>\n<| c |>\n\
    I like your solution, but I believe it can be simplified even more. `lst.inject(0)\
    \ { |sum, el| sum + el if el.class == Integer && el > 0 }`\n<|/ c |>\n<| c |>\n\
    I like your solution, but I believe it can be simplified even more. `lst.inject(0)\
    \ { |sum, el| sum + el if el.class == Integer && el > 0 }`\n<|/ c |>\n<| c |>\n\
    I like your solution, but I believe it can be simplified even more. `lst.inject(0)\
    \ { |sum, el| sum + el if el.class == Integer && el > 0 }`\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\n      x\n    elsif\
    \ x.is_a?(Float)\n      x\n    elsif x.is_a?(String)\n      x.to_i\n    else\n\
    \      0\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n\
    <code>", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x *= 2\n\
    \    end\n  end\n  lst.inject(0) {|sum, x| sum + x }\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby,arrays |>\n<code>", "  lst.each do |x|\n    next if x.is_a?(Integer)\
    \ && x.negative?\n    next if x.is_a?(Float) && x.nan?\n    sum += x*x\n  end\n\
    \  sum\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,arrays |>\n<code>", " \
    \ lst.each do |x|\n    if x.is_a?(Integer)\n      x -= x % 2\n    else\n     \
    \ x -= x.to_i\n    end\n  end\n  lst.inject(0) {|sum, x| sum + x * x }\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nI like your solution, but I wonder why you\
    \ use `inject` instead of `reduce`?\n<|/ c |>\n<| c |>\n`inject` is more idiomatic\
    \ for Ruby than `reduce`. `reduce` is more idiomatic for other languages. `inject`\
    \ has some advantages over `reduce`, but `inject` has some advantages over `reduce`\
    \ too.\n<|/ c |>\n<| c |>\n`inject` is more idiomatic for Ruby than `reduce`.\
    \ `reduce` is more idiomatic for other languages. `inject` has some advantages\
    \ over `reduce`, but `inject` has some advantages over `reduce` too.\n<|/ c |>\n\
    <| c |>\n`inject` is more idiomatic for Ruby than `reduce`. `reduce` is more idiomatic\
    \ for other languages. `inject` has some advantages over `reduce`, but `inject`\
    \ has some advantages over `reduce` too.\n<|/ c |>\n<| c |>\n`inject` is more\
    \ idiomatic for Ruby than `reduce`. `reduce` is more idiomatic for other languages.\
    \ `inject` has some advantages over `reduce`, but `inject` has some advantages\
    \ over `reduce` too.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  lst.each do |x|\n\
    \    if x.is_a?(Integer)\n      x\n    elsif x.is_a?(Float)\n      x\n    elsif\
    \ x.is_a?(String)\n      x.to_i\n    elsif x.is_a?(Array)\n      x.to_i\n    else\n\
    \      0\n    end\n  end\nend", "  lst.each do |x|\n    if x.is_a?(Integer) &&\
    \ x > 0\n      x *= 2\n    elsif x.is_a?(Integer) && x < 0\n      x /= 2\n   \
    \ end\n  end\n  lst.inject(0) { |sum, x| sum + x }\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis doesn't work if the list is empty. `inject` returns `nil` if the\
    \ list is empty. `inject` returns `nil` if the list contains `nil` values.\n<|/\
    \ c |>\n<| c |>\n: Yes, I know. I was just trying to give a solution that would\
    \ work no matter what the input list was. Since I didn't want to give a solution\
    \ that would only work for integers, I didn't bother to handle negative numbers.\
    \ I added a comment to the question to clarify that my solution only works for\
    \ integers.\n<|/ c |>\n<| c |>\n: I added a solution that works for negative numbers.\
    \ I didn't bother to handle empty lists. I added a comment to the question to\
    \ clarify that my solution only works for integers.\n<|/ c |>\n<| c |>\n: I added\
    \ a solution that works for negative numbers. I didn't bother to handle empty\
    \ lists. I added a comment to the question to clarify that my solution only works\
    \ for integers.\n<|/ c |>\n<| c |>\n: I added a solution that works for negative\
    \ numbers. I didn't bother to handle empty lists. I added a comment to the question\
    \ to clarify that my solution only works for integers.\n<|/ c |>\n<| a dscore=3\
    \ |>\n<code>", "  lst.each do |x|\n    if x.is_a? Integer\n      x % 2 == 0 ?\
    \ x * 2 : x\n    else\n      0\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis doesn't work if you have a negative number in the array. Try\
    \ it with `[-1,-2,0]`.\n<|/ c |>\n<| c |>\nI see what you mean. Thanks for pointing\
    \ that out. I've updated the answer to account for negative numbers. I hope this\
    \ helps.\n<|/ c |>\n<| c |>\nI see what you mean. Thanks for pointing that out.\
    \ I've updated the answer to account for negative numbers. I hope this helps.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  lst.inject(0) do |sum, number|\n\
    \    sum + number if number % 2 == 1\n  end\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a |>\n<code>", "  lst.each do |num|\n    if num < 0\n      num = 0\n    elsif\
    \ num.is_a?(Integer)\n      num\n    else\n      num * num\n    end\n  end\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't answer the question, which is\
    \ about how to do this in Ruby, not Ruby on Rails.\n<|/ c |>\n<| c |>\nI added\
    \ a Ruby solution to the answer. Thanks for pointing that out.\n<|/ c |>\n<| a\
    \ dscore=0 |>\n<code>", "  lst.each do |x|\n    next if x.is_a?(Numeric) || x.nil?\n\
    \    next if x.is_a?(String) || x.nil?\n    next if x.is_a?(Fixnum) || x.nil?\n\
    \    next if x.is_a?(Bignum) || x.nil?\n    next if x.is_a?(TrueClass) || x.nil?\n\
    \    next if x.is_a?(FalseClass) || x.nil?\n    next if x.is_a?(Object) || x.nil?\n\
    \    next if x.is_a?(Array) || x.nil?\n    next if x.is_a?(Hash) || x.nil?\n \
    \   next if x.is_a?(Proc)\n    next if x.is_a?(IO) || x.nil?\n    next if x.is_a?(StringIO)\
    \ || x.nil?\n    next if x.is_a?(IO::Memory) || x.nil?\n    next if x.is_a?(IO::File)\
    \ || x.nil?\n    next if x.is_a?(IO::WaitReadable) || x.nil?\n    next if x.is_a?(IO::WaitWritable)\
    \ || x.nil?\n    next if x.is_a?(IO::WaitDrained) || x.nil?\n    next if x.is_a?(IO::WaitHandle)\
    \ || x.nil?\n    next if x.is_a?(IO::WaitForeground) || x.nil?\n    next if x.is_a?(IO::WaitOther)\
    \ || x.nil?\n    next if x.is_a?(IO::WaitNamed) || x.nil?\n    next if x.is_a?(IO::WaitInfinite)\
    \ || x.nil?\n    next if x.is_a?(IO::WaitForever) || x.nil?\n    next if x.is_a?(IO::WaitStatus)\
    \ || x.nil?\n    next if x.is_a?(IO::WaitOptions) || x.nil?\n    next if x.is_a?(IO::WaitTimeout)\
    \ || x.nil?\n    next if x.is_a?(IO::WaitQueue) || x.nil?\n    next if x.is_a?(IO::WaitEvent)\
    \ || x.nil?\n    next if x.is_a?(IO::WaitReadable) || x.nil?\n    next if x.is_a?(IO::WaitWritable)\
    \ || x.nil?\n    next if x.is_a?(IO::WaitDrained) || x.nil?\n    next if x.is_a?(IO::WaitHandle)\
    \ || x.nil?\n    next if x.is_a?(IO::WaitForeground) || x.nil?\n    next ", " \
    \ lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n    elsif x.is_a?(Integer)\
    \ && x < 0\n      0\n    else\n      x + x\n    end\n  end\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nThis doesn't answer the question of how to find the\
    \ sum of squares of odd numbers in a list.\n<|/ c |>\n<| c |>\nI thought the question\
    \ was how to find the sum of squares of odd numbers in a list. My bad.\n<|/ c\
    \ |>\n<| c |>\nI added an example for that.\n<|/ c |>\n<| c |>\nThis doesn't answer\
    \ the question of how to find the sum of squares of odd numbers in a list. `double_the_difference`\
    \ doesn't do that.\n<|/ c |>\n<| c |>\nI added an example for that.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "  lst.each do |x|\n    if x.is_a? Integer\n      x\
    \ if x % 2 == 1\n    elsif x.is_a? Float\n      x if x.to_i % 2 == 1\n    else\n\
    \      x\n    end\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\n\
    <code>", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n    elsif\
    \ x.is_a?(Integer) && x < 0\n      0\n    elsif x.is_a?(Integer) && x == 0\n \
    \     0\n    else\n      x + x\n    end\n  end\nend", "  lst.each do |x|\n   \
    \ if x.is_a?(Integer) && x > 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n\
    \      0\n    else\n      x + x\n    end\n  end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer) &&\
    \ x > 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n   \
    \   x * 2\n    end\n  end\nend", "  lst.each do |x|\n    if x.is_a?(Integer) &&\
    \ x > 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n   \
    \   x + x\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<|\
    \ a tags=ruby,ruby-on-rails |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\
    \ && x > 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n\
    \      x + x\n    end\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like\
    \ your solution, but I find it a little too complicated for my taste. I'd rather\
    \ use a simple `inject` with a `case` statement to do the same thing.\n<|/ c |>\n\
    <| c |>\nI agree with you. I just wanted to show a more Ruby-like way of doing\
    \ it.\n<|/ c |>\n<| c |>\nI agree with you. I just wanted to show a more Ruby-like\
    \ way of doing it.\n<|/ c |>\n<| c |>\nI agree with you. I just wanted to show\
    \ a more Ruby-like way of doing it.\n<|/ c |>\n<| c |>\nI agree with you. I just\
    \ wanted to show a more Ruby-like way of doing it.\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>", "  lst.each do |x|\n    if x.is_a? Integer\n      x if x % 2 == 1\n \
    \   else\n      0\n    end\n  end.reduce(:+)\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nI like your solution, but I wonder why you use `.each` instead of `map`?\n\
    <|/ c |>\n<| c |>\n`map` returns a new array, so you lose the original array.\
    \ `each` doesn't return anything, so you get a new array with the results. I find\
    \ `map` easier to read, but that's just me.\n<|/ c |>\n<| c |>\nI see. Thanks\
    \ for explaining!\n<|/ c |>\n<| c |>\nI like your solution, but I wonder why you\
    \ use `.each` instead of `map`?\n<|/ c |>\n<| c |>\n`map` returns an array, so\
    \ you lose the original array. `each` doesn't return anything, so you get a new\
    \ array with the results. I find `map` easier to read, but that's just me.\n<|/\
    \ c |>\n<| a dscore=5 |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\n\
    \      x -= x\n    end\n  end\n  lst.inject(0) { |sum, e| sum + e * e }\nend",
  "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n    elsif x.is_a?(Integer)\
    \ && x < 0\n      0\n    else\n      x + x\n    end\n  end\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nThis doesn't answer the question. OP wants to know how\
    \ to return 0 when an empty list is passed in.\n<|/ c |>\n<| c |>\nI added a comment\
    \ to the question to clarify that OP wants to return 0 when an empty list is passed\
    \ in.\n<|/ c |>\n<| c |>\nI added a comment to the question to clarify that OP\
    \ wants to return 0 when an empty list is passed in.\n<|/ c |>\n<| c |>\nI added\
    \ a comment to the question to clarify that OP wants to return 0 when an empty\
    \ list is passed in.\n<|/ c |>\n<| c |>\nI added a comment to the question to\
    \ clarify that OP wants to return 0 when an empty list is passed in.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "  lst.each do |x|\n    if x.is_a? Integer\n      x\
    \ if x % 2 == 1\n    elsif x.is_a? Float\n      x if x.to_i % 2 == 1\n    else\n\
    \      x\n    end\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n\
    <code>", "  lst.each do |x|\n    next if x.is_a?(Numeric) && x.to_i < 0\n    next\
    \ if x.is_a?(Numeric) && x.to_i == 0\n    next if x.is_a?(Numeric) && x.to_i ==\
    \ 1\n    next if x.is_a?(Numeric) && x.to_i == -1\n    sum += x.to_i ** 2\n  end\n\
    \  sum\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a dscore=0 |>\n<code>",
  "  lst.each do |x|\n    if x.is_a?(Integer)\n      x\n    elsif x.is_a?(Float)\n\
    \      x.to_i\n    else\n      0\n    end\n  end\nend", "  lst.each do |i|\n \
    \   if i.is_a? Integer\n      i\n    elsif i.is_a? Float\n      i.to_i\n    elsif\
    \ i.is_a? String\n      i.to_i\n    else\n      0\n    end\n  end\nend", "  lst.each\
    \ do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n    elsif x.is_a?(Integer)\
    \ && x < 0\n      0\n    else\n      x + x\n    end\n  end\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| c |>\nThis doesn't work if you have a negative number in\
    \ the list. Try it with `[-3, -2, -1]`.\n<|/ c |>\n<| c |>\nI didn't see that\
    \ requirement. Thanks for pointing it out.\n<|/ c |>\n<| c |>\nI added a version\
    \ that doesn't require negative numbers in the list.\n<|/ c |>\n<| c |>\nI added\
    \ a version that doesn't require negative numbers in the list.\n<|/ c |>\n<| c\
    \ |>\nI added a version that doesn't require negative numbers in the list.\n<|/\
    \ c |>\n<| a dscore=2 |>\n<code>", "  lst.each do |x|\n    if x.is_a? Integer\n\
    \      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? Float\n      x % 2 == 0 ? x *\
    \ 2 : x\n    else\n      0\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| c |>\nThis doesn't work if you have a negative number in the list. `double_the_difference.call([-1,\
    \ -2, 0])` returns `0` instead of `-2`.\n<|/ c |>\n<| c |>\nI added a version\
    \ that doesn't have that problem.\n<|/ c |>\n<| c |>\nI added a version that doesn't\
    \ have that problem.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n\
    <code>", "  lst.each do |num|\n    if num.is_a?(Integer) && num > 0\n      num\
    \ * num\n    else\n      0\n    end\n  end\nend", "  lst.each do |x|\n    if x.is_a?(Integer)\n\
    \      x\n    elsif x.is_a?(Float)\n      x\n    elsif x.is_a?(String)\n     \
    \ x.to_i\n    else\n      0\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis doesn't work if you have a string in the array. `[\"1\"]`\
    \ returns `1` instead of `nil`.\n<|/ c |>\n<| c |>\nI didn't realize that `String`\
    \ was a subclass of `Integer`. Thanks for pointing that out. I've updated the\
    \ answer to include a check for `String`.\n<|/ c |>\n<| a tags=ruby,arrays |>\n\
    <code>", "  lst.each do |x|\n    if x.is_a?(Integer)\n      x if x % 2 == 0\n\
    \    elsif x.is_a?(Float)\n      x if x.to_i % 2 == 0\n    else\n      x\n   \
    \ end\n  end.reduce(:+)\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\n\
    <code>", "  lst.each do |x|\n    if x.is_a? Integer\n      x if x % 2 == 1\n \
    \   else\n      x if x % 2 == 0\n    end\n  end\nend", "  lst.each do |x|\n  \
    \  if x.is_a? Integer\n      x if x % 2 == 0\n    else\n      x if x % 2 != 0\n\
    \    end\n  end\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't\
    \ work if you pass in an empty array. Try `double_the_difference.call([nil])`\n\
    <|/ c |>\n<| c |>\nI see what you mean. Thanks for pointing that out. I've updated\
    \ the answer to account for that.\n<|/ c |>\n<| a |>\n<code>", "  lst.each do\
    \ |x|\n    if x.is_a? Integer\n      x if x % 2 == 0\n    else\n      x if x <\
    \ 0\n    end\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work\
    \ if you have a negative number in the list. Try `double_the_difference.call([-1,\
    \ -2, 0])`\n<|/ c |>\n<| c |>\nI added a solution that doesn't require the list\
    \ to be sorted.\n<|/ c |>\n<| c |>\nI added a solution that doesn't require the\
    \ list to be sorted.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  lst.each do |x|\n\
    \    if x.is_a?(Integer) && x > 0\n      x\n    elsif x.is_a?(Integer) && x <\
    \ 0\n      0\n    elsif x.is_a?(Integer) && x == 0\n      0\n    else\n      x\
    \ + x\n    end\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't\
    \ answer the question. OP wants to return 0 if the list is empty.\n<|/ c |>\n\
    <| c |>\nYes, I missed that part. Thanks for pointing that out.\n<|/ c |>\n<|\
    \ c |>\nI added a solution that does that.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  lst.each do |x|\n    next if x.negative?\n    next if x.zero?\n\
    \    sum += x * x\n  end\n  sum\nend", "  lst.inject(0) {|sum, el| sum + el if\
    \ el % 2 == 1 }\nend", "  lst.map!{|x| x * 2}\n  lst.delete_if{|x| x < 0}\n  lst.delete_if{|x|\
    \ x.is_a?(Integer)}\n  lst.inject(0) {|sum, num| sum + num}\nend", "  lst.each\
    \ do |x|\n    next if x.negative?\n    next if x.zero?\n    next if x.odd?\n \
    \   sum += x\n  end\n  sum\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<|\
    \ c |>\nThanks so much for the help. I appreciate it.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  lst.each do |x|\n    if x.is_a? Integer\n      x if x % 2 ==\
    \ 1\n    elsif x.is_a? Float\n      x if x.to_i % 2 == 1\n    else\n      0\n\
    \    end\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThanks for your answer.\
    \ Your code is very clear and easy to understand. However I still have some questions.\
    \ What is the difference between `if x.is_a? Integer` and `if x.is_a? Float`?\
    \ Why do we use `if x.is_a? Float` instead of `if x.is_a? Integer`? Why do we\
    \ use `if x.is_a? Float` instead of `if x.is_a? Integer`? Why do we use `if x.is_a?\
    \ Float` instead of `if x.is_a? Integer`? Why do we use `if x.is_a? Float` instead\
    \ of `if x.is_a? Integer`? Why do we use `if x.is_a? Float` instead of `if x.is_a?\
    \ Integer`? Why do we use `if x.is_a? Float` instead of `if x.is_a? Integer`?\
    \ Why do we use `if x.is_a? Float` instead of `if x.is_a? Integer`? Why do we\
    \ use `if x.is_a? Float` instead of `if x.is_a? Integer`? Why do we use `if x.is_a?\
    \ Float` instead of `if x.is_a? Integer`? Why do we use `if x.is_a? Float` instead\
    \ of `if x.is_a? Integer`? Why do we use `if x.is_a? Float` instead of `if x.is_a?\
    \ Integer`? Why do we use `if x.is_a? Float` instead of `if x.is_a? Integer`?\
    \ Why do we use `if x.is_a? Float` instead of `if x.is_a? Integer`? Why do we\
    \ use `if x.is_a? Float` instead of `if x.is_a? Integer`? Why do we use `if x.is_a?\
    \ Float` instead of `if x.is_a? Integer`? Why do we use `if x.is_a? Float` instead\
    \ of `if x.is_a? Integer`? Why do we use `if x.is_a? Float` instead of `if x.is_a?\
    \ Integer`? Why do we use `if x.is_a? Float` instead of `if x.is_a? Integer`?\
    \ Why do we use `if x.is_a? Float` instead of `if x.is_a? Integer`? Why do we\
    \ use `if x.is_a? Float` instead of `if x.is_a? Integer`? Why do we use `if x.is_a?\
    \ Float` instead of `if x.is_a? Integer`? Why do we use `if x.is_a? Float", " \
    \ lst.each do |num|\n    if num.is_a? Integer\n      num\n    elsif num.is_a?\
    \ Float\n      num\n    else\n      0\n    end\n  end\nend\n</cell>\n<text>\n\
    Exercise: Write a function that takes a string and returns the number of words\
    \ in the string. Words are separated by spaces.", "  lst.each do |x|\n    if x.is_a?\
    \ Integer\n      x if x % 2 == 1\n    else\n      x if x < 0\n    end\n  end\n\
    end", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n    elsif\
    \ x.is_a?(Integer) && x < 0\n      0\n    else\n      x + x\n    end\n  end\n\
    end\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails |>\n<| c |>\nThis doesn't work\
    \ if you have a negative number in the array. Try it with `[-2,-1,0,1]`\n<|/ c\
    \ |>\n<| c |>\nI didn't see that requirement in the question. I'll update my answer\
    \ to include a check for negative numbers.\n<|/ c |>\n<| c |>\nI added a note\
    \ about negative numbers to the answer.\n<|/ c |>\n<| c |>\nI added a note about\
    \ negative numbers to the answer.\n<|/ c |>\n<| c |>\nI added a note about negative\
    \ numbers to the answer.\n<|/ c |>\n<| a |>\n<code>", "  lst.each do |x|\n   \
    \ if x.is_a?(Integer) && x > 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n\
    \      0\n    else\n      x * 2\n    end\n  end.reduce(:+)\nend", "  lst.each\
    \ do |x|\n    if x.is_a? Integer\n      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a?\
    \ Float\n      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? String\n      x % 2 ==\
    \ 0 ? x * 2 : x\n    elsif x.is_a? Array\n      x % 2 == 0 ? x * 2 : x\n    elsif\
    \ x.is_a? Hash\n      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? NilClass\n   \
    \   x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? TrueClass\n      x % 2 == 0 ? x\
    \ * 2 : x\n    elsif x.is_a? FalseClass\n      x % 2 == 0 ? x * 2 : x\n    elsif\
    \ x.is_a? Nil\n      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? Fixnum\n      x\
    \ % 2 == 0 ? x * 2 : x\n    elsif x.is_a? Bignum\n      x % 2 == 0 ? x * 2 : x\n\
    \    elsif x.is_a? Complex\n      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? Range\n\
    \      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? Enumerator\n      x % 2 == 0\
    \ ? x * 2 : x\n    elsif x.is_a? IO\n      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a?\
    \ StringIO\n      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? IO::NullIO\n     \
    \ x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? StringIO::NullIO\n      x % 2 == 0\
    \ ? x * 2 : x\n    elsif x.is_a? IO::Unreadable\n      x % 2 == 0 ? x * 2 : x\n\
    \    elsif x.is_a? IO::Unreadable::Unreadable\n      x % 2 == 0 ? x * 2 : x\n\
    \    elsif x.is_a? IO::Unreadable::Unreadable::Unreadable\n      x % 2 == 0 ?\
    \ x * 2 : x\n    elsif x.is_a? IO::Unreadable::Unreadable::Unreadable::Unreadable\n\
    \      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? IO::Unreadable::Unreadable::Unreadable::Unreadable::Unreadable\n\
    \      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? IO::Unreadable::Unreadable::Unreadable::Unreadable::Unreadable::Unreadable\n\
    \      x % 2 == 0 ? x * 2 : ", "  lst.each do |x|\n    if x.is_a? Integer\n  \
    \    x if x % 2 == 1\n    else\n      0\n    end\n  end.reduce(:+)\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis doesn't work. Try it with `[9,\
    \ -2]`.\n<|/ c |>\n<| c |>\nI fixed it.  I forgot that reduce only works on arrays.\
    \  I thought it was a method on Enumerable.  I guess not.\n<|/ c |>\n<| c |>\n\
    I fixed it again.  I forgot that reduce only works on arrays.  I thought it was\
    \ a method on Enumerable.  I guess not.\n<|/ c |>\n<| c |>\nI fixed it again.\
    \  I forgot that reduce only works on arrays.  I thought it was a method on Enumerable.\
    \  I guess not.\n<|/ c |>\n<| c |>\nI fixed it again.  I forgot that reduce only\
    \ works on arrays.  I thought it was a method on Enumerable.  I guess not.\n<|/\
    \ c |>\n<| a dscore=0 |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\n\
    \      x\n    elsif x.is_a?(Float)\n      x\n    elsif x.is_a?(String)\n     \
    \ x.to_i\n    else\n      0\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nI like your use of map and reduce to solve this problem. Thanks!\n\
    <|/ c |>\n<| c |>\nI like your use of map and reduce to solve this problem. Thanks!\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  lst.inject(0) { |sum, number|\
    \ sum + number**2 if number > 0 }\nend\n</cell>\n<text>\nThe inject method is\
    \ a method of Enumerable that iterates through each element of a collection and\
    \ performs a calculation on each element. The calculation can either be an addition\
    \ or a multiplication. In the case of inject we use the block to perform the calculation.\
    \ inject also takes a second argument which is the initial value for the calculation.\
    \ The initial value is then returned at the end of the calculation. In the case\
    \ of the example above we pass in 0 as the initial value for the calculation.",
  "  lst.each do |x|\n    if x.is_a? Integer\n      x if x % 2 == 1\n    elsif x.is_a?\
    \ Float\n      x if x.to_i % 2 == 1\n    else\n      x\n    end\n  end\nend",
  "  lst.each do |x|\n    if x.is_a? Integer\n      x if x % 2 == 1\n    else\n  \
    \    x if x % 2 == 0\n    end\n  end\nend", "  lst.map!{|x| x*2}\n  lst.select\
    \ {|x| x % 2 == 1}.inject(:+)\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n\
    <| a dscore=0 |>\n<code>", "  lst.each do |num|\n    if num.is_a?(Integer) &&\
    \ num > 0\n      num * num\n    else\n      0\n    end\n  end\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThanks so much! This was very helpful.\n\
    <|/ c |>\n<| c |>\nNo problem. Glad I could help.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>", "  lst.each do |x|\n    next if x.nil?\n    next if x.is_a?(Numeric)\n\
    \    next if x.is_a?(String)\n    next if x.is_a?(Fixnum)\n    next if x.is_a?(Float)\n\
    \    next if x.is_a?(BigDecimal)\n    next if x.is_a?(BigInteger)\n    next if\
    \ x.is_a?(Array)\n    next if x.is_a?(Hash)\n    next if x.is_a?(Range)\n    next\
    \ if x.is_a?(IO)\n    next if x.is_a?(File)\n    next if x.is_a?(StringIO)\n \
    \   next if x.is_a?(IO::MemoryStream)\n    next if x.is_a?(IO::File)\n    next\
    \ if x.is_a?(IO::BufferedReader)\n    next if x.is_a?(IO::BufferedWriter)\n  \
    \  next if x.is_a?(IO::BufferedRWPair)\n    next if x.is_a?(IO::BufferedRW)\n\
    \    next if x.is_a?(IO::BufferedWriter::Abstract)\n    next if x.is_a?(IO::BufferedReader::Abstract)\n\
    \    next if x.is_a?(IO::BufferedRW::Abstract)\n    next if x.is_a?(IO::BufferedWriter::Buffered)\n\
    \    next if x.is_a?(IO::BufferedReader::Buffered)\n    next if x.is_a?(IO::BufferedRW::Buffered)\n\
    \    next if x.is_a?(IO::BufferedWriter::BufferedRW)\n    next if x.is_a?(IO::BufferedReader::BufferedRW)\n\
    \    next if x.is_a?(IO::BufferedRW::BufferedRW)\n    next if x.is_a?(IO::Pipe)\n\
    \    next if x.is_a?(IO::Pipe::Abstract)\n    next if x.is_a?(IO::Pipe::Pipe)\n\
    \    next if x.is_a?(IO::Pipe::Pipe::Pipe)\n    next if x.is_a?(IO::Pipe::Pipe::Pipe::Pipe)\n\
    \    next if x.is_a?(IO::Pipe::Pipe::Pipe::Pipe)\n    next if x.is_a?(IO::Pipe::Pipe::Pipe::Pipe::Pipe)\n\
    \    next if x.is_a?(IO::Pipe::Pipe::Pipe::Pipe::Pipe)\n    next if x.is_a?(IO::Pipe::Pipe::Pipe::Pipe::Pipe::Pipe)\n\
    \    next if x.is_a", "  lst.each do |x|\n    if x.is_a?(Integer)\n      x\n \
    \   elsif x.is_a?(Float)\n      x\n    elsif x.is_a?(String)\n      x.to_i\n \
    \   elsif x.is_a?(Array)\n      double_the_difference(x)\n    else\n      0\n\
    \    end\n  end\nend", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n\
    \      x\n    else\n      0\n    end\n  end\nend", "  lst.each do |num|\n    return\
    \ 0 if num < 0\n    return num if num.is_a? Integer\n  end\n  lst.inject(0) do\
    \ |sum, num|\n    sum + num * num\n  end\nend", "  lst.each do |x|\n    if x.is_a?\
    \ Integer\n      x % 2 == 0 ? x * 2 : x\n    else\n      0\n    end\n  end\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't work. Try it with `[9, -2]`.\n\
    <|/ c |>\n<| c |>\nI see what you mean. I'll fix it.\n<|/ c |>\n<| c |>\nI fixed\
    \ it now. Thanks for pointing that out.\n<|/ c |>\n<| c |>\nI fixed it now. Thanks\
    \ for pointing that out.\n<|/ c |>\n<| c |>\nI fixed it now. Thanks for pointing\
    \ that out.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\
    \ && x > 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n\
    \      x + x\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n\
    <| c |>\nThanks for your answer. I'm a beginner at Ruby, so I appreciate your\
    \ help. I understand that my code was very inefficient, but I wanted to understand\
    \ why my code wasn't working.\n<|/ c |>\n<| c |>\nI added an explanation to the\
    \ answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  lst.each do |n|\n    return\
    \ 0 if n.to_i < 0\n    return 0 if n.to_i.zero?\n    return 0 if n.to_i.even?\n\
    \  end\n  lst.inject(0) { |sum, n| sum + n * n }\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nI like your solution, however it would be better to use the `inject`\
    \ method instead of `each` since it returns the accumulated value instead of just\
    \ iterating over the array. Also, `inject` can take a block to perform the addition\
    \ instead of having to use a `+` operator.\n<|/ c |>\n<| c |>\nI agree with you.\
    \ I just wanted to show how it could be done with inject. Thanks for your comment!\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  lst.each do |num|\n    if num > 0\n  \
    \    num * num\n    end\n  end\nend", "  lst.each do |x|\n    if x.is_a?(Integer)\
    \ && x > 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n\
    \      x + x\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n\
    <| c |>\nThanks for your answer. I am new to Ruby and I didn't know about `Enumerable`\
    \ module. I am going to read more about it.\n<|/ c |>\n<| c |>\nI added an explanation\
    \ to the answer. Hope it helps.\n<|/ c |>\n<| c |>\nThanks for your explanation.\
    \ I will read more about `Enumerable` module.\n<|/ c |>\n<| c |>\nI added an explanation\
    \ to the answer. Hope it helps.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>",
  "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n    elsif x.is_a?(Integer)\
    \ && x < 0\n      0\n    elsif x.is_a?(Integer) && x == 0\n      0\n    else\n\
    \      x + x\n    end\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\n      x\n    elsif\
    \ x.is_a?(Float)\n      x\n    elsif x.is_a?(String)\n      x.to_i\n    else\n\
    \      0\n    end\n  end\nend", "  lst.each do |x|\n    if x.is_a?(Integer)\n\
    \      x\n    elsif x.is_a?(Float)\n      x\n    elsif x.is_a?(String)\n     \
    \ x.to_i\n    else\n      0\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis doesn't answer the question, which is about how to avoid the double\
    \ loop. Also, why are you using `Integer` instead of `Fixnum`?\n<|/ c |>\n<| c\
    \ |>\nI agree with you, my answer was more about how to avoid the double loop.\
    \ Fixnum is more appropriate for integers. I edited my answer to reflect that.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  lst.each do |x|\n    if x.is_a? Integer\n\
    \      x if x % 2 == 0\n    else\n      0\n    end\n  end.reduce(:+)\nend\n</code>\n\
    <|/ a |>\n<| c |>\nI like your solution, but I believe that `each_with_object`\
    \ would be more idiomatic than `inject`: `lst.each_with_object(0) do |x, acc|\
    \ acc += x if x.is_a? Integer end`\n<|/ c |>\n<| c |>\nI agree, `each_with_object`\
    \ is more idiomatic than `inject`. I just wanted to show that `inject` could be\
    \ used here as well.\n<|/ c |>\n<| c |>\nI like your solution, but I believe that\
    \ `each_with_object` would be more idiomatic than `inject`: `lst.each_with_object(0)\
    \ do |x, acc| acc += x if x.is_a? Integer end`\n<|/ c |>\n<| c |>\nI agree, `each_with_object`\
    \ is more idiomatic than `inject`. I just wanted to show that `inject` could be\
    \ used here as well.\n<|/ c |>\n<| a dscore=3 |>\n<code>", "  lst.each do |x|\n\
    \    if x.is_a? Integer\n      x if x % 2 == 1\n    else\n      0\n    end\n \
    \ end.reduce(:+)\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't answer\
    \ the question. He wants to know how to return 0 if the list is empty.\n<|/ c\
    \ |>\n<| c |>\nI added a comment to the question asking if he wants to return\
    \ 0 if the list is empty.\n<|/ c |>\n<| c |>\nI added a comment to the question\
    \ asking if he wants to return 0 if the list is empty.\n<|/ c |>\n<| c |>\nI added\
    \ a comment to the question asking if he wants to return 0 if the list is empty.\n\
    <|/ c |>\n<| c |>\nI added a comment to the question asking if he wants to return\
    \ 0 if the list is empty.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  lst.each do\
    \ |x|\n    if x.is_a?(Integer) && x > 0\n      x\n    elsif x.is_a?(Integer) &&\
    \ x < 0\n      0\n    else\n      x + x\n    end\n  end\nend", "  lst.each do\
    \ |x|\n    if x.is_a?(Integer)\n      x\n    elsif x.is_a?(Float)\n      x.to_i\n\
    \    else\n      0\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| a dscore=0 |>\n<code>", "  lst.inject(0) do |sum, number|\n    sum +\
    \ number if number % 2 == 1\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n\
    \    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n      x + x\n    end\n\
    \  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. Try it with\
    \ `[9, -2]`.\n<|/ c |>\n<| c |>\nI tested it and it works. I added the test case\
    \ in the answer.\n<|/ c |>\n<| c |>\nI see you added a test case for negative\
    \ numbers. I added a test case for negative numbers and it works.\n<|/ c |>\n\
    <| c |>\nI added a test case for negative numbers and it works. I added a test\
    \ case for negative numbers and it works. I added a test case for negative numbers\
    \ and it works. I added a test case for negative numbers and it works. I added\
    \ a test case for negative numbers and it works. I added a test case for negative\
    \ numbers and it works. I added a test case for negative numbers and it works.\
    \ I added a test case for negative numbers and it works. I added a test case for\
    \ negative numbers and it works. I added a test case for negative numbers and\
    \ it works. I added a test case for negative numbers and it works. I added a test\
    \ case for negative numbers and it works. I added a test case for negative numbers\
    \ and it works. I added a test case for negative numbers and it works. I added\
    \ a test case for negative numbers and it works. I added a test case for negative\
    \ numbers and it works. I added a test case for negative numbers and it works.\
    \ I added a test case for negative numbers and it works. I added a test case for\
    \ negative numbers and it works. I added a test case for negative numbers and\
    \ it works. I added a test case for negative numbers and it works. I added a test\
    \ case for negative numbers and it works. I added a test case for negative numbers\
    \ and it works. I added a test case for negative numbers and it works. I added\
    \ a test case for negative numbers and it works. I added a test case for negative\
    \ numbers and it works. I added a test case for negative numbers and it works.\
    \ I added a test case for negative numbers and it works. I added a test case for\
    \ negative numbers and it works. I added a test case for negative numbers and\
    \ it works. I added a test case for negative number", "  lst.inject(0) { |sum,\
    \ item| sum + item if item % 2 == 1 }\nend", "  lst.each do |x|\n    if x.is_a?\
    \ Integer\n      x if x % 2 == 1\n    else\n      x if x % 2 == 0\n    end\n \
    \ end\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>", "  lst.each\
    \ do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n    elsif x.is_a?(Integer)\
    \ && x < 0\n      0\n    else\n      x + x\n    end\n  end\nend\n</code>\n<|/\
    \ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work. Try it with `[9, -2]`.\n\
    <|/ c |>\n<| c |>\nI added a comment to the question to clarify that negative\
    \ numbers are to be ignored.\n<|/ c |>\n<| c |>\nI added a comment to the question\
    \ to clarify that negative numbers are to be ignored.\n<|/ c |>\n<| c |>\nI added\
    \ a comment to the question to clarify that negative numbers are to be ignored.\n\
    <|/ c |>\n<| c |>\nI added a comment to the question to clarify that negative\
    \ numbers are to be ignored.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", " \
    \ lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n    elsif x.is_a?(Integer)\
    \ && x < 0\n      0\n    elsif x.is_a?(Integer) && x == 0\n      0\n    else\n\
    \      x + x\n    end\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n\
    \    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n      x + x\n    end\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThanks so much!\
    \ I really appreciate your help.\n<|/ c |>\n<| c |>\nNo problem. Glad I could\
    \ help.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  lst.each do |x|\n\
    \    if x.is_a?(Integer) && x > 0\n      x *= 2\n    elsif x.is_a?(Integer) &&\
    \ x < 0\n      x *= -2\n    end\n  end\n  lst.inject(0) { |sum, x| sum + x }\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| c |>\nThanks\
    \ for your answer. I'm still a beginner at Ruby, so I appreciate your help. I\
    \ really appreciate your time spent writing this answer. Thanks again.\n<|/ c\
    \ |>\n<| c |>\nI added a more concise version of the code I wrote. Hope it helps.\n\
    <|/ c |>\n<| c |>\nThanks again for your help. I appreciate it.\n<|/ c |>\n<|\
    \ a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<code>", "  lst.each do |x|\n\
    \    if x.is_a?(Integer) && x > 0\n      x\n    else\n      0\n    end\n  end\n\
    end", "  lst.inject(0) { |sum, number| sum + number if number % 2 == 1 }\nend",
  "  lst.each do |i|\n    next if i.nil?\n    next if i.negative?\n    next if i.zero?\n\
    \    sum += i * i\n  end\n  sum\nend", "  lst.each do |x|\n    if x.is_a?(Integer)\
    \ && x > 0\n      x\n    else\n      0\n    end\n  end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby,arrays |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\
    \ && x > 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n\
    \      x + x\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n\
    <code>", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n    elsif\
    \ x.is_a?(Integer) && x < 0\n      0\n    else\n      x + x\n    end\n  end\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "  lst.each do |i|\n    if\
    \ i.is_a? Integer\n      i\n    elsif i.is_a? Float\n      i.to_i\n    else\n\
    \      0\n    end\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't\
    \ answer the question of how to get the sum of the squares of the odd numbers\
    \ in the list. Also, `map` returns an array, so `sum` will throw an error.\n<|/\
    \ c |>\n<| c |>\nI agree, my answer was more of a \"how do I do this\" rather\
    \ than \"how do I do it\". I was trying to show how to get the sum of the squares\
    \ of the odd numbers in the list. I'll update my answer to show how to get the\
    \ sum of the squares of the odd numbers in the list.\n<|/ c |>\n<| c |>\nI updated\
    \ my answer to show how to get the sum of the squares of the odd numbers in the\
    \ list.\n<|/ c |>\n<| c |>\nI updated my answer to show how to get the sum of\
    \ the squares of the odd numbers in the list.\n<|/ c |>\n<| c |>\nI updated my\
    \ answer to show how to get the sum of the squares of the odd numbers in the list.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\
    \ && x > 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n\
    \      x + x\n    end\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  lst.each do |x|\n    next if x.is_a?(Numeric) && x.to_i < 0\n\
    \    next if x.is_a?(Numeric) && x.to_i < 0\n    next if x.is_a?(Numeric) && x.to_i\
    \ < 0\n    next if x.is_a?(Numeric) && x.to_i < 0\n    next if x.is_a?(Numeric)\
    \ && x.to_i < 0\n    next if x.is_a?(Numeric) && x.to_i < 0\n    next if x.is_a?(Numeric)\
    \ && x.to_i < 0\n    next if x.is_a?(Numeric) && x.to_i < 0\n    next if x.is_a?(Numeric)\
    \ && x.to_i < 0\n    next if x.is_a?(Numeric) && x.to_i < 0\n    next if x.is_a?(Numeric)\
    \ && x.to_i < 0\n    next if x.is_a?(Numeric) && x.to_i < 0\n    next if x.is_a?(Numeric)\
    \ && x.to_i < 0\n    next if x.is_a?(Numeric) && x.to_i < 0\n    next if x.is_a?(Numeric)\
    \ && x.to_i < 0\n    next if x.is_a?(Numeric) && x.to_i < 0\n    next if x.is_a?(Numeric)\
    \ && x.to_i < 0\n    next if x.is_a?(Numeric) && x.to_i < 0\n    next if x.is_a?(Numeric)\
    \ && x.to_i < 0\n    next if x.is_a?(Numeric) && x.to_i < 0\n    next if x.is_a?(Numeric)\
    \ && x.to_i < 0\n    next if x.is_a?(Numeric) && x.to_i < 0\n    next if x.is_a?(Numeric)\
    \ && x.to_i < 0\n    next if x.is_a?(Numeric) && x.to_i < 0\n    next if x.is_a?(Numeric)\
    \ && x.to_i < 0\n    next if x.is_a?(Numeric) && x.to_i < 0\n    next if x.is_a?(Numeric)\
    \ && x.to_i < 0\n    next if x.is_a?(Numeric) && x.to_i < 0\n    next if x.is_a?(Numeric)\
    \ && x.to_i < 0\n    next if x.is_a?(Numeric) && x.to_i < 0\n    next if x.is_a?(Numeric)\
    \ && x.to_i < 0\n    next if x.is_a?(Numeric) && x.to_i < 0\n    next if x.is_a?(Numeric)\
    \ && x.to_i < 0\n    next if x.is_a?(Numeric) && x.to_i < 0\n    next if x.is_a?(Numeric)\
    \ && x.to_i < 0\n    next if x.is_a?(Numeric) && x.to_i < 0\n", "  lst.each do\
    \ |x|\n    if x.is_a?(Integer) && x > 0\n      x\n    elsif x.is_a?(Integer) &&\
    \ x < 0\n      0\n    else\n      x + x\n    end\n  end\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis doesn't answer the question. OP wants to know why his code\
    \ doesn't work, not how to fix it.\n<|/ c |>\n<| c |>\nThe OP wants to know why\
    \ his code doesn't work, not how to fix it. The code does work, it's just not\
    \ as efficient as possible.\n<|/ c |>\n<| c |>\nI agree with you. But the OP asked\
    \ \"why my code doesn't work\", not \"how to fix it\". I think it's important\
    \ to point out that your code is more efficient than mine.\n<|/ c |>\n<| c |>\n\
    I agree with you. But the OP asked \"why my code doesn't work\", not \"how to\
    \ fix it\". I think it's important to point out that your code is more efficient\
    \ than mine.\n<|/ c |>\n<| c |>\nI agree with you. But the OP asked \"why my code\
    \ doesn't work\", not \"how to fix it\". I think it's important to point out that\
    \ your code is more efficient than mine.\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  "  lst.inject(0) { |sum, item| sum + item if item % 2 == 1 }\nend", "  lst.each\
    \ do |x|\n    if x.is_a? Integer\n      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a?\
    \ Float\n      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? String\n      x % 2 ==\
    \ 0 ? x * 2 : x\n    elsif x.is_a? Array\n      x % 2 == 0 ? x * 2 : x\n    else\n\
    \      x\n    end\n  end\nend", "  lst.each do |x|\n    if x.is_a?(Integer) &&\
    \ x > 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n   \
    \   x + x\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<|\
    \ c |>\nI like your solution, but I believe it can be simplified even more. `lst.inject(0)\
    \ { |sum, el| sum + el if el.is_a?(Integer) && el > 0 }`\n<|/ c |>\n<| c |>\n\
    Yes, that is a lot simpler. Thanks!\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n\
    <code>", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n    elsif\
    \ x.is_a?(Integer) && x < 0\n      0\n    else\n      x + x\n    end\n  end\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\n<code>", "  lst.each do |x|\n\
    \    if x.is_a? Integer\n      x % 2 == 0 ? x * 2 : x\n    else\n      0\n   \
    \ end\n  end\nend", "  lst.each do |x|\n    next if x.is_a?(Numeric) && x.negative?\n\
    \    next if x.is_a?(Integer) && x < 0\n    break if x == 0\n    sum += x * x\n\
    \  end\n  sum\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis doesn't\
    \ work if you have a negative number in the list. Try `double_the_difference.call([-1,\
    \ -2, 0])`\n<|/ c |>\n<| c |>\n: I added a note about that to the answer.\n<|/\
    \ c |>\n<| c |>\nI added a note about that to the answer.\n<|/ c |>\n<| c |>\n\
    I added a note about that to the answer.\n<|/ c |>\n<| c |>\nI added a note about\
    \ that to the answer.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  lst.each do |x|\n\
    \    next if x.is_a?(Numeric) && x.negative?\n    next if x.is_a?(Numeric) &&\
    \ x.zero?\n    sum += x * x\n  end\n  sum\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| a tags=ruby,arrays |>\n<code>", "  lst.each do |num|\n    if num.is_a?(Integer)\
    \ && num > 0\n      num * num\n    else\n      0\n    end\n  end\nend", "  lst.each\
    \ do |x|\n    if x.is_a? Integer\n      x if x % 2 == 1\n    elsif x.is_a? Float\n\
    \      x if x % 2 == 0\n    else\n      x\n    end\n  end.reduce(:+)\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\
    \ && x > 0\n      x\n    else\n      0\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nThanks for your answer. I'm still trying to understand how this\
    \ works. I understand that `lst.each do |x|` iterates through each element in\
    \ the list, but I don't understand how `if x.is_a?(Integer) && x > 0` works. I\
    \ understand that `&&` means \"and\", but I don't understand how `x > 0` works.\
    \ I understand that `x > 0` means \"greater than zero\", but I don't understand\
    \ how `x.is_a?(Integer)` works. I understand that `x.is_a?(Integer)` means \"\
    is x an Integer\", but I don't understand how `x > 0` works. I understand that\
    \ `x > 0` means \"greater than zero\", but I don't understand how `if x.is_a?(Integer)\
    \ && x > 0` works. I understand that `if x.is_a?(Integer) && x > 0` means \"if\
    \ x is an Integer AND greater than zero\", but I don't understand how `x > 0`\
    \ works. I understand that `x > 0` means \"greater than zero\", but I don't understand\
    \ how `if x.is_a?(Integer) && x > 0` works. I understand that `if x.is_a?(Integer)\
    \ && x > 0` means \"if x is an Integer AND greater than zero\", but I don't understand\
    \ how `x > 0` works. I understand that `x > 0` means \"greater than zero\", but\
    \ I don't understand how `if x.is_a?(Integer) && x > 0` works. I understand that\
    \ `if x.is_a?(Integer) && x > 0` means \"if x is an Integer AND greater than zero\"\
    , but I don't understand how `x > 0` works. I understand that `x > 0` means \"\
    greater than zero\", but I don't understand how `if x.is_a?(Integer) && x > 0`\
    \ works. I understand that `if x.is_a?(Integer) && x > 0` means \"if x is an Integer\
    \ AND greater than zero\", but I don't understand how `x > 0` works. I understand\
    \ that `x > 0` means \"greater than zero\", but I don't understand how `if x.is_a?(Integer)\
    \ && x > 0` works. I understand that `if x.is_a?(Integer) && x > 0` means \"if\
    \ x is an Integer AND greater than zero\", but I don't understand how `x > 0`\
    \ works. I understand that `x > 0` means \"greater than zero\", but I don't understand\
    \ how `if x.is_a?(Integer", "  lst.each do |x|\n    if x.is_a?(Integer) && x >\
    \ 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n      x\
    \ + x\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>",
  "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n    else\n      0\n\
    \    end\n  end\nend", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n\
    \      x\n    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n      x + x\n\
    \    end\n  end\nend", "  lst.each do |x|\n    if x.is_a? Integer\n      x % 2\
    \ == 0 ? x * 2 : x\n    elsif x.is_a? Float\n      x * 2\n    else\n      0\n\
    \    end\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nI like\
    \ your solution, but I wonder why you used `map` instead of `each`?\n<|/ c |>\n\
    <| c |>\n`map` returns an array, so I used `each` instead. `map` returns an array\
    \ of the same size as the original array, but `each` returns nothing.\n<|/ c |>\n\
    <| c |>\nI see. Thanks for explaining.\n<|/ c |>\n<| c |>\nI like your solution,\
    \ but I wonder why you used `map` instead of `each`?\n<|/ c |>\n<| c |>\n`map`\
    \ returns an array, so I used `each` instead. `map` returns an array of the same\
    \ size as the original array, but `each` returns nothing.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\n      x -= x\n   \
    \ end\n  end\n  lst.inject(0) {|sum, el| sum + el*el }\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI like your solution, but I believe that `inject` should be used\
    \ instead of `reduce` since `reduce` will iterate over the entire list even if\
    \ the first element is a duplicate.\n<|/ c |>\n<| c |>\nI agree with you. `inject`\
    \ should be used instead of `reduce` since `reduce` will iterate over the entire\
    \ list even if the first element is a duplicate.\n<|/ c |>\n<| c |>\nI agree with\
    \ you. `inject` should be used instead of `reduce` since `reduce` will iterate\
    \ over the entire list even if the first element is a duplicate.\n<|/ c |>\n<|\
    \ c |>\nI agree with you. `inject` should be used instead of `reduce` since `reduce`\
    \ will iterate over the entire list even if the first element is a duplicate.\n\
    <|/ c |>\n<| c |>\nI agree with you. `inject` should be used instead of `reduce`\
    \ since `reduce` will iterate over the entire list even if the first element is\
    \ a duplicate.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  lst.each do |x|\n    if\
    \ x.is_a? Integer\n      x if x % 2 == 1\n    elsif x.is_a? Float\n      x if\
    \ x.to_i % 2 == 1\n    else\n      x\n    end\n  end.reduce(:+)\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis doesn't answer the question of\
    \ how to get rid of the `if` statements.\n<|/ c |>\n<| c |>\nI added an explanation\
    \ on how to get rid of the `if` statements.\n<|/ c |>\n<| c |>\nI added an explanation\
    \ on how to get rid of the `if` statements.\n<|/ c |>\n<| c |>\nI added an explanation\
    \ on how to get rid of the `if` statements.\n<|/ c |>\n<| c |>\nI added an explanation\
    \ on how to get rid of the `if` statements.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  lst.each do |x|\n    if x.is_a?(Integer)\n      x % 2 == 0 ? x * 2 : x\n    else\n\
    \      0\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c\
    \ |>\nThis is not an answer to the question. He wants to know why his code doesn't\
    \ work, not how to fix it.\n<|/ c |>\n<| c |>\nThe OP has stated that he wants\
    \ to know why his code doesn't work. He also stated that he wants to know why\
    \ his code doesn't work. He also stated that he wants to know why his code doesn't\
    \ work. He also stated that he wants to know why his code doesn't work. He also\
    \ stated that he wants to know why his code doesn't work. He also stated that\
    \ he wants to know why his code doesn't work. He also stated that he wants to\
    \ know why his code doesn't work. He also stated that he wants to know why his\
    \ code doesn't work. He also stated that he wants to know why his code doesn't\
    \ work. He also stated that he wants to know why his code doesn't work. He also\
    \ stated that he wants to know why his code doesn't work. He also stated that\
    \ he wants to know why his code doesn't work. He also stated that he wants to\
    \ know why his code doesn't work. He also stated that he wants to know why his\
    \ code doesn't work. He also stated that he wants to know why his code doesn't\
    \ work. He also stated that he wants to know why his code doesn't work. He also\
    \ stated that he wants to know why his code doesn't work. He also stated that\
    \ he wants to know why his code doesn't work. He also stated that he wants to\
    \ know why his code doesn't work. He also stated that he wants to know why his\
    \ code doesn't work. He also stated that he wants to know why his code doesn't\
    \ work. He also stated that he wants to know why his code doesn't work. He also\
    \ stated that he wants to know why his code doesn't work. He also stated that\
    \ he wants to know why his code doesn't work. He also stated that he wants to\
    \ know why his code doesn't work. He also stated that he wants to know why his\
    \ code doesn't work. He also stated that he ", "  lst.each do |num|\n    next\
    \ if num < 0\n    next if num.is_a?(Integer)\n    next if num.is_a?(Float)\n \
    \   sum += num * num\n  end\n  sum\nend", "  lst.each do |x|\n    if x.is_a? Integer\n\
    \      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? Float\n      x % 2 == 0 ? x *\
    \ 2 : x\n    else\n      0\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=ruby,arrays,ruby-on-rails |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\
    \ && x > 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n\
    \      x + x\n    end\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis\
    \ doesn't work if you pass in an empty array. Try `double_the_difference.call([])`.\n\
    <|/ c |>\n<| c |>\nI added a check for empty arrays. Thanks.\n<|/ c |>\n<| c |>\n\
    I added a check for negative numbers. Thanks.\n<|/ c |>\n<| c |>\nI added a check\
    \ for negative numbers. Thanks.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  lst.each\
    \ do |x|\n    if x.is_a? Integer\n      x if x % 2 == 1\n    elsif x.is_a? Float\n\
    \      x if x.to_i % 2 == 1\n    else\n      0\n    end\n  end\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThanks for your answer. Your code is\
    \ very clear and easy to understand. Thank you very much!\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  lst.inject(0) { |sum, item| sum + item if item % 2 == 1 }\n\
    end", "  lst.each do |x|\n    next if x.is_a?(Numeric)\n    next if x.is_a?(String)\
    \ || x.is_a?(Symbol)\n    next if x.is_a?(TrueClass) || x.is_a?(FalseClass)\n\
    \    next if x.is_a?(Array)\n    next if x.is_a?(Hash)\n    next if x.is_a?(Range)\n\
    \    next if x.is_a?(IO)\n    next if x.is_a?(File)\n    next if x.is_a?(Process)\n\
    \    next if x.is_a?(Thread)\n    next if x.is_a?(Proc)\n    next if x.is_a?(IO::WaitReadable)\n\
    \    next if x.is_a?(IO::WaitWritable)\n    next if x.is_a?(IO::WaitHandle)\n\
    \    next if x.is_a?(IO::Pipe)\n    next if x.is_a?(IO::Pipe::Reader)\n    next\
    \ if x.is_a?(IO::Pipe::Writer)\n    next if x.is_a?(IO::Pipe::Error)\n    next\
    \ if x.is_a?(IO::Pipe::IN)\n    next if x.is_a?(IO::Pipe::OUT)\n    next if x.is_a?(IO::Pipe::ERR)\n\
    \    next if x.is_a?(IO::Pipe::INOUT)\n    next if x.is_a?(IO::Pipe::UNDEF)\n\
    \    next if x.is_a?(IO::Pipe::TIMEOUT)\n    next if x.is_a?(IO::Pipe::BUF)\n\
    \    next if x.is_a?(IO::Pipe::RD)\n    next if x.is_a?(IO::Pipe::WR)\n    next\
    \ if x.is_a?(IO::Pipe::RDWR)\n    next if x.is_a?(IO::Pipe::RD)\n    next if x.is_a?(IO::Pipe::WR)\n\
    \    next if x.is_a?(IO::Pipe::RDWR)\n    next if x.is_a?(IO::Pipe::RD)\n    next\
    \ if x.is_a?(IO::Pipe::WR)\n    next if x.is_a?(IO::Pipe::RDWR)\n    next if x.is_a?(IO::Pipe::RD)\n\
    \    next if x.is_a?(IO::Pipe::WR)\n    next if x.is_a?(IO::Pipe::RDWR)\n    next\
    \ if x.is_a?(IO::Pipe::RD)\n    next ", "  lst.each do |x|\n    if x.is_a?(Integer)\
    \ && x > 0\n      x *= 2\n    elsif x.is_a?(Integer) && x < 0\n      x *= -1\n\
    \    end\n  end\n  lst.inject(0) {|sum, x| sum + x}\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nI like your solution, but I wonder why you used `inject` instead\
    \ of `reduce`?\n<|/ c |>\n<| c |>\n`inject` works on arrays, `reduce` works on\
    \ enumerables. `inject` works on arrays, `reduce` works on enumerables. `inject`\
    \ works on arrays, `reduce` works on enumerables. `inject` works on arrays, `reduce`\
    \ works on enumerables. `inject` works on arrays, `reduce` works on enumerables.\
    \ `inject` works on arrays, `reduce` works on enumerables. `inject` works on arrays,\
    \ `reduce` works on enumerables. `inject` works on arrays, `reduce` works on enumerables.\
    \ `inject` works on arrays, `reduce` works on enumerables. `inject` works on arrays,\
    \ `reduce` works on enumerables. `inject` works on arrays, `reduce` works on enumerables.\
    \ `inject` works on arrays, `reduce` works on enumerables. `inject` works on arrays,\
    \ `reduce` works on enumerables. `inject` works on arrays, `reduce` works on enumerables.\
    \ `inject` works on arrays, `reduce` works on enumerables. `inject` works on arrays,\
    \ `reduce` works on enumerables. `inject` works on arrays, `reduce` works on enumerables.\
    \ `inject` works on arrays, `reduce` works on enumerables. `inject` works on arrays,\
    \ `reduce` works on enumerables. `inject` works on arrays, `reduce` works on enumerables.\
    \ `inject` works on arrays, `reduce` works on enumerables. `inject` works on arrays,\
    \ `reduce` works on enumerables. `inject` works on arrays, `reduce` works on enumerables.\
    \ `inject` works on arrays, `reduce` works on enumerables. `inject` works on arrays,\
    \ `reduce` works on enumerables. `inject` works on arrays, `reduce` works on enumerables.\
    \ `inject` works on arrays, `reduce` works on enumerables. `inject` works on arrays,\
    \ `reduce` works on enumerables. `inject` works on arrays, `reduce` works on enumerable",
  "  lst.each do |num|\n    return 0 if num < 0\n    return num if num.is_a?(Integer)\n\
    \    return num * num if num.is_a?(Float)\n  end\n  0\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| a dscore=0 |>\n<code>", "  lst.each do |x|\n    if x.is_a? Integer\n\
    \      x % 2 == 0 ? x*x : x\n    elsif x.is_a? Float\n      x % 2 == 0 ? x*x :\
    \ x\n    else\n      x\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails\
    \ |>\n<| c |>\nI like your solution, but I believe it can be simplified a bit.\
    \ `lst.map { |x| x.is_a?(Integer) ? x*x : x }.reduce(:+)` should do the trick.\n\
    <|/ c |>\n<| c |>\nI agree, that is a lot cleaner. I'll update my answer.\n<|/\
    \ c |>\n<| c |>\nI like your solution, but I believe it can be simplified a bit.\
    \ `lst.map { |x| x.is_a?(Integer) ? x*x : x }.reduce(:+)` should do the trick.\n\
    <|/ c |>\n<| c |>\nI like your solution, but I believe it can be simplified a\
    \ bit. `lst.map { |x| x.is_a?(Integer) ? x*x : x }.reduce(:+)` should do the trick.\n\
    <|/ c |>\n<| c |>\nI like your solution, but I believe it can be simplified a\
    \ bit. `lst.map { |x| x.is_a?(Integer) ? x*x : x }.reduce(:+)` should do the trick.\n\
    <|/ c |>\n<| a dscore=3 |>\n<code>", "  lst.each do |x|\n    if x.is_a? Integer\n\
    \      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? Float\n      x * 2\n    else\n\
    \      0\n    end\n  end.reduce(:+)\nend", "  lst.each do |x|\n    if x.is_a?\
    \ Integer\n      x if x % 2 == 1\n    else\n      x if x % 2 == 0\n    end\n \
    \ end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like your solution, but I\
    \ believe it would be more efficient to just do `lst.select { |x| x.is_a? Integer\
    \ }.inject(0) { |sum, x| sum + x }`.\n<|/ c |>\n<| c |>\n: Yes, that would be\
    \ more efficient. Thanks.\n<|/ c |>\n<| c |>\n: I added a more efficient solution.\
    \ Thanks.\n<|/ c |>\n<| c |>\n: I added a more efficient solution. Thanks.\n<|/\
    \ c |>\n<| c |>\n: I added a more efficient solution. Thanks.\n<|/ c |>\n<| a\
    \ tags=ruby |>\n<code>", "  lst.each do |i|\n    next if i.negative?\n    next\
    \ if i.zero?\n    sum += i\n  end\n  sum\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=0 |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n\
    \      x\n    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n      x * x\n\
    \    end\n  end.reduce(:+)\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n\
    <code>", "  lst.each do |x|\n    if x.is_a?(Integer)\n      x\n    elsif x.is_a?(Float)\n\
    \      x\n    elsif x.is_a?(String)\n      x.to_i\n    else\n      0\n    end\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| c |>\n\
    This doesn't work if you pass in an array of hashes. I added an answer that does\
    \ work\n<|/ c |>\n<| a |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\
    \ && x > 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n\
    \      x * 2\n    end\n  end.reduce(:+)\nend", "  lst.each do |x|\n    if x.is_a?(Integer)\
    \ && x > 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n\
    \      x + x\n    end\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby\
    \ |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n\
    \    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n      x + x\n    end\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n\
    \    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n      x + x\n    end\n\
    \  end\nend", "  lst.each do |i|\n    if i.is_a? Integer\n      i -= 1 if i %\
    \ 2 == 1\n    end\n  end\n  lst.inject(0) {|sum, i| sum + i }\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nI like your solution, but I believe\
    \ it would be better to use the `each_with_index` method instead of `each`.  `each_with_index`\
    \ will give you the index as well as the element in the array.  Then you can just\
    \ subtract 1 from the index instead of having to subtract 1 from the element in\
    \ the array.\n<|/ c |>\n<| c |>\nThanks, I didn't know about each_with_index.\
    \ I've updated my answer.\n<|/ c |>\n<| c |>\nThanks guys. I appreciate all the\
    \ help. I went with your first solution and it worked great. Thanks again!\n<|/\
    \ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\n\
    \      x\n    elsif x.is_a?(Float)\n      x\n    elsif x.is_a?(String)\n     \
    \ x.to_i\n    else\n      0\n    end\n  end.reduce(:+)\nend\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\n<code>", "  lst.each do |x|\n    next if x.is_a?(String) ||\
    \ x.nil?\n    next if x.is_a?(Fixnum) || x.nil?\n    next if x.is_a?(Bignum) ||\
    \ x.nil?\n    next if x.is_a?(Float) || x.nil?\n    next if x.is_a?(TrueClass)\
    \ || x.nil?\n    next if x.is_a?(FalseClass) || x.nil?\n    next if x.is_a?(Array)\
    \ || x.nil?\n    next if x.is_a?(Hash) || x.nil?\n    next if x.is_a?(Range) ||\
    \ x.nil?\n    next if x.is_a?(IO) || x.nil?\n    next if x.is_a?(StringIO) ||\
    \ x.nil?\n    next if x.is_a?(File) || x.nil?\n    next if x.is_a?(Enumerator)\
    \ || x.nil?\n    next if x.is_a?(Enumerable) || x.nil?\n    next if x.is_a?(IO::WaitReadable)\
    \ || x.nil?\n    next if x.is_a?(IO::WaitWritable) || x.nil?\n    next if x.is_a?(IO::WaitDrained)\
    \ || x.nil?\n    next if x.is_a?(IO::WaitHandle) || x.nil?\n    next if x.is_a?(IO::WaitForeground)\
    \ || x.nil?\n    next if x.is_a?(IO::WaitAll) || x.nil?\n    next if x.is_a?(IO::WaitAny)\
    \ || x.nil?\n    next if x.is_a?(IO::WaitWrite) || x.nil?\n    next if x.is_a?(IO::WaitNamedPipe)\
    \ || x.nil?\n    next if x.is_a?(IO::WaitNamedPipe2) || x.nil?\n    next if x.is_a?(IO::WaitNamedPipeError)\
    \ || x.nil?\n    next if x.is_a?(IO::WaitHandle::WaitHandle) || x.nil?\n    next\
    \ if x.is_a?(IO::WaitHandle::WaitHandleValue) || x.nil?\n    next if x.is_a?(IO::WaitHandle::WaitHandleValue::WAIT_ABANDONED_0)\
    \ || x.nil?\n    next if x.is_a?(IO::WaitHandle::WaitHandleValue::WAIT_ABANDONED_1)\
    \ || x.nil?\n    next if x.is_a?(IO::WaitHandle::WaitHandleValue::WAIT_ABANDONED_2)\
    \ || x.nil?\n    next if x.is_", "  lst.each do |x|\n    if x.is_a? Integer\n\
    \      x if x % 2 == 1\n    else\n      x if x % 2 == 0\n    end\n  end\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nI like this solution, but\
    \ I feel like it could be improved. For example, `double_the_difference([9, -2])`\
    \ returns `81` instead of `0`, which would be more intuitive. Also, `double_the_difference([0,\
    \ 1])` returns `0` instead of `1`, which would be more intuitive. Also, `double_the_difference([0,\
    \ 0])` returns `0` instead of `0`, which would be more intuitive. Also, `double_the_difference([-1,\
    \ -2, 0])` returns `0` instead of `-1`, which would be more intuitive.\n<|/ c\
    \ |>\n<| c |>\nI agree, this is definitely a better solution. I'll update my answer\
    \ with your suggestions.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>",
  "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x *= 2\n    end\n  end\n\
    \  lst.inject(0) do |sum, num|\n    sum + num\n  end\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nI like your solution, but I wonder why you chose to write `if x.is_a?(Integer)\
    \ && x > 0` instead of `if x.is_a?(Integer) && x.positive?`\n<|/ c |>\n<| c |>\n\
    I chose to write it because I wanted to be explicit about what I was doing. `x.positive?`\
    \ would not work if `x` was a string. `x.is_a?(Integer)` would not work if `x`\
    \ was an array. `x.is_a?(Integer)` would not work if `x` was an `Object` other\
    \ than `Integer`.\n<|/ c |>\n<| c |>\nI see. Thanks for explaining.\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>", "  lst.each do |x|\n    if x.is_a? Integer\n      x\
    \ % 2 == 0 ? x * 2 : x\n    elsif x.is_a? Float\n      x % 2 == 0 ? x * 2 : x\n\
    \    elsif x.is_a? String\n      x % 2 == 0 ? x * 2 : x\n    else\n      x\n \
    \   end\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis\
    \ doesn't answer the question. OP wants to know why his code doesn't work, not\
    \ how to fix it.\n<|/ c |>\n<| c |>\nI answered the question. He asked why his\
    \ code doesn't work. He also asked how to fix it. He also asked how to fix his\
    \ code. He also asked how to fix his code. He also asked how to fix his code.\
    \ He also asked how to fix his code. He also asked how to fix his code. He also\
    \ asked how to fix his code. He also asked how to fix his code. He also asked\
    \ how to fix his code. He also asked how to fix his code. He also asked how to\
    \ fix his code. He also asked how to fix his code. He also asked how to fix his\
    \ code. He also asked how to fix his code. He also asked how to fix his code.\
    \ He also asked how to fix his code. He also asked how to fix his code. He also\
    \ asked how to fix his code. He also asked how to fix his code. He also asked\
    \ how to fix his code. He also asked how to fix his code. He also asked how to\
    \ fix his code. He also asked how to fix his code. He also asked how to fix his\
    \ code. He also asked how to fix his code. He also asked how to fix his code.\
    \ He also asked how to fix his code. He also asked how to fix his code. He also\
    \ asked how to fix his code. He also asked how to fix his code. He also asked\
    \ how to fix his code. He also asked how to fix his code. He also asked how to\
    \ fix his code. He also asked how to fix his code. He also asked how to fix his\
    \ code. He also asked how to fix his code. He also asked how to fix his code.\
    \ He also asked how to ", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n\
    \      x *= 2\n    elsif x.is_a?(Integer) && x < 0\n      x /= 2\n    end\n  end\n\
    \  lst.inject(0) do |sum, e|\n    sum + e\n  end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nI like your solution, but I believe that `inject` can be replaced\
    \ by `reduce`\n<|/ c |>\n<| c |>\n: Yes, `reduce` is more concise. `inject` was\
    \ introduced later, so I used it for consistency with the other solutions.\n<|/\
    \ c |>\n<| a dscore=1 |>\n<code>", "  lst.each do |n|\n    next if n.is_a? Float\n\
    \    next if n.is_a? Integer\n    next if n.is_a? String\n    next if n.is_a?\
    \ Symbol\n    next if n.is_a? NilClass\n    next if n.is_a? TrueClass\n    next\
    \ if n.is_a? FalseClass\n    next if n.is_a? Nil\n    next if n.is_a? False\n\
    \    next if n.is_a? True\n    next if n.is_a? Fixnum\n    next if n.is_a? Bignum\n\
    \    next if n.is_a? Float\n    next if n.is_a? Rational\n    next if n.is_a?\
    \ Numeric\n    next if n.is_a? Array\n    next if n.is_a? Hash\n    next if n.is_a?\
    \ Range\n    next if n.is_a? IO\n    next if n.is_a? StringIO\n    next if n.is_a?\
    \ IO::Memory\n    next if n.is_a? IO::File\n    next if n.is_a? IO::Null\n   \
    \ next if n.is_a? IO::Pipe\n    next if n.is_a? IO::Pipe::Read\n    next if n.is_a?\
    \ IO::Pipe::Write\n    next if n.is_a? IO::Pipe::Open\n    next if n.is_a? IO::Pipe::Open::Read\n\
    \    next if n.is_a? IO::Pipe::Open::Write\n    next if n.is_a? IO::Pipe::Open::ReadWrite\n\
    \    next if n.is_a? IO::Pipe::Open::ReadWrite::Pipe\n    next if n.is_a? IO::Pipe::Open::ReadWrite::Pipe::Read\n\
    \    next if n.is_a? IO::Pipe::Open::ReadWrite::Pipe::Write\n    next if n.is_a?\
    \ IO::Pipe::Open::ReadWrite::Pipe::Open\n    next if n.is_a? IO::Pipe::Open::ReadWrite::Pipe::Open::Read\n\
    \    next if n.is_a? IO::Pipe::Open::ReadWrite::Pipe::Open::Write\n    next if\
    \ n.is_a? IO::Pipe::Open::ReadWrite::Pipe::Open::Read::Pipe\n    next if n.is_a?\
    \ IO::Pipe::Open::ReadWrite::Pipe::Open::Read::Pipe::Read\n    next if n.is_a?\
    \ IO::Pipe::Open::ReadWrite::", "  lst.each do |x|\n    if x.is_a?(Integer) &&\
    \ x > 0\n      x\n    else\n      0\n    end\n  end\nend", "  lst.each do |x|\n\
    \    if x.is_a?(Integer) && x > 0\n      x\n    elsif x.is_a?(Integer) && x <\
    \ 0\n      0\n    else\n      x + x\n    end\n  end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer) &&\
    \ x > 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n      0\n    elsif x.is_a?(Integer)\
    \ && x == 0\n      0\n    else\n      x + x\n    end\n  end\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\n\
    It does work. Try it with `[1,2,3]`. `double_the_difference([1,2,3])` returns\
    \ `6`.\n<|/ c |>\n<| c |>\nIt doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n\
    <| c |>\nIt does work. Try it with `[1,2,3]`. `double_the_difference([1,2,3])`\
    \ returns `6`.\n<|/ c |>\n<| c |>\nIt does work. Try it with `[1,2,3]`. `double_the_difference([1,2,3])`\
    \ returns `6`.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  lst.each\
    \ do |x|\n    if x.is_a?(Integer) && x > 0\n      x *= 2\n    end\n  end\n  lst.inject(0)\
    \ do |sum, num|\n    sum + num\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This doesn't answer the question. The OP wants to know how to implement this in\
    \ Ruby.\n<|/ c |>\n<| c |>\nI agree with you. My answer was more of a \"how would\
    \ I do it in Ruby\" than an \"how would I do it in Python\". I'll update my answer\
    \ to reflect that.\n<|/ c |>\n<| c |>\nI updated my answer to include a Ruby implementation.\n\
    <|/ c |>\n<| c |>\nI updated my answer to include a Ruby implementation.\n<|/\
    \ c |>\n<| c |>\nI updated my answer to include a Ruby implementation.\n<|/ c\
    \ |>\n<| a dscore=0 |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\n\
    \      x if x % 2 == 0\n    else\n      x if x % 2 != 0\n    end\n  end\nend",
  "  lst.inject(0) do |sum, num|\n    sum + num if num % 2 == 1\n  end\nend", "  lst.each\
    \ do |x|\n    if x.is_a?(Integer) && x > 0\n      x *= 2\n    elsif x.is_a?(Integer)\
    \ && x < 0\n      x *= -2\n    end\n  end\n  lst.inject(:+)\nend\n</code>\n<|/\
    \ a tags=ruby,ruby-on-rails |>\n<| c |>\nI like your solution, but I believe it\
    \ can be simplified a bit. `lst.inject(:+)` can be replaced with `lst.inject(:*)`.\n\
    <|/ c |>\n<| c |>\nI agree, but I wanted to keep the original code as much as\
    \ possible. :)\n<|/ c |>\n<| c |>\nI agree with you. :)\n<|/ c |>\n<| c |>\nI\
    \ like your solution, but I believe it can be simplified a bit. `lst.each do |x|\n\
    \    if x.is_a?(Integer) && x > 0\n      x *= 2\n    elsif x.is_a?(Integer) &&\
    \ x < 0\n      x *= -2\n    end\n  end\n  lst.inject(:+)\nend` can be replaced\
    \ with `lst.inject(:*)`.\n<|/ c |>\n<| c |>\nI agree, but I wanted to keep the\
    \ original code as much as possible. :)\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  lst.each do |x|\n    if x.is_a? Integer\n      x % 2 == 0 ?\
    \ x * 2 : x\n    elsif x.is_a? Float\n      x % 2 == 0 ? x * 2 : x\n    elsif\
    \ x.is_a? String\n      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? Array\n    \
    \  x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? Hash\n      x % 2 == 0 ? x * 2 :\
    \ x\n    elsif x.is_a? NilClass\n      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a?\
    \ TrueClass\n      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? FalseClass\n    \
    \  x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? Nil\n      x % 2 == 0 ? x * 2 : x\n\
    \    elsif x.is_a? Fixnum\n      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? Bignum\n\
    \      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? Complex\n      x % 2 == 0 ? x\
    \ * 2 : x\n    elsif x.is_a? Range\n      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a?\
    \ Regexp\n      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? IO\n      x % 2 == 0\
    \ ? x * 2 : x\n    elsif x.is_a? Enumerator\n      x % 2 == 0 ? x * 2 : x\n  \
    \  elsif x.is_a? Enumerable\n      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? IO::NullIO\n\
    \      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? IO::File\n      x % 2 == 0 ?\
    \ x * 2 : x\n    elsif x.is_a? IO::Dir\n      x % 2 == 0 ? x * 2 : x\n    elsif\
    \ x.is_a? IO::StandardError\n      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? IO::NullIO\n\
    \      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a? IO::NullFile\n      x % 2 ==\
    \ 0 ? x * 2 : x\n    elsif x.is_a? IO::NullFile\n      x % 2 == 0 ? x * 2 : x\n\
    \    elsif x.is_a? IO::NullFile\n      x % 2 == 0 ? x * 2 : x\n    elsif x.is_a?\
    \ IO::NullFile\n      x % 2 == 0 ? x * 2 : x\n    elsif ", "  lst.each do |x|\n\
    \    if x.is_a?(Integer)\n      x += 1\n    end\n    if x.is_a?(Float)\n     \
    \ x += 0.0\n    end\n  end\n  lst.inject(0) { |sum, e| sum + e * e }\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't work. `[1,2,3].inject(0) { |sum, e| sum + e *\
    \ e }\n=> 6` should be `10`\n<|/ c |>\n<| c |>\n: It does work. Try it yourself.\n\
    <|/ c |>\n<| c |>\n: I see what you mean. Fixed it.\n<|/ c |>\n<| c |>\n: I added\
    \ a version that doesn't require the use of `inject`.\n<|/ c |>\n<| c |>\n: I\
    \ added a version that doesn't require the use of `inject`.\n<|/ c |>\n<| a dscore=3\
    \ |>\n<code>", "  lst.each do |num|\n    return 0 if num < 0\n    return num if\
    \ num.is_a?(Integer)\n    return num * num if num.is_a?(Float)\n  end\n  0\nend\n\
    </code>\n<|/ a |>\n<| c |>\nI like your solution, but I wonder if it would be\
    \ more efficient to just do `return 0 if num < 0` and `return num if num.is_a?(Integer)`\
    \ and `return num * num if num.is_a?(Float)` instead of `return 0 if num < 0`,\
    \ `return num if num.is_a?(Integer)` and `return num * num if num.is_a?(Float)`\n\
    <|/ c |>\n<| c |>\n: Yes, that would be more efficient. I'll add that to the answer.\n\
    <|/ c |>\n<| c |>\n: I added a version that uses `each` instead of `map`. It should\
    \ be more efficient than my first version.\n<|/ c |>\n<| c |>\n: I added a version\
    \ that uses `each` instead of `map`. It should be more efficient than my first\
    \ version.\n<|/ c |>\n<| c |>\n: I added a version that uses `each` instead of\
    \ `map`. It should be more efficient than my first version.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x\n\
    \    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n      x + x\n    end\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nI like your solution,\
    \ but I believe it can be simplified a bit. `lst.inject(0) { |sum, x| sum + x\
    \ if x.is_a?(Integer) && x > 0; sum + x if x.is_a?(Integer) && x < 0; sum + x\
    \ if x.is_a?(Integer) && x == 0; sum + x if x.is_a?(Integer) && x == nil; sum\
    \ + x if x.is_a?(Integer) && x == false; sum + x if x.is_a?(Integer) && x == nil;\
    \ sum + x if x.is_a?(Integer) && x == false; sum + x if x.is_a?(Integer) && x\
    \ == nil; sum + x if x.is_a?(Integer) && x == false; sum + x if x.is_a?(Integer)\
    \ && x == nil; sum + x if x.is_a?(Integer) && x == false; sum + x if x.is_a?(Integer)\
    \ && x == nil; sum + x if x.is_a?(Integer) && x == false; sum + x if x.is_a?(Integer)\
    \ && x == nil; sum + x if x.is_a?(Integer) && x == false; sum + x if x.is_a?(Integer)\
    \ && x == nil; sum + x if x.is_a?(Integer) && x == false; sum + x if x.is_a?(Integer)\
    \ && x == nil; sum + x if x.is_a?(Integer) && x == false; sum + x if x.is_a?(Integer)\
    \ && x == nil; sum + x if x.is_a?(Integer) && x == false; sum + x if x.is_a?(Integer)\
    \ && x == nil; sum + x if x.is_a?(Integer) && x == false; sum + x if x.is_a?(Integer)\
    \ && x == nil; sum + x if x.is_a?(Integer) && x == false; sum + x if x.is_a?(Integer)\
    \ && x == nil; sum + x if x.is_a?(Integer) && x == false; sum + x if x.is_a?(Integer)\
    \ && x == nil; sum + x if x.is_a?(Integer) && x == false; sum + x if x.is_a?(Integer)\
    \ && x == nil; sum + x if x.is_a?(Integer) && x == false; sum + x if x.is_a?(Integer)\
    \ && x == nil; sum + x if x.is_", "  lst.each do |x|\n    if x.is_a? Integer\n\
    \      x if x % 2 == 1\n    elsif x.is_a? Float\n      x if x.to_i % 2 == 1\n\
    \    else\n      x\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>", "  lst.each do |num|\n    if num.is_a? Integer\n      num\n   \
    \ elsif num.is_a? Float\n      num\n    elsif num.is_a? String\n      num.to_i\n\
    \    else\n      0\n    end\n  end\nend", "  lst.each do |x|\n    next if x.is_a?(Numeric)\
    \ || x.nil?\n    next if x.is_a?(String) || x.nil?\n    next if x.is_a?(Symbol)\
    \ || x.nil?\n    next if x.is_a?(TrueClass) || x.nil?\n    next if x.is_a?(FalseClass)\
    \ || x.nil?\n    next if x.is_a?(Bignum) || x.nil?\n    next if x.is_a?(Fixnum)\
    \ || x.nil?\n    next if x.is_a?(Float) || x.nil?\n    next if x.is_a?(Array)\
    \ || x.nil?\n    next if x.is_a?(Hash) || x.nil?\n    next if x.is_a?(Range) ||\
    \ x.nil?\n    next if x.is_a?(IO) || x.nil?\n    next if x.is_a?(StringIO) ||\
    \ x.nil?\n    next if x.is_a?(IO::Memory) || x.nil?\n    next if x.is_a?(IO::Pipe)\
    \ || x.nil?\n    next if x.is_a?(IO::Null) || x.nil?\n    next if x.is_a?(IO::File)\
    \ || x.nil?\n    next if x.is_a?(IO::File::Base) || x.nil?\n    next if x.is_a?(IO::File::Null)\
    \ || x.nil?\n    next if x.is_a?(IO::File::Temp) || x.nil?\n    next if x.is_a?(IO::File::RDONLY)\
    \ || x.nil?\n    next if x.is_a?(IO::File::WRONLY) || x.nil?\n    next if x.is_a?(IO::File::CREAT)\
    \ || x.nil?\n    next if x.is_a?(IO::File::EXCL) || x.nil?\n    next if x.is_a?(IO::File::TRUNC)\
    \ || x.nil?\n    next if x.is_a?(IO::File::APPEND) || x.nil?\n    next if x.is_a?(IO::File::BINARY)\
    \ || x.nil?\n    next if x.is_a?(IO::File::CREAT | IO::File::EXCL) || x.nil?\n\
    \    next if x.is_a?(IO::File::TRUNC | IO::File::APPEND) || x.nil?\n    next if\
    \ x.is_a?(IO::File::BINARY | IO::File::CREAT | IO::File::EXCL) || x.nil?\n   \
    \ next if x.is_a?(IO::", "  lst.each do |x|\n    next if x.negative?\n    next\
    \ if x.is_integer?\n    sum += x * x\n  end\n  sum\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't answer the question, which is about how to write this\
    \ in Ruby.\n<|/ c |>\n<| c |>\nI didn't see that he was asking how to write it\
    \ in Ruby, but I'll leave this here for future reference. Thanks for pointing\
    \ it out.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  lst.each do |i|\n    if i.is_a?\
    \ Integer\n      i\n    elsif i.is_a? Float\n      i.to_i\n    else\n      0\n\
    \    end\n  end\nend", "  lst.each do |x|\n    if x.is_a? Integer\n      x if\
    \ x % 2 == 1\n    elsif x.is_a? Float\n      x if x % 2 == 0\n    else\n     \
    \ x\n    end\n  end.reduce(:+)\nend", "  lst.each do |x|\n    if x.is_a?(Integer)\
    \ && x > 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n\
    \      x * 2\n    end\n  end\nend", "  lst.each do |x|\n    if x.is_a? Integer\n\
    \      x if x % 2 == 1\n    else\n      x if x % 2 == 0\n    end\n  end\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a tags=ruby,ruby-on-rails |>\n<code>",
  "  lst.each do |x|\n    next if x.negative?\n    next if x.is_integer?\n    next\
    \ if x.zero?\n    sum += x * x\n  end\n  sum\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nI like this solution, but I wonder why you chose to write `x.negative?`\
    \ instead of `x < 0`.\n<|/ c |>\n<| c |>\nI chose to write `x.negative?` because\
    \ I wanted to show that `x.negative?` returns true or false and `x < 0` returns\
    \ true or false and `x == 0` returns true or false. `x.negative?` makes it clear\
    \ that `x.negative?` returns true or false and `x < 0` returns true or false and\
    \ `x == 0` returns true or false.\n<|/ c |>\n<| c |>\nI see. Thanks for the explanation.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer)\
    \ && x > 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n\
    \      x * 2\n    end\n  end.reduce(:+)\nend\n</code>\n<|/ a tags=ruby |>\n<|\
    \ a tags=ruby |>\n<code>", "  lst.each do |x|\n    if x.is_a?(Integer) && x >\
    \ 0\n      x\n    elsif x.is_a?(Integer) && x < 0\n      0\n    else\n      x\
    \ + x\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ answer the question. He wants to know how to do this without using an `each`\
    \ loop. He also wants to know how to do it without using an `if` statement. He\
    \ also wants to know how to do it without using `map` or `reduce`.\n<|/ c |>\n\
    <| c |>\nI agree with you. My answer is not the best way to solve the problem.\
    \ I'm just trying to help the OP understand how it works. I agree that he should\
    \ probably use map or reduce but he didn't ask for that solution.\n<|/ c |>\n\
    <| c |>\nI agree with you. I just wanted to point out that your answer doesn't\
    \ actually answer the question. He asked how to do this without using an `each`\
    \ loop. He also asked how to do this without using an `if` statement. He also\
    \ asked how to do this without using `map` or `reduce`.\n<|/ c |>\n<| c |>\nI\
    \ agree with you. I just wanted to point out that your answer doesn't actually\
    \ answer the question. He asked how to do this without using an `each` loop. He\
    \ also asked how to do this without using an `if` statement. He also asked how\
    \ to do this without using `map` or `reduce`.\n<|/ c |>\n<| c |>\nI agree with\
    \ you. I just wanted to point out that your answer doesn't actually answer the\
    \ question. He asked how to do this without using an `each` loop. He also asked\
    \ how to do this without using an `if` statement. He also asked how to do this\
    \ without using `map` or `reduce`.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  lst.each\
    \ do |num|\n    if num.is_a?(Integer) && num > 0\n      num * num\n    else\n\
    \      0\n    end\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\n\
    <code>", "  lst.each do |num|\n    if num > 0\n      num * num\n    end\n  end\n\
    end", "  lst.each do |x|\n    if x.is_a?(Integer) && x > 0\n      x *= 2\n   \
    \ end\n  end\n  lst.inject(0) do |sum, el|\n    sum + el\n  end\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work if you pass in an empty\
    \ array. `[].inject(0) { |sum, el| sum + el }` returns `0`, not `nil`.\n<|/ c\
    \ |>\n<| c |>\n, thanks for pointing that out. I've updated the answer to account\
    \ for empty arrays.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  lst.each do |x|\n\
    \    if x.is_a?(Integer)\n      x += 1\n    end\n    x -= 1 if x % 2 == 1\n  end\n\
    \  lst.inject(0) do |sum, el|\n    sum + el\n  end\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThanks for your answer. I'm new to Ruby, so I appreciate your help.\
    \ I understand your code, but I'm having trouble understanding how it works. I\
    \ understand that `lst.each do |x|` iterates through the array, but I don't understand\
    \ how `x += 1` works. I understand that `x -= 1` subtracts 1 from x, but I don't\
    \ understand how `x += 1` works. Can you explain how `x += 1` works?\n<|/ c |>\n\
    <| c |>\n`x += 1` increments the value of `x` by one. `x -= 1` decrements the\
    \ value of `x` by one. `x += 2` increments the value of `x` by two. `x -= 2` decrements\
    \ the value of `x` by two. `x += 3` increments the value of `x` by three. `x -=\
    \ 3` decrements the value of `x` by three. `x += 4` increments the value of `x`\
    \ by four. `x -= 4` decrements the value of `x` by four. `x += 5` increments the\
    \ value of `x` by five. `x -= 5` decrements the value of `x` by five. `x += 6`\
    \ increments the value of `x` by six. `x -= 6` decrements the value of `x` by\
    \ six.\n<|/ c |>\n<| c |>\n`x += 7` increments the value of `x` by seven. `x -=\
    \ 7` decrements the value of `x` by seven. `x += 8` increments the value of `x`\
    \ by eight. `x -= 8` decrements the value of `x` by eight. `x += 9` increments\
    \ the value of `x` by nine. `x -= 9` decrements the value of `x` by nine. `x +=\
    \ 10` increments the value of `x` by ten. `x -= 10` decrements the value of `x`\
    \ by ten. `x += 11` increments the value of `x` by eleven. `x -= 11` decrements\
    \ the value of `x` by eleven. `x += 12` increments the value of `x` by twelve.\
    \ `x -= 12` decrements the value of `x` by twelve. `x += 13` increments the value\
    \ of "]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
