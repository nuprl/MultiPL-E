name: HumanEval_65_circular_shift
language: rb
prompt: "# Circular shift the digits of the integer x, shift the digits right by shift\n\
  # and return the result as a string.\n# If shift > number of digits, return digits\
  \ reversed.\n# >>> circular_shift.call(12, 1)\n# \"21\"\n# >>> circular_shift.call(12,\
  \ 2)\n# \"12\"\ndef circular_shift(x, shift)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_circular_shift\n\
  \    candidate = method(:circular_shift)\n    assert_equal(\"001\", candidate.call(100,\
  \ 2))\n    assert_equal(\"12\", candidate.call(12, 2))\n    assert_equal(\"79\"\
  , candidate.call(97, 8))\n    assert_equal(\"21\", candidate.call(12, 1))\n    assert_equal(\"\
  11\", candidate.call(11, 101))\n  end\nend\n"
completions: ["  x.to_s.split(\"\").reverse.each_slice(shift).map(&:join).join\nend",
  "  x = x.to_s\n  shift = shift || 0\n  digits = x.reverse.split(//)\n  digits.reverse!\n\
    \  digits[shift].concat(digits[shift + 1])\n  digits.reverse!\n  return digits.join(\"\
    \")\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s <<\
    \ digit if digit > 0 && digit <= shift.to_i\n    s << digit if digit > shift &&\
    \ digit <= (shift.to_i + 1)\n    s << digit if digit > (shift.to_i + 1)\n    s\n\
    \  end\nend", "  x = x.to_s\n  shift = shift || 0\n  digits = x.chars.to_a\n \
    \ digits.reverse!\n  digits.reverse!\n  digits[0..(shift.to_i - 1)].concat(digits[shift..-1]).reverse!\n\
    \  digits.join(\"\")\nend", "  x = x.to_s\n  shift = shift || 0\n  len = x.length\n\
    \  digits = x.chars.to_a\n  digits.reverse!\n  digits.each_with_index do |digit,\
    \ i|\n    digits[i] = digits[(len - (i + shift) % len)]\n  end\n  digits.join\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit <= shift.to_i\n    s << digit.modulo(10).to_s\n  end\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit < shift\n    s << digit\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <\
    \ shift\n    s << digit\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\"\
    ) do |result, digit|\n    result << digit if digit > x % 10\n    result << digit\
    \ % 10\n    result << digit / 10\n  end\nend", "  x = x.to_s\n  shift = shift\
    \ || 0\n  digits = x.split(//)\n  digits.reverse!\n  digits[shift] = digits[shift].to_s\n\
    \  digits.reverse!\n  return digits.join(//)\nend", "  x.to_s.reverse.slice(shift,\
    \ x.to_s.length).reverse\nend", "  x = x.to_s\n  shift = shift.to_s\n  shift =\
    \ shift - x.length % shift if shift > x.length else shift\n  digits = x.reverse.split(//)\n\
    \  digits.reverse!\n  digits.reverse!\n  digits[0...shift].join\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |result, digit|\n    result << digit if digit > x.to_s.split(\"\
    \").reverse.shift\n    result\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ for the answer. I am not able to understand this code. Can you please explain\
    \ it a bit?\n<|/ c |>\n<| c |>\nI added some comments to the code. Hope it helps.\n\
    <|/ c |>\n<| c |>\nThanks for the explanation. I am not able to understand this\
    \ code. Can you please explain it a bit?\n<|/ c |>\n<| c |>\nI added some comments\
    \ to the code. Hope it helps.\n<|/ c |>\n<| c |>\nThanks for the explanation.\
    \ I am not able to understand this code. Can you please explain it a bit?\n<|/\
    \ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit <= shift.to_i\n    s <<\
    \ digit if digit > shift && digit <= (shift.to_i + 1)\n    s << digit if digit\
    \ > (shift.to_i + 1)\n    s\n  end\nend", "  return x.to_s.reverse.slice(shift,\
    \ x.to_s.length)\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n\
    \    s << digit if digit > 0 && digit < shift\n    s << digit\n  end\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nI like this solution, but I wonder\
    \ if it would be more efficient to just do `x.to_s.split(\"\").reverse.inject(\"\
    \") { |s, digit| s << digit if digit > 0 && digit < shift }`\n<|/ c |>\n<| c |>\n\
    : Yes, that would be more efficient.\n<|/ c |>\n<| c |>\nI like your solution,\
    \ but I wonder if it would be more efficient to just do `x.to_s.split(\"\").reverse.inject(\"\
    \") { |s, digit| s << digit if digit > 0 && digit < shift }`\n<|/ c |>\n<| c |>\n\
    : Yes, that would be more efficient.\n<|/ c |>\n<| c |>\n: I added a benchmark\
    \ test to my answer.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  x.to_s.split(\"\"\
    ).reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n\
    \    s << digit\n  end\nend", "  x.to_s.split(\"\").reverse.each_slice(shift).map(&:join).join(\"\
    \")\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s <<\
    \ digit if digit > 0 && digit <= shift && digit % 2 == 1\n    s << digit\n  end\n\
    end", "  x = x.to_s\n  shift = shift || 0\n  digits = x.split(//)\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.", "  x = x.to_s\n  shift = shift.to_i\n  digits\
    \ = x.split(//)\n  digits.reverse!\n  digits[shift..-1].concat(digits[0..shift])\n\
    \  digits.join(\"\")\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s,\
    \ digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.modulo(10)\n\
    \  end\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like this solution, but I\
    \ wonder if there is a way to do this without having to call `to_s` on the number\
    \ first?\n<|/ c |>\n<| c |>\nI guess you could do `x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.modulo(10)\n\
    \  end.reverse`\n<|/ c |>\n<| c |>\nThat would work, but it's still calling `to_s`\
    \ on the number first. I'm looking for a way to avoid that.\n<|/ c |>\n<| c |>\n\
    I guess you could do `x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n\
    \    s << digit if digit > 0 && digit < shift\n    s << digit.modulo(10)\n  end.reverse.reverse`\n\
    <|/ c |>\n<| c |>\nThat would work, but it's still calling `to_s` on the number\
    \ first. I'm looking for a way to avoid that.\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit[shift..-1]\
    \ if shift > 0\n    shift -= 1\n    s\n  end\nend", "  x.to_s.reverse.chars.take(shift).join\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <=\
    \ shift.to_i\n    s << digit\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nI like your solution,\
    \ but I wonder if there is a way to do it without having to use an if statement?\n\
    <|/ c |>\n<| c |>\nI added a solution without an if statement\n<|/ c |>\n<| c\
    \ |>\nI like your solution, but I wonder if there is a way to do it without having\
    \ to use an if statement?\n<|/ c |>\n<| c |>\nI added a solution without an if\
    \ statement\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  x.to_s.reverse.chars.take(shift).join\n\
    end", "  return x.to_s.reverse.slice(shift, x.to_s.length - shift)\nend", "  x\
    \ = x.to_s\n  shift = shift || 0\n  digits = x.split(//)\n  digits.reverse!\n\
    \  digits[0..(shift.to_i - shift.to_s)] = digits[0..(shift.to_i - shift.to_s)].join\n\
    \  digits.reverse!\n  digits.join(//)\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<code>", "  return x.to_s.reverse.slice(shift, x.to_s.length - shift)\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit <= shift && digit % 2 == 1\n    s << digit if digit >\
    \ shift && digit <= (2 * shift) && digit % 2 == 0\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |result, digit|\n    result + ((digit << shift).to_s\
    \ % 10)\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n\
    \    s << digit if digit > 0 && digit < shift\n    s << digit.modulo(10)\n  end\n\
    end", "  x = x.to_s\n  shift = shift % x.size\n  x.slice!(0, shift)\n  x.reverse!\n\
    \  x\nend", "  x = x.to_s\n  shift = shift.to_i\n  digits = x.to_s.reverse\n \
    \ digits = digits.chars.drop(shift).reverse\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit if digit > 0 && digit <= shift.to_i\n    s << digit if digit > shift\
    \ && digit <= (shift.to_i + 1)\n    s << digit if digit > (shift.to_i + 1)\n \
    \   s << digit if digit > (shift.to_i + 2)\n    s << digit if digit > (shift.to_i\
    \ + 3)\n    s << digit if digit > (shift.to_i + 4)\n    s << digit if digit >\
    \ (shift.to_i + 5)\n    s << digit if digit > (shift.to_i + 6)\n    s << digit\
    \ if digit > (shift.to_i + 7)\n    s << digit if digit > (shift.to_i + 8)\n  \
    \  s << digit if digit > (shift.to_i + 9)\n    s << digit if digit > (shift.to_i\
    \ + 10)\n    s << digit if digit > (shift.to_i + 11)\n    s << digit if digit\
    \ > (shift.to_i + 12)\n    s << digit if digit > (shift.to_i + 13)\n    s << digit\
    \ if digit > (shift.to_i + 14)\n    s << digit if digit > (shift.to_i + 15)\n\
    \    s << digit if digit > (shift.to_i + 16)\n    s << digit if digit > (shift.to_i\
    \ + 17)\n    s << digit if digit > (shift.to_i + 18)\n    s << digit if digit\
    \ > (shift.to_i + 19)\n    s << digit if digit > (shift.to_i + 20)\n    s << digit\
    \ if digit > (shift.to_i + 21)\n    s << digit if digit > (shift.to_i + 22)\n\
    \    s << digit if digit > (shift.to_i + 23)\n    s << digit if digit > (shift.to_i\
    \ + 24)\n    s << digit if digit > (shift.to_i + 25)\n    s << digit if digit\
    \ > (shift.to_i + 26)\n    s << digit if digit > (shift.to_i + 27)\n    s << digit\
    \ if digit > (shift.to_i + 28)\n    s << digit if digit > (shift.to_i + 29)\n\
    \    s << digit if digit > (shift.to_i + 30)\n    s << digit if digit > (shift.to_i\
    \ + 31)\n    s << digit if digit > (shift.to_i + 32)\n    s << digit if digit\
    \ > (shift.to_i + 33)\n    s << digit if digit > (shift.to_i + 34)\n    s << digit\
    \ if digit > (shift.to_", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n\
    \    s << digit if digit > 0 && digit < shift\n    s << digit.modulo(10).to_s\n\
    \  end\nend", "  x.to_s.reverse.chars.take(shift).join\nend", "  x.to_s.reverse.chars.take(shift).join\n\
    end", "  x.to_s.reverse.chars.take(shift).join\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |result, digit|\n    digit = digit.to_i(10)\n    digit = digit >> shift\
    \ if digit > 0\n    result << digit\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| a dscore=0 |>\n<code>", "  x.to_s.split(\"\").reverse.inject(\"\") do\
    \ |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit\n \
    \ end\nend", "  x = x.to_i\n  shift = shift.to_i\n  return x.to_s(10).reverse.chars.drop(shift).join\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit < shift\n    s << digit.modulo(10)\n  end\nend", "  x\
    \ = x.to_s\n  shift = shift || 0\n  len = x.length\n  digits = x.chars.to_a\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.", "  x = x.to_s\n  shift = shift % x.size\n  digits\
    \ = x.chars.reverse.each_slice(shift).map(&:join)\n  digits.join\nend", "  x =\
    \ x.to_s\n  shift = shift.to_i\n  digits = x.split(//)\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  ", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit.modulo(10**(shift.to_i\
    \ - shift.to_s.size + 1))\n    shift -= 1\n  end\nend", "  x = x.to_s\n  shift\
    \ = shift || 0\n  len = x.length\n  digits = x.split(//)\n  digits.reverse!\n\
    \  digits[0..(len-shift)].concat(digits[len..-1])\n  digits.join(\"\")\nend",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\"\
    ).reverse.inject(\"\") do |s, digit|\n    s << digit[shift..-1]\n  end\nend",
  "  x.to_s.reverse.chars.take(shift).join\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit if digit > 0 && digit <= shift.to_i\n    s << digit if digit > shift\
    \ && digit <= (shift.to_i + 1)\n    s << digit if digit > (shift.to_i + 1)\n \
    \ end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a dscore=0 |>\n<code>",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit.chr if\
    \ digit > x.to_s.chars.last\n    s << digit.chr if (digit < x.to_s.chars.first)\n\
    \    s << digit.chr if (digit == x.to_s.chars.last)\n    s << digit.chr if (digit\
    \ == x.to_s.chars.first)\n    s << digit.chr if (digit > x.to_s.chars.last)\n\
    \    s << digit.chr if (digit < x.to_s.chars.first)\n    s\n  end\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nI like your solution, but I wonder\
    \ if there is a way to do this without having to use `.to_s` on the string. Maybe\
    \ some kind of regex or something?\n<|/ c |>\n<| c |>\nI added a solution that\
    \ doesn't require `.to_s`.\n<|/ c |>\n<| c |>\nI added a solution that doesn't\
    \ require `.to_s`.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  x.to_s.split(\"\"\
    ).reverse.inject(\"\") do |result, digit|\n    result << digit if digit > x.to_s.split(\"\
    \").reverse.shift\n    result << digit\n  end\nend", "  x = x.to_s\n  shift =\
    \ shift || 0\n  len = x.length\n  digits = x.chars.to_a\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s <<\
    \ digit[(s.length - shift) % s.length]\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit if digit > 0 && digit <= shift.to_i\n    s << digit if digit > shift\
    \ && digit <= (shift.to_i + 1)\n    s << digit if digit > (shift.to_i + 1)\n \
    \ end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s <<\
    \ digit if digit > 0 && digit <= shift.to_i\n    s << digit if digit > shift &&\
    \ digit <= (shift.to_i + 1)\n    s << digit if digit > (shift.to_i + 1)\n  end\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like your solution, but I wonder\
    \ if there is a way to avoid the use of inject and instead use recursion.\n<|/\
    \ c |>\n<| c |>\n: I added a recursive solution that is probably more efficient\
    \ than `inject`.\n<|/ c |>\n<| c |>\nThanks for the recursive solution. I'm still\
    \ trying to understand how it works. I understand that `inject` iterates through\
    \ the array and appends the element to `s` until it reaches the end of the array.\
    \ How does it know to stop when it reaches the end of the array? Also, how does\
    \ it know to append the element to `s` until it reaches the end of the array?\
    \ Does it keep track of the length of the array?\n<|/ c |>\n<| c |>\n: I added\
    \ some comments to the code. Hope that helps.\n<|/ c |>\n<| c |>\nThanks for the\
    \ explanation. I'm still trying to understand how it works. I understand that\
    \ `inject` iterates through the array and appends the element to `s` until it\
    \ reaches the end of the array. How does it know to stop when it reaches the end\
    \ of the array? Also, how does it know to append the element to `s` until it reaches\
    \ the end of the array? Does it keep track of the length of the array?\n<|/ c\
    \ |>\n<| a tags=ruby |>\n<code>", "  x = x.to_i\n  shift = shift.to_i\n  return\
    \ x.to_s.reverse.chars.take(shift).join\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit <= shift.to_i\n    s <<\
    \ digit if digit > shift && digit <= (shift.to_i + 1)\n    s << digit if digit\
    \ > (shift.to_i + 1)\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>",
  "  x.to_s.split(\"\").reverse.each_with_index do |digit, index|\n    digit = digit.succ\n\
    \    digit = digit.to_s.chars.to_a[shift..-1] + digit.to_s.chars.to_a[0..shift]\n\
    \    digit = digit.to_i\n    digit = digit.succ\n    digit = digit.to_s.chars.to_a[0..shift]\n\
    \    digit = digit.to_i\n    digit = digit.succ\n    digit = digit.to_s.chars.to_a[shift..-1]\n\
    \    digit = digit.to_i\n    digit = digit.succ\n    digit = digit.to_s.chars.to_a[0..shift]\n\
    \    digit = digit.to_i\n    digit = digit.succ\n    digit = digit.to_s.chars.to_a[shift..-1]\n\
    \    digit = digit.to_i\n    digit = digit.succ\n    digit = digit.to_s.chars.to_a[0..shift]\n\
    \    digit = digit.to_i\n    digit = digit.succ\n    digit = digit.to_s.chars.to_a[shift..-1]\n\
    \    digit = digit.to_i\n    digit = digit.succ\n    digit = digit.to_s.chars.to_a[0..shift]\n\
    \    digit = digit.to_i\n    digit = digit.succ\n    digit = digit.to_s.chars.to_a[shift..-1]\n\
    \    digit = digit.to_i\n    digit = digit.succ\n    digit = digit.to_s.chars.to_a[0..shift]\n\
    \    digit = digit.to_i\n    digit = digit.succ\n    digit = digit.to_s.chars.to_a[shift..-1]\n\
    \    digit = digit.to_i\n    digit = digit.succ\n    digit = digit.to_s.chars.to_a[0..shift]\n\
    \    digit = digit.to_i\n    digit = digit.succ\n    digit = digit.to_s.chars.to_a[shift..-1]\n\
    \    digit = digit.to_i\n    digit = digit.succ\n    digit = digit.to_s.chars.to_a[0..shift]\n\
    \    digit = digit.to_i\n    digit = digit.succ\n    digit = digit.to_s.chars.to_a[shift..-1]\n\
    \    digit = digit.to_i\n    digit = digit.succ\n    digit = digit.to_s.chars.to_a[0..shift]\n\
    \    digit = digit.to_i\n    digit = digit.succ\n    digit = digit.to_s.chars.to_a[",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit <= shift.to_i\n    s << digit if digit > shift && digit <= (shift.to_i\
    \ + 1)\n    s << digit if digit > (shift.to_i + 1)\n    s\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |result, digit|\n    result << digit if digit > x.to_s.split(\"\
    \").reverse.shift\n    result << digit if digit > x.to_s.split(\"\").reverse.shift(shift)\n\
    \    result\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |result,\
    \ digit|\n    digit = digit.to_s.chars.to_a[shift..-1]\n    result << digit <<\
    \ digit\n  end\nend", "  x.to_s.reverse.chars.take(shift).join\nend", "  return\
    \ x.to_s.reverse.slice(shift, x.to_s.length)\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |result, digit|\n\
    \    result << digit if digit > x.to_s[shift..-1]\n    result << digit\n  end\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |result, digit|\n    result\
    \ << digit << shift if shift > 0 && digit != 0\n    shift -= 1\n    result\n \
    \ end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s <<\
    \ digit if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  return\
    \ x.to_s.reverse.slice(shift, x.to_s.length)\nend", "  x.to_s.reverse.chars.take(shift).join\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit < shift\n    s << digit\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <\
    \ shift\n    s << digit.modulo(10)\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.modulo(10)\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit.modulo(10**(shift.to_i - shift.to_s.to_i)).to_s\n    shift -= 1\n \
    \ end\nend", "  x.to_s.reverse.slice(shift, x.to_s.length).reverse.join\nend",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit < shift\n    s << digit\n  end\nend", "  x = x.to_i\n  shift =\
    \ shift.to_i\n  digits = x.to_s(10)\n  digits = digits.reverse\n  digits = digits.gsub(/\\\
    d{#{shift}}/) { |s| s.reverse.to_i(10) }\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.", "  return x.to_s.reverse.slice(shift,\
    \ x.to_s.length)\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n\
    \    s << digit if digit > 0 && digit < shift\n    s << digit.modulo(10)\n  end\n\
    end", "  x.to_s.reverse.chars.take(shift).join\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n\
    \  end\nend", "  x = x.to_s\n  shift = shift || 0\n  digits = x.reverse.split(//)\n\
    \  digits.reverse!\n  digits[shift].concat(digits[shift..-1])\n  digits.reverse!\n\
    \  digits.join(\"\")\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s,\
    \ digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n \
    \ end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s <<\
    \ digit if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  x =\
    \ x.to_s\n  shift = shift || 0\n  digits = x.reverse.split(//)\n  digits.reverse!\n\
    \  digits[shift].concat(digits[shift + 1])\n  digits.join(\"\")\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <\
    \ shift\n    s << digit.modulo(10)\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit <= shift.to_i\n    s <<\
    \ digit if digit > shift && digit <= (shift.to_i + 1)\n    s << digit if digit\
    \ > (shift.to_i + 1)\n    s << digit if digit > (shift.to_i + 2)\n    s << digit\
    \ if digit > (shift.to_i + 3)\n    s << digit if digit > (shift.to_i + 4)\n  \
    \  s << digit if digit > (shift.to_i + 5)\n    s << digit if digit > (shift.to_i\
    \ + 6)\n    s << digit if digit > (shift.to_i + 7)\n    s << digit if digit >\
    \ (shift.to_i + 8)\n    s << digit if digit > (shift.to_i + 9)\n    s << digit\
    \ if digit > (shift.to_i + 10)\n    s << digit if digit > (shift.to_i + 11)\n\
    \    s << digit if digit > (shift.to_i + 12)\n    s << digit if digit > (shift.to_i\
    \ + 13)\n    s << digit if digit > (shift.to_i + 14)\n    s << digit if digit\
    \ > (shift.to_i + 15)\n    s << digit if digit > (shift.to_i + 16)\n    s << digit\
    \ if digit > (shift.to_i + 17)\n    s << digit if digit > (shift.to_i + 18)\n\
    \    s << digit if digit > (shift.to_i + 19)\n    s << digit if digit > (shift.to_i\
    \ + 20)\n    s << digit if digit > (shift.to_i + 21)\n    s << digit if digit\
    \ > (shift.to_i + 22)\n    s << digit if digit > (shift.to_i + 23)\n    s << digit\
    \ if digit > (shift.to_i + 24)\n    s << digit if digit > (shift.to_i + 25)\n\
    \    s << digit if digit > (shift.to_i + 26)\n    s << digit if digit > (shift.to_i\
    \ + 27)\n    s << digit if digit > (shift.to_i + 28)\n    s << digit if digit\
    \ > (shift.to_i + 29)\n    s << digit if digit > (shift.to_i + 30)\n    s << digit\
    \ if digit > (shift.to_i + 31)\n    s << digit if digit > (shift.to_i + 32)\n\
    \    s << digit if digit > (shift.to_i + 33)\n    s << digit if digit > (shift.to_i\
    \ + 34)\n    s << digit if digit > (shift.to_", "  x = x.to_s\n  shift = shift\
    \ || 0\n  x.reverse!\n  x.slice!(0, shift)\n  x.reverse!\n  x.slice!(0, shift)\n\
    \  x.reverse!\n  x\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |result,\
    \ digit|\n    result << digit if digit > x.to_s[shift..-1]\n    result << digit\
    \ if digit < x.to_s[0..-shift]\n    result\n  end\nend", "  x.to_s.split(\"\"\
    ).reverse.inject(\"\") do |s, digit|\n    s << digit[(s.length - shift) % s.length]\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", " \
    \ x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit < shift\n    s << digit.modulo(10)\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <=\
    \ shift.to_i\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit <= shift.to_i\n    s <<\
    \ digit if digit > shift && digit <= (shift.to_i + 1)\n    s << digit if digit\
    \ > (shift.to_i + 1)\n    s\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  x.to_s.split(\"\").reverse.each_with_index\
    \ do |digit, index|\n    digit = digit.succ\n    digit = digit.succ\n    digit\
    \ = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n\
    \    digit = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n    digit\
    \ = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n\
    \    digit = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n    digit\
    \ = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n\
    \    digit = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n    digit\
    \ = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n\
    \    digit = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n    digit\
    \ = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n\
    \    digit = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n    digit\
    \ = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n\
    \    digit = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n    digit\
    \ = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n\
    \    digit = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n    digit\
    \ = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n\
    \    digit = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n    digit\
    \ = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n\
    \    digit = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n    digit\
    \ = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n    digit = digit.succ\n\
    \    digit = digit.succ\n    digit = ", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit if digit > 0 && digit < shift\n    s << digit.modulo(10)\n  end\nend",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit <= shift.to_i\n    s << digit\n  end\nend", "  x = x.to_i\n  shift\
    \ = shift.to_i\n  return x.to_s.reverse.slice(shift, x.to_s.length - shift)\n\
    end", "  x.to_s.reverse.chars.take(shift).join\nend", "  x = x.to_i\n  shift =\
    \ shift.to_i\n  digits = x.digits.reverse\n  digits[0..(shift - 1)].concat(digits[shift..-1])\n\
    end", "  x = x.to_s\n  shift = shift.to_i\n  x.slice!(0, shift)\n  x.reverse!\n\
    \  x.slice!(0, shift)\n  x\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do\
    \ |result, digit|\n    result << digit if digit > 0 && digit <= shift && digit\
    \ % 2 == 1\n    result << digit if digit > shift && digit <= (shift << 1)\n  \
    \  result << digit if digit > (shift << 1)\n    result\n  end\nend", "  x = x.to_s\n\
    \  shift = shift.to_i\n  digits = x.split(//)\n  digits.reverse!\n  digits.reverse!\
    \ if shift > digits.length\n  digits.join(//)\nend", "  x.to_s.reverse.chars.take(shift).join\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  x = x.to_s\n\
    \  shift = shift.to_i\n  digits = x.split(//)\n  digits.reverse!\n  digits[shift..-1]\
    \ + digits.first(shift)\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s,\
    \ digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n \
    \ end\nend", "  x = x.to_s\n  shift = shift || 0\n  digits = x.chars.reverse.each_cons(2).to_a\n\
    \  digits.reverse!\n  digits.each_with_index do |digit, i|\n    digits[i] = digit.chr\
    \ << shift\n    shift -= digit.ord\n  end\n  digits.join\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <\
    \ shift\n    s << digit\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\"\
    ) do |s, digit|\n    s << digit[1..-1] if digit =~ /^\\d/\n    s << digit\n  end\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit <= shift && digit > s.length\n    s << digit.chr\n  end\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. Try it with `circular_shift(12,\
    \ 1)`.\n<|/ c |>\n<| c |>\nIt does work. Try it with `circular_shift(12, 2)`.\n\
    <|/ c |>\n<| c |>\nIt doesn't work. Try it with `circular_shift(12, 1)`.\n<|/\
    \ c |>\n<| c |>\nIt does work. Try it with `circular_shift(12, 2)`.\n<|/ c |>\n\
    <| c |>\nIt does work. Try it with `circular_shift(12, 1)`.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit.modulo(10**(shift.to_i - shift.to_s.to_i))\n    shift -= 1\n  end\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <\
    \ shift\n    s << digit.modulo(10)\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nI like your use of inject to solve this problem. Thanks for sharing your\
    \ solution.\n<|/ c |>\n<| a dscore=1 |>\nHere's a solution using recursion:\n\
    <code>", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend\n</code>\n<|/\
    \ a tags=ruby,ruby-on-rails |>\n<| c |>\nI like this solution, but I wonder if\
    \ it would be more efficient to reverse the string before splitting it? `x.to_s.reverse.split(\"\
    \")`\n<|/ c |>\n<| c |>\n: I doubt that would be more efficient, since `split`\
    \ has to scan the string anyway. `reverse` would be more efficient, since it only\
    \ has to reverse the string once.\n<|/ c |>\n<| c |>\nI doubt that would be more\
    \ efficient, since `split` has to scan the string anyway. `reverse` would be more\
    \ efficient, since it only has to reverse the string once.\n<|/ c |>\n<| c |>\n\
    : I doubt that would be more efficient, since `split` has to scan the string anyway.\
    \ `reverse` would be more efficient, since it only has to reverse the string once.\n\
    <|/ c |>\n<| c |>\n: I doubt that would be more efficient, since `split` has to\
    \ scan the string anyway. `reverse` would be more efficient, since it only has\
    \ to reverse the string once.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>",
  "  x = x.to_s\n  shift = shift % x.length\n  digits = x.chars.reverse\n  digits[0...shift].concat(digits[shift...-1]).reverse\n\
    end", "  x.to_s.reverse.slice(shift, x.to_s.length).reverse.join\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |result, digit|\n    result << digit if digit > x.to_s.split(\"\
    \").reverse.shift\n    result << digit\n  end\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nI like your solution, but I wonder if there's a way to do it without\
    \ using recursion.\n<|/ c |>\n<| c |>\nI added a non-recursive solution to my\
    \ answer.\n<|/ c |>\n<| c |>\nI like your solution, but I wonder if there's a\
    \ way to do it without using recursion.\n<|/ c |>\n<| c |>\nI added a non-recursive\
    \ solution to my answer.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <\
    \ shift\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit <= shift && digit < 10\n\
    \    s << digit.to_s[shift..-1]\n  end\nend", "  x = x.to_s\n  shift = shift ||\
    \ 0\n  digits = x.reverse.chars.to_a\n  digits.reverse!\n  digits[shift..-1].each\
    \ { |digit| digits.unshift(digit) }\n  digits.join\nend", "  x = x.to_s\n  shift\
    \ = shift || 0\n  digits = x.reverse.chars.to_a\n  digits.reverse!\n  digits.reverse!\n\
    \  digits[shift..-1] + digits.take(shift)\nend", "  x = x.to_s\n  shift = shift\
    \ % x.size\n  digits = x.chars.to_a\n  digits.reverse!\n  digits.fill('0')\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n \
    \ digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!", " \
    \ x.to_s.split(\"\").reverse.inject(\"\") do |result, digit|\n    result << digit\
    \ if digit > 0 && digit < shift\n    result << digit.modulo(10).to_s\n  end\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  return x.to_s.reverse.slice(shift,\
    \ x.to_s.length)\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |result,\
    \ digit|\n    result << digit if digit > x.to_s.split(\"\").reverse.shift\n  \
    \  result << digit\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do\
    \ |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit\n \
    \ end\nend", "  x = x.to_i\n  shift = shift.to_i\n  digits = x.digits.reverse\n\
    \  digits.each_with_index do |digit, i|\n    digits[i] = digit.divmod(10).first\n\
    \  end\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |result, digit|\n    result << digit if digit > x.to_s[shift..-1]\n   \
    \ result << digit\n  end\nend", "  x.to_s.reverse.chars.take(shift).join\nend",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\"\
    ).reverse.inject(\"\") do |s, digit|\n    s << digit[shift]\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <\
    \ shift\n    s << digit.modulo(10)\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", " \
    \ x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit < shift\n    s << digit\n  end\nend", "  x = x.to_s\n  shift =\
    \ shift || 0\n  digits = x.chars.to_a\n  digits.reverse!\n  digits[0...shift].concat\
    \ digits[shift...-1]\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s,\
    \ digit|\n    s << digit if digit > 0 && digit <= shift \n    s << digit.chr\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |result, digit|\n\
    \    result << digit if (shift == 0 || shift > digit.length)\n    result << digit[0,\
    \ shift]\n    shift -= 1\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a dscore=0 |>\n<code>",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |result, digit|\n    result << digit\
    \ << digit if digit < 10\n    result << digit >> shift if digit >> shift\n   \
    \ result\n  end\nend", "  x = x.to_s\n  shift = shift % x.length\n  digits = x.to_s.reverse\n\
    \  digits[0...shift].concat(digits[shift+1..-1]).reverse\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <\
    \ shift\n    s << digit.chr\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to avoid the\
    \ extra method call. Perhaps some way to get `circular_shift` to return an array?\n\
    <|/ c |>\n<| c |>\nI added a version that returns an array instead of a string.\n\
    <|/ c |>\n<| c |>\nI like your solution, but I wonder if there is a way to avoid\
    \ the extra method call. Perhaps some way to get circular_shift to return an array?\n\
    <|/ c |>\n<| c |>\nI added a version that returns an array instead of a string.\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.modulo(10)\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| c |>\n\
    I like your solution, however it only works with integers. I need a solution that\
    \ works with floats as well.\n<|/ c |>\n<| c |>\nI added a solution that works\
    \ with floats as well.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<code>", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit if digit > 0 && digit <= shift \n    s << digit.modulo(10).to_s\n \
    \ end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |result, digit|\n \
    \   digit = digit.to_i(10)\n    digit = (digit >> shift) | (digit << (32 - shift))\n\
    \    result << digit\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\")\
    \ do |s, digit|\n    s << digit.slice(shift, shift + 1) if digit =~ /\\d/\n  \
    \  s[s.length - shift..-1]\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.modulo(10)\n\
    \  end\nend", "  x.to_s.reverse.chars.take(shift).join\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <=\
    \ shift.to_i\n    s << digit\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    I like this solution, although I prefer a recursive solution because it's more\
    \ readable and easier to understand.\n<|/ c |>\n<| c |>\nI agree, it's more readable.\
    \ Recursion is often the best solution for problems like this one. :)\n<|/ c |>\n\
    <| a tags=ruby,string |>\n<code>", "  x.to_s.split(\"\").reverse.inject(\"\")\
    \ do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n\
    \  end\nend", "  x = x.to_s\n  shift = shift.to_i\n  \n  if shift > x.length\n\
    \    shift = x.length\n  \n  x.slice!(0, shift)\n  x.reverse!\n  \n  x\nend",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit <= shift.to_i\n    s << digit if digit > shift && digit <= (shift.to_i\
    \ + 1)\n    s << digit if digit > (shift.to_i + 1)\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <=\
    \ shift && digit % 2 == 1\n    s << digit if digit > shift && digit <= (shift\
    \ + 1) && digit % 2 == 0\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like\
    \ this solution, but I wonder if there is a way to avoid the string concatenation.\
    \ Perhaps using a `StringBuffer`?\n<|/ c |>\n<| c |>\nI added a version that avoids\
    \ string concatenation. Not sure how it compares to your solution, though.\n<|/\
    \ c |>\n<| c |>\nI like your solution, too. My solution was more of a \"hack\"\
    \ that I was trying to get rid of. Your solution is much more elegant.\n<|/ c\
    \ |>\n<| a dscore=2 |>\nHere's a solution using recursion:\n<code>", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <\
    \ shift\n    s << digit % 10\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nI like your solution, however it only works for positive numbers.\
    \ I modified it slightly to make it work for negative numbers as well. `def circular_shift(x,\
    \ shift)\n  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit < shift\n    s << digit % 10\n  end\nend`\n<|/ c |>\n\
    <| c |>\nI added a version that works for negative numbers as well.\n<|/ c |>\n\
    <| a tags=ruby,ruby-on-rails |>\n<code>", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n\
    \  end\nend", "  x = x.to_i\n  shift = shift.to_i\n  digits = x.digits.reverse\n\
    \  digits[shift] = digits[shift].to_s\n  digits.reverse!\n  digits.join\nend",
  "  x = x.to_s\n  shift = shift.to_i\n  len = x.length\n  digits = x.chars.to_a\n\
    \  digits.reverse!\n  digits[0..(len-shift)].concat(digits[len..-1])\nend", " \
    \ x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\"\
    ).reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <=\
    \ shift && digit > s.length\n    s << digit.chr\n  end\nend", "  x.to_s.reverse.chars.take(shift).join\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit <= shift && digit > s.length\n    s << digit.chr\n  end\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nI like your solution,\
    \ but I wonder if there is a way to do it without having to use an extra variable.\
    \ I'm thinking about something like `x.to_s.split(\"\").reverse.inject(\"\") {\
    \ |s, digit| s << digit if digit > 0 && digit <= shift && digit > s.length s <<\
    \ digit.chr }`\n<|/ c |>\n<| c |>\nI added a solution that doesn't use an extra\
    \ variable.\n<|/ c |>\n<| c |>\nI like your solution, but I wonder if there is\
    \ a way to do it without having to use an extra variable. I'm thinking about something\
    \ like `x.to_s.split(\"\").reverse.inject(\"\") { |s, digit| s << digit if digit\
    \ > 0 && digit <= shift && digit > s.length s << digit.chr }`\n<|/ c |>\n<| c\
    \ |>\nI added a solution that doesn't use an extra variable.\n<|/ c |>\n<| c |>\n\
    I like your solution, but I wonder if there is a way to do it without having to\
    \ use an extra variable. I'm thinking about something like `x.to_s.split(\"\"\
    ).reverse.inject(\"\") { |s, digit| s << digit if digit > 0 && digit <= shift\
    \ && digit > s.length s << digit.chr }`\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "  return x.to_s.reverse.slice(shift, x.to_s.length)\nend", "  x.to_s.split(\"\"\
    ).reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <=\
    \ shift.to_i\n    s << digit.modulo(10)\n  end\nend\n</code>\n<|/ a |>\n<| c |>\n\
    I like your solution, however it fails for negative numbers. I added a fix for\
    \ that in my answer.\n<|/ c |>\n<| c |>\nI added a fix for negative numbers. I\
    \ didn't want to change your answer because I thought it would be confusing to\
    \ someone who didn't know about `modulo`.\n<|/ c |>\n<| c |>\nI added a fix for\
    \ negative numbers. I didn't want to change your answer because I thought it would\
    \ be confusing to someone who didn't know about `modulo`.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", " \
    \ x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit < shift\n    s << digit\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit <= shift.to_i\n    s <<\
    \ digit\n  end\nend", "  x.to_s.reverse.chars.take(shift).join\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <\
    \ shift\n    s << digit.chr\n  end\nend", "  x = x.to_s\n  shift = shift.to_i\n\
    \  \n  digits = x.to_s.split(//)\n  digits.reverse!\n  \n  digits.each_with_index\
    \ do |digit, i|\n    digits[i] = digits[i - shift]\n  end\n  \n  digits.join(//)\n\
    end", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit\
    \ if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <\
    \ shift\n    s << digit.modulo(10)\n  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit\n\
    \  end\nend", "  return x.to_s.reverse.slice(shift, x.to_s.length - shift)\nend",
  "  x.to_s.split(\"\").reverse.each_slice(shift).map(&:join).join(\"\")\nend", " \
    \ x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit < shift\n    s << digit.chr\n  end\nend", "  return x.to_s.reverse.slice(shift,\
    \ x.to_s.length)\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n\
    \    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend",
  "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit <= shift && digit % 2 == 1\n    s << digit\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |s, digit|\n    s << digit if digit > 0 && digit <=\
    \ shift && digit < x.to_s.length\n    s << x.to_s[digit-shift]\n  end\nend", " \
    \ x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s << digit if digit\
    \ > 0 && digit < shift\n    s << digit.modulo(10)\n  end\nend", "  x.to_s.split(\"\
    \").reverse.inject(\"\") do |result, digit|\n    result << digit if digit > x.to_s.split(\"\
    \").reverse.shift\n    result << digit\n  end\nend", "  x = x.to_s\n  shift =\
    \ shift || 0\n  digits = x.split(//)\n  digits.reverse!\n  digits[shift] = digits[shift].split(//).reverse.join\n\
    \  digits.join(\"\")\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s,\
    \ digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.modulo(10)\n\
    \  end\nend", "  x.to_s.split(\"\").reverse.inject(\"\") do |s, digit|\n    s\
    \ << digit if digit > 0 && digit < shift\n    s << digit.chr\n  end\nend", " \
    \ x.to_s.reverse.chars.take(shift).join\nend", "  x.to_s.split(\"\").reverse.inject(\"\
    \") do |s, digit|\n    s << digit if digit > 0 && digit < shift\n    s << digit.chr\n\
    \  end\nend", "  x.to_s.reverse.chars.take(shift).join\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| a dscore=1 |>\n<code>", "  x.to_s.split(\"\").reverse.inject(\"\") do\
    \ |s, digit|\n    s << digit if digit > 0 && digit <= shift.to_i\n    s << digit\
    \ if digit > shift && digit <= (shift.to_i + 1)\n    s << digit if digit > (shift.to_i\
    \ + 1)\n  end\nend", "  x = x.to_i\n  shift = shift.to_i\n  return x.to_s(10).reverse.chars.reverse.inject(\"\
    \") do |result, digit|\n    digit = digit.to_i(10)\n    result << digit << shift\
    \ if digit > 0 && digit < 10\n    digit\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
