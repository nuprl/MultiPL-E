name: HumanEval_149_sorted_list_sum
language: rb
prompt: "# Write a function that accepts a list of strings as a parameter,\n# deletes\
  \ the strings that have odd lengths from it,\n# and returns the resulted list with\
  \ a sorted order,\n# The list is always a list of strings and never an array of\
  \ numbers,\n# and it may contain duplicates.\n# The order of the list should be\
  \ ascending by length of each word, and you\n# should return the list sorted by\
  \ that rule.\n# If two words have the same length, sort the list alphabetically.\n\
  # The function should return a list of strings in sorted order.\n# You may assume\
  \ that all words will have the same length.\n# For example:\n# >>> list_sort.call([\"\
  aa\", \"a\", \"aaa\"])\n# [\"aa\"]\n# >>> list_sort.call([\"ab\", \"a\", \"aaa\"\
  , \"cd\"])\n# [\"ab\", \"cd\"]\ndef sorted_list_sum(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sorted_list_sum\n\
  \    candidate = method(:sorted_list_sum)\n    assert_equal([\"aa\"], candidate.call([\"\
  aa\", \"a\", \"aaa\"]))\n    assert_equal([\"AI\", \"asdf\", \"school\"], candidate.call([\"\
  school\", \"AI\", \"asdf\", \"b\"]))\n    assert_equal([], candidate.call([\"d\"\
  , \"b\", \"c\", \"a\"]))\n    assert_equal([\"abcd\", \"dcba\"], candidate.call([\"\
  d\", \"dcba\", \"abcd\", \"a\"]))\n    assert_equal([\"AI\", \"ai\", \"au\"], candidate.call([\"\
  AI\", \"ai\", \"au\"]))\n    assert_equal([], candidate.call([\"a\", \"b\", \"b\"\
  , \"c\", \"c\", \"a\"]))\n    assert_equal([\"cc\", \"dd\", \"aaaa\", \"bbbb\"],\
  \ candidate.call([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]))\n  end\nend\n"
completions: ["  lst.sort!\n  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\n\
    end", "  lst.sort!\n  lst.delete_if { |x| x.length % 2 != 0 }\n  lst.sort!\nend",
  "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\nend", " \
    \ lst.sort!\n  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\nend", " \
    \ lst.sort!\n  lst.group_by{|s| s.length}.map{|k,v| v.sort!}.flatten.sort!\nend",
  "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\nend", " \
    \ lst.sort!\n  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\nend", " \
    \ lst.sort!\n  lst.delete_if { |x| x.length % 2 != 0 }\n  lst\nend", "  lst.sort!\n\
    \  lst.uniq!\n  lst.sort!\n  lst\nend", "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k,\
    \ v| v.sort!}.flatten\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>",
  "  lst.sort!\n  lst.delete_if { |x| x.length % 2 != 0 }\n  lst.sort!\nend", "  lst.sort!\n\
    \  lst.uniq!\n  lst.sort!\n  lst\nend", "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k,\
    \ v| v.sort.map{|x| x}}.flatten.sort\nend", "  lst.sort!\n  lst.group_by{|x| x.size}.map{|k,\
    \ v| v.sort!}.flatten\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>",
  "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\nend", " \
    \ lst.sort!\n  lst.uniq!\n  lst.sort!\nend", "  lst.sort!\n  lst.delete_if {|word|\
    \ word.length % 2 == 1}\n  lst.sort!\nend", "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k,\
    \ v| v.sort.map{|x| x}}.flatten.sort\nend\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ |>\n<| c |>\nI like your solution, but I wonder why you chose to sort the list\
    \ twice. Why not sort it once and only then group and map the result?\n<|/ c |>\n\
    <| c |>\nI thought about it a little more and I realized that sorting it once\
    \ is probably a better solution. I'll edit my answer to reflect that.\n<|/ c |>\n\
    <| c |>\nI like your solution, but I wonder why you chose to sort the list twice.\
    \ Why not sort it once and only then group and map the result?\n<|/ c |>\n<| c\
    \ |>\nI chose to sort it twice because I wanted to sort it by length and then\
    \ alphabetically. Sorting it once and only then sorting it alphabetically would\
    \ not work. Sorting it twice would give me the list sorted by length and then\
    \ alphabetically. Sorting it once and only then sorting it alphabetically would\
    \ give me the list sorted by length and then by alphabetically. Sorting it once\
    \ and only then sorting it by length would give me the list sorted by length and\
    \ then by alphabetically. Sorting it once and only then sorting it by length would\
    \ give me the list sorted by length and then by alphabetically.\n<|/ c |>\n<|\
    \ c |>\nI see what you mean. I think I understand now. Thanks!\n<|/ c |>\n<| a\
    \ tags=ruby,arrays,sorting |>\n<code>", "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k,\
    \ v| v.sort!}.flatten\nend", "  lst.sort!\n  lst.uniq!\n  lst.sort!\nend", " \
    \ lst.sort!\n  lst.group_by{|x| x.size}.map{|k, v| v.sort.reverse}.flatten\nend",
  "  lst.sort!\n  lst.uniq!\n  lst.sort!\nend", "  lst.sort!\n  lst.uniq!\n  lst.sort!\n\
    end", "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\n\
    end", "  lst.sort!\n  lst.group_by{|x| x.size}.map{|k, v| v.sort!}.flatten\nend",
  "  lst.sort\n  lst.uniq\n  lst.sort\nend", "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k,\
    \ v| v.sort.map{|x| x}}.flatten.sort\nend", "  lst.sort!\n  lst.delete_if { |x|\
    \ x.length % 2 != 0 }\n  lst\nend", "  lst.sort!\n  lst.group_by{|x| x.size}.map{|k,\
    \ v| v.sort!}.flatten\nend\n</code>\n<|/ a tags=ruby,sorting |>\n<| a dscore=0\
    \ |>\n<code>", "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\n\
    end", "  lst.sort!\n  lst.group_by{|x| x.size}.map{|k, v| v.sort!}.flatten\nend",
  "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\nend", " \
    \ lst.sort!\n  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\nend", " \
    \ lst.sort!\n  lst.group_by{|s| s.length}.map{|k, v| v.sort!}.flatten\nend", " \
    \ lst.sort!\n  lst.map!{|x| x.split(//).sort}\n  lst.flatten!\n  lst.sort!\n \
    \ lst\nend", "  lst.sort\n  lst.group_by{|x| x.size}.map{|k, v| v.map{|x| x}.join}.sort\n\
    end", "  lst.sort!\n  lst.uniq!\n  lst.sort!\nend", "  lst.sort!\n  lst.group_by{|x|\
    \ x.size}.map{|k, v| v.sort!}.flatten\nend", "  lst.sort!\n  lst.uniq!\n  lst.sort!\n\
    end", "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\n\
    end", "  lst.sort!\n  lst.group_by{|x| x.size}.map{|k, v| v.sort!}.flatten\nend\n\
    </code>\n<|/ a tags=ruby,sorting,arrays |>\n<| a dscore=1 |>\n<code>", "  lst.sort!\n\
    \  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\nend", "  lst.sort!\n\
    \  lst.uniq!\n  lst.sort!\n  lst\nend", "  lst.sort!\n  lst.delete_if { |x| x.length\
    \ % 2 != 0 }\n  lst\nend", "  lst.sort!\n  lst.map!{|x| x.split(//).sort}\n  lst.flatten!\n\
    \  lst.sort!\n  lst\nend", "  lst.sort!\n  lst.uniq!\n  lst.sort!\n  lst\nend",
  "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\nend", " \
    \ lst.sort!\n  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten.sort!\n\
    end", "  lst.sort\n  lst.group_by{|x| x.length}.map{|k, v| v.sort}.flatten\nend",
  "  lst.sort!\n  lst.group_by{|x| x.size}.map{|k, v| v.sort!}.flatten.sort!\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis doesn't work if you have\
    \ a string like \"ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab\
    \ ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab\
    \ ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab\
    \ ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab\
    \ ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab\
    \ ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab\
    \ ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab\
    \ ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab\
    \ ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab", "  lst.sort!\n\
    \  lst.map!{|x| x.split(//).sort}\n  lst.flatten!\n  lst.uniq!\n  lst.sort!\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,sorting,arrays |>\n<code>", " \
    \ lst.sort!\n  lst.uniq!\n  lst.sort!\nend", "  lst.sort!\n  lst.group_by{|x|\
    \ x.length}.map{|k, v| v.sort!}.flatten\nend", "  lst.sort\n  lst.delete_if {|x|\
    \ x.length % 2 != 0}\n  lst.sort\nend", "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k,\
    \ v| v.sort!}.flatten\nend", "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k,\
    \ v| v.map{|x| x}}.flatten.sort!\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  lst.sort\n  lst.delete_if\
    \ { |word| word.length % 2 == 1 }\n  lst.sort\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis doesn't work. `delete_if` removes elements from the array while\
    \ iterating over it, which will cause `sort` to throw an exception.\n<|/ c |>\n\
    <| c |>\nThanks, I didn't know that. I've updated the answer.\n<|/ c |>\n<| a\
    \ tags=ruby |>\n<code>", "  lst.sort!\n  lst.group_by{|x| x.size}.map{|k, v| v.sort!}.flatten\n\
    end", "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\n\
    end", "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\n\
    end", "  lst.sort!\n  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten.sort!\n\
    end", "  lst.sort!\n  lst.uniq!\n  lst.sort!\nend", "  lst.sort!\n  lst.uniq!\n\
    \  lst.sort!\nend", "  lst.sort!\n  lst.uniq!\n  lst.sort!\nend", "  lst.sort!\n\
    \  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\nend\n</code>\n<|/ a\
    \ tags=ruby,arrays,sorting |>\n<| a dscore=0 |>\n<code>", "  lst.sort!\n  lst.delete_if\
    \ { |x| x.length % 2 != 0 }\n  lst.sort!\nend", "  lst.sort\n  lst.map!{|x| x.split(//).sort}\n\
    \  lst.map!{|x| x.join(\"\")}\n  lst.sort\nend", "  lst.sort!\n  lst.uniq!\n \
    \ lst.sort!\n  lst\nend", "  lst.sort!\n  lst.uniq!\n  lst.sort!\nend", "  lst.sort!\n\
    \  lst.group_by{|x| x.length}.map{|k, v| v.sort!}.flatten\nend", "  lst.sort!\n\
    \  lst.delete_if{|x| x.length % 2 != 0}\n  lst\nend", "  lst.sort!\n  lst.delete_if{|x|\
    \ x.length % 2 == 1}\n  lst.sort!\nend", "  lst.sort!\n  lst.delete_if { |word|\
    \ word.length % 2 != 0 }\n  lst.sort!\nend", "  lst.sort!\n  lst.group_by{|x|\
    \ x.length}.map{|k, v| v.sort!}.flatten\nend", "  lst.sort!\n  lst.delete_if {\
    \ |word| word.length % 2 != 0 }\n  lst.sort!\nend", "  lst.sort!\n  lst.group_by{|x|\
    \ x.length}.map{|k, v| v.sort!}.flatten\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
