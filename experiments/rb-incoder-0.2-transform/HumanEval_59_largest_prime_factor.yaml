name: HumanEval_59_largest_prime_factor
language: rb
prompt: "# Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  # >>> largest_prime_factor.call(13195)\n# 29\n# >>> largest_prime_factor.call(2048)\n\
  # 2\ndef largest_prime_factor(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_prime_factor\n\
  \    candidate = method(:largest_prime_factor)\n    assert_equal(5, candidate.call(15))\n\
  \    assert_equal(3, candidate.call(27))\n    assert_equal(7, candidate.call(63))\n\
  \    assert_equal(11, candidate.call(330))\n    assert_equal(29, candidate.call(13195))\n\
  \  end\nend\n"
completions: ["  prime_divisors(n)\n  largest_prime = nil\n  largest_divisor = nil\n\
    \  n.times do |i|\n    prime_divisors(i)\n    largest_divisor = nil\n    prime_divisors.each\
    \ do |divisor|\n      largest_divisor = divisor if largest_divisor == nil || divisor\
    \ > largest_divisor\n    end\n    largest_prime = largest_divisor if largest_divisor\
    \ != nil\n  end\n  largest_prime\nend", "  return n if n.is_a?(Integer) && n.odd?\
    \ && n > 2 else largest_prime_factor(n./2)\nend", "  factors = []\n  i = 2\n \
    \ while i * i <= n\n    factors.push(i)\n    i += 2\n  factors.each do |factor|\n\
    \    if n % factor == 0\n      n = n / factor\n      break\n    end\n  end\n \
    \ n\nend", "  factors = []\n  i = 2\n  while i * i <= n\n    i += 1\n  while n\
    \ != 1\n    if n % i == 0\n      factors << i\n      n /= i\n    end\n    i +=\
    \ 1\n  end\n  factors << n if n != 1\n  factors.max\nend", "  i = 2\n  while i\
    \ * i <= n\n    i += 1\n  i\nend", "  factors = []\n  i = 2\n  while i * i <=\
    \ n\n    i += 1\n  while n >= i\n    factors.push(i)\n    n /= i\n  factors.push(n)\n\
    \  factors.reverse\n  factors.find { |f| f > n }\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis doesn't work for large numbers. For example, `largest_prime_factor(1000000000000000000)`\
    \ returns `nil`.\n<|/ c |>\n<| c |>\n: It works for me on Ruby 2.4.1\n<|/ c |>\n\
    <| c |>\n: I added a version that works for large numbers. I tested it on Ruby\
    \ 2.4.1\n<|/ c |>\n<| c |>\n: I added a version that works for large numbers.\
    \ I tested it on Ruby 2.4.1\n<|/ c |>\n<| c |>\n: I added a version that works\
    \ for large numbers. I tested it on Ruby 2.4.1\n<|/ c |>\n<| a |>\n<code>", " \
    \ factors = []\n  i = 2\n  while i * i <= n\n    factors.push(i)\n    i += 2\n\
    \  factors.each do |factor|\n    if n % factor == 0\n      return factor\n   \
    \ end\n  end\n  return n\nend", "  prime_divisors(n)\n  prime_divisors.each do\
    \ |prime|\n    return prime if prime.is_a?(Integer)\n  end\n  nil\nend", "  factors\
    \ = []\n  i = 2\n  while i * i <= n\n    factors.push(i)\n    i += 1\n  factors.each\
    \ do |factor|\n    break if n % factor == 0\n    n /= factor\n  end\n  n\nend\n\
    </code>\n<|/ a tags=ruby,primes |>\n<| c |>\nThe `break` statement is unnecessary\
    \ and can be removed.\n<|/ c |>\n<| c |>\nThanks, I didn't know that. I've removed\
    \ it.\n<|/ c |>\n<| c |>\nThe `break` statement is unnecessary and can be removed.\
    \ `factors.each { |factor| n /= factor if n % factor == 0 }` would work just fine.\n\
    <|/ c |>\n<| c |>\nThanks, I didn't know that. I've removed it.\n<|/ c |>\n<|\
    \ c |>\n`factors.each { |factor| n /= factor if n % factor == 0 }` would work\
    \ just fine.\n<|/ c |>\n<| a |>\n<code>", "  factors = []\n  i = 2\n  while i\
    \ * i <= n\n    factors.push(i)\n    i += 1\n  factors.each do |factor|\n    break\
    \ if n % factor == 0\n    n /= factor\n  end\n  n\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThanks for your answer. I'm sorry I didn't specify that I was looking\
    \ for a solution that doesn't use recursion.\n<|/ c |>\n<| c |>\nI added a non-recursive\
    \ solution that doesn't use recursion.\n<|/ c |>\n<| c |>\nThanks for your answer.\
    \ I'm sorry I didn't specify that I was looking for a solution that doesn't use\
    \ recursion.\n<|/ c |>\n<| c |>\nI added a non-recursive solution that doesn't\
    \ use recursion.\n<|/ c |>\n<| a tags=ruby,primes |>\n<code>", "  factors = []\n\
    \  i = 2\n  while i * i <= n\n    factors.push(i)\n    i += 1\n  factors.each\
    \ do |factor|\n    if n % factor == 0\n      return factor\n    end\n  end\n \
    \ raise \"n must be greater than 1 and a prime\"\nend", "  prime_divisors(n)\n\
    \  largest_prime = nil\n  largest_prime_divisor = nil\n  n.times do |i|\n    prime_divisors(i)\n\
    \    largest_prime_divisor = nil\n    prime_divisors.each do |divisor|\n     \
    \ if divisor > largest_prime_divisor\n        largest_prime_divisor = divisor\n\
    \        largest_prime = i\n      end\n    end\n  end\n  largest_prime\nend",
  "  prime_divisors = prime_divisors(n)\n  prime_divisors.each do |prime|\n    if\
    \ n % prime == 0\n      return prime\n    end\n  end\n  return n\nend", "  prime_divisors(n)\n\
    \  largest_prime = prime_divisors.last\n  largest_prime == 1 ? return n : largest_prime_factor(largest_prime)\n\
    end", "  factors = []\n  i = 2\n  while i * i <= n\n    i += 1\n  while i <= n\
    \ / 2\n    factors.push(i)\n    i += 1\n  factors.each do |factor|\n    if n %\
    \ factor == 0\n      n = n / factor\n      break\n    end\n  end\n  n\nend", " \
    \ prime_divisors = prime_factors(n)\n  largest_prime_factor = prime_divisors.max\n\
    \  prime_divisors.each do |prime|\n    if n % prime == 0\n      largest_prime_factor\
    \ = prime\n    end\n  end\n  largest_prime_factor\nend", "  factors = []\n  i\
    \ = 2\n  while i * i <= n\n    i += 1\n  while n >= i\n    factors.push(i)\n \
    \   n /= i\n  factors.reverse\n  i = 2\n  while i * i <= n\n    i += 1\n  while\
    \ n >= i\n    factors.push(i)\n    n /= i\n  factors.reverse\n  factors.first\n\
    end", "  factors = []\n  i = 2\n  while i * i <= n\n    i += 1\n  while n % i\
    \ == 0\n    n /= i\n    factors << i\n    i += 1\n  factors << n if n > 1\n  factors.max\n\
    end", "  factor = 1\n  while n > 1\n    if n % factor == 0\n      break\n    n\
    \ /= factor\n    factor += 1\n  end\n  factor\nend", "  prime_divisors(n)\n  largest_divisor\
    \ = divisors(n)\n  largest_divisor == 1 ? n : largest_divisor\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
