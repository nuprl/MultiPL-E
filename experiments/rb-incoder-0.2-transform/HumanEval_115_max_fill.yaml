name: HumanEval_115_max_fill
language: rb
prompt: "# You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well has\
  \ a corresponding bucket that can be used to extract water from it, \n# and all\
  \ buckets have the same capacity.\n# Your task is to use the buckets to empty the\
  \ wells.\n# Output the number of times you need to lower the buckets.\n# Example\
  \ 1:\n# >>> max_fill.call([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n# 6\n\
  # Example 2:\n# >>> max_fill.call([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
  \ 1, 1, 1]], 2)\n# 5\n# Example 3:\n# >>> max_fill.call([[0, 0, 0], [0, 0, 0]],\
  \ 5)\n# 0\n# Constraints:\n# * all wells have the same length\n# * 1 <= grid.length\
  \ <= 10^2\n# * 1 <= grid[:,1].length <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <=\
  \ capacity <= 10\ndef max_fill(grid, capacity)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_fill\n\
  \    candidate = method(:max_fill)\n    assert_equal(6, candidate.call([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))\n    assert_equal(5, candidate.call([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))\n    assert_equal(0,\
  \ candidate.call([[0, 0, 0], [0, 0, 0]], 5))\n    assert_equal(4, candidate.call([[1,\
  \ 1, 1, 1], [1, 1, 1, 1]], 2))\n    assert_equal(2, candidate.call([[1, 1, 1, 1],\
  \ [1, 1, 1, 1]], 9))\n  end\nend\n"
completions: ["    count = 0\n    \n    # Your code here\n    \n    return count\n\
    </cell>\n<text>\nLet's test your function", "    # Fill the buckets\n    buckets\
    \ = Array.new(capacity, Array.new(capacity, 0))\n    grid.each do |row|\n    \
    \    row.each do |col|\n            if col == 1\n                buckets[row][col]\
    \ = 1\n            end\n        end\n    end", "    # write your code here\n \
    \   count = 0\n    \n    buckets = Array.new(capacity)\n    \n    grid.each do\
    \ |row|\n        row.each do |col|\n            if col == 1\n                buckets[col]\
    \ += 1\n            end\n        end\n    end\n    \n    buckets.each do |b|\n\
    \        count += b if b > 0\n    end\n    \n    return count\nend\n</cell>\n\
    <text>\nBacktracking\nThe above problem can be solved using backtracking. However,\
    \ this approach is very inefficient and will take too long to solve large problems.\
    \ A better approach is to solve the problem using dynamic programming.", "   \
    \ count = 0\n    \n    # loop through each row\n    for row in grid\n        #\
    \ loop through each column\n        for col in row\n            # if the bucket\
    \ is full\n            if grid[row][col] == 1\n                # empty the bucket\n\
    \                grid[row][col] = 0\n                # increment the count\n \
    \               count += 1\n            end\n        end\n    end\n    \n    return\
    \ count\nend", "    # write your code here\n    count = 0\n    buckets = Array.new(capacity)\n\
    \    grid.each do |row|\n        row.each do |cell|\n            if cell == 1\n\
    \                count += 1\n                buckets[cell] += 1\n            end\n\
    \        end\n    end\n    buckets.each do |bucket|\n        if bucket < capacity\n\
    \            buckets[bucket] -= 1\n        end\n    end\n    return count\nend\n\
    </cell>\n<cell>", "    # write your code here\n    count = 0\n    \n    for row\
    \ in grid\n        count += row.count(0)\n        \n    return count\n</cell>\n\
    <text>\nBacktracking\nThe above algorithm is called \"backtracking\" because it\
    \ is an algorithm that attempts to solve a problem by trying all possible ways\
    \ of reaching its solution. Backtracking is a technique that can solve problems\
    \ more efficiently than iterative algorithms because it is able to explore the\
    \ solution space in multiple directions instead of just one.", "    # Write your\
    \ code here.\n    \n    count = 0\n    \n    for i in range(len(grid))\n     \
    \   \n        for j in range(len(grid[0]))\n            \n            if grid[i][j]\
    \ == 1\n                \n                count += 1\n                \n     \
    \           if count > capacity\n                    \n                    count\
    \ = 0\n                    \n    return count\n</cell>\n<text>\nSolution 2", " \
    \   # Write your code here.\n    \n    count = 0\n    \n    for i in range(len(grid)):\n\
    \        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n    \
    \            count += 1\n                \n                if count > capacity:\n\
    \                    count = 0\n                    grid[i][j] = 0\n         \
    \           \n    return count\n</cell>\n<cell>", "  count = 0\n  for i in 1..grid.length\n\
    \    for j in 1..grid[i].length\n      if grid[i][j] == 0\n        grid[i][j]\
    \ = capacity\n        count += 1\n      end\n    end\n  end\n  count\nend", " \
    \   count = 0\n    \n    # iterate through each row\n    for row in grid\n   \
    \     # iterate through each column\n        for col in row\n            # if\
    \ the bucket is full\n            if grid[row][col] == 1\n                # empty\
    \ the bucket\n                grid[row][col] = 0\n                # increment\
    \ the count\n                count += 1\n            end\n        end\n    end\n\
    \    \n    return count\nend", "    count = 0\n    \n    buckets = Array.new(capacity)\n\
    \    \n    grid.each do |row|\n        row.each do |val|\n            buckets[val]\
    \ += 1\n        end\n    end\n    \n    buckets.each do |b|\n        if b > 0\n\
    \            count += b\n        end\n    end\n    \n    return count\nend", " \
    \   # write your code here\n    \n    count = 0\n    \n    for row in grid\n \
    \       \n        if row.length == capacity\n            count += 1\n        \
    \    \n    return count\n    \n    ", "    # write your code here\n    count =\
    \ 0\n    buckets = Array.new(capacity)\n    grid.each do |row|\n        row.each\
    \ do |val|\n            if val == 1\n                buckets[val] += 1\n     \
    \       end\n        end\n    end\n    buckets.each do |val|\n        if val >\
    \ 0\n            count += val\n        end\n    end\n    return count\nend", " \
    \   # Write your code here\n    count = 0\n    \n    buckets = Array.new(capacity)\n\
    \    \n    grid.each do |row|\n        row.each do |cell|\n            if cell\
    \ == 1\n                buckets[cell] += 1\n            end\n        end\n   \
    \ end\n    \n    buckets.each do |bucket|\n        if bucket < capacity\n    \
    \        buckets[bucket] -= 1\n            count += 1\n        end\n    end\n\
    \    \n    return count\nend\n</cell>\n<cell>", "    count = 0\n    \n    # loop\
    \ through each row\n    for i in 0...grid.length\n        # loop through each\
    \ column\n        for j in 0...grid[i].length\n            # if the bucket is\
    \ full\n            if grid[i][j] == 1\n                # then increase the count\
    \ by one\n                count += 1\n                # if the bucket is still\
    \ full\n                if count >= capacity\n                    # then empty\
    \ the bucket\n                    grid[i][j] = 0\n                    # and decrease\
    \ the count by one\n                    count -= 1\n            end\n        end\n\
    \    end\n    \n    return count\nend", "    # write your code here\n    count\
    \ = 0\n    buckets = Array.new(capacity)\n    grid.each do |row|\n        row.each\
    \ do |cell|\n            if cell == 1\n                buckets[cell] += 1\n  \
    \          end\n        end\n    end\n    buckets.each do |bucket|\n        if\
    \ bucket < capacity\n            buckets[bucket] -= 1\n            count += 1\n\
    \        end\n    end\n    return count\nend\n</cell>\n<text>\nBacktracking\n\
    Backtracking is a technique for solving problems where the solution space is too\
    \ large to be solved using traditional methods. In a nutshell, backtracking is\
    \ a technique for solving problems where the solution space is too large to explore\
    \ all possibilities exhaustively, but still manageable by reasonable amounts of\
    \ computation.", "    # write your code here\n    \n    buckets = Array.new(capacity)\n\
    \    buckets.each do |b|\n        b.fill(0)\n    end\n    \n    grid.each do |row|\n\
    \        row.each do |cell|\n            if cell == 1\n                buckets[cell]\
    \ += 1\n            end\n        end\n    end\n    \n    buckets.each do |b|\n\
    \        if b > 0\n            b -= 1\n        end\n    end\n    \n    buckets.each\
    \ do |b|\n        if b == 0\n            return b\n        end\n    end\n    \n\
    \    return 0\nend", "    # write your code here\n    count = 0\n    \n    buckets\
    \ = Array.new(10).fill(0).each_with_index.to_a\n    \n    grid.each do |row|\n\
    \        row.each_with_index do |value, index|\n            buckets[value] -=\
    \ 1\n            if buckets[value] <= 0\n                buckets[value] = capacity\n\
    \                count += 1\n            end\n        end\n    end\n    \n   \
    \ return count\nend", "    count = 0\n    \n    # iterate through each row and\
    \ each column\n    grid.each do |row|\n        row.each do |col|\n           \
    \ # if the bucket is full, remove water from it\n            if col == capacity\n\
    \                count += capacity - col\n                col.clear\n        \
    \    end\n        end\n    end\n    \n    return count\nend", "    count = 0\n\
    \    \n    buckets = Array.new(capacity, Array.new(capacity, 0))\n    \n    grid.each\
    \ do |row|\n        row.each do |col|\n            if col == 1\n             \
    \   buckets[row][col] = 1\n            else\n                buckets[row][col]\
    \ = buckets[row][col-1]\n            end\n        end\n    end\n    \n    buckets.each\
    \ do |row|\n        row.each do |col|\n            if col == 1\n             \
    \   count += 1\n            end\n        end\n    end\n    \n    return count\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
