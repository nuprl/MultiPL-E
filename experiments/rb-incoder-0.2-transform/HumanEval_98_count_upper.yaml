name: HumanEval_98_count_upper
language: rb
prompt: "# Given a string s, count the number of uppercase vowels in even indices.\n\
  # For example:\n# >>> count_upper.call(\"aBCdEf\")\n# 1\n# >>> count_upper.call(\"\
  abcdefg\")\n# 0\n# >>> count_upper.call(\"dBBE\")\n# 0\ndef count_upper(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_upper\n\
  \    candidate = method(:count_upper)\n    assert_equal(1, candidate.call(\"aBCdEf\"\
  ))\n    assert_equal(0, candidate.call(\"abcdefg\"))\n    assert_equal(0, candidate.call(\"\
  dBBE\"))\n    assert_equal(0, candidate.call(\"B\"))\n    assert_equal(1, candidate.call(\"\
  U\"))\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(2, candidate.call(\"\
  EEEE\"))\n  end\nend\n"
completions: ["  s.gsub(/[AEIOU]/) do |c|\n    case = c.upcase\n    case[/[AEIOU]/].nil?\
    \ ? 0 : case == \"A\" ? 1 : case == \"E\" ? 2 : case == \"I\" ? 3 : case == \"\
    O\" ? 4 : case == \"U\" ? 5 : 6\n  end\nend", "  s.each_char.with_index do |c,\
    \ i|\n    if i % 2 == 0 && c.upcase == c\n      yield i\n    end\n  end\nend",
  "  s.chars.each_with_index.inject(0) do |sum, (char, i)|\n    sum + 1 if char.upcase\
    \ && i % 2 == 0\n  end\nend", "  s.chars.each_with_index.inject(0) { |sum, (ch,\
    \ i)| sum + 1 if i % 2 == 0 && ch.upcase == ch }\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if index % 2 == 0 && char.upcase == char\n\
    \  end\nend", "  s.gsub(/[aeiou]/) do |match|\n    match.size % 2 == 0 ? match.size\
    \ : match.size - 1\n  end\nend", "  s.gsub(/[AEIOU]/) { |c| c == 'A' ? 1 : 0 }\n\
    end", "  s.gsub(/[AEIOU]/) do |c|\n    case = c.upcase\n    case[/[aeiou]/i].nil?\
    \ ? case : case.count(\"A\") + case.count(\"E\") + case.count(\"I\") + case.count(\"\
    O\") + case.count(\"U\")\n  end\nend", "  s.gsub(/[AEIOU]/) do |c|\n    case =\
    \ c.upcase\n    case[/[aeiou]/].to_i.even? ? case : 0\n  end\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, i)|\n    sum + 1 if i % 2 == 0 && char.upcase == char\n  end\n\
    end", "  s.gsub(/[AEIOU]/) { |c| c == 'A' ? 1 : 0 }\nend", "  s.gsub!(/[AEIOU]/)\
    \ do |c|\n    case = c.upcase\n    case[/[aeiou]/i].nil? ? case : case.gsub(/[aeiou]/i,\
    \ '').length\n  end\n  s.count(\"A\"..\"Z\").to_i\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + (char.upcase && (index % 2 == 0))\n  end\n\
    end", "  s.each_char.with_index do |c,i|\n    if i % 2 == 0 && c.upcase == c\n\
    \      yield i\n    end\n  end\nend", "  s.gsub(/[aeiou]/) do |match|\n    match.length\
    \ % 2 == 0 ? match.length / 2 : 0\n  end\nend", "  s.gsub(/[AEIOU]/) {|c| c ==\
    \ 'A' ? 1 : c == 'E' ? 2 : c == 'I' ? 3 : c == 'O' ? 4 : c == 'U' ? 5 : 0}\nend",
  "  s.scan(/[aeiou]/)\n  s.count(\"A\"..\"Z\")\nend", "  s.scan(/[aeiou]/)\n  s.count(\"\
    A\"..\"Z\")\nend", "  s.gsub!(/[aeiou]/, '')\n  s.each_char.with_index { |c,i|\
    \ return 0 if i % 2 == 0 && c.upcase == c }\n  s.length\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (char, index)|\n    sum + 1 if char.upcase && index%2 == 0\n  end\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
