name: HumanEval_145_order_by_points
language: rb
prompt: "# Write a function which sorts the given list of integers\n# in ascending\
  \ order according to the sum of their digits.\n# Note: if there are several items\
  \ with similar sum of their digits,\n# order them based on their index in original\
  \ list.\n# For example:\n# >>> order_by_points.call([1, 11, -1, -11, -12])\n# [-1,\
  \ -11, 1, -12, 11]\n# >>> order_by_points.call([])\n# []\ndef order_by_points(nums)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_order_by_points\n\
  \    candidate = method(:order_by_points)\n    assert_equal([-1, -11, 1, -12, 11],\
  \ candidate.call([1, 11, -1, -11, -12]))\n    assert_equal([0, 2, 3, 6, 53, 423,\
  \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145,\
  \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32,\
  \ 43, 54, -98, 2, -3]))\n    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    assert_equal([-76, -21, 0, 4, 23, 6, 6],\
  \ candidate.call([0, 6, 6, -76, -21, 23, 4]))\n  end\nend\n"
completions: ["  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_s }\nend", " \
    \ nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    sum = 0\n    digits =\
    \ num.to_s.chars.map(&:to_i)\n    digits.each do |digit|\n      sum += digit\n\
    \    end\n    if sum > 0\n      nums.insert(nums.index(num), num)\n    end\n \
    \ end\n  nums\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if\
    \ the list contains negative numbers. Try `order_by_points.call([-1, -10, -20,\
    \ -30])`\n<|/ c |>\n<| c |>\nI added a note about this to the answer.\n<|/ c |>\n\
    <| c |>\nI added a note about this to the answer.\n<|/ c |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums.sum != i\n    nums.delete_at(i)\n    nums.unshift(n)\n  end\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i }\nend",
  "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i) }.values.map {\
    \ |nums| nums.sort }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n\
    \    sum = 0\n    n.to_s.split('').each do |c|\n      sum += c.to_i\n    end\n\
    \    n.to_s.split('').each do |c|\n      sum -= c.to_i\n    end\n    if sum ==\
    \ 0\n      nums.unshift(n)\n    end\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    n.to_s.split('').sort.reverse!\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num, index|\n    nums[index]\
    \ = num if num.digits.sum < nums[index].digits.sum\n  end\n  nums\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks for your answer. Your solution is very elegant\
    \ and works perfectly for my case. Thanks again!\n<|/ c |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break\
    \ if num.zero?\n    break if num.negative?\n    break if num.zero? && num.negative?\n\
    \  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis\
    \ doesn't work for negative numbers. Try `order_by_points.call([-1, -10, -20,\
    \ -30])`.\n<|/ c |>\n<| c |>\n: I agree, thanks for pointing that out. I've updated\
    \ my answer to account for negative numbers.\n<|/ c |>\n<| c |>\nI believe that\
    \ `nums.sort!` should be `nums.sort`. `sort!` modifies the array in place and\
    \ returns the sorted array. `sort` returns a new array with the sorted elements.\n\
    <|/ c |>\n<| c |>\n: You're right. I've updated my answer to reflect your suggestion.\n\
    <|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    n.to_s.split('').sort.reverse!\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n \
    \   break if num == -1\n    break if num == -num\n    break if num == num\n  end\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits\
    \ = num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+) if digits.empty?\n\
    \    digits = digits.sort_by(&:last)\n    digits = digits.reverse\n    nums.insert(nums.index(num),\
    \ digits)\n  end\n  nums\nend", "  nums.sort! do |a, b|\n    digits = a.to_s.chars.map(&:to_i).zip(b.to_s.chars.map(&:to_i)).map\
    \ { |x, y| x + y }\n    digits.max <=> digits.min\n  end\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    break if num.zero?\n    break if num.odd?\n\
    \    break if num.zero? || num.even?\n    break if num.zero? || num.odd? || num.even?\n\
    \    break if num.zero? || num.even? || num.odd?\n    break if num.zero? || num.odd?\
    \ || num.even? || num.zero?\n    break if num.zero? || num.even? || num.odd? ||\
    \ num.zero? || num.even?\n    break if num.zero? || num.even? || num.odd? || num.zero?\
    \ || num.even? || num.zero?\n    break if num.zero? || num.even? || num.odd? ||\
    \ num.zero? || num.even? || num.zero? || num.odd?\n    break if num.zero? || num.even?\
    \ || num.odd? || num.zero? || num.even? || num.zero? || num.odd? || num.zero?\n\
    \    break if num.zero? || num.even? || num.odd? || num.zero? || num.even? ||\
    \ num.zero? || num.odd? || num.zero? || num.even?\n    break if num.zero? || num.even?\
    \ || num.odd? || num.zero? || num.even? || num.zero? || num.odd? || num.zero?\
    \ || num.even? || num.zero?\n    break if num.zero? || num.even? || num.odd? ||\
    \ num.zero? || num.even? || num.zero? || num.odd? || num.zero? || num.even? ||\
    \ num.zero? || num.odd?\n    break if num.zero? || num.even? || num.odd? || num.zero?\
    \ || num.even? || num.zero? || num.odd? || num.zero? || num.even? || num.zero?\
    \ || num.odd? || num.zero?\n    break if num.zero? || num.even? || num.odd? ||\
    \ num.zero? || num.even? || num.zero? || num.odd? || num.", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_s\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.map! {|n| n.to_i}\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n    break\
    \ if nums[i] == n\n    nums[i] = n\n  end\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    if digits > nums[i]\n      nums[i], nums[i]\
    \ = nums[i], nums[i]\n    end\n  end\n  nums\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This doesn't work. Try `order_by_points.call([-12, -11, -10, -9, -8, -7, -6, -5,\
    \ -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9])`\n<|/ c |>\n<| c |>\n: I see\
    \ what you mean. I've updated the answer to handle negative numbers as well.\n\
    <|/ c |>\n<| c |>\nI believe this fails for `order_by_points.call([-12, -11, -10,\
    \ -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9])`\n<|/ c |>\n\
    <| c |>\n: I see what you mean. I've updated the answer to handle negative numbers\
    \ as well.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n\
    \  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n   \
    \ digits_sum = digits.inject(0) {|sum, digit| sum + digit}\n    if digits_sum\
    \ == 0 || (digits_sum == digits[digits.length-1])\n      nums[i] = n\n    end\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n \
    \   sum = 0\n    digits = num.to_s.chars.map(&:to_i)\n    digits.each do |d|\n\
    \      sum += d\n    end\n    if sum != 0\n      nums.insert(nums.index(num),\
    \ num)\n    end\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\nend", "  nums.sort!\
    \ do |a, b|\n    sum1 = sum2 = 0\n    a.each_byte { |x| sum1 += x }\n    b.each_byte\
    \ { |x| sum2 += x }\n    sum1 < sum2 ? -1 : sum1 > sum2 ? 1 : 0\n  end\nend",
  "  nums.sort! { |a, b| a.to_i + b.to_i }\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.map! {|n|\
    \ n.to_i}\n  nums\nend", "  nums.sort! do |a, b|\n    digits = a.to_s.split(//).map(&:to_i)\n\
    \    digits_b = b.to_s.split(//).map(&:to_i)\n    digits_a.zip(digits_b).map {\
    \ |d| d[0] + d[1] }.sum\n  end\nend", "  nums.sort!\n  nums.each_with_index do\
    \ |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    if digits == nums.max\n      nums[i] = n\n    end\n  end\n  nums\nend", " \
    \ nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break if num.zero?\n\
    \    break if num.odd?\n    break if num.zero?\n    break if num.even?\n    break\
    \ if num.odd?\n    break if num.even?\n    break if num.odd?\n    break if num.even?\n\
    \    break if num.odd?\n    break if num.even?\n    break if num.odd?\n    break\
    \ if num.even?\n    break if num.odd?\n    break if num.even?\n    break if num.odd?\n\
    \    break if num.even?\n    break if num.odd?\n    break if num.even?\n    break\
    \ if num.odd?\n    break if num.even?\n    break if num.odd?\n    break if num.even?\n\
    \    break if num.odd?\n    break if num.even?\n    break if num.odd?\n    break\
    \ if num.even?\n    break if num.odd?\n    break if num.even?\n    break if num.odd?\n\
    \    break if num.even?\n    break if num.odd?\n    break if num.even?\n    break\
    \ if num.odd?\n    break if num.even?\n    break if num.odd?\n    break if num.even?\n\
    \    break if num.odd?\n    break if num.even?\n    break if num.odd?\n    break\
    \ if num.even?\n    break if num.odd?\n    break if num.even?\n    break if num.odd?\n\
    \    break if num.even?\n    break if num.odd?\n    break if num.even?\n    break\
    \ if num.odd?\n    break if num.even?\n    break if num.odd?\n    break if num.even?\n\
    \    break if num.odd?\n    break if num.even?\n    break if num.odd?\n    break\
    \ if num.even?\n    break if num.odd?\n    break if num.even?\n    break if num.odd?\n\
    \    break if num.even?\n    break if num.odd?\n    break if num.even?\n    break\
    \ if num.odd?\n    break if num", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    digits = num.to_s.split(//)\n    digits.each { |d| nums[d] = nums[d].to_i\
    \ }\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits =\
    \ num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs", "  nums.sort!\
    \ { |a, b| a.to_s + b.to_s }\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ answer the question. OP wants to sort by digits, not alphabetically.\n<|/ c\
    \ |>\n<| c |>\nI misunderstood the question. Thanks for pointing it out. I edited\
    \ my answer.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    break if nums.sum == num\n    nums.delete(num)\n\
    \  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| a dscore=1\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits\
    \ = num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits\
    \ = digits.to_i\n    if digits > 0 && !nums.include?(num)\n      nums.unshift(num)\n\
    \    end\n  end\n  nums\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num,\
    \ i|\n    break if num == nums[i]\n    nums[i] = num\n  end\n  nums\nend", " \
    \ nums.sort!\n  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = 0 if digits.zero?\n    digits\
    \ = 1 if digits.zero?\n    digits = 2 if digits.even?\n    digits = 3 if digits.odd?\n\
    \    digits = 4 if digits.odd?\n    digits = 5 if digits.even?\n    digits = 6\
    \ if digits.even?\n    digits = 7 if digits.odd?\n    digits = 8 if digits.odd?\n\
    \    digits = 9 if digits.even?\n    digits = 10 if digits.even?\n    digits =\
    \ 11 if digits.odd?\n    digits = 12 if digits.odd?\n    digits = 13 if digits.even?\n\
    \    digits = 14 if digits.even?\n    digits = 15 if digits.odd?\n    digits =\
    \ 16 if digits.odd?\n    digits = 17 if digits.even?\n    digits = 18 if digits.even?\n\
    \    digits = 19 if digits.odd?\n    digits = 20 if digits.even?\n    digits =\
    \ 21 if digits.even?\n    digits = 22 if digits.even?\n    digits = 23 if digits.odd?\n\
    \    digits = 24 if digits.odd?\n    digits = 25 if digits.even?\n    digits =\
    \ 26 if digits.even?\n    digits = 27 if digits.odd?\n    digits = 28 if digits.odd?\n\
    \    digits = 29 if digits.even?\n    digits = 30 if digits.even?\n    digits\
    \ = 31 if digits.odd?\n    digits = 32 if digits.odd?\n    digits = 33 if digits.even?\n\
    \    digits = 34 if digits.even?\n    digits = 35 if digits.odd?\n    digits =\
    \ 36 if digits.odd?\n    digits = 37 if digits.even?\n    digits = 38 if digits.even?\n\
    \    digits = 39 if digits.odd?\n    digits = 40 if digits.even?\n    digits =\
    \ 41 if digits.even?\n    digits = 42 if digits.even?\n    digits = 43 if digits.odd?\n\
    \    digits = 44 if digits.odd?\n    digits = 45 if digits.even?\n    digits =\
    \ 46 if digits.even?\n    digits = 47 if digits.odd?\n    digits = 48 if digits.odd?\n\
    \    digits = 49 if digits.even?\n    digits = 50 if digits.even?\n    digits\
    \ = 51 if digits.even?\n    ", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |num, i|\n    nums[i] = num if nums.sum.to_i == num.to_i\n  end\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break if nums.sum.to_s\
    \ == num.to_s\n    nums.delete_at(nums.index(num))\n  end\n  nums\nend\n</code>\n\
    <|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't work if there are two\
    \ or more elements with same sum.\n<|/ c |>\n<| c |>\nI added a note to the question.\
    \ Thanks for pointing it out.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |n, i|\n    break if nums.sum != n\n\
    \    nums[i] = n\n  end\n  nums\nend", "  nums.sort! { |a, b| a.to_s + b.to_s\
    \ }\nend", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i) }.\n\
    \    map { |k, v| [k, v.map(&:last)] }.\n    map { |k, v| v.sort_by { |n| n.to_s.split(//).map(&:to_i)\
    \ }.\n    map { |k, v| [k, v.map(&:first)] }.\n    flatten\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |num, i|\n    break if num == -1\n\
    \    nums[i] = num if num.digits.sum < num.digits.max\n  end\n  nums\nend\n</code>\n\
    <|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't work for negative numbers.\
    \ `order_by_points.call([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0])` returns\
    \ `[-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0]`\n<|/ c |>\n<| c |>\nYes, it does.\
    \ I tested it before posting it. The OP didn't specify negative numbers in the\
    \ question. He just said \"integers\". He didn't say \"negative integers\".\n\
    <|/ c |>\n<| c |>\nI didn't say negative integers, I said integers. I didn't say\
    \ negative integers, I said integers. I didn't say negative integers, I said integers.\
    \ I didn't say negative integers, I said integers. I didn't say negative integers,\
    \ I said integers. I didn't say negative integers, I said integers. I didn't say\
    \ negative integers, I said integers. I didn't say negative integers, I said integers.\
    \ I didn't say negative integers, I said integers. I didn't say negative integers,\
    \ I said integers. I didn't say negative integers, I said integers. I didn't say\
    \ negative integers, I said integers. I didn't say negative integers, I said integers.\
    \ I didn't say negative integers, I said integers. I didn't say negative integers,\
    \ I said integers. I didn't say negative integers, I said integers. I didn't say\
    \ negative integers, I said integers. I didn't say negative integers, I said integers.\
    \ I didn't say negative integers, I said integers. I didn't say negative integers,\
    \ I said integers. I didn't say negative integers, I said integers. I didn't say\
    \ negative integers, I said integers. I didn't say negative integers, I said integers.\
    \ I didn't say negative integers, I said integers. I didn't say negative integers,\
    \ I said integers. I didn't say negative integers, I said integers. I didn't say\
    \ negative integers, I said integers. I didn't say negative integers, I said integers.\
    \ I didn't say negative integers, I said integers. I didn't say negative integers,\
    \ I said integers. I didn't say negative integers, I said integers. I didn't say\
    \ negative integers, I said integers. I didn't say negative integers, I said ",
  "  nums.sort!\n  nums.reverse!\n  nums.map! {|n| n.to_i}\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.split(//).map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digit", " \
    \ nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num, i|\n    nums[i]\
    \ = num if num.zero?\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    i = num.abs\n    break if i == 0\n    i = i / 10\n    j = num\
    \ / i\n    nums[i] = j\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    i = num.to_i\n    break if i == 0\n    nums.delete_at(i)\n\
    \    nums.insert(i, num)\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums.sum == i\n    nums[i] = n\n\
    \  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work if there are\
    \ two or more numbers with the same sum.\n<|/ c |>\n<| c |>\nYes, you are right.\
    \ I've added a note to the answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |n, i|\n    break if nums[i] == n\n\
    \    nums[i] = n\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,sorting\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num,\
    \ i|\n    nums[i] = num if nums[i].to_s.chars.map(&:to_i).sum == num.to_s.chars.map(&:to_i).sum\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_s.split('').map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums[i] == n\n    nums[i] = n\n  end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    n.to_s.split('').sort.reverse!\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num, i|\n    break if\
    \ num == 0 || nums.sum != num\n    nums[i] = num\n  end\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    break if num.zero?\n    break if num.odd?\n\
    \    break if num.zero? || num.even?\n    break if num.zero? || num.odd? || num.even?\n\
    \    break if num.zero? || num.even? || num.odd?\n    break if num.zero? || num.odd?\
    \ || num.even? || num.zero?\n    break if num.zero? || num.even? || num.odd? ||\
    \ num.zero? || num.even?\n    break if num.zero? || num.even? || num.odd? || num.zero?\
    \ || num.even? || num.zero?\n    break if num.zero? || num.even? || num.odd? ||\
    \ num.zero? || num.even? || num.zero? || num.even?\n    break if num.zero? ||\
    \ num.even? || num.odd? || num.zero? || num.even? || num.zero? || num.even? ||\
    \ num.zero?\n    break if num.zero? || num.even? || num.odd? || num.zero? || num.even?\
    \ || num.zero? || num.even? || num.zero? || num.even?\n    break if num.zero?\
    \ || num.even? || num.odd? || num.zero? || num.even? || num.zero? || num.even?\
    \ || num.zero? || num.even? || num.zero?\n    break if num.zero? || num.even?\
    \ || num.odd? || num.zero? || num.even? || num.zero? || num.even? || num.zero?\
    \ || num.even? || num.zero? || num.even?\n    break if num.zero? || num.even?\
    \ || num.odd? || num.zero? || num.even? || num.zero? || num.even? || num.zero?\
    \ || num.even? || num.zero? || num.even? || num.zero?\n    break if num.zero?\
    \ || num.even? || num.odd? || num.zero? || num.even? || num.zero? || num.even?\
    \ || num.", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThis doesn't work if there are two numbers with the\
    \ same sum.\n<|/ c |>\n<| c |>\nIt doesn't work if there are two numbers with\
    \ the same sum.\n<|/ c |>\n<| c |>\nI added a note to my answer.\n<|/ c |>\n<|\
    \ c |>\nI added a note to my answer.\n<|/ c |>\n<| a |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.map { |n| n.to_i }\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    break if n.to_s.chars.map(&:to_i).sum == n.to_s.chars.map(&:to_i).sum\n\
    \    break if n.to_s.chars.map(&:to_i).sum > n.to_s.chars.map(&:to_i).sum\n  end\n\
    \  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't\
    \ work if there are two or more numbers with the same sum.\n<|/ c |>\n<| c |>\n\
    Yes, it does. I tested it before posting it. I just added a note at the bottom\
    \ of the answer.\n<|/ c |>\n<| c |>\nI see what you mean. My bad.\n<|/ c |>\n\
    <| c |>\nI see what you mean. My bad.\n<|/ c |>\n<| c |>\nI see what you mean.\
    \ My bad.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    sum = 0\n    n.to_s.split(\"\").each do |c|\n      sum\
    \ += c.to_i\n    end\n    n.to_s.split(\"\").each do |c|\n      sum -= c.to_i\n\
    \    end\n    if sum > 0\n      nums.insert(n, sum)\n    end\n  end\nend\n</code>\n\
    <|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't work if there are two\
    \ numbers with the same sum.\n<|/ c |>\n<| c |>\n: I agree, my answer doesn't\
    \ work if there are two numbers with the same sum. I'll try to fix it.\n<|/ c\
    \ |>\n<| c |>\n: I fixed my answer, now it works with two numbers with the same\
    \ sum.\n<|/ c |>\n<| c |>\n: I added a more efficient solution to my answer.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |num, i|\n    break if nums.sum < 0\n    nums.delete_at(i)\n    nums.unshift(num)\n\
    \  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis\
    \ doesn't work if there are two or more numbers with the same sum.\n<|/ c |>\n\
    <| c |>\nYes, you are right. I didn't think about this case. I'll fix my answer.\n\
    <|/ c |>\n<| c |>\nI added a fix for that case.\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i }\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |num, i|\n    nums[i] = num if nums.sum.to_i\
    \ == num.to_i\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n\
    <| a |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    sum\
    \ = 0\n    n.to_s.split('').each do |c|\n      sum += c.to_i\n    end\n    next\
    \ if sum == 0 || sum < 0\n    n.to_s.split('').each do |c|\n      sum -= c.to_i\n\
    \    end\n    next if sum < 0\n    n.to_s.split('').each do |c|\n      sum +=\
    \ c.to_i\n    end\n    next if sum == 0\n    n.to_s.split('').each do |c|\n  \
    \    sum -= c.to_i\n    end\n    next if sum == 0\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.group_by { |n| n.to_s.split(//).map(&:to_i) }.values.map { |n| n.first\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.each_with_index do |n, i|\n    break if nums.sum - n < 0\n    nums[i],\
    \ nums[nums.sum - n] = nums[nums.sum - n], nums[i]\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |n, i|\n    nums.delete_at(i)\n  \
    \  nums.insert(i, n)\n  end\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n\
    <| c |>\nThis doesn't work if there are two or more numbers with the same sum.\n\
    <|/ c |>\n<| c |>\nYes, I know. That's why I wrote \"if there are several items\
    \ with similar sum of their digits, order them based on their index in original\
    \ list.\"\n<|/ c |>\n<| c |>\nI see what you mean, but that doesn't mean that\
    \ your solution doesn't work. For example, `[1, 1, 1]` would sort as `[1, 1, 1]`\
    \ instead of `[1, 1]`.\n<|/ c |>\n<| c |>\nYes, you are right. I didn't think\
    \ about that case. Thanks for pointing out. I've updated my answer.\n<|/ c |>\n\
    <| c |>\nI like the idea of sorting by sum, but I think this only works if you\
    \ know that all the numbers are positive. For example, `[1, 1, -1]` would sort\
    \ as `[1, -1, 1]` instead of `[1, 1]`.\n<|/ c |>\n<| a |>\n<code>", "  nums.sort!\
    \ { |a, b| a.to_i + b.to_i }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    nums[i] = [n] + nums[i] if nums[i].to_s.chars.map(&:to_i).sum\
    \ == n\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\n\
    This doesn't work if there are multiple items with the same sum.\n<|/ c |>\n<|\
    \ c |>\nYes, I forgot about that case. I've updated my answer.\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work if there are multiple items with the same sum.\n<|/ c\
    \ |>\n<| c |>\nYes, I forgot about that case. I've updated my answer.\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    if digits == 0\n      nums[i] = n\n    end\n  end\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    sum =\
    \ 0\n    while num > 0\n      sum += num % 10\n      num /= 10\n    end\n    sum\n\
    \  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    i = num.to_i\n\
    \    break if nums.count > 1\n    j = nums.index(i)\n    nums.insert(j, i)\n \
    \ end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    sum\
    \ = 0\n    while n != 0\n      sum += n % 10\n      n /= 10\n    end\n    puts\
    \ sum if sum == 0 || sum == nums.last\n  end\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThanks for your answer! I didn't know that you can sort a list by sum.\
    \ I'm going to try it out and see if it works.\n<|/ c |>\n<| c |>\nI ran the code\
    \ and it didn't work. I'm going to try and figure out why.\n<|/ c |>\n<| c |>\n\
    I added some comments to my answer. Hope it helps.\n<|/ c |>\n<| c |>\nThanks\
    \ for your answer! I ran the code and it didn't work. I'm going to try and figure\
    \ out why.\n<|/ c |>\n<| c |>\nI added some comments to my answer. Hope it helps.\n\
    <|/ c |>\n<| a tags=ruby,arrays,sorting |>\n<code>", "  nums.sort!\n  nums.map\
    \ { |n| n.to_s.split('').map(&:to_i).reduce(:+) }\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    digits = num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    if digits > 0 && !nums.include?(num)\n      nums.unshift(num)\n\
    \    end\n  end\n  nums\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
