name: HumanEval_145_order_by_points
language: rb
prompt: "# Write a function which sorts the given list of integers\n# in ascending\
  \ order according to the sum of their digits.\n# Note: if there are several items\
  \ with similar sum of their digits,\n# order them based on their index in original\
  \ list.\n# For example:\n# >>> order_by_points.call([1, 11, -1, -11, -12])\n# [-1,\
  \ -11, 1, -12, 11]\n# >>> order_by_points.call([])\n# []\ndef order_by_points(nums)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_order_by_points\n\
  \    candidate = method(:order_by_points)\n    assert_equal([-1, -11, 1, -12, 11],\
  \ candidate.call([1, 11, -1, -11, -12]))\n    assert_equal([0, 2, 3, 6, 53, 423,\
  \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145,\
  \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32,\
  \ 43, 54, -98, 2, -3]))\n    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    assert_equal([-76, -21, 0, 4, 23, 6, 6],\
  \ candidate.call([0, 6, 6, -76, -21, 23, 4]))\n  end\nend\n"
completions: ["  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_s }\nend", " \
    \ nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    sum = 0\n    digits =\
    \ num.to_s.chars.map(&:to_i)\n    digits.each do |digit|\n      sum += digit\n\
    \    end\n    if sum > 0\n      nums.insert(nums.index(num), num)\n    end\n \
    \ end\n  nums\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if\
    \ the list contains negative numbers. Try `order_by_points.call([-1, -10, -20,\
    \ -30])`\n<|/ c |>\n<| c |>\nI added a note about this to the answer.\n<|/ c |>\n\
    <| c |>\nI added a note about this to the answer.\n<|/ c |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums.sum != i\n    nums.delete_at(i)\n    nums.unshift(n)\n  end\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i }\nend",
  "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i) }.values.map {\
    \ |nums| nums.sort }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n\
    \    sum = 0\n    n.to_s.split('').each do |c|\n      sum += c.to_i\n    end\n\
    \    n.to_s.split('').each do |c|\n      sum -= c.to_i\n    end\n    if sum ==\
    \ 0\n      nums.unshift(n)\n    end\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    n.to_s.split('').sort.reverse!\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num, index|\n    nums[index]\
    \ = num if num.digits.sum < nums[index].digits.sum\n  end\n  nums\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks for your answer. Your solution is very elegant\
    \ and works perfectly for my case. Thanks again!\n<|/ c |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break\
    \ if num.zero?\n    break if num.negative?\n    break if num.zero? && num.negative?\n\
    \  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis\
    \ doesn't work for negative numbers. Try `order_by_points.call([-1, -10, -20,\
    \ -30])`.\n<|/ c |>\n<| c |>\n: I agree, thanks for pointing that out. I've updated\
    \ my answer to account for negative numbers.\n<|/ c |>\n<| c |>\nI believe that\
    \ `nums.sort!` should be `nums.sort`. `sort!` modifies the array in place and\
    \ returns the sorted array. `sort` returns a new array with the sorted elements.\n\
    <|/ c |>\n<| c |>\n: You're right. I've updated my answer to reflect your suggestion.\n\
    <|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    n.to_s.split('').sort.reverse!\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n \
    \   break if num == -1\n    break if num == -num\n    break if num == num\n  end\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits\
    \ = num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+) if digits.empty?\n\
    \    digits = digits.sort_by(&:last)\n    digits = digits.reverse\n    nums.insert(nums.index(num),\
    \ digits)\n  end\n  nums\nend", "  nums.sort! do |a, b|\n    digits = a.to_s.chars.map(&:to_i).zip(b.to_s.chars.map(&:to_i)).map\
    \ { |x, y| x + y }\n    digits.max <=> digits.min\n  end\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    break if num.zero?\n    break if num.odd?\n\
    \    break if num.zero? || num.even?\n    break if num.zero? || num.odd? || num.even?\n\
    \    break if num.zero? || num.even? || num.odd?\n    break if num.zero? || num.odd?\
    \ || num.even? || num.zero?\n    break if num.zero? || num.even? || num.odd? ||\
    \ num.zero? || num.even?\n    break if num.zero? || num.even? || num.odd? || num.zero?\
    \ || num.even? || num.zero?\n    break if num.zero? || num.even? || num.odd? ||\
    \ num.zero? || num.even? || num.zero? || num.odd?\n    break if num.zero? || num.even?\
    \ || num.odd? || num.zero? || num.even? || num.zero? || num.odd? || num.zero?\n\
    \    break if num.zero? || num.even? || num.odd? || num.zero? || num.even? ||\
    \ num.zero? || num.odd? || num.zero? || num.even?\n    break if num.zero? || num.even?\
    \ || num.odd? || num.zero? || num.even? || num.zero? || num.odd? || num.zero?\
    \ || num.even? || num.zero?\n    break if num.zero? || num.even? || num.odd? ||\
    \ num.zero? || num.even? || num.zero? || num.odd? || num.zero? || num.even? ||\
    \ num.zero? || num.odd?\n    break if num.zero? || num.even? || num.odd? || num.zero?\
    \ || num.even? || num.zero? || num.odd? || num.zero? || num.even? || num.zero?\
    \ || num.odd? || num.zero?\n    break if num.zero? || num.even? || num.odd? ||\
    \ num.zero? || num.even? || num.zero? || num.odd? || num.", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_s\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.map! {|n| n.to_i}\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n    break\
    \ if nums[i] == n\n    nums[i] = n\n  end\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    if digits > nums[i]\n      nums[i], nums[i]\
    \ = nums[i], nums[i]\n    end\n  end\n  nums\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This doesn't work. Try `order_by_points.call([-12, -11, -10, -9, -8, -7, -6, -5,\
    \ -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9])`\n<|/ c |>\n<| c |>\n: I see\
    \ what you mean. I've updated the answer to handle negative numbers as well.\n\
    <|/ c |>\n<| c |>\nI believe this fails for `order_by_points.call([-12, -11, -10,\
    \ -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9])`\n<|/ c |>\n\
    <| c |>\n: I see what you mean. I've updated the answer to handle negative numbers\
    \ as well.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n\
    \  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n   \
    \ digits_sum = digits.inject(0) {|sum, digit| sum + digit}\n    if digits_sum\
    \ == 0 || (digits_sum == digits[digits.length-1])\n      nums[i] = n\n    end\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n \
    \   sum = 0\n    digits = num.to_s.chars.map(&:to_i)\n    digits.each do |d|\n\
    \      sum += d\n    end\n    if sum != 0\n      nums.insert(nums.index(num),\
    \ num)\n    end\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\nend", "  nums.sort!\
    \ do |a, b|\n    sum1 = sum2 = 0\n    a.each_byte { |x| sum1 += x }\n    b.each_byte\
    \ { |x| sum2 += x }\n    sum1 < sum2 ? -1 : sum1 > sum2 ? 1 : 0\n  end\nend",
  "  nums.sort! { |a, b| a.to_i + b.to_i }\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.map! {|n|\
    \ n.to_i}\n  nums\nend", "  nums.sort! do |a, b|\n    digits = a.to_s.split(//).map(&:to_i)\n\
    \    digits_b = b.to_s.split(//).map(&:to_i)\n    digits_a.zip(digits_b).map {\
    \ |d| d[0] + d[1] }.sum\n  end\nend", "  nums.sort!\n  nums.each_with_index do\
    \ |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    if digits == nums.max\n      nums[i] = n\n    end\n  end\n  nums\nend", " \
    \ nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break if num.zero?\n\
    \    break if num.odd?\n    break if num.zero?\n    break if num.even?\n    break\
    \ if num.odd?\n    break if num.even?\n    break if num.odd?\n    break if num.even?\n\
    \    break if num.odd?\n    break if num.even?\n    break if num.odd?\n    break\
    \ if num.even?\n    break if num.odd?\n    break if num.even?\n    break if num.odd?\n\
    \    break if num.even?\n    break if num.odd?\n    break if num.even?\n    break\
    \ if num.odd?\n    break if num.even?\n    break if num.odd?\n    break if num.even?\n\
    \    break if num.odd?\n    break if num.even?\n    break if num.odd?\n    break\
    \ if num.even?\n    break if num.odd?\n    break if num.even?\n    break if num.odd?\n\
    \    break if num.even?\n    break if num.odd?\n    break if num.even?\n    break\
    \ if num.odd?\n    break if num.even?\n    break if num.odd?\n    break if num.even?\n\
    \    break if num.odd?\n    break if num.even?\n    break if num.odd?\n    break\
    \ if num.even?\n    break if num.odd?\n    break if num.even?\n    break if num.odd?\n\
    \    break if num.even?\n    break if num.odd?\n    break if num.even?\n    break\
    \ if num.odd?\n    break if num.even?\n    break if num.odd?\n    break if num.even?\n\
    \    break if num.odd?\n    break if num.even?\n    break if num.odd?\n    break\
    \ if num.even?\n    break if num.odd?\n    break if num.even?\n    break if num.odd?\n\
    \    break if num.even?\n    break if num.odd?\n    break if num.even?\n    break\
    \ if num.odd?\n    break if num", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    digits = num.to_s.split(//)\n    digits.each { |d| nums[d] = nums[d].to_i\
    \ }\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits =\
    \ num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits =\
    \ digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits =\
    \ digits.abs\n    digits = digits.to_i\n    digits = digits.abs", "  nums.sort!\
    \ { |a, b| a.to_s + b.to_s }\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ answer the question. OP wants to sort by digits, not alphabetically.\n<|/ c\
    \ |>\n<| c |>\nI misunderstood the question. Thanks for pointing it out. I edited\
    \ my answer.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    break if nums.sum == num\n    nums.delete(num)\n\
    \  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| a dscore=1\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits\
    \ = num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits\
    \ = digits.to_i\n    if digits > 0 && !nums.include?(num)\n      nums.unshift(num)\n\
    \    end\n  end\n  nums\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num,\
    \ i|\n    break if num == nums[i]\n    nums[i] = num\n  end\n  nums\nend", " \
    \ nums.sort!\n  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = 0 if digits.zero?\n    digits\
    \ = 1 if digits.zero?\n    digits = 2 if digits.even?\n    digits = 3 if digits.odd?\n\
    \    digits = 4 if digits.odd?\n    digits = 5 if digits.even?\n    digits = 6\
    \ if digits.even?\n    digits = 7 if digits.odd?\n    digits = 8 if digits.odd?\n\
    \    digits = 9 if digits.even?\n    digits = 10 if digits.even?\n    digits =\
    \ 11 if digits.odd?\n    digits = 12 if digits.odd?\n    digits = 13 if digits.even?\n\
    \    digits = 14 if digits.even?\n    digits = 15 if digits.odd?\n    digits =\
    \ 16 if digits.odd?\n    digits = 17 if digits.even?\n    digits = 18 if digits.even?\n\
    \    digits = 19 if digits.odd?\n    digits = 20 if digits.even?\n    digits =\
    \ 21 if digits.even?\n    digits = 22 if digits.even?\n    digits = 23 if digits.odd?\n\
    \    digits = 24 if digits.odd?\n    digits = 25 if digits.even?\n    digits =\
    \ 26 if digits.even?\n    digits = 27 if digits.odd?\n    digits = 28 if digits.odd?\n\
    \    digits = 29 if digits.even?\n    digits = 30 if digits.even?\n    digits\
    \ = 31 if digits.odd?\n    digits = 32 if digits.odd?\n    digits = 33 if digits.even?\n\
    \    digits = 34 if digits.even?\n    digits = 35 if digits.odd?\n    digits =\
    \ 36 if digits.odd?\n    digits = 37 if digits.even?\n    digits = 38 if digits.even?\n\
    \    digits = 39 if digits.odd?\n    digits = 40 if digits.even?\n    digits =\
    \ 41 if digits.even?\n    digits = 42 if digits.even?\n    digits = 43 if digits.odd?\n\
    \    digits = 44 if digits.odd?\n    digits = 45 if digits.even?\n    digits =\
    \ 46 if digits.even?\n    digits = 47 if digits.odd?\n    digits = 48 if digits.odd?\n\
    \    digits = 49 if digits.even?\n    digits = 50 if digits.even?\n    digits\
    \ = 51 if digits.even?\n    ", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |num, i|\n    nums[i] = num if nums.sum.to_i == num.to_i\n  end\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break if nums.sum.to_s\
    \ == num.to_s\n    nums.delete_at(nums.index(num))\n  end\n  nums\nend\n</code>\n\
    <|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't work if there are two\
    \ or more elements with same sum.\n<|/ c |>\n<| c |>\nI added a note to the question.\
    \ Thanks for pointing it out.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |n, i|\n    break if nums.sum != n\n\
    \    nums[i] = n\n  end\n  nums\nend", "  nums.sort! { |a, b| a.to_s + b.to_s\
    \ }\nend", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i) }.\n\
    \    map { |k, v| [k, v.map(&:last)] }.\n    map { |k, v| v.sort_by { |n| n.to_s.split(//).map(&:to_i)\
    \ }.\n    map { |k, v| [k, v.map(&:first)] }.\n    flatten\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |num, i|\n    break if num == -1\n\
    \    nums[i] = num if num.digits.sum < num.digits.max\n  end\n  nums\nend\n</code>\n\
    <|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't work for negative numbers.\
    \ `order_by_points.call([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0])` returns\
    \ `[-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0]`\n<|/ c |>\n<| c |>\nYes, it does.\
    \ I tested it before posting it. The OP didn't specify negative numbers in the\
    \ question. He just said \"integers\". He didn't say \"negative integers\".\n\
    <|/ c |>\n<| c |>\nI didn't say negative integers, I said integers. I didn't say\
    \ negative integers, I said integers. I didn't say negative integers, I said integers.\
    \ I didn't say negative integers, I said integers. I didn't say negative integers,\
    \ I said integers. I didn't say negative integers, I said integers. I didn't say\
    \ negative integers, I said integers. I didn't say negative integers, I said integers.\
    \ I didn't say negative integers, I said integers. I didn't say negative integers,\
    \ I said integers. I didn't say negative integers, I said integers. I didn't say\
    \ negative integers, I said integers. I didn't say negative integers, I said integers.\
    \ I didn't say negative integers, I said integers. I didn't say negative integers,\
    \ I said integers. I didn't say negative integers, I said integers. I didn't say\
    \ negative integers, I said integers. I didn't say negative integers, I said integers.\
    \ I didn't say negative integers, I said integers. I didn't say negative integers,\
    \ I said integers. I didn't say negative integers, I said integers. I didn't say\
    \ negative integers, I said integers. I didn't say negative integers, I said integers.\
    \ I didn't say negative integers, I said integers. I didn't say negative integers,\
    \ I said integers. I didn't say negative integers, I said integers. I didn't say\
    \ negative integers, I said integers. I didn't say negative integers, I said integers.\
    \ I didn't say negative integers, I said integers. I didn't say negative integers,\
    \ I said integers. I didn't say negative integers, I said integers. I didn't say\
    \ negative integers, I said integers. I didn't say negative integers, I said ",
  "  nums.sort!\n  nums.reverse!\n  nums.map! {|n| n.to_i}\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.split(//).map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digit", " \
    \ nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num, i|\n    nums[i]\
    \ = num if num.zero?\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    i = num.abs\n    break if i == 0\n    i = i / 10\n    j = num\
    \ / i\n    nums[i] = j\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    i = num.to_i\n    break if i == 0\n    nums.delete_at(i)\n\
    \    nums.insert(i, num)\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums.sum == i\n    nums[i] = n\n\
    \  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work if there are\
    \ two or more numbers with the same sum.\n<|/ c |>\n<| c |>\nYes, you are right.\
    \ I've added a note to the answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |n, i|\n    break if nums[i] == n\n\
    \    nums[i] = n\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,sorting\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num,\
    \ i|\n    nums[i] = num if nums[i].to_s.chars.map(&:to_i).sum == num.to_s.chars.map(&:to_i).sum\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_s.split('').map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums[i] == n\n    nums[i] = n\n  end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    n.to_s.split('').sort.reverse!\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num, i|\n    break if\
    \ num == 0 || nums.sum != num\n    nums[i] = num\n  end\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    break if num.zero?\n    break if num.odd?\n\
    \    break if num.zero? || num.even?\n    break if num.zero? || num.odd? || num.even?\n\
    \    break if num.zero? || num.even? || num.odd?\n    break if num.zero? || num.odd?\
    \ || num.even? || num.zero?\n    break if num.zero? || num.even? || num.odd? ||\
    \ num.zero? || num.even?\n    break if num.zero? || num.even? || num.odd? || num.zero?\
    \ || num.even? || num.zero?\n    break if num.zero? || num.even? || num.odd? ||\
    \ num.zero? || num.even? || num.zero? || num.even?\n    break if num.zero? ||\
    \ num.even? || num.odd? || num.zero? || num.even? || num.zero? || num.even? ||\
    \ num.zero?\n    break if num.zero? || num.even? || num.odd? || num.zero? || num.even?\
    \ || num.zero? || num.even? || num.zero? || num.even?\n    break if num.zero?\
    \ || num.even? || num.odd? || num.zero? || num.even? || num.zero? || num.even?\
    \ || num.zero? || num.even? || num.zero?\n    break if num.zero? || num.even?\
    \ || num.odd? || num.zero? || num.even? || num.zero? || num.even? || num.zero?\
    \ || num.even? || num.zero? || num.even?\n    break if num.zero? || num.even?\
    \ || num.odd? || num.zero? || num.even? || num.zero? || num.even? || num.zero?\
    \ || num.even? || num.zero? || num.even? || num.zero?\n    break if num.zero?\
    \ || num.even? || num.odd? || num.zero? || num.even? || num.zero? || num.even?\
    \ || num.", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThis doesn't work if there are two numbers with the\
    \ same sum.\n<|/ c |>\n<| c |>\nIt doesn't work if there are two numbers with\
    \ the same sum.\n<|/ c |>\n<| c |>\nI added a note to my answer.\n<|/ c |>\n<|\
    \ c |>\nI added a note to my answer.\n<|/ c |>\n<| a |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.map { |n| n.to_i }\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    break if n.to_s.chars.map(&:to_i).sum == n.to_s.chars.map(&:to_i).sum\n\
    \    break if n.to_s.chars.map(&:to_i).sum > n.to_s.chars.map(&:to_i).sum\n  end\n\
    \  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't\
    \ work if there are two or more numbers with the same sum.\n<|/ c |>\n<| c |>\n\
    Yes, it does. I tested it before posting it. I just added a note at the bottom\
    \ of the answer.\n<|/ c |>\n<| c |>\nI see what you mean. My bad.\n<|/ c |>\n\
    <| c |>\nI see what you mean. My bad.\n<|/ c |>\n<| c |>\nI see what you mean.\
    \ My bad.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    sum = 0\n    n.to_s.split(\"\").each do |c|\n      sum\
    \ += c.to_i\n    end\n    n.to_s.split(\"\").each do |c|\n      sum -= c.to_i\n\
    \    end\n    if sum > 0\n      nums.insert(n, sum)\n    end\n  end\nend\n</code>\n\
    <|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't work if there are two\
    \ numbers with the same sum.\n<|/ c |>\n<| c |>\n: I agree, my answer doesn't\
    \ work if there are two numbers with the same sum. I'll try to fix it.\n<|/ c\
    \ |>\n<| c |>\n: I fixed my answer, now it works with two numbers with the same\
    \ sum.\n<|/ c |>\n<| c |>\n: I added a more efficient solution to my answer.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |num, i|\n    break if nums.sum < 0\n    nums.delete_at(i)\n    nums.unshift(num)\n\
    \  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis\
    \ doesn't work if there are two or more numbers with the same sum.\n<|/ c |>\n\
    <| c |>\nYes, you are right. I didn't think about this case. I'll fix my answer.\n\
    <|/ c |>\n<| c |>\nI added a fix for that case.\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i }\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |num, i|\n    nums[i] = num if nums.sum.to_i\
    \ == num.to_i\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n\
    <| a |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    sum\
    \ = 0\n    n.to_s.split('').each do |c|\n      sum += c.to_i\n    end\n    next\
    \ if sum == 0 || sum < 0\n    n.to_s.split('').each do |c|\n      sum -= c.to_i\n\
    \    end\n    next if sum < 0\n    n.to_s.split('').each do |c|\n      sum +=\
    \ c.to_i\n    end\n    next if sum == 0\n    n.to_s.split('').each do |c|\n  \
    \    sum -= c.to_i\n    end\n    next if sum == 0\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.group_by { |n| n.to_s.split(//).map(&:to_i) }.values.map { |n| n.first\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.each_with_index do |n, i|\n    break if nums.sum - n < 0\n    nums[i],\
    \ nums[nums.sum - n] = nums[nums.sum - n], nums[i]\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |n, i|\n    nums.delete_at(i)\n  \
    \  nums.insert(i, n)\n  end\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n\
    <| c |>\nThis doesn't work if there are two or more numbers with the same sum.\n\
    <|/ c |>\n<| c |>\nYes, I know. That's why I wrote \"if there are several items\
    \ with similar sum of their digits, order them based on their index in original\
    \ list.\"\n<|/ c |>\n<| c |>\nI see what you mean, but that doesn't mean that\
    \ your solution doesn't work. For example, `[1, 1, 1]` would sort as `[1, 1, 1]`\
    \ instead of `[1, 1]`.\n<|/ c |>\n<| c |>\nYes, you are right. I didn't think\
    \ about that case. Thanks for pointing out. I've updated my answer.\n<|/ c |>\n\
    <| c |>\nI like the idea of sorting by sum, but I think this only works if you\
    \ know that all the numbers are positive. For example, `[1, 1, -1]` would sort\
    \ as `[1, -1, 1]` instead of `[1, 1]`.\n<|/ c |>\n<| a |>\n<code>", "  nums.sort!\
    \ { |a, b| a.to_i + b.to_i }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    nums[i] = [n] + nums[i] if nums[i].to_s.chars.map(&:to_i).sum\
    \ == n\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\n\
    This doesn't work if there are multiple items with the same sum.\n<|/ c |>\n<|\
    \ c |>\nYes, I forgot about that case. I've updated my answer.\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work if there are multiple items with the same sum.\n<|/ c\
    \ |>\n<| c |>\nYes, I forgot about that case. I've updated my answer.\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    if digits == 0\n      nums[i] = n\n    end\n  end\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    sum =\
    \ 0\n    while num > 0\n      sum += num % 10\n      num /= 10\n    end\n    sum\n\
    \  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    i = num.to_i\n\
    \    break if nums.count > 1\n    j = nums.index(i)\n    nums.insert(j, i)\n \
    \ end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    sum\
    \ = 0\n    while n != 0\n      sum += n % 10\n      n /= 10\n    end\n    puts\
    \ sum if sum == 0 || sum == nums.last\n  end\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThanks for your answer! I didn't know that you can sort a list by sum.\
    \ I'm going to try it out and see if it works.\n<|/ c |>\n<| c |>\nI ran the code\
    \ and it didn't work. I'm going to try and figure out why.\n<|/ c |>\n<| c |>\n\
    I added some comments to my answer. Hope it helps.\n<|/ c |>\n<| c |>\nThanks\
    \ for your answer! I ran the code and it didn't work. I'm going to try and figure\
    \ out why.\n<|/ c |>\n<| c |>\nI added some comments to my answer. Hope it helps.\n\
    <|/ c |>\n<| a tags=ruby,arrays,sorting |>\n<code>", "  nums.sort!\n  nums.map\
    \ { |n| n.to_s.split('').map(&:to_i).reduce(:+) }\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    digits = num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    if digits > 0 && !nums.include?(num)\n      nums.unshift(num)\n\
    \    end\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums.sum == i\n    nums.delete_at(i)\n    nums.unshift(n)\n\
    \  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting |>\n<| c |>\nI like your\
    \ solution, but I believe it can be done more efficiently by using a hash to store\
    \ the sum of the digits of each number, then sorting by the hash's keys. That\
    \ would avoid the O(n) sum-of-digits calculation.\n<|/ c |>\n<| c |>\nI agree\
    \ with you. Hash would be more efficient.\n<|/ c |>\n<| c |>\nI believe that would\
    \ still be O(n) though, since you're still iterating over every number in the\
    \ list. You're also not storing the sum of the digits, just the sum of the digits\
    \ of each number. You'd still have to iterate over every number in the list to\
    \ calculate the sum of the digits of each number, which would still be O(n).\n\
    <|/ c |>\n<| c |>\nYes, you are right. I missed the part where you said \"order\
    \ them based on their index in original list\". I will update my answer.\n<|/\
    \ c |>\n<| c |>\nI believe that would still be O(n) though, since you're still\
    \ iterating over every number in the list. You're also not storing the sum of\
    \ the digits, just the sum of the digits of each number. You'd still have to iterate\
    \ over every number in the list to calculate the sum of the digits of each number,\
    \ which would still be O(n).\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.split(//)\n    digits\
    \ = digits.map { |d| d.to_i }\n    digits.inject(0) do |sum, digit|\n      sum\
    \ + digit\n    end\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums.sum == i\n    nums[i] = n\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    i = num.abs\n    j = num.floor\
    \ - i\n    nums[i] = nums[j]\n    nums[j] = num\n  end\n  nums\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    digits = n.to_s.split(//).map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    digits = digits\
    \ if digits > 1\n    digits = 0 if digits < 0\n    digits = digits if digits ==\
    \ 0\n    digits = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits\
    \ = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits = 0 if digits\
    \ == 0\n    digits = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits\
    \ = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits = 0 if digits\
    \ == 0\n    digits = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits\
    \ = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits = 0 if digits\
    \ == 0\n    digits = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits\
    \ = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits = 0 if digits\
    \ == 0\n    digits = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits\
    \ = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits = 0 if digits\
    \ == 0\n    digits = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits\
    \ = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits = 0 if digits\
    \ == 0\n    digits = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits\
    \ = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits = 0 if digits\
    \ == 0\n    digits = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits\
    \ = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits = 0 if digits\
    \ == 0\n    digits = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits\
    \ = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits = 0 if digits\
    \ == 0\n    digits = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits\
    \ = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits = 0 if digits\
    \ == 0\n    digits = 0 if digits == 0\n    digits = 0 if digits == 0\n    digits\
    \ = 0 if digits == 0\n    digits = 0 if digits == 0\n    ", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    sum = 0\n    n.to_s.split(\"\").each do |c|\n      sum\
    \ += c.to_i\n    end\n    n.to_s.split(\"\").each do |c|\n      sum -= c.to_i\n\
    \    end\n    if sum > 0\n      nums.insert(n, 1)\n    end\n  end\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |num, i|\n    nums[i] = num if num.zero?\n\
    \  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num,\
    \ i|\n    nums[i] = num if nums.sum.to_i == num.to_i\n  end\n  nums\nend", " \
    \ nums.sort!\n  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = 0 if digits.zero?\n    digits\
    \ = 1 if digits.zero?\n    digits = 2 if digits.zero?\n    if digits > 0\n   \
    \   nums[i] = n\n    end\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are two or more elements with equal\
    \ sum.\n<|/ c |>\n<| c |>\nYes, it does. I tested it on [ruby 2.5.1](https://repl.it/repls/BrightMelancholyBash)\
    \ and [ruby 2.6.3](https://repl.it/repls/BrightMelancholyBash). Please test it\
    \ yourself.\n<|/ c |>\n<| c |>\nI tested it on [ruby 2.5.1](https://repl.it/repls/BrightMelancholyBash)\
    \ and [ruby 2.6.3](https://repl.it/repls/BrightMelancholyBash). Please test it\
    \ yourself.\n<|/ c |>\n<| c |>\nI tested it on [ruby 2.5.1](https://repl.it/repls/BrightMelancholyBash)\
    \ and [ruby 2.6.3](https://repl.it/repls/BrightMelancholyBash). Please test it\
    \ yourself.\n<|/ c |>\n<| c |>\nI tested it on [ruby 2.5.1](https://repl.it/repls/BrightMelancholyBash)\
    \ and [ruby 2.6.3](https://repl.it/repls/BrightMelancholyBash). Please test it\
    \ yourself.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n  nums.each_with_index\
    \ do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+)\
    \ if digits.empty?\n    digits = digits.max\n    nums[i] = n\n    nums[i] = digits\
    \ if digits > i\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    break if num == -1\n    break if num == -num\n    break if num\
    \ == num\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do\
    \ |n|\n    n.to_s.split('').sort.reverse!\n  end\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    break if n.zero?\n    break if n.odd?\n    break if n.even?\n\
    \    break if n.to_s.size < 2\n    break if n.to_s.size < 3\n    break if n.to_s.size\
    \ < 4\n    break if n.to_s.size < 5\n    break if n.to_s.size < 6\n    break if\
    \ n.to_s.size < 7\n    break if n.to_s.size < 8\n    break if n.to_s.size < 9\n\
    \    break if n.to_s.size < 10\n    break if n.to_s.size < 11\n    break if n.to_s.size\
    \ < 12\n    break if n.to_s.size < 13\n    break if n.to_s.size < 14\n    break\
    \ if n.to_s.size < 15\n    break if n.to_s.size < 16\n    break if n.to_s.size\
    \ < 17\n    break if n.to_s.size < 18\n    break if n.to_s.size < 19\n    break\
    \ if n.to_s.size < 20\n    break if n.to_s.size < 21\n    break if n.to_s.size\
    \ < 22\n    break if n.to_s.size < 23\n    break if n.to_s.size < 24\n    break\
    \ if n.to_s.size < 25\n    break if n.to_s.size < 26\n    break if n.to_s.size\
    \ < 27\n    break if n.to_s.size < 28\n    break if n.to_s.size < 29\n    break\
    \ if n.to_s.size < 30\n    break if n.to_s.size < 31\n    break if n.to_s.size\
    \ < 32\n    break if n.to_s.size < 33\n    break if n.to_s.size < 34\n    break\
    \ if n.to_s.size < 35\n    break if n.to_s.size < 36\n    break if n.to_s.size\
    \ < 37\n    break if n.to_s.size < 38\n    break if n.to_s.size < 39\n    break\
    \ if n.to_s.size < 40\n    break if n.to_s.size < 41\n    break if n.to_s.size\
    \ < 42\n    break if n.to_s.size < 43\n    break if n.to_s.size < 44\n    break\
    \ if n.to_s.size < 45\n    break if n.to_s.size < 46\n    break if n.to_s.size\
    \ < 47\n    break if n.to_s.size < 48\n    ", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    if digits > nums[i]\n      nums[i], nums[i]\
    \ = nums[i], nums[i]\n    end\n  end\n  nums\nend", "  nums.sort!\n  nums.group_by\
    \ { |x| x.to_s.split(//).map(&:to_i) }.map { |k, v| [k, v.map(&:last)] }.flatten.sort_by\
    \ { |x| x.reduce(:+) }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n\
    \    break if nums.sum == num\n    nums.unshift(num)\n  end\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    digits = num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    if digits > 0 && !(digits == 1 && num == 0)\n \
    \     nums.insert(nums.index(num), num)\n    end\n  end\n  nums\nend", "  nums.sort!\
    \ do |a, b|\n    sum1 = a.to_s.split(\"\").map(&:to_i).inject(0){|sum, el| sum\
    \ + el}\n    sum2 = b.to_s.split(\"\").map(&:to_i).inject(0){|sum, el| sum + el}\n\
    \    sum1 < sum2 ? -1 : sum1 > sum2 ? 1 : 0\n  end\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    break if n.to_s.chars.map(&:to_i).sum == n.to_s.chars.map(&:to_i).sum\n\
    \    nums.delete_at(n) if nums.index(n) == n\n  end\n  nums\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    break if nums.sum == num\n    nums.unshift(num)\n \
    \ end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_s.reverse\n    digits\
    \ = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digits = digits.to_s.reverse\n    digits\
    \ = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digits = digits.to_s.reverse\n    digits\
    \ = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digits = digits.to_s.reverse\n    digits\
    \ = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digits = digits.to_s.reverse\n    digits\
    \ = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums.sum - n == 0\n    nums[i] = n\n  end\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    i = num.abs\n\
    \    j = num.abs\n    while i > 0 && j > 0\n      i -= num % 10\n      j -= num\
    \ % 10\n      num = (num / 10).floor\n    end\n    nums[i] = num\n  end\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num, i|\n    break if\
    \ num == 0 && nums.size == 1\n    break if nums.include?(num)\n    nums[i] = num\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n \
    \   break if nums.sum == num\n    nums.delete_at(nums.index(num))\n  end\n  nums\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. Try it with `order_by_points.call([-12,\
    \ -11, -10, -9, -8])`\n<|/ c |>\n<| c |>\nIt works. I tested it before posting.\
    \ What is the problem?\n<|/ c |>\n<| c |>\nIt doesn't work. Try it with `order_by_points.call([-12,\
    \ -11, -10, -9, -8])`\n<|/ c |>\n<| c |>\nIt works. I tested it before posting.\
    \ What is the problem?\n<|/ c |>\n<| c |>\nIt doesn't work. Try it with `order_by_points.call([-12,\
    \ -11, -10, -9, -8])`\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    if digits == 0\n      nums[i] = n\n    end\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do\
    \ |n, i|\n    nums[i] = nums[i].to_i\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    digits = n.to_s.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_s\n\
    \    digits = digits.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_s\n\
    \    digits = digits.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_s\n\
    \    digits = digits.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_s\n\
    \    digits = digits.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_s\n\
    \    digits = digits.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_s\n\
    \    digits = digits.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_s\n\
    \    digits = digits.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_s\n\
    \    digits = digits.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_s\n\
    \    digits = digits.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_s\n\
    \    digits = digits.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_s\n\
    \    digits = digits.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_s\n\
    \    digits = digits.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_s\n\
    \    digits = digits.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_s\n\
    \    digits = digits.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_s\n\
    \    digits = digits.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_s\n\
    \    digits = digits.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_s\n\
    \    digits = digits.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_s\n\
    \    digits = digits.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_s\n\
    \    digits = digits.split(//).map(&:to_i)\n    digit", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    sum =\
    \ 0\n    digits = num.to_s.chars.map(&:to_i)\n    digits.each do |digit|\n   \
    \   sum += digit\n    end\n    if sum > 0\n      nums.insert(nums.index(num),\
    \ num)\n    end\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    sum = 0\n    while num > 0\n      sum += num % 10\n      num /=\
    \ 10\n    end\n    sum\n  end\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n\
    <| c |>\nThis doesn't work. Try `order_by_points.call([-12, -11, -10, -9, -8])`.\n\
    <|/ c |>\n<| c |>\nI see what you mean. I've updated the answer to account for\
    \ negative numbers.\n<|/ c |>\n<| c |>\nThis doesn't work. Try `order_by_points.call([-12,\
    \ -11, -10, -9, -8])`.\n<|/ c |>\n<| c |>\nI see what you mean. I've updated the\
    \ answer to account for negative numbers.\n<|/ c |>\n<| a |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    if num < 0\n\
    \      nums.unshift(num)\n      break\n    elsif num == 0\n      nums.unshift(num)\n\
    \      break\n    elsif num > 0\n      nums.unshift(num)\n      break\n    end\n\
    \  end\n  nums\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work. Try it with\
    \ `order_by_points.call([-12, -11, -1, 1])`\n<|/ c |>\n<| c |>\nI fixed the bug,\
    \ thanks for pointing it out. Now it works fine.\n<|/ c |>\n<| c |>\nI added a\
    \ more efficient solution that doesn't require sorting the list twice.\n<|/ c\
    \ |>\n<| a tags=ruby,sorting |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |num, i|\n    nums[i] = num if nums.sum.to_i == num.to_i\n  end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis doesn't work if there are two or more numbers\
    \ with the same sum.\n<|/ c |>\n<| c |>\nIt doesn't work because `nums.sum.to_i\
    \ == num.to_i` will always be true and `nums.sort!` will always sort them in ascending\
    \ order. `nums.sort!` will always sort them in ascending order and `nums.reverse!`\
    \ will always reverse them in descending order. `nums.each_with_index do |num,\
    \ i|` will always iterate over them in ascending order. `nums[i] = num if nums.sum.to_i\
    \ == num.to_i` will always assign the number to the first place in the array if\
    \ the sum of the digits is the same as the number itself. `nums.sort!` will always\
    \ sort them in ascending order and `nums.reverse!` will always reverse them in\
    \ descending order.\n<|/ c |>\n<| c |>\nI added a solution that doesn't require\
    \ any additional methods. I hope it helps.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if there are two or more numbers with the same sum.\n<|/ c |>\n<| c |>\nI added\
    \ a solution that doesn't require any additional methods. I hope it helps.\n<|/\
    \ c |>\n<| a tags=ruby |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    break if nums.sum == num\n    nums.unshift(num)\n  end\nend",
  "  nums.sort!\n  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    if digits ==\
    \ 0\n      nums[i] = n\n      next\n    end\n    digits = digits.abs\n    digits\
    \ = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits\
    \ = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits\
    \ = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits\
    \ = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits\
    \ = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits\
    \ = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits\
    \ = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits\
    \ = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits\
    \ = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits\
    \ = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits\
    \ = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits\
    \ = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits\
    \ = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits\
    \ = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits\
    \ = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits\
    \ = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits\
    \ = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits\
    \ = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits\
    \ = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits\
    \ = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits\
    \ = digits.to_i\n    digits = digits.abs\n    digits = digits.to_i\n    digits\
    \ = digits.abs\n    digits = digits.to_i\n    digits = digits.abs\n    digits\
    \ = digits.to_i\n    digits = digits.abs", "  nums.sort!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums.sum - n < 0\n    nums[i] = n\n  end\nend\n</code>\n\
    <|/ a tags=ruby,sorting,arrays |>\n<| c |>\nI like your solution, but I wonder\
    \ if there is a way to do it without having to iterate over the array twice.\n\
    <|/ c |>\n<| c |>\nI guess I should clarify that I am looking for a solution which\
    \ does not require the use of `each_with_index`.\n<|/ c |>\n<| c |>\nI added a\
    \ solution without `each_with_index`\n<|/ c |>\n<| c |>\nI like your solution,\
    \ but I wonder if there is a way to do it without having to iterate over the array\
    \ twice.\n<|/ c |>\n<| c |>\nI added a solution without `each_with_index`\n<|/\
    \ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums.sum != i\n    nums[i] = n\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map! {|n| n.to_i}\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    i = num.to_i\n\
    \    break if i == 0\n    i = num.to_s.chars.map(&:to_i).reduce(:+)\n    break\
    \ if i == 0\n    nums.insert(i, num)\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nI like this solution, but I wonder if it can be done without using\
    \ recursion.\n<|/ c |>\n<| c |>\nI guess it can be done without recursion, but\
    \ I wouldn't recommend it. I would just use recursion.\n<|/ c |>\n<| c |>\nI agree\
    \ with you. Recursion is more elegant, but I think it can be done without recursion.\n\
    <|/ c |>\n<| c |>\nI agree with you, but I wonder if it can be done without using\
    \ recursion.\n<|/ c |>\n<| c |>\nI guess it can be done without recursion, but\
    \ I wouldn't recommend it. I would just use recursion.\n<|/ c |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>", "  nums.sort!\n  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    digits = 0\
    \ if digits < 0\n    digits = digits if digits > 9\n    digits = 0 if digits <\
    \ 0\n    digits = digits if digits > 9\n    if digits == nums[i]\n      nums[i]\
    \ = i\n    end\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    break if num == 0 \n    break if num == -1\n    break if num ==\
    \ -2\n    break if num == -3\n    break if num == -4\n    break if num == -5\n\
    \    break if num == -6\n    break if num == -7\n    break if num == -8\n    break\
    \ if num == -9\n    break if num == -10\n    break if num == -11\n    break if\
    \ num == -12\n    break if num == -13\n    break if num == -14\n    break if num\
    \ == -15\n    break if num == -16\n    break if num == -17\n    break if num ==\
    \ -18\n    break if num == -19\n    break if num == -20\n    break if num == -21\n\
    \    break if num == -22\n    break if num == -23\n    break if num == -24\n \
    \   break if num == -25\n    break if num == -26\n    break if num == -27\n  \
    \  break if num == -28\n    break if num == -29\n    break if num == -30\n   \
    \ break if num == -31\n    break if num == -32\n    break if num == -33\n    break\
    \ if num == -34\n    break if num == -35\n    break if num == -36\n    break if\
    \ num == -37\n    break if num == -38\n    break if num == -39\n    break if num\
    \ == -40\n    break if num == -41\n    break if num == -42\n    break if num ==\
    \ -43\n    break if num == -44\n    break if num == -45\n    break if num == -46\n\
    \    break if num == -47\n    break if num == -48\n    break if num == -49\n \
    \   break if num == -50\n    break if num == -51\n    break if num == -52\n  \
    \  break if num == -53\n    break if num == -54\n    break if num == -55\n   \
    \ break if num == -56\n    break if num == -57\n    break if num == -58\n    break\
    \ if num == -59\n    break if num == -60\n    break if num == -61\n    break if\
    \ num == -62\n    break if num == -63\n    break if ", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    n.to_s.split('').sort.reverse.each do |s|\n      nums.delete_at(s.to_i)\n\
    \    end\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do\
    \ |num|\n    i = num.to_i\n    j = num.to_s.chars.map(&:to_i).reduce(:+)\n   \
    \ break if j == i\n    nums[i] = nums[j]\n  end\n  nums\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.map! {|n|\
    \ n.to_i}\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map! {|x| x.to_i}\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums[i] == n\n    nums[i] = n\n  end\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nI like the idea of using each_with_index to find the first element\
    \ with a matching sum, but this doesn't work if there are multiple elements with\
    \ that sum.\n<|/ c |>\n<| c |>\n: I added a version that does that.\n<|/ c |>\n\
    <| c |>\n: I added a version that does that too.\n<|/ c |>\n<| c |>\n: I added\
    \ a version that does that too.\n<|/ c |>\n<| c |>\n: I added a version that does\
    \ that too.\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution using sort_by and Enumerable#group_by.\n\
    <code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n  \
    \  break if nums.sum - n < 0\n    nums[i] = n\n  end\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums.sum < 0\n    nums[i] = n\n\
    \  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work. Try it with\
    \ `order_by_points.call([-1, 1, -10, 10, -100, 100])`\n<|/ c |>\n<| c |>\nI tested\
    \ it and it works fine. `order_by_points.call([-1, 1, -10, 10, -100, 100])` returns\
    \ `[-1, 1, -10, 10, -100, 100]`\n<|/ c |>\n<| c |>\nI tested it and it works fine.\
    \ `order_by_points.call([-1, 1, -10, 10, -100, 100])` returns `[-1, 1, -10, 10,\
    \ -100, 100]`\n<|/ c |>\n<| c |>\nI tested it and it works fine. `order_by_points.call([-1,\
    \ 1, -10, 10, -100, 100])` returns `[-1, 1, -10, 10, -100, 100]`\n<|/ c |>\n<|\
    \ c |>\nI tested it and it works fine. `order_by_points.call([-1, 1, -10, 10,\
    \ -100, 100])` returns `[-1, 1, -10, 10, -100, 100]`\n<|/ c |>\n<| a |>\n<code>",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    i = num.to_i\n    j =\
    \ nums.index{|num| num.to_i == i}\n    if j != nil\n      nums.insert(j, num)\n\
    \    end\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do\
    \ |num|\n    break if num == -1\n    break if num == -num\n    break if num ==\
    \ num\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n\
    \    digits = num.to_s.split(//).map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    if num < 0\n      num *= -1\n      digits *= -1\n\
    \    end\n    if digits > num\n      nums.insert(nums.index(num), num)\n    end\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i\
    \ }\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    if digits >\
    \ nums[i]\n      nums[i], nums[i] = nums[i], nums[i]\n    end\n  end\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n    break\
    \ if nums.sum - n == 0\n    nums[i] = n\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if the array contains negative numbers. Try `order_by_points.call([-1,\
    \ -10, -100, -1000, -1000])`\n<|/ c |>\n<| c |>\nI added a note about negative\
    \ numbers. I hope that helps.\n<|/ c |>\n<| c |>\nThis doesn't work if the array\
    \ contains negative numbers. Try `order_by_points.call([-1, -10, -100, -1000,\
    \ -1000])`\n<|/ c |>\n<| c |>\nI added a note about negative numbers. I hope that\
    \ helps.\n<|/ c |>\n<| c |>\nThis doesn't work if the array contains negative\
    \ numbers. Try `order_by_points.call([-1, -10, -100, -1000, -1000])`\n<|/ c |>\n\
    <| a dscore=5 |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.map! {|n| n.to_i}\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break\
    \ if nums.sum == num\n    nums.delete(num)\n  end\n  nums\nend\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nThis doesn't work if there are multiple numbers with the\
    \ same sum.\n<|/ c |>\n<| c |>\nYes, you're right. I missed that requirement.\
    \ I've updated my answer.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.split(//).map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    if digits >\
    \ 0 && digits < 10\n      nums.insert(nums.index(num), num)\n    end\n  end\n\
    \  nums\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't work if there\
    \ are multiple items with the same sum.\n<|/ c |>\n<| c |>\nYes, you're right.\
    \ I've added a note about this case in the answer.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if there are multiple items with the same sum.\n<|/ c |>\n<| c |>\nYes,\
    \ you're right. I've added a note about this case in the answer.\n<|/ c |>\n<|\
    \ a dscore=0 |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.map! {|x| x.abs}\
    \ if nums.any?\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n    break if nums.sum\
    \ - n == 0\n    nums[i] = n\n  end\nend", "  nums.sort!\n  nums.map { |n| n.to_i\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    digits = n.to_s.chars.map(&:to_i)\n    digits_sum = digits.inject(0) {|sum,\
    \ digit| sum + digit}\n    if digits_sum == digits.max\n      nums[i] = n\n  \
    \  end\n  end\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis\
    \ doesn't work if the numbers are negative.\n<|/ c |>\n<| c |>\n, thanks for pointing\
    \ out. I've updated the answer to handle negative numbers.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  nums.sort!\n  nums.group_by { |x| x.to_s.split(//).map(&:to_i)\
    \ }.\n    map { |k, v| [k, v.map(&:last)] }.\n    sort_by { |k, v| k.sum }.\n\
    \    map { |k, v| v.first }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    digits = n.to_s.split(//).map(&:to_i)\n    digits_sum = digits.inject(0)\
    \ {|sum, digit| sum + digit}\n    if digits_sum > 0\n      nums[i] = n\n    end\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n \
    \   break if num == -1\n    break if num == 0\n    break if num == 1\n    break\
    \ if num == -1\n    break if num == 0\n    break if num == 1\n    break if num\
    \ == -1\n    break if num == 0\n    break if num == 1\n    break if num == -1\n\
    \    break if num == 0\n    break if num == 1\n    break if num == -1\n    break\
    \ if num == 0\n    break if num == 1\n    break if num == -1\n    break if num\
    \ == 0\n    break if num == 1\n    break if num == -1\n    break if num == 0\n\
    \    break if num == 1\n    break if num == -1\n    break if num == 0\n    break\
    \ if num == 1\n    break if num == -1\n    break if num == 0\n    break if num\
    \ == 1\n    break if num == -1\n    break if num == 0\n    break if num == 1\n\
    \    break if num == -1\n    break if num == 0\n    break if num == 1\n    break\
    \ if num == -1\n    break if num == 0\n    break if num == 1\n    break if num\
    \ == -1\n    break if num == 0\n    break if num == 1\n    break if num == -1\n\
    \    break if num == 0\n    break if num == 1\n    break if num == -1\n    break\
    \ if num == 0\n    break if num == 1\n    break if num == -1\n    break if num\
    \ == 0\n    break if num == 1\n    break if num == -1\n    break if num == 0\n\
    \    break if num == 1\n    break if num == -1\n    break if num == 0\n    break\
    \ if num == 1\n    break if num == -1\n    break if num == 0\n    break if num\
    \ == 1\n    break if num == -1\n    break if num == 0\n    break if num == 1\n\
    \    break if num == -1\n    break if num == 0\n    break if num == 1\n    break\
    \ if num == -1\n    break if num == 0\n    break if num == 1\n    break if num\
    \ == -1\n    break if num == 0\n    break if num == 1\n    break if num == -1\n\
    \    break if num == 0\n    break if num == 1\n    break if num == -1\n    break\
    \ if num == 0\n    break if num == 1\n    break if num == -1\n    break if num\
    \ == 0\n    break if num", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n\
    \    break if nums.sum == num\n    nums.delete(num)\n  end\n  nums\nend\n</code>\n\
    <|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't work if there are two\
    \ numbers with the same sum.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before\
    \ posting it. I just added a note at the bottom of my answer.\n<|/ c |>\n<| c\
    \ |>\nI tested it again and it doesn't work. Try it with `order_by_points.call([-1,\
    \ -12, -11, -11])`.\n<|/ c |>\n<| c |>\nI tested it again and it doesn't work.\
    \ Try it with `order_by_points.call([-1, -12, -11, -11])`.\n<|/ c |>\n<| c |>\n\
    I tested it again and it doesn't work. Try it with `order_by_points.call([-1,\
    \ -12, -11, -11])`.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums.sum < 0\n    break if nums.sum\
    \ > n\n    nums[i], nums[nums.index(n)] = nums[nums.index(n)], nums[i]\n  end\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n    break\
    \ if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend\n</cell>\n<cell>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |n|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    if digits >\
    \ 0 && (nums.index(n - digits) != nil)\n      nums.insert(nums.index(n - digits),\
    \ n)\n    end\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    break if nums.sum < num\n    nums.delete(num)\n  end\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n    break\
    \ if nums[i] == n\n    nums[i] = n\n  end\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    digits = num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    digits = 0 if digits < 0\n    digits = digits if\
    \ digits > 9\n    nums[nums.index(num)] = digits\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\nend", "  nums.sort! { |a, b| a.to_i + b.to_i }\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.map { |n| n.to_i }\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\n  nums\nend\n</cell>\n<cell>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |num, i|\n    nums[i] = num if nums.sum.to_i == num.to_i\n  end\n  nums\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n   \
    \ digits_sum = digits.inject(0) {|sum, digit| sum + digit}\n    if digits_sum\
    \ > 0\n      nums[i] = n\n    end\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work. Try it with `order_by_points.call([-12, -11,\
    \ -10, -9, -8])`.\n<|/ c |>\n<| c |>\n: I see what you mean. I've updated the\
    \ answer accordingly.\n<|/ c |>\n<| c |>\nI see what you mean. I've updated the\
    \ answer accordingly.\n<|/ c |>\n<| c |>\nI see what you mean. I've updated the\
    \ answer accordingly.\n<|/ c |>\n<| c |>\nI see what you mean. I've updated the\
    \ answer accordingly.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", " \
    \ nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num, i|\n    break if\
    \ num == nums.last\n    nums.delete_at(i)\n    nums.insert(i, num)\n  end\n  nums\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for the answer. I'm a beginner\
    \ in Ruby and I didn't know that you can sort a list by comparing its elements.\
    \ I thought that sorting a list was something that happens automatically when\
    \ you call a method on it. Thanks for the explanation too.\n<|/ c |>\n<| c |>\n\
    Yeah, I didn't know that either, but then I learned something new today. :)\n\
    <|/ c |>\n<| c |>\nI added a more efficient solution that doesn't require sorting.\n\
    <|/ c |>\n<| c |>\nI added a solution that doesn't require sorting.\n<|/ c |>\n\
    <| c |>\nI added a solution that doesn't require sorting.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break\
    \ if num == -1\n    break if num == 0\n    break if num == 1\n    break if num\
    \ == -1\n    break if num == 0\n    break if num == 1\n    break if num == -1\n\
    \    break if num == 0\n    break if num == 1\n    break if num == -1\n    break\
    \ if num == 0\n    break if num == 1\n    break if num == -1\n    break if num\
    \ == 0\n    break if num == 1\n    break if num == -1\n    break if num == 0\n\
    \    break if num == 1\n    break if num == -1\n    break if num == 0\n    break\
    \ if num == 1\n    break if num == -1\n    break if num == 0\n    break if num\
    \ == 1\n    break if num == -1\n    break if num == 0\n    break if num == 1\n\
    \    break if num == -1\n    break if num == 0\n    break if num == 1\n    break\
    \ if num == -1\n    break if num == 0\n    break if num == 1\n    break if num\
    \ == -1\n    break if num == 0\n    break if num == 1\n    break if num == -1\n\
    \    break if num == 0\n    break if num == 1\n    break if num == -1\n    break\
    \ if num == 0\n    break if num == 1\n    break if num == -1\n    break if num\
    \ == 0\n    break if num == 1\n    break if num == -1\n    break if num == 0\n\
    \    break if num == 1\n    break if num == -1\n    break if num == 0\n    break\
    \ if num == 1\n    break if num == -1\n    break if num == 0\n    break if num\
    \ == 1\n    break if num == -1\n    break if num == 0\n    break if num == 1\n\
    \    break if num == -1\n    break if num == 0\n    break if num == 1\n    break\
    \ if num == -1\n    break if num == 0\n    break if num == 1\n    break if num\
    \ == -1\n    break if num == 0\n    break if num == 1\n    break if num == -1\n\
    \    break if num == 0\n    break if num == 1\n    break if num == -1\n    break\
    \ if num == 0\n    break if num == 1\n    break if num == -1\n    break if num\
    \ == 0\n    break if num == 1\n    break if num == -1\n    break if num == 0\n\
    \    break if num", "  nums.sort!\n  nums.reverse!\n  nums.map! {|n| n.to_i}\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    sum = 0\n\
    \    while n > 0 do\n      sum += n % 10\n      n /= 10\n    end\n    sum\n  end\n\
    end", "  nums.sort!\n  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    if digits >\
    \ nums[i]\n      nums[i], nums[i] = nums[i], nums[i]\n    end\n  end\n  nums\n\
    end\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't work if\
    \ there are two or more numbers with the same sum of digits. For example, `order_by_points.call([-12,\
    \ -12, -12, -12, -12])` returns `[-12, -12, -12, -12, -12]`.\n<|/ c |>\n<| c |>\n\
    I see your point. I've updated my answer to account for that.\n<|/ c |>\n<| a\
    \ dscore=2 |>\nHere's a solution that uses Array#<=> and Array#sort_by:\n<code>",
  "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n    break if nums.sum\
    \ != i\n    nums.delete_at(i)\n    nums.unshift(n)\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |num, i|\n    nums[i] = num if num.zero?\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do\
    \ |n, i|\n    break if nums.sum - n < 0\n    nums[i] = n\n  end\nend\n</code>\n\
    <|/ a tags=ruby,sorting,arrays |>\n<| c |>\nI like this solution, but I wonder\
    \ if there is a way to do it without using each_with_index?\n<|/ c |>\n<| c |>\n\
    I added a solution without `each_with_index`\n<|/ c |>\n<| c |>\nI like your solution,\
    \ thank you! I wonder if there is a way to do it without using each_with_index?\
    \ I guess there is, but I haven't been able to figure it out.\n<|/ c |>\n<| c\
    \ |>\nI added a solution without `each_with_index`\n<|/ c |>\n<| c |>\nI like\
    \ your solution, thank you! I wonder if there is a way to do it without using\
    \ each_with_index? I guess there is, but I haven't been able to figure it out.\n\
    <|/ c |>\n<| a |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend\n\
    </code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nI like your solution, but\
    \ I believe it can be improved. `nums.sort!` sorts the array in-place, which is\
    \ unnecessary since you immediately call `nums.reverse!`. Also, `nums.each_with_index\
    \ do |n, i|` can be replaced with `nums.each_with_index { |n, i| break if nums[i]\
    \ == n }`.\n<|/ c |>\n<| c |>\n, thanks for your comment. I think `nums.sort!`\
    \ sorts the array in-place because `nums` is modified in-place. `nums.reverse!`\
    \ reverses the array in-place because `nums` is modified in-place. `nums.each_with_index\
    \ { |n, i| break if nums[i] == n }` can be replaced with `nums.each_with_index\
    \ { |n, i| break if nums[i] == n }`. `nums.sort!` sorts the array in-place because\
    \ `nums` is modified in-place. `nums.reverse!` reverses the array in-place because\
    \ `nums` is modified in-place. `nums.each_with_index { |n, i| break if nums[i]\
    \ == n }` can be replaced with `nums.each_with_index { |n, i| break if nums[i]\
    \ == n }`.\n<|/ c |>\n<| c |>\n, thanks for your comment. I think `nums.sort!`\
    \ sorts the array in-place because `nums` is modified in-place. `nums.reverse!`\
    \ reverses the array in-place because `nums` is modified in-place. `nums.each_with_index\
    \ { |n, i| break if nums[i] == n }` can be replaced with `nums.each_with_index\
    \ { |n, i| break if nums[i] == n }`. `nums.sort!` sorts the array in-place because\
    \ `nums` is modified in-place. `nums.reverse!` reverses the array in-place because\
    \ `nums` is modified in-place. `nums.each_with_index { |n, i| break if nums[i]\
    \ == n }` can be replaced with `nums.each_with_index { |n, i| break if nums[i]\
    \ == n }`.\n<|/ c |>\n<| c |>\n, thanks for ", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\n  nums\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if there are\
    \ multiple items with the same sum.\n<|/ c |>\n<| c |>\n: I agree, thanks for\
    \ pointing that out. I've updated my answer to include a note about that.\n<|/\
    \ c |>\n<| c |>\n: I've updated my answer to include a solution that doesn't require\
    \ sorting the list twice.\n<|/ c |>\n<| c |>\n: I've updated my answer to include\
    \ a solution that doesn't require sorting the list twice.\n<|/ c |>\n<| c |>\n\
    : I've updated my answer to include a solution that doesn't require sorting the\
    \ list twice.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |n, i|\n    break if nums[i] == n\n\
    \    nums[i] = n\n  end\n  nums\nend", "  nums.sort! do |a, b|\n    sum1 = a +\
    \ b\n    sum2 = b + a\n    if sum1 == sum2\n      a\n    else\n      a <=> b\n\
    \    end\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n\
    \    digits = num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    if digits > num\n      nums.delete(num)\n     \
    \ nums.insert(num, num)\n    end\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are multiple items with the same sum.\n\
    <|/ c |>\n<| c |>\nYes, I agree with you. My solution doesn't work when there\
    \ are multiple items with the same sum.\n<|/ c |>\n<| c |>\nI added a solution\
    \ that works with multiple items with the same sum.\n<|/ c |>\n<| c |>\nI added\
    \ a solution that works with multiple items with the same sum.\n<|/ c |>\n<| a\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break\
    \ if num == 0 || num == -1\n    break if num == nums.max\n    nums.delete(num)\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n \
    \   break if nums.sum == num\n    nums.delete(num)\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.map { |n| n.to_i }\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    sum = 0\n    digits = num.to_s.split(//).map { |d|\
    \ d.to_i }\n    digits.each do |d|\n      sum += d\n    end\n    if sum > 0\n\
    \      nums.insert(nums.index(num), num)\n    end\n  end\n  nums\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n  nums.each_with_index\
    \ do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    if digits == 0\n      nums[i] = n\n    end\n  end\n\
    \  nums\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer. Your\
    \ solution works well for small lists, but for large lists it takes too long to\
    \ finish.\n<|/ c |>\n<| c |>\nYes, I tested it on large lists and it took about\
    \ a minute to sort a list with 10000 elements. I guess it depends on the number\
    \ of elements in the list. Do you really need to sort a list with 10000 elements?\n\
    <|/ c |>\n<| c |>\nYes, I need to sort a list with 10000 elements. I guess it\
    \ depends on the number of elements in the list. Do you really need to sort a\
    \ list with 10000 elements?\n<|/ c |>\n<| c |>\nI updated my answer to include\
    \ a solution that sorts 10000 elements in a fraction of a second. Hope it helps.\n\
    <|/ c |>\n<| c |>\nThanks for your answer. Your solution works well for small\
    \ lists, but for large lists it takes too long to finish.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    break if\
    \ n.to_s.chars.map(&:to_i).inject(:+) == n\n    break if n.to_s.chars.map(&:to_i).inject(:+)\
    \ == n\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums.sum - n < 0\n    nums[i], nums[nums.sum - n] =\
    \ nums[nums.sum - n], nums[i]\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums.sum - n < 0\n    nums[i]\
    \ = n\n  end\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.map { |n| n.to_s.split('').map(&:to_i).reduce(:+) }\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.split(//).map(&:to_i)\n\
    \    digits.each do |digit|\n      nums.delete_at(nums.index(num) if num == digit)\n\
    \    end\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do\
    \ |num|\n    break if num.zero?\n    break if num.odd?\n    break if num.zero?\n\
    \    break if num.even?\n    break if num.zero?\n    break if num.odd?\n    break\
    \ if num.zero?\n    break if num.even?\n    break if num.zero?\n    break if num.odd?\n\
    \    break if num.zero?\n    break if num.even?\n    break if num.zero?\n    break\
    \ if num.odd?\n    break if num.zero?\n    break if num.even?\n    break if num.zero?\n\
    \    break if num.odd?\n    break if num.zero?\n    break if num.even?\n    break\
    \ if num.zero?\n    break if num.odd?\n    break if num.zero?\n    break if num.even?\n\
    \    break if num.zero?\n    break if num.odd?\n    break if num.zero?\n    break\
    \ if num.even?\n    break if num.zero?\n    break if num.odd?\n    break if num.zero?\n\
    \    break if num.even?\n    break if num.zero?\n    break if num.odd?\n    break\
    \ if num.zero?\n    break if num.even?\n    break if num.zero?\n    break if num.odd?\n\
    \    break if num.zero?\n    break if num.even?\n    break if num.zero?\n    break\
    \ if num.odd?\n    break if num.zero?\n    break if num.even?\n    break if num.zero?\n\
    \    break if num.odd?\n    break if num.zero?\n    break if num.even?\n    break\
    \ if num.zero?\n    break if num.odd?\n    break if num.zero?\n    break if num.even?\n\
    \    break if num.zero?\n    break if num.odd?\n    break if num.zero?\n    break\
    \ if num.even?\n    break if num.zero?\n    break if num.odd?\n    break if num.zero?\n\
    \    break if num.even?\n    break if num.zero?\n    break if num", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    break if nums.sum == num\n    nums.delete(num)\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n \
    \   digits = num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = ", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't\
    \ work if there are two numbers with the same sum.\n<|/ c |>\n<| c |>\nYes, you\
    \ are right. I missed that case. Thanks for pointing out. I've updated my answer.\n\
    <|/ c |>\n<| a |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_s\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n \
    \   if digits == nums.sum\n      nums.swap(i, nums.length - i - 1)\n    end\n\
    \  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis\
    \ doesn't work for `order_by_points.call([-4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,\
    \ -4, -4, -4, -4, -", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n \
    \   break if nums.sum.to_s == num.to_s\n    nums.delete_at(nums.index(num))\n\
    \  end\n  nums\nend\n</code>\n<|/ a |>\n<| c |>\nThis solution doesn't work if\
    \ there are multiple items with the same sum.\n<|/ c |>\n<| c |>\nYes, it does.\
    \ I added a note to the answer.\n<|/ c |>\n<| c |>\nI added a solution that doesn't\
    \ require sorting the list twice.\n<|/ c |>\n<| c |>\nI added a solution that\
    \ doesn't require sorting the list twice.\n<|/ c |>\n<| a tags=ruby,sorting,arrays\
    \ |>\nHere's a solution using Array#sort_by:\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    next if nums.count(n) == 1\n    digits\
    \ = nums.map { |m| m.to_i }\n    digits[i] = n\n    nums = digits.sort\n  end\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.chars.map(&:to_i)\n\
    \    digits.each_with_index do |digit, index|\n      nums[index] = digit if digit\
    \ > nums[index]\n    end\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are two or more numbers with the same\
    \ sum.\n<|/ c |>\n<| c |>\n, thanks for pointing out. I've fixed the code accordingly.\n\
    <|/ c |>\n<| c |>\n, thanks for pointing out. I've fixed the code accordingly.\n\
    <|/ c |>\n<| c |>\n, thanks for pointing out. I've fixed the code accordingly.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  nums.sort!\n  nums.map { |n| n.to_i }.sort_by\
    \ { |n| n.reduce(:+) }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n\
    \    n.to_s.split('').sort.reverse!\n  end\n  nums\nend", "  nums.sort!\n  nums.map\
    \ { |n| n.to_i }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    if i == 0 || digits < nums[i-1].to_s.chars.map(&:to_i).inject(:+).abs\n\
    \      nums.swap(i, 1)\n    end\n  end\n  nums\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |num, i|\n    break if num == nums[i]\n    nums[i] = num\n  end\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break if nums.sum\
    \ == num\n    nums.delete(num)\n  end\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    digits = num.to_s.chars.map(&:to_i)\n    digits.inject(0)\
    \ do |sum, digit|\n      sum + digit\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nI like this solution. One thing I noticed is that it sorts numbers\
    \ with same sum as if they were in reverse order. For example: order_by_points.call([-12,\
    \ -11, -1, 1, 11]) returns [-12, -11, -1, 1, 11]. Is there a way to fix this?\n\
    <|/ c |>\n<| c |>\nYes, just add `nums.reverse!` before `nums.sort!`\n<|/ c |>\n\
    <| a dscore=1 |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break if\
    \ num.zero?\n    break if num.negative?\n    break if num.zero? || num.odd?\n\
    \    break if num.zero? || num.even?\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis\
    \ doesn't work for me. `order_by_points.call([-12, -11, -10, -9, -8, -7, -6, -5,\
    \ -4, -3, -2, -1, 0])` returns `[-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, -12,\
    \ -11]`\n<|/ c |>\n<| c |>\nI tested it on ruby 2.4.1 and it works. What version\
    \ of ruby are you using?\n<|/ c |>\n<| c |>\nI'm using ruby 2.4.1p111\n<|/ c |>\n\
    <| c |>\nI tested it on ruby 2.4.0 and it works. What version of ruby are you\
    \ using?\n<|/ c |>\n<| c |>\nI'm using ruby 2.4.1p111. I tested it on ruby 2.4.0\
    \ and it works. What version of ruby are you using?\n<|/ c |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.map! {|n| n.to_i}\n  nums\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
