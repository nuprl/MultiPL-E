name: HumanEval_145_order_by_points
language: rb
prompt: "# Write a function which sorts the given list of integers\n# in ascending\
  \ order according to the sum of their digits.\n# Note: if there are several items\
  \ with similar sum of their digits,\n# order them based on their index in original\
  \ list.\n# For example:\n# >>> order_by_points.call([1, 11, -1, -11, -12])\n# [-1,\
  \ -11, 1, -12, 11]\n# >>> order_by_points.call([])\n# []\ndef order_by_points(nums)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_order_by_points\n\
  \    candidate = method(:order_by_points)\n    assert_equal([-1, -11, 1, -12, 11],\
  \ candidate.call([1, 11, -1, -11, -12]))\n    assert_equal([0, 2, 3, 6, 53, 423,\
  \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145,\
  \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32,\
  \ 43, 54, -98, 2, -3]))\n    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    assert_equal([-76, -21, 0, 4, 23, 6, 6],\
  \ candidate.call([0, 6, 6, -76, -21, 23, 4]))\n  end\nend\n"
completions: ["  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_s }\nend", " \
    \ nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    sum = 0\n    digits =\
    \ num.to_s.chars.map(&:to_i)\n    digits.each do |digit|\n      sum += digit\n\
    \    end\n    if sum > 0\n      nums.insert(nums.index(num), num)\n    end\n \
    \ end\n  nums\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if\
    \ the list contains negative numbers. Try `order_by_points.call([-1, -10, -20,\
    \ -30])`\n<|/ c |>\n<| c |>\nI added a note about this to the answer.\n<|/ c |>\n\
    <| c |>\nI added a note about this to the answer.\n<|/ c |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums.sum != i\n    nums.delete_at(i)\n    nums.unshift(n)\n  end\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i }\nend",
  "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i) }.values.map {\
    \ |nums| nums.sort }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n\
    \    sum = 0\n    n.to_s.split('').each do |c|\n      sum += c.to_i\n    end\n\
    \    n.to_s.split('').each do |c|\n      sum -= c.to_i\n    end\n    if sum ==\
    \ 0\n      nums.unshift(n)\n    end\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    n.to_s.split('').sort.reverse!\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num, index|\n    nums[index]\
    \ = num if num.digits.sum < nums[index].digits.sum\n  end\n  nums\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks for your answer. Your solution is very elegant\
    \ and works perfectly for my case. Thanks again!\n<|/ c |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break\
    \ if num.zero?\n    break if num.negative?\n    break if num.zero? && num.negative?\n\
    \  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis\
    \ doesn't work for negative numbers. Try `order_by_points.call([-1, -10, -20,\
    \ -30])`.\n<|/ c |>\n<| c |>\n: I agree, thanks for pointing that out. I've updated\
    \ my answer to account for negative numbers.\n<|/ c |>\n<| c |>\nI believe that\
    \ `nums.sort!` should be `nums.sort`. `sort!` modifies the array in place and\
    \ returns the sorted array. `sort` returns a new array with the sorted elements.\n\
    <|/ c |>\n<| c |>\n: You're right. I've updated my answer to reflect your suggestion.\n\
    <|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    n.to_s.split('').sort.reverse!\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n \
    \   break if num == -1\n    break if num == -num\n    break if num == num\n  end\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits\
    \ = num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+) if digits.empty?\n\
    \    digits = digits.sort_by(&:last)\n    digits = digits.reverse\n    nums.insert(nums.index(num),\
    \ digits)\n  end\n  nums\nend", "  nums.sort! do |a, b|\n    digits = a.to_s.chars.map(&:to_i).zip(b.to_s.chars.map(&:to_i)).map\
    \ { |x, y| x + y }\n    digits.max <=> digits.min\n  end\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    break if num.zero?\n    break if num.odd?\n\
    \    break if num.zero? || num.even?\n    break if num.zero? || num.odd? || num.even?\n\
    \    break if num.zero? || num.even? || num.odd?\n    break if num.zero? || num.odd?\
    \ || num.even? || num.zero?\n    break if num.zero? || num.even? || num.odd? ||\
    \ num.zero? || num.even?\n    break if num.zero? || num.even? || num.odd? || num.zero?\
    \ || num.even? || num.zero?\n    break if num.zero? || num.even? || num.odd? ||\
    \ num.zero? || num.even? || num.zero? || num.odd?\n    break if num.zero? || num.even?\
    \ || num.odd? || num.zero? || num.even? || num.zero? || num.odd? || num.zero?\n\
    \    break if num.zero? || num.even? || num.odd? || num.zero? || num.even? ||\
    \ num.zero? || num.odd? || num.zero? || num.even?\n    break if num.zero? || num.even?\
    \ || num.odd? || num.zero? || num.even? || num.zero? || num.odd? || num.zero?\
    \ || num.even? || num.zero?\n    break if num.zero? || num.even? || num.odd? ||\
    \ num.zero? || num.even? || num.zero? || num.odd? || num.zero? || num.even? ||\
    \ num.zero? || num.odd?\n    break if num.zero? || num.even? || num.odd? || num.zero?\
    \ || num.even? || num.zero? || num.odd? || num.zero? || num.even? || num.zero?\
    \ || num.odd? || num.zero?\n    break if num.zero? || num.even? || num.odd? ||\
    \ num.zero? || num.even? || num.zero? || num.odd? || num.", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_s\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.map! {|n| n.to_i}\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n    break\
    \ if nums[i] == n\n    nums[i] = n\n  end\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    if digits > nums[i]\n      nums[i], nums[i]\
    \ = nums[i], nums[i]\n    end\n  end\n  nums\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This doesn't work. Try `order_by_points.call([-12, -11, -10, -9, -8, -7, -6, -5,\
    \ -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9])`\n<|/ c |>\n<| c |>\n: I see\
    \ what you mean. I've updated the answer to handle negative numbers as well.\n\
    <|/ c |>\n<| c |>\nI believe this fails for `order_by_points.call([-12, -11, -10,\
    \ -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9])`\n<|/ c |>\n\
    <| c |>\n: I see what you mean. I've updated the answer to handle negative numbers\
    \ as well.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
