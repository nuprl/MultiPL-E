name: HumanEval_44_change_base
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Change numerical base of input number x to base.\n    // return string representation\
  \ after the conversion.\n    // base numbers are less than 10.\n    // >>> changeBase((8l),\
  \ (3l))\n    // (\"22\")\n    // >>> changeBase((8l), (2l))\n    // (\"1000\")\n\
  \    // >>> changeBase((7l), (2l))\n    // (\"111\")\n    def changeBase(x : Long,\
  \ base : Long) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(changeBase((8l),\
  \ (3l)).equals((\"22\")));\n    assert(changeBase((9l), (3l)).equals((\"100\")));\n\
  \    assert(changeBase((234l), (2l)).equals((\"11101010\")));\n    assert(changeBase((16l),\
  \ (2l)).equals((\"10000\")));\n    assert(changeBase((8l), (2l)).equals((\"1000\"\
  )));\n    assert(changeBase((7l), (2l)).equals((\"111\")));\n    assert(changeBase((2l),\
  \ (3l)).equals((\"2\")));\n    assert(changeBase((3l), (4l)).equals((\"3\")));\n\
  \    assert(changeBase((4l), (5l)).equals((\"4\")));\n    assert(changeBase((5l),\
  \ (6l)).equals((\"5\")));\n    assert(changeBase((6l), (7l)).equals((\"6\")));\n\
  \    assert(changeBase((7l), (8l)).equals((\"7\")));\n    }\n\n}\n"
completions: ["        val digits = x.toString.reverse.grouped(base.toInt).map(_.mkString).reverse\n\
    \        val result = digits.mkString(\"\")\n        val baseString = if (base\
    \ < 10) \"0\" + base.toString else base.toString\n        result", "        val\
    \ digits = x.toString.reverse.grouped(base.toInt).map(_.mkString).reverse\n  \
    \      val result = digits.mkString(\"\")\n        result + (if (digits.size ==\
    \ base.toInt) \"\" else s\"0\" * (base - digits.size))", "        val digits =\
    \ x.toString.reverse.grouped(base.toInt).map(_.mkString).reverse\n        val\
    \ result = digits.mkString(\"\")\n        val baseString = base.toString.reverse\n\
    \        val digitString = digits.mkString(\"\")\n        val result = baseString\
    \ + digitString\n        result", "        val digits = x.toString.reverse.grouped(base.toInt).map(_.mkString).reverse\n\
    \        val result = digits.mkString(\"\")\n        result + (if (digits.size\
    \ == base.toInt) \"\" else base.toString.toUpperCase)", "        val digits =\
    \ x.toString.reverse.grouped(base.toInt).map(_.mkString).reverse\n        val\
    \ result = if (digits.isEmpty) \"\" else digits.head\n        result + (if (digits.tail.isEmpty)\
    \ \"\" else digits.tail.mkString(\"\"))", "        val baseDigits = base.toString.length\n\
    \        val digits = x.toString.length\n        val result = new StringBuilder(digits)\n\
    \        var i = 0\n        while (i < digits) {\n            val digit = x.toString.charAt(i)\n\
    \            val baseDigit = digit.charAt(0)\n            val newDigit = digit.charAt(digits.length\
    \ - 1)\n            val newBaseDigit = digit.charAt(digits.length - 2)\n     \
    \       if (baseDigit == newBaseDigit) {\n                result.append(newDigit)\n\
    \            } else {\n                val baseDigitIndex = baseDigits.toString.indexOf(newBaseDigit)\n\
    \                result.append(baseDigitIndex.toString.toInt)\n              \
    \  result.append(newDigit)\n            }\n            i += 1\n        }\n   \
    \     return result.toString", "        val str = x.toString.reverse\n       \
    \ val baseStr = str.toCharArray.takeWhile(c => c != '0').mkString\n        val\
    \ baseInt = base.toCharArray.map(c => c - '0').sum\n        val baseIntStr = (baseInt\
    \ / base).toString.reverse\n        val baseStrInt = baseStr.toCharArray.map(c\
    \ => c - '0').sum\n        val baseStrIntStr = (baseStrInt / base).toString.reverse\n\
    \        val baseStrIntStrStr = (baseStrIntStr / base).toString.reverse\n    \
    \    val baseStrIntStrStrStr = (baseStrIntStrStr / base).toString.reverse\n  \
    \      val baseStrIntStrStrStrStr = (baseStrIntStrStrStr / base).toString.reverse\n\
    \        val baseStrIntStrStrStrStrStr = (baseStrIntStrStrStrStrStr / base).toString.reverse\n\
    \        val baseStrIntStrStrStrStrStrStr = (baseStrIntStrStrStrStrStrStrStr /\
    \ base).toString.reverse\n        val baseStrIntStrStrStrStrStrStrStrStr = (baseStrIntStrStrStrStrStrStrStrStrStr\
    \ / base).toString.reverse\n        val baseStrIntStrStrStrStrStrStrStrStrStr\
    \ = (baseStrIntStrStrStrStrStrStrStrStrStrStrStr / base).toString.reverse\n  \
    \      val baseStrIntStrStrStrStrStrStrStrStrStrStrStrStr = (baseStrIntStrStrStrStrStrStrStrStrStrStrStrStrStr\
    \ / base).toString.reverse\n        val baseStrIntStrStrStrStrStrStrStrStrStrStrStrStrStrStr\
    \ = (baseStrIntStrStrStrStrStrStrStrStrStrStrStrStrStrStrStr / base).toString.reverse\n\
    \        val baseStrIntStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStr = (baseStrIntStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStr\
    \ / base).toString.reverse\n        val baseStrIntStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStr\
    \ = (baseStrIntStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStr\
    \ / base).toString.reverse\n        val baseStrIntStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStrStr\
    \ = (baseStrIntStrStrStrStrStrStrStrStrStrStrStrStrStrStr", "        var result\
    \ = \"\"\n        var remainder = x % base\n        var quotient = x / base\n\
    \        while (quotient > 0) {\n            result += quotient.toString.charAt(0)\n\
    \            quotient = quotient / base\n        }\n        if (remainder > 0)\
    \ {\n            result += remainder.toString.charAt(0)\n        }\n        return\
    \ result", "        val digits = x.toString.reverse.grouped(base.toInt).map(_.mkString).reverse\n\
    \        val result = digits.mkString(\"\")\n        result + (if (digits.size\
    \ == 1) \"0\" else \"\")", "        val digits = x.toString.reverse.grouped(base.toInt).map(_.toString.reverse).mkString\n\
    \        val result = if (digits.isEmpty) \"\" else digits.reverse.mkString(\"\
    \")\n        result", "        val digits = x.toString.reverse.grouped(base.toInt)\n\
    \        val result = digits.map(_.reverse).mkString(\"\")\n        result", " \
    \       val bases = List(\"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\"\
    , \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\"\
    , \"27\", \"28\", \"29\", \"30\", \"31\")\n        val digits = List(\"0\", \"\
    1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\")\n        val digitBase\
    \ = bases.zip(digits).map(x => x._1 -> x._2)\n        val digitBase2 = digitBase.map(x\
    \ => x._1 -> x._2.toLong)\n        val digitBase3 = digitBase2.map(x => x._1 ->\
    \ x._2.toLong)\n        val digitBase4 = digitBase3.map(x => x._1 -> x._2.toLong)\n\
    \        val digitBase5 = digitBase4.map(x => x._1 -> x._2.toLong)\n        val\
    \ digitBase6 = digitBase5.map(x => x._1 -> x._2.toLong)\n        val digitBase7\
    \ = digitBase6.map(x => x._1 -> x._2.toLong)\n        val digitBase8 = digitBase7.map(x\
    \ => x._1 -> x._2.toLong)\n        val digitBase9 = digitBase8.map(x => x._1 ->\
    \ x._2.toLong)\n        val digitBase10 = digitBase9.map(x => x._1 -> x._2.toLong)\n\
    \        val digitBase11 = digitBase10.map(x => x._1 -> x._2.toLong)\n       \
    \ val digitBase12 = digitBase11.map(x => x._1 -> x._2.toLong)\n        val digitBase13\
    \ = digitBase12.map(x => x._1 -> x._2.toLong)\n        val digitBase14 = digitBase13.map(x\
    \ => x._1 -> x._2.toLong)\n        val digitBase15 = digitBase14.map(x => x._1\
    \ -> x._2.toLong)\n        val digitBase16 = digitBase15.map(x => x._1 -> x._2.toLong)\n\
    \        val digitBase17 = digitBase16.map(x => x._1 -> x._2.toLong)\n       \
    \ val digitBase18 = digitBase17.map(x => x._1 -> x._2.toLong)\n        val digitBase19\
    \ = digitBase18.map(x => x._1 -> x._2.toLong)\n        val digitBase20 = digitBase19.map(x\
    \ => x._1 ", "        val digits = x.toString.reverse.grouped(base.toInt).map(_.mkString).reverse\n\
    \        val result = if (digits.isEmpty) \"\" else digits.head\n        result\
    \ + (if (digits.tail.isEmpty) \"\" else digits.tail.mkString(\"\"))", "      \
    \  val digits = x.toString.reverse.grouped(base.toInt).map(_.mkString).reverse\n\
    \        val result = if (digits.isEmpty) \"\" else digits.head\n        result\
    \ + digits.tail.foldLeft(\"\") { (result, digit) => digit + result }", "     \
    \   val digits = x.toString.reverse.grouped(base.toInt).map(_.toString.reverse).mkString\n\
    \        val result = digits reverse\n        result + (if (digits.isEmpty) \"\
    \" else \"0\" * (base - digits.length))", "        val digits = x.toString.reverse.grouped(base.toInt).map(_.mkString).reverse\n\
    \        val result = digits.mkString(\"\")\n        result + (if (digits.size\
    \ == base.toInt) \"\" else (base.toInt - digits.size)*base)", "        val bases\
    \ = List(\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"\
    )\n        val digits = x.toString.reverse.grouped(base.toInt).map(_.mkString).reverse\n\
    \        val result = bases.zip(digits).map { case (base, digit) => digit + base\
    \ }\n        result.mkString(\"\")", "        val digits = x.toString.reverse.grouped(base.toInt).map(_.mkString).reverse\n\
    \        val result = digits.mkString(\"\")\n        result + (if (digits.size\
    \ == base.toInt) \"\" else s\"0\" * (base - digits.size))", "        val digits\
    \ = x.toString.reverse.grouped(base.toInt).map(_.toString.reverse).mkString\n\
    \        val result = digits + digits.dropRight(base.toInt)\n        result +\
    \ (if (digits.isEmpty) \"\" else base.toChar)", "        val digits = x.toString.reverse\n\
    \        val digitLength = digits.length\n        val baseDigits = base.toString.reverse\n\
    \        val baseDigitLength = baseDigits.length\n        val result = new StringBuilder\n\
    \        var i = 0\n        while (i < digitLength) {\n            val digit =\
    \ digits.charAt(i)\n            val baseDigit = baseDigits.charAt(i)\n       \
    \     if (digit == baseDigit) {\n                result.append(digit)\n      \
    \      } else {\n                result.append(digit)\n                result.append(baseDigit)\n\
    \            }\n            i += 1\n        }\n        return result.toString"]
stop_tokens:
- "\n    }\n"
