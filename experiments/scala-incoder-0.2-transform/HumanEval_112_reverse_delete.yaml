name: HumanEval_112_reverse_delete
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Task\n    // We are given two strings s and c, you have to deleted all the\
  \ characters in s that are equal to any character in c\n    // then check if the\
  \ result string is palindrome.\n    // A string is called palindrome if it reads\
  \ the same backward as forward.\n    // You should return a tuple containing the\
  \ result string and True/False for the check.\n    // Example\n    // >>> reverseDelete((\"\
  abcde\"), (\"ae\"))\n    // ((\"bcd\", false))\n    // >>> reverseDelete((\"abcdef\"\
  ), (\"b\"))\n    // ((\"acdef\", false))\n    // >>> reverseDelete((\"abcdedcba\"\
  ), (\"ab\"))\n    // ((\"cdedc\", true))\n    def reverseDelete(s : String, c :\
  \ String) : Tuple2[String, Boolean] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(reverseDelete((\"\
  abcde\"), (\"ae\")).equals(((\"bcd\", false))));\n    assert(reverseDelete((\"abcdef\"\
  ), (\"b\")).equals(((\"acdef\", false))));\n    assert(reverseDelete((\"abcdedcba\"\
  ), (\"ab\")).equals(((\"cdedc\", true))));\n    assert(reverseDelete((\"dwik\"),\
  \ (\"w\")).equals(((\"dik\", false))));\n    assert(reverseDelete((\"a\"), (\"a\"\
  )).equals(((\"\", true))));\n    assert(reverseDelete((\"abcdedcba\"), (\"\")).equals(((\"\
  abcdedcba\", true))));\n    assert(reverseDelete((\"abcdedcba\"), (\"v\")).equals(((\"\
  abcdedcba\", true))));\n    assert(reverseDelete((\"vabba\"), (\"v\")).equals(((\"\
  abba\", true))));\n    assert(reverseDelete((\"mamma\"), (\"mia\")).equals(((\"\"\
  , true))));\n    }\n\n}\n"
completions: ["        val result = s.reverse.filterNot(c contains _)\n        val\
    \ isPalindrome = result.equals(s.reverse)\n        (result, isPalindrome)", " \
    \       val result = s.reverse.filter( x => !c.contains(x) )\n        val isPalindrome\
    \ = result.equals(s.reverse)\n        (result, isPalindrome)", "        val resultString\
    \ = s.filterNot(c.toSet)\n        val isPalindrome = resultString == resultString.reverse\n\
    \        (resultString, isPalindrome)", "        val reverse = mutable.ListBuffer[Char]()\n\
    \        val result = mutable.ListBuffer[Char]()\n        val isPalindrome = mutable.ListBuffer[Boolean]()\n\
    \        for (i <- 0 until s.length)\n            if (s(i) == c(0))\n        \
    \        reverse.append(s(i))\n            else\n                for (j <- 0 until\
    \ s.length)\n                    if (s(i) == c(j))\n                        reverse.append(s(i))\n\
    \                    else\n                        if (s(i) != c(j))\n       \
    \                     isPalindrome.append(false)\n                        else\n\
    \                            isPalindrome.append(true)\n        for (i <- 0 until\
    \ reverse.length)\n            if (reverse(i) == s(0))\n                result.append((reverse(i),\
    \ isPalindrome(i)))\n            else\n                for (j <- 0 until reverse.length)\n\
    \                    if (reverse(i) == s(j))\n                        result.append((reverse(i),\
    \ isPalindrome(i)))\n                    else\n                        if (reverse(i)\
    \ != s(j))\n                            isPalindrome.append(false)\n         \
    \               else\n                            isPalindrome.append(true)\n\
    \        result.takeWhile(x => x._2).reverse", "        val result = s.filterNot(c.toSet).reverse.mkString\n\
    \        (result, s.equals(result))", "        val result = s.filterNot(c.contains)\n\
    \        val isPalindrome = result.equals(s.reverse)\n        (result, isPalindrome)",
  "        val result = s.filterNot(c.contains)\n        val reverseResult = result.reverse\n\
    \        val isPalindrome = reverseResult == result\n        (result, reverseResult)",
  "        val sArray = s.toCharArray\n        val cArray = c.toCharArray\n      \
    \  val result = new StringBuilder(s.length)\n        var i = 0\n        var j\
    \ = 0\n        while (i < sArray.length && j < cArray.length) {\n            if\
    \ (sArray(i) == cArray(j)) {\n                i += 1\n                j += 1\n\
    \            } else {\n                if (i < sArray.length) {\n            \
    \        result.append(sArray(i))\n                    i += 1\n              \
    \  }\n                if (j < cArray.length) {\n                    result.append(cArray(j))\n\
    \                    j += 1\n                }\n            }\n        }\n   \
    \     if (i == sArray.length) {\n            val reverseString = result.toString\n\
    \            val isPalindrome = reverseString.reverse == reverseString\n     \
    \       val tuple = reverseString -> isPalindrome\n            return tuple\n\
    \        } else {\n            val reverseString = result.toString\n         \
    \   val isPalindrome = reverseString.reverse == reverseString\n            val\
    \ tuple = reverseString -> isPalindrome\n            return tuple\n        }",
  "        val result = s.filterNot(c.contains)\n        val isPalindrome = result\
    \ == s.reverse\n        (result, isPalindrome)", "        val result = new StringBuilder\n\
    \        val deleted = new mutable.HashSet[Char](c)\n        for(i <- 0 until\
    \ s.length){\n            if(deleted.contains(s.charAt(i))){\n               \
    \ deleted.remove(s.charAt(i))\n            }\n            result.append(s.charAt(i))\n\
    \        }\n        if(deleted.isEmpty){\n            (result.toString(), true)\n\
    \        }else{\n            (result.toString(), false)\n        }", "       \
    \ val sArr = s.toCharArray\n        val cArr = c.toCharArray\n        val sLen\
    \ = sArr.length\n        val cLen = cArr.length\n        val resultStr = new StringBuilder(sLen)\n\
    \        val resultBool = new Boolean(sLen)\n        val resultChar = new Char(sLen)\n\
    \        val resultCharArray = new Array[Char](sLen)\n        val resultCharArray2\
    \ = new Array[Char](sLen)\n        val resultCharArray3 = new Array[Char](sLen)\n\
    \        val resultCharArray4 = new Array[Char](sLen)\n        val resultCharArray5\
    \ = new Array[Char](sLen)\n        val resultCharArray6 = new Array[Char](sLen)\n\
    \        val resultCharArray7 = new Array[Char](sLen)\n        val resultCharArray8\
    \ = new Array[Char](sLen)\n        val resultCharArray9 = new Array[Char](sLen)\n\
    \        val resultCharArray10 = new Array[Char](sLen)\n        val resultCharArray11\
    \ = new Array[Char](sLen)\n        val resultCharArray12 = new Array[Char](sLen)\n\
    \        val resultCharArray13 = new Array[Char](sLen)\n        val resultCharArray14\
    \ = new Array[Char](sLen)\n        val resultCharArray15 = new Array[Char](sLen)\n\
    \        val resultCharArray16 = new Array[Char](sLen)\n        val resultCharArray17\
    \ = new Array[Char](sLen)\n        val resultCharArray18 = new Array[Char](sLen)\n\
    \        val resultCharArray19 = new Array[Char](sLen)\n        val resultCharArray20\
    \ = new Array[Char](sLen)\n        val resultCharArray21 = new Array[Char](sLen)\n\
    \        val resultCharArray22 = new Array[Char](sLen)\n        val resultCharArray23\
    \ = new Array[Char](sLen)\n        val resultCharArray24 = new Array[Char](sLen)\n\
    \        val resultCharArray25 = new Array[Char](sLen)\n        val resultCharArray26\
    \ = new Array[Char](sLen)\n        val resultCharArray27 = new Array[Char](sLen)\n\
    \        val resultCharArray28 = new Array[Char](sLen)\n        val resultCharArray29\
    \ = new Array[Char](sLen)\n        val resultCharArray30 = new ", "        val\
    \ result = new mutable.ListBuffer[String]()\n        val charSet = c.toSet\n \
    \       for(i <- 0 until s.length){\n            val char = s(i)\n           \
    \ if(charSet.contains(char)){\n                result += char\n            }\n\
    \        }\n        if(result.size == s.length){\n            val reverse = result.reverse\n\
    \            val equal = reverse == s\n            (reverse, equal)\n        }\n\
    \        else {\n            (\"\", false)\n        }", "        val result =\
    \ s.reverse.filter( x => !c.contains(x))\n        val isPalindrome = result.equals(s.reverse)\n\
    \        (result, isPalindrome)", "        val result = s.reverse.filter( x =>\
    \ x != c ).reverse\n        val isPalindrome = result == s\n        (result, isPalindrome)",
  "        val result = s.filterNot(c.toSet).reverse\n        val isPalindrome = result.equals(s.reverse)\n\
    \        (result, isPalindrome)", "        val sArr = s.toCharArray\n        val\
    \ cArr = c.toCharArray\n        val sLen = s.length\n        val cLen = c.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var resultString\
    \ = \"\"\n        var isPalindrome = true\n        while(i < sLen && j < cLen)\
    \ {\n            if(sArr(i) == cArr(j)) {\n                i += 1\n          \
    \      j += 1\n                k += 1\n            }\n            else {\n   \
    \             resultString += sArr(i)\n                i += 1\n              \
    \  k += 1\n            }\n        }\n        if(k == cLen) {\n            isPalindrome\
    \ = false\n        }\n        else {\n            resultString += sArr(i)\n  \
    \      }\n        val resultTuple = resultString.toString.reverse, isPalindrome\n\
    \        return resultTuple", "        val newS = s.filterNot(c.contains)\n  \
    \      val newC = c.filterNot(s.contains)\n        (newS, newC == newS)", "  \
    \      val result = s.reverse.filter( x => !c.contains(x))\n        (result, s.equals(result.reverse))",
  "        val result = s.reverse.filter( x => !c.contains(x) )\n        val isPalindrome\
    \ = result.equals(s.reverse)\n        (result, isPalindrome)", "        var result\
    \ = \"\"\n        var isPalindrome = true\n        for (i <- 0 until s.length\
    \ - 1) {\n            if (s(i) != c(s.length - 1 - i)) {\n                result\
    \ += s(i)\n            } else {\n                isPalindrome = false\n      \
    \      }\n        }\n        if (result == s) {\n            (result, isPalindrome)\n\
    \        } else {\n            (result, isPalindrome)\n        }"]
stop_tokens:
- "\n    }\n"
