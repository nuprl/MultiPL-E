name: HumanEval_131_digits
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, return the product of the odd digits.\n    //\
  \ Return 0 if all digits are even.\n    // For example:\n    // >>> digits((1l))\n\
  \    // (1l)\n    // >>> digits((4l))\n    // (0l)\n    // >>> digits((235l))\n\
  \    // (15l)\n    def digits(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(digits((5l)) == (5l));\n\
  \    assert(digits((54l)) == (5l));\n    assert(digits((120l)) == (1l));\n    assert(digits((5014l))\
  \ == (5l));\n    assert(digits((98765l)) == (315l));\n    assert(digits((5576543l))\
  \ == (2625l));\n    assert(digits((2468l)) == (0l));\n    }\n\n}\n"
completions: ["        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l)(_ * _)", "        val digits = mutable.ListBuffer[Long]()\n\
    \        val remainder = n % 10\n        val quotient = n / 10\n        while(quotient\
    \ > 0) {\n            digits += quotient\n            quotient = quotient / 10\n\
    \        }\n        digits += remainder\n        digits.reverse.foldLeft(1l)(_\
    \ * _)", "        val digits = n.toString.toInt\n        val odd = digits.filter(_\
    \ % 2 == 1)\n        odd.length == 0 ? 0l : odd.product", "        val digits\
    \ = mutable.ArrayBuffer.empty[Long]\n        val remainder = n % 10\n        n\
    \ /= 10\n        while(n > 0) {\n            digits += remainder\n           \
    \ remainder = n % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(0l)(_\
    \ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n \
    \       val evens = digits.filter(x => x % 2 == 0)\n        val odds = digits.filter(x\
    \ => x % 2 != 0)\n        evens.foldLeft(0l)(_ * _) + odds.foldLeft(0l)(_ * _)",
  "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(1l)((acc,\
    \ x) => acc * x)", "        val digits = mutable.ListBuffer[Long]()\n        var\
    \ product = 1\n        while (n > 0) {\n            digits += n % 10\n       \
    \     n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n     \
    \   if (digits.isEmpty) 0\n        else product", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        if (digits.forall(_.isEven)) 0 else digits.foldLeft(0l)(_ * _)", "  \
    \      val digits = mutable.ListBuffer[Long]()\n        while(n > 0) {\n     \
    \       digits.append(n % 10)\n            n /= 10\n        }\n        digits.reverse.foldLeft(0l)(_\
    \ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n  \
    \      digits.foldLeft(0l) { (acc, digit) => acc * digit }", "        var result\
    \ = 1\n        var digits = n.toString.reverse\n        while(digits.nonEmpty)\
    \ {\n            val digit = digits.head\n            digits =\n             \
    \   digits.tail\n                if (digit % 2 == 1)\n                    result\
    \ *= digit\n        }\n        result", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        val digits\
    \ = mutable.ListBuffer[Long]()\n        var product = 1\n        while(n > 0){\n\
    \            digits += n % 10\n            product *= n % 10\n            n /=\
    \ 10\n        }\n        if(digits.isEmpty) 0\n        else product", "      \
    \  val digits = n.toString.reverse.grouped(2).map(_.toInt)\n        val even =\
    \ digits.filter(_.toString.toLong % 2 == 0).length\n        val odd = digits.filter(_.toString.toLong\
    \ % 2 != 0).length\n        if (even > odd) 0\n        else digits.map(_.toString.toLong).product",
  "        var product = 0\n        var digits = n.toString.toInt\n        while(digits\
    \ > 0) {\n            product *= digits\n            digits -= 1\n        }\n\
    \        if (digits == 0) product\n        else 0", "        val digits = mutable.ListBuffer[Long]()\n\
    \        while(n > 0){\n            digits += n % 10\n            n /= 10\n  \
    \      }\n        digits.reverse.foldLeft(0l){ (acc, digit) => acc * digit }",
  "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l){\
    \ (acc, digit) => acc * digit }", "        val digits = mutable.ListBuffer[Long]()\n\
    \        val factors = mutable.ListBuffer[Long]()\n        val product = mutable.Long(1)\n\
    \        val n = n.toInt\n        val digit = n.toString.charAt(0)\n        val\
    \ factor = (digit.toLong - '0').pow(digits.length)\n        val factors = factor.until(factors.length)\n\
    \        factors.foreach(factor => digits += factor)\n        digits.foreach(digit\
    \ => product *= digit)\n        product", "        var result = 1\n        var\
    \ remainder = n\n        while (remainder > 0) {\n            result *= (remainder\
    \ % 10)\n            remainder = remainder / 10\n        }\n        if (remainder\
    \ == 0) result * 1\n        else result", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(1l) {\n            case (acc, digit) => acc * digit\n\
    \        }", "        val d = n.toString.reverse.map(_.toInt)\n        val even\
    \ = d.filter(_ % 2 == 0)\n        val odd = d.filter(_ % 2 != 0)\n        val\
    \ product = even.foldLeft(0l)(_ * _)\n        product * odd.sum", "        val\
    \ digits = n.toString.reverse.grouped(2).map(_.toLong)\n        if (digits.forall(_.isEven))\
    \ 0\n        else digits.foldLeft(1L) { (acc, digit) => acc * digit }", "    \
    \    var result : Long = 1\n        val digits = n.toString.reverse\n        for(i\
    \ <- 0 until digits.length){\n            val digit = digits(i)\n            if(digit\
    \ % 2 == 1){\n                result *= digit\n            }\n        }\n    \
    \    result", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1l) { (product, digit) => product * digit }", "     \
    \   val digits = n.toString.reverse.grouped(2).map(_.toInt)\n        val odd =\
    \ digits.filter(x => x % 2 == 1).length\n        if (odd > 0) 0l else digits.product",
  "        var sum = 0\n        var product = 1\n        var digits = n.toString.toInt\n\
    \        var evenDigits = digits % 2\n        while(digits > 0) {\n          \
    \  sum += digits(digits / 2)\n            product *= digits(digits / 2)\n    \
    \        digits /= 2\n        }\n        if(evenDigits == 0) return product\n\
    \        else return 0", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        val even = digits.filter(x => x % 2 == 0)\n        val odd = digits.filter(x\
    \ => x % 2 != 0)\n        val product = even.foldLeft(0l)(_ * _) + odd.foldLeft(0l)(_\
    \ * _)\n        if (product == 0l) 0\n        else product", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l)(_\
    \ * _)", "        var product = 0\n        val digits = n.toString.reverse\n \
    \       for(i <- 0 until digits.length)\n            if(digits(i) % 2 == 1)\n\
    \                product *= digits(i)\n        product", "        val digits =\
    \ n.toString.reverse.grouped(2).map(_.toLong)\n        digits.reduceLeft(_ * _)",
  "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n        digits.foldLeft(0l){\
    \ (sum, digit) => sum * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        val even = digits.filter(x => x % 2 == 0)\n        val odd = digits.filter(x\
    \ => x % 2 != 0)\n        if (even.isEmpty) 0\n        else even.head * odd.head",
  "        val digits = n.toString.toInt\n        val product = digits * digits *\
    \ digits\n        if (product % 2 == 0) product else 0", "        val digits =\
    \ mutable.ListBuffer.empty[Long]\n        val n = n.toInt\n        for(i <- 0\
    \ until n) {\n            digits += i.toLong\n        }\n        digits.foldLeft(1l)\
    \ {\n            case (acc, digit) => acc * digit\n        }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toInt)\n        val odd = digits.filter(x\
    \ => x % 2 == 1)\n        if (odd.isEmpty) 0\n        else odd.reduceLeft(_ *\
    \ _)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n    \
    \    digits.foldLeft(1l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(1l)((x,\
    \ y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = mutable.ListBuffer.empty[Long]\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n\
    \        product", "        val digits = mutable.ListBuffer.empty[Long]\n    \
    \    while(n > 0) {\n            digits += n % 10\n            n /= 10\n     \
    \   }\n        digits.reverse.foldLeft(0l)(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l) {\
    \ (acc, digit) =>\n            if (digit.isEven) acc * digit else acc\n      \
    \  }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n   \
    \     val even = digits.filter(x => x.toLong % 2 == 0).length\n        val odd\
    \ = digits.filter(x => x.toLong % 2 != 0).length\n        if (even > odd) {\n\
    \            return 0\n        } else {\n            return digits.map(x => x.toLong\
    \ * 2).reduce(_ * _)\n        }", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(1l) {\n            case (acc, digit) => acc * digit\n\
    \        }", "        var product = 1\n        var digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foreach(x => product *= x)\n        if (digits.forall(x => x %\
    \ 2 == 0)) {\n            return 0\n        } else {\n            return product\n\
    \        }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        val even = digits.filter(x => x.toString.toLong % 2 == 0)\n        val\
    \ odd = digits.filter(x => x.toString.toLong % 2 != 0)\n        val product =\
    \ even.foldLeft(0l)(_ * _) + odd.foldLeft(0l)(_ * _)\n        if (product == 0l)\
    \ 0\n        else product", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        val div = n.toInt\n        val remainder = n % div\n        while(div\
    \ > 0) {\n            digits.append(div % 10)\n            div = div / 10\n  \
    \      }\n        digits.append(remainder)\n        digits.reverse.foldLeft(1l)\
    \ { (acc, digit) => acc * 10 + digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.reduceLeft(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0l){ (product, digit) => product * digit }", "      \
    \  val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.reduceLeft(_\
    \ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n \
    \       digits.foldLeft(1l) { (acc, digit) => acc * digit }", "        val product\
    \ = n.toString.reverse.foldLeft(1L)(_ * _)\n        if (product % 2 == 0) product\
    \ else 0", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1l) {\n            case (acc, digit) => acc * digit\n\
    \        }", "        var result = 1\n        var remainder = n\n        while(remainder\
    \ > 0) {\n            result *= (remainder % 10)\n            remainder /= 10\n\
    \        }\n        if (remainder == 0) {\n            result\n        } else\
    \ {\n            0\n        }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        val digits\
    \ = mutable.ListBuffer[Long]()\n        var product = 1\n        while (n > 0)\
    \ {\n            digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foreach(product\
    \ *= _)\n        if (digits.isEmpty) 0\n        else product", "        val digits\
    \ = n.toString.toList.map(_.toInt)\n        val odd = digits.filter(x => x % 2\
    \ != 0)\n        if (odd.isEmpty) 0\n        else odd.product", "        val digits\
    \ = mutable.ArrayBuffer.empty[Long]\n        var product = 1\n        while (n\
    \ > 0)\n        {\n            digits += n % 10\n            product *= n % 10\n\
    \            n /= 10\n        }\n        if (digits.isEmpty) 0\n        else product",
  "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        val evens\
    \ = digits.filter(x => x % 2 == 0)\n        val odds = digits.filter(x => x %\
    \ 2 != 0)\n        evens.foldLeft(0l) { (acc, x) => acc * x }", "        val d\
    \ = n.toInt\n        if (d < 10) return d\n        val r = n % 10\n        val\
    \ m = n / 10\n        val r = digits(m)\n        if (d % 2 == 0) r * r\n     \
    \   else r * r * 10", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0l){ (acc, digit) =>\n            acc * digit\n     \
    \   }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n  \
    \      digits.foldLeft(1l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(1l) {\
    \ (acc, digit) => acc * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1l) { (x, y) => x * y }", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.forall(_.toString.toDouble % 2 != 0)\n            ? 0\n      \
    \      : digits.foldLeft(1L) { (a, b) => a * b}", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l) { (acc, digit) =>\n            acc * digit\n    \
    \    }", "        val digits = n.toString.toList.map(_.toInt)\n        val odd\
    \ = digits.filter(x => x % 2 != 0)\n        if (odd.isEmpty) 0\n        else odd.product",
  "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n        digits.foldLeft(0l){\
    \ (sum, digit) => sum * digit }", "        val digits = mutable.ListBuffer[Long]()\n\
    \        val n = n.toInt\n        while(n > 0){\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foldLeft(0l){ (acc, digit)\
    \ => acc * 10 + digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        if (digits.forall(_.isEven))\n            return 0\n        digits.reduceLeft((x,\
    \ y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        val even = digits.filter(x\
    \ => x.toLong % 2 == 0).length\n        val odd = digits.filter(x => x.toLong\
    \ % 2 != 0).length\n        if (even > odd) 0\n        else digits.map(_.toLong).product",
  "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.reduceLeft((x,\
    \ y) => x * y)", "        val product = n.toString.reverse.foldLeft(1l) {\n  \
    \          case (acc, digit) => acc * digit.toLong\n        }\n        if (product\
    \ % 2 == 0) 0 else product", "        val digits = mutable.ListBuffer.empty[Long]\n\
    \        val digit = n.toString.reverse.dropWhile(_ == '0').drop(1)\n        digits\
    \ += digit\n        digits.reverse.foldLeft(0l) { (acc, digit) => acc * digit.toLong\
    \ }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n    \
    \    digits.foldLeft(0l)(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.forall(_ % 2 ==\
    \ 0)\n            ? 0\n            : digits.product", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        if (digits.forall(_.isEven)) 0\n        else digits.foldLeft(1L) { (acc,\
    \ digit) => acc * digit }", "        var product = 1\n        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foreach(x => product *= x)\n        if (digits.forall(x => x ==\
    \ 0)) 0 else product", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l)(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        var result = 1\n      \
    \  var remainder = n\n        while(remainder > 0) {\n            result *= (remainder\
    \ % 2)\n            remainder = remainder / 2\n        }\n        result", " \
    \       val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.reduceLeft(_\
    \ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n \
    \       val even = digits.filter(_ % 2 == 0)\n        val odd = digits.filter(_\
    \ % 2 != 0)\n        even.foldLeft(0l)(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l){\
    \ (acc, digit) => acc * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1l) { (acc, digit) =>\n            if (digit.isEven)\
    \ acc * digit\n            else acc\n        }", "        var product = 1\n  \
    \      var digits = n.toString.reverse.grouped(2).map(_.toInt)\n        digits.foreach\
    \ { x => product *= x }\n        product", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l) { (acc, x) => acc * x }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        val even = digits.filter(_.toString.toLong % 2 == 0).length\n       \
    \ val odd = digits.filter(_.toString.toLong % 2 != 0).length\n        if (even\
    \ == 0) 0\n        else if (even == 1) digits.head.toLong * digits.last.toLong\n\
    \        else digits.head.toLong * digits(digits.last.toLong + 1)", "        val\
    \ digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.reduceLeft((x,\
    \ y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.forall(_.isEven)\n            ? 0\n            : digits.foldLeft(1L)\
    \ {\n                case (acc, digit) => acc * digit\n            }", "     \
    \   val digits = mutable.ArrayBuffer.empty[Long]\n        var remainder = n\n\
    \        while (remainder > 0) {\n            digits += (remainder % 10)\n   \
    \         remainder = remainder / 10\n        }\n        if (digits.isEmpty) 0\n\
    \        else digits.reduceLeft(_ * _)", "        val digits = mutable.ListBuffer[Long]()\n\
    \        while(n > 0){\n            digits += n % 10\n            n /= 10\n  \
    \      }\n        digits.reverse.foldLeft(1l)(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l) { (acc, digit) =>\n            acc * digit\n    \
    \    }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n \
    \       digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(1L)(_\
    \ * _)", "        var product = 0\n        var digits = n.toString.toInt\n   \
    \     while (digits > 0) {\n            product *= digits\n            digits\
    \ -= 1\n        }\n        if (product % 2 == 0) product else 0", "        val\
    \ digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.reduceLeft((x,\
    \ y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.forall(_ % 2 == 0)\n            ? 0\n            : digits.reduceLeft((x,\
    \ y) => x * y)", "        val digits = mutable.ListBuffer.empty[Long]\n      \
    \  var product = 0\n        while (n > 0) {\n            digits += n % 10\n  \
    \          n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n\
    \        if (digits.isEmpty) 0\n        else product", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        val digit = n.toString.reverse.dropWhile(_ == '0').dropWhile(_ == '1').reverse\n\
    \        digits.+=(digit)\n        digits.sum", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val product = n.toString.dropRight(n.toString.length-1)\n\
    \        val digits = product.toInt\n        if (digits == 0) 0\n        else\
    \ digits * digits(n/digits)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft(_ * _)", "        val digits = mutable.ListBuffer.empty[Long]\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            product *= n % 10\n            n /= 10\n        }\n        if (digits.isEmpty)\
    \ 0\n        else digits.reverse.foldLeft(product) { (product, digit) =>\n   \
    \         product * digit\n        }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        if (digits.forall(_.isEven)) 0\n        else digits.foldLeft(1L) { (acc,\
    \ digit) => acc * digit }", "        val digits = n.toString.toList.map(_.toInt)\n\
    \        val odd = digits.filter(x => x % 2 != 0)\n        if (odd.isEmpty) 0\n\
    \        else odd.reduceLeft(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toInt)\n        digits.foldLeft(0l) {\
    \ (acc, digit) =>\n            acc * digit % 10\n        }", "        var res\
    \ = 1\n        var i = 0\n        while (i < n.toString.length) {\n          \
    \  if (n.toString.charAt(i) % 2 == 1) {\n                res *= n.toString.charAt(i)\n\
    \            }\n            i += 1\n        }\n        if (res == 0) {\n     \
    \       return 0\n        }\n        return res", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        val even = digits.filter(x => x.toInt == 0)\n        val odd = digits.filter(x\
    \ => x.toInt % 2 == 1)\n        val product = even.foldLeft(0l)(_ * _) + odd.foldLeft(0l)(_\
    \ * _)\n        product", "        val product = n.toString.map(_.toInt).foldLeft(1l)(_\
    \ * _)\n        if (product % 2 == 0) product else 0", "        val product =\
    \ n.toString.reverse.foldLeft(1l) {\n            case (acc, digit) => acc * digit.toLong\n\
    \        }\n        if (product % 2 == 0) 0 else product", "        val digits\
    \ = mutable.ListBuffer[Long]()\n        val product = n.toString.reverse.map(_.toInt).product\n\
    \        val digit = n.toString.reverse.map(_.toInt).filter(_ % 2 == 1).length\n\
    \        digits += product\n        digits += digit\n        digits.toList.sum",
  "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l)\
    \ { (acc, digit) => acc * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.reduceLeft((x,\
    \ y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.reduceLeft((x,\
    \ y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.reduceLeft((x,\
    \ y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l){\
    \ (acc, digit) => acc * digit }", "        val digits = n.toString.toInt\n   \
    \     val odd = digits.filter(_ % 2 != 0)\n        if (odd.isEmpty) 0\n      \
    \  else odd.product", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        val even = digits.filter(x\
    \ => x % 2 == 0)\n        val odd = digits.filter(x => x % 2 != 0)\n        if\
    \ (even.isEmpty) 0\n        else if (odd.isEmpty) even.head\n        else even.head\
    \ * odd.head", "        var product = 1\n        var digits = n.toString.reverse.grouped(2).map(_\
    \ + \"\").reverse\n        digits.foreach(x => product *= x.toLong)\n        product",
  "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.forall(_.toString.toLong\
    \ % 2 != 0)\n            ? 0\n            : digits.foldLeft(1L)(_ * _)", "   \
    \     val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.forall(_\
    \ % 2 != 0)\n            ? 0\n            : digits.foldLeft(1L) { (a, b) => a\
    \ * b}", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n \
    \       digits.reduceLeft(_ * _)", "        val d = n.toString.reverse\n     \
    \   val odd = d.filter(_ % 2 == 1)\n        if (odd.isEmpty) 0\n        else odd.product",
  "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l)\
    \ { (acc, digit) => acc * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        if (digits.forall(_.isEven)) 0\n        else digits.foldLeft(1L) { (a,\
    \ b) => a * b}", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l) { (acc, digit) => acc * digit }", "        val product\
    \ = n.toString.toInt\n        val digits = n.toString.toInt\n        val oddDigits\
    \ = digits % 2\n        if (oddDigits == 0) {\n            return product\n  \
    \      }\n        else {\n            return 0\n        }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l)(_\
    \ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n \
    \       digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.reduceLeft((x,\
    \ y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(1l) {\
    \ (a, b) => a * b}", "        val digits = mutable.ListBuffer.empty[Long]\n  \
    \      val remainder = n % 10\n        val quotient = n / 10\n        while(quotient\
    \ > 0) {\n            digits.append(quotient)\n            quotient = quotient\
    \ / 10\n        }\n        if(remainder == 0) {\n            digits.reverse\n\
    \        } else {\n            digits.append(remainder)\n        }\n        digits.reverse.foldLeft(1l)(_\
    \ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n \
    \       digits.reduceLeft(_ * _)", "        val d = n.toString.toInt\n       \
    \ val odd = d.filter(_ % 2 == 1)\n        if (odd.isEmpty) 0\n        else odd.product",
  "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n        digits.foldLeft(0l)\
    \ { (acc, digit) => acc * digit }", "        val digits = mutable.ListBuffer.empty[Long]\n\
    \        var product = 1\n        while(n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n\
    \        product", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(1l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l)(_\
    \ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n  \
    \      val even = digits.filter(x => x % 2 == 0)\n        val odd = digits.filter(x\
    \ => x % 2 != 0)\n        if (even.size == 0)\n            0\n        else\n \
    \           odd.reduce(_ * _)", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 0\n        while(n > 0){\n            val digit = n % 10\n\
    \            digits += digit\n            n /= 10\n        }\n        digits.reverse.foreach(product\
    \ *= _)\n        product", "        val digits = n.toString.toList\n        val\
    \ odd = digits.filter(_ % 2 == 1)\n        val even = digits.filter(_ % 2 == 0)\n\
    \        odd.foldLeft(0l)(_ * _) + even.foldLeft(0l)(_ * _)", "        val d =\
    \ n.toString.reverse\n        val even = d.filter(_ % 2 == 0)\n        val odd\
    \ = d.filter(_ % 2 != 0)\n        val product = even.foldLeft(0l)(_ * _) + odd.foldLeft(0l)(_\
    \ * _)\n        product % 10", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        var result\
    \ = 1\n        var remainder = n\n        while (remainder > 0) {\n          \
    \  result *= (remainder % 2)\n            remainder = remainder / 2\n        }\n\
    \        if (remainder == 0)\n            result\n        else\n            0",
  "        var result = 1\n        var remainder = n\n        while(n > 0){\n    \
    \        result *= n % 10\n            remainder = n / 10\n        }\n       \
    \ if(remainder == 0){\n            result\n        }else{\n            result\n\
    \        }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.reduceLeft(_ *\
    \ _)", "        val digits = mutable.ListBuffer.empty[Long]\n        while(n >\
    \ 0){\n            digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(1l)(_\
    \ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n \
    \       digits.foldLeft(0l)(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1l)((acc, digit) => acc * digit)", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l){\
    \ (sum, digit) => sum * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        if (digits.forall(_.toString.toInt == 0)) 0 else digits.map(_.toLong).product",
  "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        if (digits.forall(_.isEven))\
    \ 0 else digits.foldLeft(1l)(_ * _)", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n\
    \        product", "        val digits = mutable.ListBuffer.empty[Long]\n    \
    \    var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n\
    \        product", "        val digits = mutable.ListBuffer[Long]()\n        var\
    \ product = 1\n        while (n > 0) {\n            digits += n % 10\n       \
    \     n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n     \
    \   digits.reverse.foldLeft(product)((product, digit) => product * digit)", " \
    \       val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l){\
    \ (product, digit) => product * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        if (digits.forall(_.isEven)) 0\n        else digits.reduceLeft((x, y)\
    \ => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        val evens = digits.filter(_.toString.length == 0)\n        val odds =\
    \ digits.filter(_.toString.length == 1)\n        evens.foldLeft(0l) { (acc, x)\
    \ => acc * x }", "        val digits = mutable.ListBuffer[Long]()\n        val\
    \ n = n.toInt\n        for(i <- 0 until n) {\n            digits += i.toLong\n\
    \        }\n        digits.reduceLeft(_ * 2)", "        val d = n.toString.reverse\n\
    \        val odd = d.filter(x => x % 2 == 1)\n        val even = d.filter(x =>\
    \ x % 2 == 0)\n        odd.foldLeft(0l){ (a, b) => a * 10 + b }", "        val\
    \ digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(1l)\
    \ { (product, digit) => product * digit }", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            product = product * n % 10\n            n /= 10\n        }\n    \
    \    if (digits.isEmpty) 0\n        else digits.reverse.foldLeft(product) { (product,\
    \ digit) =>\n            product * digit\n        }", "        val product = n.toString.dropRight(n.toString.length).map(_.toInt).product\n\
    \        product match {\n            case 0 => 0\n            case _ => product\n\
    \        }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val product = n.toString.toLong\
    \ * n.toString.toLong\n        val digits = n.toString.toLong.toString.reverse.grouped(2).toList\n\
    \        digits.foldLeft(product)((product, digit) => product * digit)", "   \
    \     val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l)\
    \ { (acc, digit) => acc * digit }", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while(n > 0) {\n            digits += n % 10\n\
    \            product *= n % 10\n            n /= 10\n        }\n        if (digits.isEmpty)\
    \ 0\n        else digits.reverse.foldLeft(product)((acc, digit) => acc * digit)",
  "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(1l)(_\
    \ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n \
    \       digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l)(_\
    \ * _)", "        var result = 1\n        var digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foreach(x => result *= x)\n        result", "        val digits\
    \ = mutable.ListBuffer[Long]()\n        var product = 0L\n        while(n > 0)\
    \ {\n            digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foreach(product\
    \ *= _)\n        digits.reverse.foreach(product += _)\n        product"]
stop_tokens:
- "\n    }\n"
