language: scala
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase)\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => extensions_map(a)\
    \ - extensions_map(b))\n        val extensions_sorted = extensions_sorted.map(e\
    \ => class_name + e).sortWith((a, b) => a.length - b.length)\n        val extensions_sorted\
    \ = extensions_sorted.map(e => e.substring(0, e.length - 1))\n        val extensions_sorted\
    \ = extensions_sorted.map(e => class_name + e).sortWith((a, b) => a.length - b.length)\n\
    \        val extensions_sorted = extensions_sorted.map(e => e.substring(0, e.length\
    \ - 1))\n        val extensions_sorted = extensions_sorted.map(e => class_name\
    \ + e).sortWith((a, b) => a.length - b.length)\n        val extensions_sorted\
    \ = extensions_sorted.map(e => e.substring(0, e.length - 1))\n        val extensions_sorted\
    \ = extensions_sorted.map(e => class_name + e).sortWith((a, b) => a.length - b.length)\n\
    \        val extensions_sorted = extensions_sorted.map(e => e.substring(0, e.length\
    \ - 1))\n        val extensions_sorted = extensions_sorted.map(e => class_name\
    \ + e).sortWith((a, b) => a.length - b.length)\n        val extensions_sorted\
    \ = extensions_sorted.map(e => e.substring(0, e.length - 1))\n        val extensions_sorted\
    \ = extensions_sorted.map(e => class_name + e).sortWith((a, b) => a.length - b.length)\n\
    \        val extensions_sorted = extensions_sorted.map(e => e.substring(0, e.length\
    \ - 1))\n        val extensions_sorted = extensions_sorted.map(e => class_name\
    \ + e).sortWith((a, b) => a.length - b.length)\n        val extensions_sorted\
    \ = extensions_sorted.map(e => e.substring(0, e.length - 1))\n        val extensions_sorted\
    \ = extensions_sorted.map(e => class_name + e).sortWith((a, b) => a.length - b.length)\n\
    \        val extensions_sorted = extensions_sorted.map(e => e.substring(0, e.length\
    \ - 1))\n        val extensions_sorted = extensions_sorted.map(e => class_name\
    \ + e).sortWith((a, b) => a.length - b.length)\n        val extensions_sorted\
    \ = extensions_sorted.map(e => e.substring(0, e.length - 1))\n        val extensions_sorted\
    \ = extensions_sorted.map(e => class_name + e).sortWith((a, b) => a.length - b.length)\n\
    \        val extensions_sorted = extensions_sorted.map(e => e.substring(0, e.length\
    \ - 1))\n        val extensions_\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8i12a3ci.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8i12a3ci.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions_sorted.map(\e[36me\e[0m => class_name\
    \ + e).sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => a.length - b.length)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp8i12a3ci.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36me\e[0m => e.substring(\e[31m0\e[0m, e.length - \e\
    [31m1\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp8i12a3ci.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36me\e[0m => class_name + e).sortWith((\e[36ma\e[0m,\
    \ \e[36mb\e[0m) => a.length - b.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp8"
  stdout: ''
  timestamp: 1659799972
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        var strength = 0\n\
    \        var extension = \"\"\n        var extension_found = false\n        for(extension\
    \ <- extensions) {\n            val cap = extension.filter(x => x.isUpper).length\n\
    \            val sm = extension.filter(x => x.isLower).length\n            val\
    \ strength = cap - sm\n            if(strength > 0) {\n                extension_found\
    \ = true\n                extension = extension\n                strength = strength\n\
    \            }\n        }\n        if(!extension_found) {\n            val cap\
    \ = extension.filter(x => x.isUpper).length\n            val sm = extension.filter(x\
    \ => x.isLower).length\n            val strength = cap - sm\n            if(strength\
    \ > 0) {\n                extension = extension\n                strength = strength\n\
    \            }\n        }\n        val class_name = class_name.replaceAll(\"[^A-Z]\"\
    , \"\")\n        val class_name_with_extension = class_name + extension\n    \
    \    val class_name_with_extension_lowercase = class_name_with_extension.toLowerCase()\n\
    \        val class_name_with_extension_lowercase = class_name_with_extension_lowercase.replaceAll(\"\
    [^a-z]\", \"\")\n        val class_name_with_extension_lowercase = class_name_with_extension_lowercase.replaceAll(\"\
    [^0-9]\", \"\")\n        val class_name_with_extension_lowercase = class_name_with_extension_lowercase.replaceAll(\"\
    [^A-Z0-9]\", \"\")\n        val class_name_with_extension_lowercase = class_name_with_extension_lowercase.replaceAll(\"\
    [^A-Z]\", \"\")\n        val class_name_with_extension_lowercase = class_name_with_extension_lowercase.replaceAll(\"\
    [^0-9]\", \"\")\n        val class_name_with_extension_lowercase = class_name_with_extension_lowercase.replaceAll(\"\
    [^A-Z0-9]\", \"\")\n        val class_name_with_extension_lowercase = class_name_with_extension_lowercase.replaceAll(\"\
    [^A-Z]\", \"\")\n        val class_name_with_extension_lowercase = class_name_with_extension_lowercase.replaceAll(\"\
    [^0-9]\", \"\")\n        val class_name_with_extension_lowercase = class_name_with_extension_lowercase.replaceAll(\"\
    [^A-Z0-9]\", \"\")\n        val class_name_with_extension_lowercase = class_name_with_extension_lowercase.replaceAll(\"\
    [^A-Z]\", \"\")\n        val class_name_with_extension_lowercase = class_name_with_extension_lowercase.replaceAll(\"\
    [^0-9]\", \"\")\n        val class_name_with_extension_lowercase = class_name_with_extension_lowercase.replaceAll(\"\
    [^A-Z0-9]\", \"\")\n        val class_name_with_extension_lowercase = class_name_with_extension_lowercase.replaceAll(\"\
    [^A-Z]\", \"\")\n        val class_name_with_extension_lowercase = class_name_with_extension_lowercase.replaceAll(\"\
    [^0-9\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp804i6by7.scala:59:97 -----------------------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m \e[36mclass_name_with_extension_lowercase\e\
    [0m = class_name_with_extension_lowercase.replaceAll(\"[^0-9\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \                   unclosed string literal\n\e[31m\e[31m-- Error: /tmp/tmp804i6by7.scala:61:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m61 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                 end of statement expected but '=' found\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp804i6by7.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mclass_name_with_extension_lowercase\e\
    [0m = class_name_with_extension_lowercase.replaceAll(\e[31m\"[^a-z]\"\e[0m, \e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclass_name_with_extension_lowercase is already defined as\
    \ \e[33mvalue\e[0m \e[35mclass_name_with_extension_lowercase\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp804i6by7.scala:47:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclass_name_with_extension_lowercase\e[0m = class_name_with_extension_lowercase.replaceAll(\e\
    [31m\"[^0-9]\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclass_name_with_extension_lowercase is already defined as\
    \ \e[33mvalue\e[0m \e[35mclass_name_with_extension_lowercase\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of topleve"
  stdout: ''
  timestamp: 1659799969
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase)\n\
    \        val extensions_count = extensions_map.filter(_._2 > 0).map(_._2).sum\n\
    \        val extensions_strength = extensions_map.filter(_._2 > 0).map(_._1).sum\n\
    \        val extensions_strength_fraction = extensions_strength.toDouble / extensions_count.toDouble\n\
    \        val extensions_strength_fraction = extensions_strength_fraction.toInt\n\
    \        val extensions_strength_fraction = extensions_strength_fraction.toDouble\
    \ * -1\n        val extensions_strength_fraction = extensions_strength_fraction.toInt\n\
    \        val extensions_strength_fraction = extensions_strength_fraction.toDouble\
    \ * -1\n        val extensions_strength_fraction = extensions_strength_fraction.toInt\n\
    \        val extensions_strength_fraction = extensions_strength_fraction.toDouble\
    \ * -1\n        val extensions_strength_fraction = extensions_strength_fraction.toInt\n\
    \        val extensions_strength_fraction = extensions_strength_fraction.toDouble\
    \ * -1\n        val extensions_strength_fraction = extensions_strength_fraction.toInt\n\
    \        val extensions_strength_fraction = extensions_strength_fraction.toDouble\
    \ * -1\n        val extensions_strength_fraction = extensions_strength_fraction.toInt\n\
    \        val extensions_strength_fraction = extensions_strength_fraction.toDouble\
    \ * -1\n        val extensions_strength_fraction = extensions_strength_fraction.toInt\n\
    \        val extensions_strength_fraction = extensions_strength_fraction.toDouble\
    \ * -1\n        val extensions_strength_fraction = extensions_strength_fraction.toInt\n\
    \        val extensions_strength_fraction = extensions_strength_fraction.toDouble\
    \ * -1\n        val extensions_strength_fraction = extensions_strength_fraction.toInt\n\
    \        val extensions_strength_fraction = extensions_strength_fraction.toDouble\
    \ * -1\n        val extensions_strength_fraction = extensions_strength_fraction.toInt\n\
    \        val extensions_strength_fraction = extensions_strength_fraction.toDouble\
    \ * -1\n        val extensions_strength_fraction = extensions_strength_fraction.toInt\n\
    \        val extensions_strength_fraction = extensions_strength_fraction.toDouble\
    \ * -1\n        val extensions_strength_fraction = extensions_strength_fraction.toInt\n\
    \        val extensions_strength_fraction = extensions_strength_fraction.toDouble\
    \ * -1\n        val extensions_\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxv7g43wt.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxv7g43wt.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_strength_fraction\e[0m = extensions_strength_fraction.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_strength_fraction is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_strength_fraction\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxv7g43wt.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_strength_fraction\e\
    [0m = extensions_strength_fraction.toDouble * -\e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_strength_fraction is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_strength_fraction\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxv7g43wt.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_strength_fraction\e\
    [0m = extensions_strength_fraction.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_strength_fraction is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_strength_fraction\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxv7g43wt.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_strength_fraction\e\
    [0m = extensions_strength_fraction.t"
  stdout: ''
  timestamp: 1659799972
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val class_name_map = class_name.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n\
    \        val max_strength = extensions_map.values.max\n        val max_key = extensions_map.keys.max\n\
    \        val max_key_index = extensions_map.keys.indexOf(max_key)\n        val\
    \ max_key_value = extensions_map.get(max_key)\n        val max_key_key_index =\
    \ class_name_map.keys.indexOf(max_key_value)\n        val max_key_class_name =\
    \ class_name_map.get(max_key_value)\n        val max_key_class_name_key_index\
    \ = extensions_map.keys.indexOf(max_key_class_name)\n        val max_key_class_name_key_value\
    \ = extensions_map.get(max_key_class_name)\n        val max_key_class_name_key_key_index\
    \ = class_name_map.keys.indexOf(max_key_class_name_key_value)\n        val max_key_class_name_key_class_name\
    \ = class_name_map.get(max_key_class_name_key_value)\n        val max_key_class_name_key_class_name_key_index\
    \ = extensions_map.keys.indexOf(max_key_class_name_key_class_name)\n        val\
    \ max_key_class_name_key_class_name_key_value = extensions_map.get(max_key_class_name_key_class_name)\n\
    \        val max_key_class_name_key_class_name_key_key_index = class_name_map.keys.indexOf(max_key_class_name_key_class_name_key_value)\n\
    \        val max_key_class_name_key_class_name_key_class_name_key_index = extensions_map.keys.indexOf(max_key_class_name_key_class_name_key_class_name_key_value)\n\
    \        val max_key_class_name_key_class_name_key_class_name_key_key_index =\
    \ class_name_map.keys.indexOf(max_key_class_name_key_class_name_key_class_name_key_class_name_key_value)\n\
    \        val max_key_class_name_key_class_name_key_class_name_key_class_name_key_index\
    \ = extensions_map.keys.indexOf(max_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_value)\n\
    \        val max_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_index\
    \ = extensions_map.keys.indexOf(max_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_value)\n\
    \        val max_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_index\
    \ = extensions_map.keys.indexOf(max_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_value)\n\
    \        val max_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_index\
    \ = extensions_map.keys.indexOf(max_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8jfzqqp4.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8jfzqqp4.scala:22:52\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mx\e[0m => (x.toUpperCase.size,\
    \ x.toLowerCase.size)).toMap\n\e[31m\e[31m   |\e[0m                          \
    \                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \              value toUpperCase is not a member of Char\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp8jfzqqp4.scala:22:72 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \ ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               value toLowerCase\
    \ is not a member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8jfzqqp4.scala:25:48\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mmax_key_index\e[0m = extensions_map.keys.indexOf(max_key)\n\e[31m\e[31m  \
    \ |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                          value indexOf is not a member of Iterable[Int]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8jfzqqp4.scala:27:52 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmax_key_key_index\e[0m =\
    \ class_name_map.keys.indexOf(max_key_value)\n\e[31m\e[31m   |\e[0m          \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 value indexOf is not a member of Iterable[Nothing]\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp8jfzqqp4.scala:28:52 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmax_key_class_name\e[0m\
    \ = class_name_map.get(max_key_value)\n\e[31m\e[31m   |\e[0m                 \
    \                                   ^^^^^^^^^^^^^\e[0m\n\e[31"
  stdout: ''
  timestamp: 1659799972
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val class_name_map = class_name.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n\
    \        val max_key = extensions_map.maxBy(_._1)._1\n        val max_value =\
    \ extensions_map.maxBy(_._1)._2\n        val max_key = class_name_map.maxBy(_._1)._1\n\
    \        val max_value = class_name_map.maxBy(_._1)._2\n        val max_key =\
    \ max_key.map(x => x.toString.toUpperCase.size)\n        val max_value = max_value.map(x\
    \ => x.toString.toUpperCase.size)\n        val max_key = max_key.max\n       \
    \ val max_value = max_value.max\n        val max_key = max_key.map(x => x.toString.toUpperCase.size)\n\
    \        val max_value = max_value.map(x => x.toString.toUpperCase.size)\n   \
    \     val max_key = max_key.max\n        val max_value = max_value.max\n     \
    \   val max_key = max_key.map(x => x.toString.toUpperCase.size)\n        val max_value\
    \ = max_value.map(x => x.toString.toUpperCase.size)\n        val max_key = max_key.max\n\
    \        val max_value = max_value.max\n        val max_key = max_key.map(x =>\
    \ x.toString.toUpperCase.size)\n        val max_value = max_value.map(x => x.toString.toUpperCase.size)\n\
    \        val max_key = max_key.max\n        val max_value = max_value.max\n  \
    \      val max_key = max_key.map(x => x.toString.toUpperCase.size)\n        val\
    \ max_value = max_value.map(x => x.toString.toUpperCase.size)\n        val max_key\
    \ = max_key.max\n        val max_value = max_value.max\n        val max_key =\
    \ max_key.map(x => x.toString.toUpperCase.size)\n        val max_value = max_value.map(x\
    \ => x.toString.toUpperCase.size)\n        val max_key = max_key.max\n       \
    \ val max_value = max_value.max\n        val max_key = max_key.map(x => x.toString.toUpperCase.size)\n\
    \        val max_value = max_value.map(x => x.toString.toUpperCase.size)\n   \
    \     val max_key = max_key.max\n        val max_value = max_value.max\n     \
    \   val max_key = max_key.map(x => x.toString.toUpperCase.size)\n        val max_value\
    \ = max_value.map(x => x.toString.toUpperCase.size)\n        val max_key = max_key.max\n\
    \        val max_value = max_value.max\n        val max_key = max_key.map(x =>\
    \ x.toString.to\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpn6g8xyej.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpn6g8xyej.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmax_key\e[0m = class_name_map.maxBy(_._1)._1\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmax_key\
    \ is already defined as \e[33mvalue\e[0m \e[35mmax_key\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpn6g8xyej.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmax_value\e[0m = class_name_map.maxBy(_._1)._2\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmax_value\
    \ is already defined as \e[33mvalue\e[0m \e[35mmax_value\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpn6g8xyej.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmax_key\e[0m = max_key.map(\e[36mx\e[0m => x.toString.toUpperCase.size)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_key is already defined as \e[33mvalue\e[0m \e[35mmax_key\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpn6g8xyej.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mmax_value\e[0m = max_value.map(\e[36mx\e\
    [0m => x.toString.toUpperCase.size)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_value is already defined as \e[33mvalue\e[0m \e[35mmax_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined i"
  stdout: ''
  timestamp: 1659799972
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.foldLeft(0)((a, b) => (class_name_map.get(b) - class_name_map.get(a)).toInt)\n\
    \        val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n \
    \       val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpi8kb2hla.scala:42:62 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._\n\e[31m\e[31m   |\e[0m                     \
    \                                         ^\e[0m\n\e[31m   |\e[0m            \
    \                       an identifier expected, but '_' found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpi8kb2hla.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1).toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpi8kb2hla.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1).toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpi8kb2hla.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1).toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be "
  stdout: ''
  timestamp: 1659799972
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(_.toUpperCase).zipWithIndex.toMap\n        val class_name_map\
    \ = class_name.zipWithIndex.toMap\n        val extensions_count = extensions_map.size\n\
    \        val class_name_count = class_name_map.size\n        val strength = extensions_count\
    \ - class_name_count\n        val extensions_sorted = extensions_map.toSeq.sortBy(_._2).reverse\n\
    \        val class_name_sorted = class_name_map.toSeq.sortBy(_._2).reverse\n \
    \       val extensions_first = extensions_sorted.head._1\n        val class_name_first\
    \ = class_name_sorted.head._1\n        val extensions_last = extensions_sorted.last._1\n\
    \        val class_name_last = class_name_sorted.last._1\n        val extensions_first_index\
    \ = extensions_sorted.indexOf((class_name_first, extensions_first))\n        val\
    \ class_name_first_index = class_name_sorted.indexOf((class_name_first, extensions_first))\n\
    \        val extensions_last_index = extensions_sorted.indexOf((class_name_last,\
    \ extensions_last))\n        val class_name_last_index = class_name_sorted.indexOf((class_name_last,\
    \ extensions_last))\n        val extensions_first_value = extensions_sorted.apply(extensions_first_index)._2\n\
    \        val class_name_first_value = class_name_sorted.apply(class_name_first_index)._2\n\
    \        val extensions_last_value = extensions_sorted.apply(extensions_last_index)._2\n\
    \        val class_name_last_value = class_name_sorted.apply(class_name_last_index)._2\n\
    \        val extensions_first_key = extensions_sorted.apply(extensions_first_index)._1\n\
    \        val class_name_first_key = class_name_sorted.apply(class_name_first_index)._1\n\
    \        val extensions_last_key = extensions_sorted.apply(extensions_last_index)._1\n\
    \        val class_name_last_key = class_name_sorted.apply(class_name_last_index)._1\n\
    \        val extensions_first_index = extensions_sorted.indexOf((class_name_first_value,\
    \ extensions_first_key))\n        val class_name_first_index = class_name_sorted.indexOf((class_name_first_value,\
    \ extensions_first_key))\n        val extensions_last_index = extensions_sorted.indexOf((class_name_last_value,\
    \ extensions_last_key))\n        val class_name_last_index = class_name_sorted.indexOf((class_name_last_value,\
    \ extensions_last_key))\n        val extensions_first_value = extensions_sorted.apply(extensions_first_index)._2\n\
    \        val class_name_first_value = class_name_sorted.apply(class_name_first_index)._2\n\
    \        val extensions_last_value = extensions_sorted.apply(extensions_last_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6opx8m_i.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6opx8m_i.scala:44:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_first_index\e[0m = extensions_sorted.indexOf((class_name_first_value,\
    \ extensions_first_key))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_first_index is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_first_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6opx8m_i.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mclass_name_first_index\e\
    [0m = class_name_sorted.indexOf((class_name_first_value, extensions_first_key))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclass_name_first_index is already defined as \e[33mvalue\e\
    [0m \e[35mclass_name_first_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6opx8m_i.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mextensions_last_index\e\
    [0m = extensions_sorted.indexOf((class_name_last_value, extensions_last_key))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_last_index is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_last_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6opx8m_i.scala:47:12 -----------"
  stdout: ''
  timestamp: 1659799971
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase, e.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(c => (c.toUpperCase, c.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.foldLeft(0)((s, e) => s + (class_name_map(e._1) - class_name_map(e._2)))\n\
    \        val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n \
    \       val extension_strength = extensions_sorted.head._2\n        val extension_class_name\
    \ = extensions_sorted.head._1\n        if (strength == extension_strength) {\n\
    \            class_name + \".\" + extension_class_name\n        } else {\n   \
    \         class_name + \".\" + extension_class_name + \".\" + extension_strength\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwgzpso7s.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mc\e[0m => (c.toUpperCase, c.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpwgzpso7s.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mc\e[0m => (c.toUpperCase, c.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwgzpso7s.scala:23:82\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.foldLeft(\e[31m0\e[0m)((\e[36ms\e[0m, \e[36me\e[0m) => s\
    \ + (class_name_map(e._1) - class_name_map(e._2)))\n\e[31m\e[31m   |\e[0m    \
    \                                                                            ^^^^\e\
    [0m\n\e[31m   |\e[0m                                                       Found:\
    \    String\n\e[31m   |\e[0m                                                 \
    \      Required: Nothing\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpwgzpso7s.scala:23:105 -------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.foldLeft(\e\
    [31m0\e[0m)((\e[36ms\e[0m, \e[36me\e[0m) => s + (class_name_map(e._1) - class_name_map(e._2)))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                               ^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                                    Found:    String\n\e[31m\
    \   |\e[0m                                                       Required: Nothing\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer"
  stdout: ''
  timestamp: 1659799972
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val strength_upper = strength.toDouble / extensions_count.toDouble\n    \
    \    val strength_lower = strength.toDouble / extensions_count.toDouble\n    \
    \    val extensions_count_sum = extensions_count.toDouble\n        val extensions_count_sum_upper\
    \ = extensions_count_sum.toDouble / extensions_count.toDouble\n        val extensions_count_sum_lower\
    \ = extensions_count_sum.toDouble / extensions_count.toDouble\n        val extensions_count_sum_sum\
    \ = extensions_count_sum.toDouble\n        val extensions_count_sum_sum_upper\
    \ = extensions_count_sum_sum.toDouble / extensions_count.toDouble\n        val\
    \ extensions_count_sum_sum_lower = extensions_count_sum_sum.toDouble / extensions_count.toDouble\n\
    \        val extensions_count_sum_sum_sum = extensions_count_sum_sum.toDouble\n\
    \        val extensions_count_sum_sum_sum_upper = extensions_count_sum_sum_sum.toDouble\
    \ / extensions_count.toDouble\n        val extensions_count_sum_sum_sum_lower\
    \ = extensions_count_sum_sum_sum.toDouble / extensions_count.toDouble\n      \
    \  val extensions_count_sum_sum_sum_sum = extensions_count_sum_sum_sum.toDouble\n\
    \        val extensions_count_sum_sum_sum_sum_upper = extensions_count_sum_sum_sum_sum.toDouble\
    \ / extensions_count.toDouble\n        val extensions_count_sum_sum_sum_sum_lower\
    \ = extensions_count_sum_sum_sum_sum.toDouble / extensions_count.toDouble\n  \
    \      val extensions_count_sum_sum_sum_sum_sum = extensions_count_sum_sum_sum_sum.toDouble\n\
    \        val extensions_count_sum_sum_sum_sum_sum_upper = extensions_count_sum_sum_sum_sum_sum.toDouble\
    \ / extensions_count.toDouble\n        val extensions_count_sum_sum_sum_sum_sum_lower\
    \ = extensions_count_sum_sum_sum_sum_sum.toDouble / extensions_count.toDouble\n\
    \        val extensions_count_sum_sum_sum_sum_sum_sum = extensions_count_sum_sum_sum_sum_sum.toDouble\n\
    \        val extensions_count_sum_sum_sum_sum_sum_sum_upper = extensions_count_sum_sum_sum_sum_sum_sum.toDouble\
    \ / extensions_count.toDouble\n        val extensions_count_sum_sum_sum_sum_sum_sum_lower\
    \ = extensions_count_sum_sum_sum_sum_sum_sum.toDouble / extension\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"\
    ), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy0m_puo3.scala:44:113 -----------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sum_sum_sum_sum_sum_sum_lower\e\
    [0m = extensions_count_sum_sum_sum_sum_sum_sum.toDouble / extension\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                 ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                                    Not found: extension\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy0m_puo3.scala:45:5\
    \ ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659799970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs).reduce(_ +\
    \ _)\n        val strongest_extension = extensions_map.values.filter(x => x ==\
    \ strength).head\n        class_name + \".\" + strongest_extension\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"\
    ), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgss5lhor.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpgss5lhor.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgss5lhor.scala:23:57\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = extensions_map.values.map(\e[36mx\e[0m => (x - class_name_map.get(x)).abs).reduce(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                                                \
    \       ^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of String, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpgss5lhor.scala:23:78 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e\
    [36mx\e[0m => (x - class_name_map.get(x)).abs).reduce(_ + _)\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \    ^\e[0m\n\e[31m   |\e[0m                                                 \
    \ Found:    (x : String)\n\e[31m   |\e[0m                                    \
    \              Re"
  stdout: ''
  timestamp: 1659799972
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.values.max\n\
    \        val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n \
    \       val extension_strength = extensions_sorted.head._2\n        val extension_name\
    \ = extensions_sorted.head._1\n        val extension_class = extension_strength\
    \ * class_name + extension_name\n        extension_class\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpddauziak.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n1 error found\n"
  stdout: ''
  timestamp: 1659799971
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_count = class_name.length\n\
    \        val strength = extensions_count - class_name_count\n        val extension\
    \ = extensions.sortWith(_ < _).head\n        val extension_length = extension.length\n\
    \        val class_name_length = class_name.length\n        val strength_length\
    \ = strength.length\n        val extension_start = extension_length - class_name_length\n\
    \        val extension_end = extension_start + extension_length\n        val class_name_start\
    \ = class_name_length - strength_length\n        val class_name_end = class_name_start\
    \ + class_name_length\n        val strength_start = strength_length - class_name_length\n\
    \        val strength_end = strength_start + strength_length\n        val class_name_start\
    \ = class_name_length - strength_length\n        val class_name_end = class_name_start\
    \ + class_name_length\n        val extension_start = extension_length - class_name_length\n\
    \        val extension_end = extension_start + extension_length\n        val class_name_start\
    \ = class_name_length - strength_length\n        val class_name_end = class_name_start\
    \ + class_name_length\n        val strength_start = strength_length - class_name_length\n\
    \        val strength_end = strength_start + strength_length\n        val class_name_start\
    \ = class_name_length - strength_length\n        val class_name_end = class_name_start\
    \ + class_name_length\n        val extension_start = extension_length - class_name_length\n\
    \        val extension_end = extension_start + extension_length\n        val class_name_start\
    \ = class_name_length - strength_length\n        val class_name_end = class_name_start\
    \ + class_name_length\n        val strength_start = strength_length - class_name_length\n\
    \        val strength_end = strength_start + strength_length\n        val class_name_start\
    \ = class_name_length - strength_length\n        val class_name_end = class_name_start\
    \ + class_name_length\n        val extension_start = extension_length - class_name_length\n\
    \        val extension_end = extension_start + extension_length\n        val class_name_start\
    \ = class_name_length - strength_length\n        val class_name_end = class_name_start\
    \ + class_name_length\n        val strength_start = strength_length - class_name_length\n\
    \        val strength_end = strength_start + strength_length\n        val class_name_start\
    \ = class_name_length - strength_length\n        val class_name_end = class_name_start\
    \ + class_name_length\n        val extension_start = extension_length - class_name_length\n\
    \        val extension_end = extension_start + extension_length\n        val class_name_start\
    \ = class_name_length - strength_length\n        val class_name_end = class_name_start\
    \ + class_name_length\n        val strength_start = strength_length - class_name_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7ztjwy25.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mclass_name_start\e[0m =\
    \ class_name_length - strength_length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclass_name_start is already defined as \e[33mvalue\e[0m \e\
    [35mclass_name_start\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7ztjwy25.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mclass_name_end\e[0m = class_name_start\
    \ + class_name_length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclass_name_end is already defined as \e[33mvalue\e[0m \e[35mclass_name_end\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7ztjwy25.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mextension_start\e[0m = extension_length\
    \ - class_name_length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_start is already defined as \e[33mvalue\e[0m \e\
    [35mextension_start\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7ztjwy25.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mextension_end\e[0m = extension_start\
    \ + extension_length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_end is already defined as \e[33mvalue\e[0m \e[35mextension_end\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7ztjwy25.scala:38:12 -------------------"
  stdout: ''
  timestamp: 1659799972
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.getOrElse(x, 0) - x.toString.toString.toUpperCase.length).max\n\
    \        val extension = extensions_map.getOrElse(strength, \"\")\n        s\"\
    $class_name.$extension\"\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphrtjyyis.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmphrtjyyis.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphrtjyyis.scala:23:79\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => class_name_map.getOrElse(x, \e\
    [31m0\e[0m) - x.toString.toString.toUpperCase.length).max\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \     ^\e[0m\n\e[31m   |\e[0m                                                \
    \  Found:    (x : String)\n\e[31m   |\e[0m                                   \
    \               Required: Nothing\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmphrtjyyis.scala:24:49 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mextension\e[0m = extensions_map.getOrElse(strength,\
    \ \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                                    \
    \             ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 \
    \             Found:    (strength : Int)\n\e[31m   |\e[0m                    \
    \                          Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659799972
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.split(\"\\\\.\").toList.map(x => x.capitalize).mkString\n     \
    \   val strength = extensions_map.getOrElse(class_name_map, -1)\n        val extensions_sorted\
    \ = extensions_map.toSeq.sortBy(_._2).reverse\n        val extensions_sorted =\
    \ extensions_sorted.takeWhile(_._2 > 0).map(_._1).mkString(\".\")\n        val\
    \ extensions_sorted = extensions_sorted.dropWhile(_._2 > 0).mkString(\".\") +\
    \ \".\"\n        val extensions_sorted = extensions_sorted.dropRight(class_name_map.length).dropRight(strength.length)\n\
    \        val extensions_sorted = extensions_sorted.drop(class_name_map.length).drop(strength.length)\n\
    \        val extensions_sorted = extensions_sorted.dropRight(strength.length)\n\
    \        val extensions_sorted = extensions_sorted.drop(strength.length)\n   \
    \     val extensions_sorted = extensions_sorted.dropRight(class_name_map.length)\n\
    \        val extensions_sorted = extensions_sorted.drop(class_name_map.length)\n\
    \        val extensions_sorted = extensions_sorted.dropRight(class_name_map.length)\n\
    \        val extensions_sorted = extensions_sorted.drop(class_name_map.length)\n\
    \        val extensions_sorted = extensions_sorted.dropRight(class_name_map.length)\n\
    \        val extensions_sorted = extensions_sorted.drop(class_name_map.length)\n\
    \        val extensions_sorted = extensions_sorted.dropRight(class_name_map.length)\n\
    \        val extensions_sorted = extensions_sorted.drop(class_name_map.length)\n\
    \        val extensions_sorted = extensions_sorted.dropRight(class_name_map.length)\n\
    \        val extensions_sorted = extensions_sorted.drop(class_name_map.length)\n\
    \        val extensions_sorted = extensions_sorted.dropRight(class_name_map.length)\n\
    \        val extensions_sorted = extensions_sorted.drop(class_name_map.length)\n\
    \        val extensions_sorted = extensions_sorted.dropRight(class_name_map.length)\n\
    \        val extensions_sorted = extensions_sorted.drop(class_name_map.length)\n\
    \        val extensions_sorted = extensions_sorted.dropRight(class_name_map.length)\n\
    \        val extensions_sorted = extensions_sorted.drop(class_name_map.length)\n\
    \        val extensions_sorted = extensions_sorted.dropRight(class_name_map.length)\n\
    \        val extensions_sorted = extensions_sor\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjt7vhgc_.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpjt7vhgc_.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.dropWhile(_._2 > \e[31m0\e[0m).mkString(\e[31m\".\"\e[0m)\
    \ + \e[31m\".\"\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpjt7vhgc_.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.dropRight(class_name_map.length).dropRight(strength.length)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpjt7vhgc_.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.drop(class_name_map.length).drop(strength.length)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659799971
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length = extensions_count_sorted.map(_.length).sum\n\
    \        val extensions_count_sorted_length_sorted = extensions_count_sorted.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sorted_length = extensions_count_sorted_length.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sorted_length_sorted = extensions_count_sorted_length.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9fzzlmr0.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9fzzlmr0.scala:25:90\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_sorted_length_sorted_length\e[0m = extensions_count_sorted_length.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                                                \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                               value sortWith is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp9fzzlmr0.scala:26:97 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sorted_length_sorted\e\
    [0m = extensions_count_sorted_length.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m  \
    \                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   value sortWith is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9fzzlmr0.scala:27:104\
    \ -----------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_sorted_length_sorted_length_sorted_length\e[0m = extensions_count_sorted_length.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                                                \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                   value sortWith is not a member of\
    \ Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9fzzlmr0.scala:28:111 -----------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sorted_length_sorted_length_sorted\e\
    [0m = extensions_count_sorted_length.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m  \
    \                                                                            \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                      value sortWith is not a member of Int\n\e"
  stdout: ''
  timestamp: 1659799642
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = class_name_map.foldLeft(0)((x, y) => (x._2 - y._2))\n        val extensions_sorted\
    \ = extensions_map.toSeq.sortBy(x => x._2).reverse\n        val extensions_sorted\
    \ = extensions_sorted.takeWhile(x => x._2 > strength).reverse\n        val extensions_sorted\
    \ = extensions_sorted.map(x => class_name_map(x._1))\n        val extensions_sorted\
    \ = extensions_sorted.mkString(\".\") + \".\"\n        extensions_sorted.mkString(class_name_map(class_name))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpafx802wm.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mx\e[0m => x._2 > strength).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpafx802wm.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36mx\e[0m => class_name_map(x._1))\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpafx802wm.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\".\"\e[0m) + \e[31m\".\"\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpafx802wm.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: "
  stdout: ''
  timestamp: 1659799971
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') / e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C') / e.toUpperCase.count(_ == 'D')).toMap\n\
    \        val strength = extensions_map.values.max\n        val extensions_sorted\
    \ = extensions_map.toSeq.sortBy(_._1)\n        val extensions_sorted = extensions_sorted.take(strength).map(_._2)\n\
    \        val extensions_sorted = extensions_sorted.mkString(\".\")\n        class_name\
    \ + extensions_sorted\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk4j5dv_h.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.take(strength).map(_._2)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpk4j5dv_h.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\".\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- Error: /tmp/tmpk4j5dv_h.scala:21:181 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) / e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m) / e.toUpperCase.count(_\
    \ == \e[31m'D'\e[0m)).toMap\n\e[31m\e[31m   |\e[0m                           \
    \                                                                            \
    \                                                                            \
    \  ^\e[0m\n\e[31m   |\e[0m                                        Cannot prove\
    \ that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                      \
    \                  where:    K is a type variable\n\e[31m   |\e[0m           \
    \                                       V is a type variable\n\e[31m   |\e[0m\
    \                                        .\n3 errors found\n"
  stdout: ''
  timestamp: 1659799970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase, e.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(c => (c.toUpperCase, c.toLowerCase)).toMap\n        val strengths\
    \ = extensions_map.values.map(_.length - class_name_map.values.map(_.length))\n\
    \        val max_strength = strengths.max\n        val max_key = extensions_map.keys.find(k\
    \ => strengths.contains(k.length - max_strength))\n        val max_value = extensions_map.get(max_key)\n\
    \        max_key match {\n            case Some(key) => key + max_value\n    \
    \        case None => class_name\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphurmxgo_.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mc\e[0m => (c.toUpperCase, c.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmphurmxgo_.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mc\e[0m => (c.toUpperCase, c.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphurmxgo_.scala:23:89\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrengths\e[0m = extensions_map.values.map(_.length - class_name_map.values.map(_.length))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                               ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue length is\
    \ not a member of Nothing, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration\
    \ AsScalaIterator\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.enumeration\
    \ AsScalaIterator\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.iterator\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import concurrent.duration.pairIntToDuration\n\
    \e[31m   |\e[0m  import concurrent.duration.pairLongToDuration\n\e[31m   |\e[0m\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmphu"
  stdout: ''
  timestamp: 1659799972
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((x, y) => x - y)\n        val\
    \ extensions_sorted = extensions_map.values.sortBy(x => x)\n        val extensions_sorted\
    \ = extensions_sorted.takeWhile(x => x < strength)\n        val extensions_sorted\
    \ = extensions_sorted.reverse\n        val extensions_sorted = extensions_sorted.mkString(\"\
    \")\n        class_name + extensions_sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfna_7ur_.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mx\e[0m => x < strength)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpfna_7ur_.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpfna_7ur_.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpfna_7ur_.scala:23:54 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_map.values.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m     \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           value sortBy is not a member of Iterable[Int]\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659799971
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map(x._1) - class_name_map(x._2)).sum\n\
    \        val extensions_sorted = extensions_map.values.sortBy(x => x._1 - x._2)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._1 < strength)\n\
    \        val extensions_sorted = extensions_sorted.map(x => class_name_map(x._1)\
    \ + x._2)\n        extensions_sorted.head\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2mpjoo2c.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mx\e[0m => x._1 < strength)\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2mpjoo2c.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36mx\e[0m => class_name_map(x._1) + x._2)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp2mpjoo2c.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp2mpjoo2c.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2mpjoo2c.scala:23:71\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0"
  stdout: ''
  timestamp: 1659799972
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val strength_str = if (strength == 0) \"0\" else strength.toString\n    \
    \    val extensions_str = extensions.map(_.toString).mkString(\".\")\n       \
    \ val class_name_str = class_name.substring(0, class_name.length - extensions_str.length)\n\
    \        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val strength_str = if (strength == 0) \"0\" else strength.toString\n\
    \        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1)).mkString(\"\
    .\")\n        val extensions_name_str = extensions.map(_.substring(0, 1))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpolocthec.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mstrength_str\e[0m = \e[33mif\e\
    [0m (strength == \e[31m0\e[0m) \e[31m\"0\"\e[0m \e[33melse\e[0m strength.toString\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength_str is already defined as \e[33mvalue\e[0m \e[35mstrength_str\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpolocthec.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mextensions_name_str\e[0m = extensions.map(_.substring(\e\
    [31m0\e[0m, \e[31m1\e[0m)).mkString(\e[31m\".\"\e[0m)\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_name_str is already defined as \e[33mvalue\e[0m\
    \ \e[35mextensions_name_str\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpolocthec.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mextensions_name_str\e[0m\
    \ = extensions.map(_.substring(\e[31m0\e[0m, \e[31m1\e[0m)).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_name_str is already defined as \e[33mvalue\e[0m\
    \ \e[35mextensions_name_str\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpolocthec.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mextensions_name_str\e[0m\
    \ = extensions.map(_.substring(\e[31m0\e[0m, \e[31m1\e[0m)).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_name_str is already defi"
  stdout: ''
  timestamp: 1660009600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((a, b) => math.max(a, b))\n \
    \       val extensions_sorted = extensions_map.values.sortWith((a, b) => a < b)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < strength)\n \
    \       val extensions_sorted = extensions_sorted.mkString(\"\") + \".\" + extensions_sorted.last\n\
    \        className + \".\" + extensions_sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0_u6kgq3.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_ < strength)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0_u6kgq3.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\"\"\e[0m) + \e[31m\".\"\e[0m + extensions_sorted.last\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp0_u6kgq3.scala:23:54 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_map.values.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => a < b)\n\e[31m\e\
    [31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         value sortWith is not a member of\
    \ Iterable[Int]\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0_u6kgq3.scala:26:8\
    \ -------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        className + \e[31m\"\
    .\"\e[0m + extensions_sorted\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m        Not found: className\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.filter(_._2.length == class_name_map.get(_._1)).length\n  \
    \      val extension = extensions_map.filter(_._2.length == class_name_map.get(_._1)).minBy(_._2)\n\
    \        val extension_class = class_name_map.get(extension._1)\n        val extension_name\
    \ = extension._2\n        val extension_class_name = extension_class.substring(extension_class.lastIndexOf(\"\
    .\") + 1)\n        val extension_class_name_with_extension = extension_class_name\
    \ + \".\" + extension_name\n        val extension_class_name_without_extension\
    \ = extension_class_name.substring(0, extension_class_name.lastIndexOf(\".\"))\n\
    \        val extension_class_name_with_extension_without_extension = extension_class_name_without_extension\
    \ + \".\" + extension_name\n        val extension_class_name_with_extension_without_extension_without_extension\
    \ = extension_class_name_with_extension_without_extension + \".\" + extension_name\n\
    \        val extension_class_name_with_extension_without_extension_without_extension_without_extension\
    \ = extension_class_name_with_extension_without_extension + \".\" + extension_name\n\
    \        val extension_class_name_with_extension_without_extension_without_extension_without_extension\
    \ = extension_class_name_with_extension_without_extension + \".\" + extension_name\n\
    \        val extension_class_name_with_extension_without_extension_without_extension_without_extension_without_extension\
    \ = extension_class_name_with_extension_without_extension + \".\" + extension_name\n\
    \        val extension_class_name_with_extension_without_extension_without_extension_without_extension_without_extension\
    \ = extension_class_name_with_extension_without_extension + \".\" + extension_name\n\
    \        val extension_class_name_with_extension_without_extension_without_extension_without_extension_without_extension_without_extension\
    \ = extension_class_name_with_extension_without_extension + \".\" + extension_name\n\
    \        val extension_class_name_with_extension_without_extension_without_extension_without_extension_without_extension_without_extension\
    \ = extension_class_name_with_extension_without_extension + \".\" + extension_name\n\
    \        val extension_class_name_with_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension\
    \ = extension_class_name_with_extension_without_extension + \".\" + extension_name\n\
    \        val extension_class_name_with_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension\
    \ = extension_class_name_with_extension_without_extension\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyz88a_89.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mextension_class_name_with_extension_without_extension_without_extension_without_extension\e\
    [0m = extension_class_name_with_extension_without_extension + \e[31m\".\"\e[0m\
    \ + extension_name\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_class_name_with_extension_without_extension_without_extension_without_extension\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  extension_class_name_with_extension_without_extension_without_extension_without_extension\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpyz88a_89.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mextension_class_name_with_extension_without_extension_without_extension_without_extension_without_extension\e\
    [0m = extension_class_name_with_extension_without_extension + \e[31m\".\"\e[0m\
    \ + extension_name\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_class_name_with_extension_without_extension_without_extension_without_extension_without_extension\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  extension_class_name_with_extension_without_extension_without_extension_without_extension_without_extension\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpyz88a_89.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mextension_class_na"
  stdout: ''
  timestamp: 1660009601
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.getOrElse(class_name, 0)\n        val strongest_extension\
    \ = extensions_map.values.max\n        val class_name_with_strongest_extension\
    \ = class_name + strongest_extension.mkString(\".\") + \".\"\n        val strongest_extension_name\
    \ = strongest_extension.mkString\n        val class_name_with_strongest_extension_with_strongest_extension_name\
    \ = class_name_with_strongest_extension + strongest_extension_name\n        val\
    \ class_name_with_strongest_extension_with_strongest_extension_name_with_strongest_extension_name\
    \ = class_name_with_strongest_extension_with_strongest_extension_name + strongest_extension_name\n\
    \        val class_name_with_strongest_extension_with_strongest_extension_name_with_strongest_extension_name_with_strongest_extension_name\
    \ = class_name_with_strongest_extension_with_strongest_extension_name_with_strongest_extension_name\
    \ + strongest_extension_name + strongest_extension_name\n        val class_name_with_strongest_extension_with_strongest_extension_name_with_strongest_extension_name_with_strongest_extension_name_with_strongest_extension_name\
    \ = class_name_with_strongest_extension_with_strongest_extension_name_with_strongest_extension_name_with_strongest_extension_name\
    \ + strongest_extension_name + strongest_extension_name + strongest_extension_name\n\
    \        val class_name_with_strongest_extension_with_strongest_extension_name_with_strongest_extension_name_with_strongest_extension_name_with_strongest_extension_name_with_strongest_extension_name\
    \ = class_name_with_strongest_extension_with_strongest_extension_name_with_strongest_extension_name_with_strongest_extension_name_with_strongest_extension_name\
    \ + strongest_extension_name + strongest_extension_name + strongest_extension_name\
    \ + strongest_extension_name + strongest_extension_name\n        val class_name_with_strongest_extension_with_strongest_extension_name_with_strongest_extension_name_with_strongest_extension_name_with_strongest_extension_name_with_strongest_extension_name_with_strongest_extension_name\
    \ = class_name_with_strongest_extension_with_strongest_extension_name_with_strongest_extension_name_with_strongest_extension_name_with_strongest_extension_name_with_strongest_extension_name\
    \ + strongest_extension_name + strongest_extension_name + strongest_extension_name\
    \ + strongest_extension_name + strongest_extension_name + strongest_extension\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9r1cp08j.scala:22:48\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.getOrElse(class_name, \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                                                ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                         Found:    (class_name : String)\n\e\
    [31m   |\e[0m                                         Required: Int\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9r1cp08j.scala:24:83 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mclass_name_with_strongest_extension\e\
    [0m = class_name + strongest_extension.mkString(\e[31m\".\"\e[0m) + \e[31m\".\"\
    \e[0m\n\e[31m\e[31m   |\e[0m                                                 \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue mkString\
    \ is not a member of Int - did you mean strongest_extension.toString?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp9r1cp08j.scala:25:59 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mstrongest_extension_name\e\
    [0m = strongest_extension.mkString\n\e[31m\e[31m   |\e[0m                    \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue mkString\
    \ is not a member of Int - did you mean strongest_extension.toString?\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp9r1cp08j.scala:32:5 ---------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009601
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpa8f1qs06.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa8f1qs06.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions_sorted.takeWhile(_._2 > \e[31m0\e\
    [0m).map(_._1)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpa8f1qs06.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpa8f1qs06.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpa8f1qs06.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_low\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpeyrb48xe.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpeyrb48xe.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_upper\e[0m = extensions.map(_.toUpperCase.length).sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_upper is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_upper\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpeyrb48xe.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_lower\e\
    [0m = extensions.map(_.toLowerCase.length).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_lower is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_lower\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpeyrb48xe.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_count_upper\
    \ - extensions_count_lower\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength is already defined as \e[33mvalue\e[0m \e[35mstrength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpeyrb48xe.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mclass_name_upper\e[0m = class_name.toUpperCase\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mclass_name_upper is already defin"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n     \
    \   val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        class_name + extensions_sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5z3ml9ao.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp5z3ml9ao.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.dropWhile(_._2 > \e[31m0\e[0m).map(_._1).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009596
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (class_name_map(x._1) - class_name_map(x._2)).sum)\n\
    \        val strongest_extension = extensions_map.values.find(x => x._2 == strength)._1.toString\n\
    \        strongest_extension\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\",\
    \ \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppw86x_z6.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmppw86x_z6.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppw86x_z6.scala:23:72\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = extensions_map.values.map(\e[36mx\e[0m => (class_name_map(x._1)\
    \ - class_name_map(x._2)).sum)\n\e[31m\e[31m   |\e[0m                        \
    \                                              ^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                  value _1 is not a member of String\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmppw86x_z6.scala:23:95 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e\
    [36mx\e[0m => (class_name_map(x._1) - class_name_map(x._2)).sum)\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                          ^^^^\e[0m\n\e[31m   |\e[0m                        \
    \              value _2 is not a member of String\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmppw86x_z6.scala:24:68 ------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mstrongest_extension\e[0m = extensions_map.values.find(\e\
    [36mx\e[0m => x._2 == strength)._1.toString\n\e[31m\e[31m   |\e[0m           \
    \                                                       ^^^^\e[0m\n\e[31m   |\e\
    [0m                   "
  stdout: ''
  timestamp: 1660009600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase).zipWithIndex.toMap\n        val class_name_map\
    \ = class_name.zipWithIndex.toMap\n        val extensions_count = extensions_map.size\n\
    \        val class_name_count = class_name_map.size\n        val extensions_strength\
    \ = extensions_count - class_name_count\n        val class_name_strength = class_name_map.get(class_name_strength).map(_._2)\n\
    \        val extensions_strength_sorted = extensions_strength.sorted\n       \
    \ val class_name_strength_sorted = class_name_strength.sorted\n        val extensions_strength_sorted.headOption.map(e\
    \ => class_name_strength_sorted.find(_ > e).get)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpn9yvmwy7.scala:29:56 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m extensions_strength_sorted.headOption.map(e\
    \ => class_name_strength_sorted.find(_ > e).get)\n\e[31m\e[31m   |\e[0m      \
    \                                                  ^^\e[0m\n\e[31m   |\e[0m  \
    \                                          ')' expected, but '=>' found\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmpn9yvmwy7.scala:30:4 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpn9yvmwy7.scala:26:53\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclass_name_strength\e[0m = class_name_map.get(class_name_strength).map(_._2)\n\
    \e[31m\e[31m   |\e[0m                                                     ^\e\
    [0m\n\e[31m   |\e[0m                          Recursive \e[33mvalue\e[0m \e[35mclass_name_strength\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn9yvmwy7.scala:26:80\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_strength\e[0m = class_name_map.get(class_name_strength).map(_._2)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                      ^^^^\e[0m\n\e[31m   |\e[0m                            \
    \             value _2 is not a member of Int\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpn9yvmwy7.scala:27:61 ------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_strength_sorted\e[0m = extensions_strength.sorted\n\
    \e[31m\e[31m   |\e[0m                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     value sorted is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn9yvmwy7.scala:28:61\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_strength_sorted\e[0m = class_name_strength.sorted\n\e[31m\e"
  stdout: ''
  timestamp: 1660009600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count - extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val\
    \ strength_upper = extensions_count_upper - extensions_count_lower\n        val\
    \ extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val strength_lower\
    \ = extensions_count_lower - extensions_count_upper\n        if (strength_upper\
    \ > strength_lower) {\n            class_name + extensions.map(_.toUpperCase).sum\
    \ + \".\" + extensions.map(_.toLowerCase).sum\n        } else {\n            class_name\
    \ + extensions.map(_.toLowerCase).sum + \".\" + extensions.map(_.toUpperCase).sum\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj1s_q_ns.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_upper\e\
    [0m = extensions.map(_.toUpperCase).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_upper is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_upper\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj1s_q_ns.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_lower\e\
    [0m = extensions.map(_.toLowerCase).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_lower is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_lower\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj1s_q_ns.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_lower\e\
    [0m = extensions.map(_.toLowerCase).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_lower is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_lower\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- Error: /tmp/tmpj1s_q_ns.scala:31:58 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            class_name + extensions.map(_.toUpperCase).sum\
    \ + \e[31m\".\"\e[0m + extensions.map(_.toLowerCase).sum\n\e[31m\e[31m   |\e[0m\
    \                                                          ^\e[0m\n\e[31m   |\e\
    [0m                No implicit Ordering defined for B\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m                where:    B is a type variable with constraint >: String\n\
    \e[31m   |\e[0m                "
  stdout: ''
  timestamp: 1660009601
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.foldLeft(0)((acc, x) => acc + (class_name_map(x._1) - class_name_map(x._2)))\n\
    \        val extensions_sorted = extensions_map.toSeq.sortBy(x => x._2).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 != class_name_map(x._1))\n\
    \        val extensions_sorted = extensions_sorted.map(x => class_name_map(x._1)\
    \ + x._2)\n        val extensions_sorted = extensions_sorted.mkString(\".\")\n\
    \        val extensions_sorted = extensions_sorted.dropRight(class_name_map(extensions_sorted.last).length)\n\
    \        extensions_sorted + class_name_map(extensions_sorted.last)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"\
    ), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6d84t225.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mx\e[0m => x._2 != class_name_map(x._1))\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6d84t225.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36mx\e[0m => class_name_map(x._1) + x._2)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6d84t225.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\".\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6d84t225.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.dropRight(class_name_map(extensions_sorted.last).length)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0"
  stdout: ''
  timestamp: 1660009601
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val sorted_extensions = extensions_map.toSeq.sortBy(_._1).reverse\n\
    \        val first_extension = sorted_extensions.head\n        val first_extension_strength\
    \ = extensions_map.getOrElse(first_extension, 0)\n        val first_extension_strength_diff\
    \ = first_extension_strength - strength\n        if (first_extension_strength_diff\
    \ == 0) {\n            class_name\n        } else if (first_extension_strength_diff\
    \ < 0) {\n            class_name + \".\" + first_extension\n        } else {\n\
    \            class_name + \".\" + first_extension + sorted_extensions.last\n \
    \       }\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpaabtu47v.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n1 error found\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs).max\n    \
    \    val extensions_sorted = extensions_map.values.sortBy(x => x - class_name_map.get(x))\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x < strength)\n\
    \        val extensions_sorted = extensions_sorted.mkString(\".\")\n        extensions_sorted\
    \ + class_name_map.get(extensions_sorted.last)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdker3k0x.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mx\e[0m => x < strength)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpdker3k0x.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\".\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpdker3k0x.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpdker3k0x.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdker3k0x.scala:23:57\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = extensions_map.values.map(\e[36mx\e[0m => (x - class"
  stdout: ''
  timestamp: 1660009602
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x.toUpperCase, x.toLowerCase)).foldLeft(0)((x,\
    \ y) => math.max(x, y))\n        val class_name_with_strength = class_name_map.values.map(x\
    \ => (x.toUpperCase, x.toLowerCase)).foldLeft(\"\")((x, y) => x + \".\" + y)\n\
    \        val strength_of_extension = extensions_map.values.map(x => (x.toUpperCase,\
    \ x.toLowerCase)).foldLeft(0)((x, y) => math.max(x, y))\n        val strength_of_class\
    \ = class_name_map.values.map(x => (x.toUpperCase, x.toLowerCase)).foldLeft(0)((x,\
    \ y) => math.max(x, y))\n        val strength_of_extension_of_class = class_name_map.values.map(x\
    \ => (x.toUpperCase, x.toLowerCase)).foldLeft(0)((x, y) => math.max(x, y))\n \
    \       val strength_of_extension_of_class_with_strength = class_name_map.values.map(x\
    \ => (x.toUpperCase, x.toLowerCase)).foldLeft(0)((x, y) => math.max(x, y))\n \
    \       val strength_of_extension_of_class_with_strength_of_extension = class_name_map.values.map(x\
    \ => (x.toUpperCase, x.toLowerCase)).foldLeft(0)((x, y) => math.max(x, y))\n \
    \       val strength_of_extension_of_class_with_strength_of_extension_of_class\
    \ = class_name_map.values.map(x => (x.toUpperCase, x.toLowerCase)).foldLeft(0)((x,\
    \ y) => math.max(x, y))\n        val strength_of_extension_of_class_with_strength_of_extension_of_class_with_strength\
    \ = class_name_map.values.map(x => (x.toUpperCase, x.toLowerCase)).foldLeft(0)((x,\
    \ y) => math.max(x, y))\n        val strength_of_extension_of_class_with_strength_of_extension_of_class_with_strength_of_extension\
    \ = class_name_map.values.map(x => (x.toUpperCase, x.toLowerCase)).foldLeft(0)((x,\
    \ y) => math.max(x, y))\n        val strength_of_extension_of_class_with_strength_of_extension_of_class_with_strength_of_extension_of_class\
    \ = class_name_map.values.map(x => (x.toUpperCase, x.toLowerCase)).foldLeft(0)((x,\
    \ y) => math.max(x, y))\n        val strength_of_extension_of_class_with_strength_of_extension_of_class_with_strength_of_extension_of_class_with_strength\
    \ = class_name_map.\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmmbdqo6y.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpmmbdqo6y.scala:22:52 ------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e[36mx\e\
    [0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m          \
    \                                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                              value toUpperCase is not a member of Char\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpmmbdqo6y.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpmmbdqo6y.scala:23:113\
    \ ----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstrength\e[0m = extensions_map.values.map(\e[36mx\e[0m => (x.toUpperCase,\
    \ x.toLowerCase)).foldLeft(\e[31m0\e[0m)((\e[36mx\e[0m, \e[36my\e[0m) => math.max(x,\
    \ y))\n\e[31m\e[31m   |\e[0m                                                 \
    \                                                           ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e\
    [0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e\
    [31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\
    \e[31m   |\e[0mmatch arguments ((x : Int), (y : (String, String)))\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpmmbdqo6y.scala:24:73 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mclass_name_with_strength\e\
    [0m = class_name_map.values.map(\e[36mx\e[0m => (x.toUpperCase, x.toLowerCase)).foldLef"
  stdout: ''
  timestamp: 1660009602
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n     \
    \   val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.replaceAll(\"\\\\W\",\
    \ \"\")\n        class_name + extensions_sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk_zmnm3m.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpk_zmnm3m.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.replaceAll(\e[31m\"\\\\W\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009595
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x.toUpperCase, x.toLowerCase)).foldLeft(0)((x,\
    \ y) => math.max(x, y))\n        val class_name_with_strength = class_name_map.values.map(x\
    \ => (x.toUpperCase, x.toLowerCase)).foldLeft(\"\")((x, y) => x + \".\" + y)\n\
    \        val strength_str = strength.map(x => x.toUpperCase).foldLeft(\"\")((x,\
    \ y) => x + \".\" + y)\n        val class_name_with_strength_str = class_name_with_strength.map(x\
    \ => x.toUpperCase).foldLeft(\"\")((x, y) => x + \".\" + y)\n        val strength_str_with_extension\
    \ = strength_str + class_name_with_strength_str\n        val class_name_with_strength_str_with_extension\
    \ = class_name_with_strength_str + strength_str\n        val strength_str_with_extension_str\
    \ = strength_str_with_extension + class_name_with_strength_str_with_extension\n\
    \        val class_name_with_strength_str_with_extension_str = class_name_with_strength_str_with_extension\
    \ + strength_str_with_extension\n        val strength_str_with_extension_str_with_extension\
    \ = strength_str_with_extension_str + class_name_with_strength_str_with_extension_str\n\
    \        val class_name_with_strength_str_with_extension_str_with_extension =\
    \ class_name_with_strength_str_with_extension_str_with_extension + strength_str_with_extension_str_with_extension\n\
    \        val strength_str_with_extension_str_with_extension_str = strength_str_with_extension_str_with_extension\
    \ + class_name_with_strength_str_with_extension_str_with_extension\n        val\
    \ class_name_with_strength_str_with_extension_str_with_extension_str = class_name_with_strength_str_with_extension_str_with_extension\
    \ + strength_str_with_extension_str_with_extension_str\n        val strength_str_with_extension_str_with_extension_str_with_extension\
    \ = strength_str_with_extension_str_with_extension_str + class_name_with_strength_str_with_extension_str_with_extension_str\n\
    \        val class_name_with_strength_str_with_extension_str_with_extension_str_with_extension\
    \ = class_name_with_strength_str_with_extension_str_with_extension_str + strength_str_with_extension_str_with_extension_str_with_extension\n\
    \        val strength_str_with_extension_str_with_extension_str_with_extension_str\
    \ = strength_\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl3khor3g.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpl3khor3g.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpl3khor3g.scala:23:113\
    \ ----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstrength\e[0m = extensions_map.values.map(\e[36mx\e[0m => (x.toUpperCase,\
    \ x.toLowerCase)).foldLeft(\e[31m0\e[0m)((\e[36mx\e[0m, \e[36my\e[0m) => math.max(x,\
    \ y))\n\e[31m\e[31m   |\e[0m                                                 \
    \                                                           ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e\
    [0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e\
    [31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\
    \e[31m   |\e[0mmatch arguments ((x : Int), (y : (String, String)))\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpl3khor3g.scala:24:73 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mclass_name_with_strength\e\
    [0m = class_name_map.values.map(\e[36mx\e[0m => (x.toUpperCase, x.toLowerCase)).foldLeft(\e\
    [31m\"\"\e[0m)((\e[36mx\e[0m, \e[36my\e[0m) => x + \e[31m\".\"\e[0m + y)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                "
  stdout: ''
  timestamp: 1660009601
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((a, b) => math.max(a, b))\n \
    \       val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n  \
    \      val extensions_sorted = extensions_sorted.takeWhile(_._2 > strength).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.mkString(\"\") + \".\" + extensions_sorted.last\n\
    \        class_name + extensions_sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp997cwp2t.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > strength).map(_._1)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp997cwp2t.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\"\"\e[0m) + \e[31m\".\"\e[0m + extensions_sorted.last\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009596
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n     \
    \   val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        class_name + extensions_sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpspdwvxf2.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpspdwvxf2.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.dropWhile(_ == \e[31m'.'\e[0m).dropRight(\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpspdwvxf2.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.dropWhile(_ == \e[31m'.'\e[0m).dropRight(\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009596
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val extensions_count\
    \ = extensions_map.size\n        val class_name_count = class_name_map.size\n\
    \        val strength = extensions_count - class_name_count\n        if (strength\
    \ > 0) class_name_map(extensions_map.maxBy(_._2)._1)\n        else class_name_map(extensions_map.minBy(_._2)._1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqt91csb5.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpqt91csb5.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqt91csb5.scala:26:68\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (strength\
    \ > \e[31m0\e[0m) class_name_map(extensions_map.maxBy(_._2)._1)\n\e[31m\e[31m\
    \   |\e[0m                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                         Found:    String\n\
    \e[31m   |\e[0m                                         Required: Nothing\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqt91csb5.scala:27:55\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m class_name_map(extensions_map.minBy(_._2)._1)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Found:    String\n\e[31m   |\e\
    [0m                            Required: Nothing\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.max\n        val extensions_sorted =\
    \ extensions_map.values.sortWith(_ < _)\n        val extensions_sorted = extensions_sorted.takeWhile(_\
    \ < strength)\n        val extensions_sorted = extensions_sorted.mkString(\"\"\
    ) + extensions_sorted.last\n        class_name + \".\" + extensions_sorted\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1v9ooart.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_ < strength)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1v9ooart.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\"\"\e[0m) + extensions_sorted.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp1v9ooart.scala:23:54 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_map.values.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m               \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                  value sortWith is not a member of Iterable[Int]\n3 errors found\n"
  stdout: ''
  timestamp: 1660009600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val extensions_count_cap = extensions.map(_.toUpperCase.length).sum -\
    \ extensions.map(_.toLowerCase.length).sum\n        val extensions_count_sm =\
    \ extensions.map(_.toLowerCase.length).sum - extensions.map(_.toUpperCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower - extensions_count_cap\
    \ - extensions_count_sm\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions_sorted.take(1)\n\
    \        val extensions_sorted = extensions_sorted.mkString(\".\") + \".\" + extensions_sorted.mkString(\"\
    .\") + \".\"\n        class_name + extensions_sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp018z3rei.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.take(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp018z3rei.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\".\"\e[0m) + \e[31m\".\"\e[0m + extensions_sorted.mkString(\e\
    [31m\".\"\e[0m) + \e[31m\".\"\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp018z3rei.scala:27:62 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength - a.length - b.length)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                                     Found:    Int\n\e[31m   |\e[0m         \
    \                                              Required: Boolean\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((a, b) => math.max(a, b))\n \
    \       val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n  \
    \      val extension_first = extensions_sorted.head._2\n        val extension_last\
    \ = extensions_sorted.last._2\n        val extension_strength = extensions_sorted.map(x\
    \ => x._1).reduce((a, b) => math.max(a, b))\n        val extension_strength_first\
    \ = extensions_sorted.map(x => x._1).reduce((a, b) => math.min(a, b))\n      \
    \  val extension_strength_last = extensions_sorted.map(x => x._1).reduce((a, b)\
    \ => math.max(a, b))\n        val extension_strength_first_last = extensions_sorted.map(x\
    \ => x._1).reduce((a, b) => math.min(a, b))\n        val extension_strength_first_last_first\
    \ = extensions_sorted.map(x => x._1).reduce((a, b) => math.max(a, b))\n      \
    \  val extension_strength_first_last_last_first = extensions_sorted.map(x => x._1).reduce((a,\
    \ b) => math.min(a, b))\n        val extension_strength_first_last_last_last_first\
    \ = extensions_sorted.map(x => x._1).reduce((a, b) => math.max(a, b))\n      \
    \  val extension_strength_first_last_last_last_last_first = extensions_sorted.map(x\
    \ => x._1).reduce((a, b) => math.min(a, b))\n        val extension_strength_first_last_last_last_last_last_first\
    \ = extensions_sorted.map(x => x._1).reduce((a, b) => math.max(a, b))\n      \
    \  val extension_strength_first_last_last_last_last_last_last_first = extensions_sorted.map(x\
    \ => x._1).reduce((a, b) => math.min(a, b))\n        val extension_strength_first_last_last_last_last_last_last_last_first\
    \ = extensions_sorted.map(x => x._1).reduce((a, b) => math.max(a, b))\n      \
    \  val extension_strength_first_last_last_last_last_last_last_last_last_first\
    \ = extensions_sorted.map(x => x._1).reduce((a, b) => math.min(a, b))\n      \
    \  val extension_strength_first_last_last_last_last_last_last_last_last_last_first\
    \ = extensions_sorted.map(x => x._1).reduce((a, b) => math.max(a, b))\n      \
    \  val extension_strength_first_last_last_last_last_last_last_last_last_last_first\
    \ = extensions_sorted.map(x => x._1).reduce((a, b) => math.min(a, b))\n      \
    \  \n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp13_l9r61.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mextension_strength_first_last_last_last_last_last_last_last_last_last_first\e\
    [0m = extensions_sorted.map(\e[36mx\e[0m => x._1).reduce((\e[36ma\e[0m, \e[36mb\e\
    [0m) => math.min(a, b))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_strength_first_last_last_last_last_last_last_last_last_last_first\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  extension_strength_first_last_last_last_last_last_last_last_last_last_first\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp13_l9r61.scala:41:5 ---------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.map(_.length).sort\n\
    \        val extensions_count_sorted_reversed = extensions_count_sorted.reverse\n\
    \        val extensions_count_sorted_reversed_sorted = extensions_count_sorted_reversed.sort\n\
    \        val extensions_count_sorted_reversed_sorted_reversed = extensions_count_sorted_reversed_sorted.reverse\n\
    \        val extensions_count_sorted_reversed_sorted_reversed_sorted = extensions_count_sorted_reversed_sorted_reversed.sort\n\
    \        val extensions_count_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = extensions_count_sorted_reversed_sorted_reversed_sorted.reverse\n        val\
    \ extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed.sort\n\
    \        val extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sort\n\
    \        val extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.sort\n\
    \        val extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.sort\n\
    \        val extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf4k3g17v.scala:22:63 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions.map(_.length).sort\n\e[31m\e[31m   |\e[0m                   \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue sort\
    \ is not a member of List[Int] - did you mean List[Int].sortBy?\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpf4k3g17v.scala:32:118 --------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\e\
    [0m = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.sort\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                              ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpf4k3g17v.scala:34:134 --------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\e\
    [0m = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.sort\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \  ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m \
    \ extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpf4k3g17v.s"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((x, y) => x.toDouble - y.toDouble)\n\
    \        val strongest_extension = extensions_map.values.minBy(x => x._1)._2\n\
    \        val class_name_with_strongest_extension = class_name + \".\" + strongest_extension\n\
    \        val class_name_with_strongest_extension_lowercase = class_name_with_strongest_extension.toLowerCase\n\
    \        val class_name_with_strongest_extension_uppercase = class_name_with_strongest_extension.toUpperCase\n\
    \        val class_name_with_strongest_extension_lowercase = class_name_with_strongest_extension_lowercase\n\
    \        val class_name_with_strongest_extension_uppercase = class_name_with_strongest_extension_uppercase\n\
    \        val class_name_with_strongest_extension_lowercase = class_name_with_strongest_extension_lowercase\n\
    \        val class_name_with_strongest_extension_uppercase = class_name_with_strongest_extension_uppercase\n\
    \        val class_name_with_strongest_extension_lowercase = class_name_with_strongest_extension_lowercase\n\
    \        val class_name_with_strongest_extension_uppercase = class_name_with_strongest_extension_uppercase\n\
    \        val class_name_with_strongest_extension_lowercase = class_name_with_strongest_extension_lowercase\n\
    \        val class_name_with_strongest_extension_uppercase = class_name_with_strongest_extension_uppercase\n\
    \        val class_name_with_strongest_extension_lowercase = class_name_with_strongest_extension_lowercase\n\
    \        val class_name_with_strongest_extension_uppercase = class_name_with_strongest_extension_uppercase\n\
    \        val class_name_with_strongest_extension_lowercase = class_name_with_strongest_extension_lowercase\n\
    \        val class_name_with_strongest_extension_uppercase = class_name_with_strongest_extension_uppercase\n\
    \        val class_name_with_strongest_extension_lowercase = class_name_with_strongest_extension_lowercase\n\
    \        val class_name_with_strongest_extension_uppercase = class_name_with_strongest_extension_uppercase\n\
    \        val class_name_with_strongest_extension_lowercase = class_name_with_strongest_extension_lowercase\n\
    \        val class_name_with_strongest_extension_uppercase = class_name_with_strongest_extension_uppercase\n\
    \        val class_name_with_strongest_extension_lowercase = class_name_with_strongest_extension_lowercase\n\
    \        val class_name_with_strongest_extension_uppercase = class_name_\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9z093mw6.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mclass_name_with_strongest_extension_lowercase\e\
    [0m = class_name_with_strongest_extension_lowercase\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclass_name_with_strongest_extension_lowercase is already defined\
    \ as \e[33mvalue\e[0m \e[35mclass_name_with_strongest_extension_lowercase\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9z093mw6.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36mclass_name_with_strongest_extension_uppercase\e\
    [0m = class_name_with_strongest_extension_uppercase\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclass_name_with_strongest_extension_uppercase is already defined\
    \ as \e[33mvalue\e[0m \e[35mclass_name_with_strongest_extension_uppercase\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9z093mw6.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36mclass_name_with_strongest_extension_lowercase\e\
    [0m = class_name_with_strongest_extension_lowercase\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclass_name_with_strongest_extension_lowercase is already defined\
    \ as \e[33mvalue\e[0m \e[35mclass_name_with_strongest_extension_lowercase\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9z093mw6.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mclass_name_"
  stdout: ''
  timestamp: 1660009611
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(_.toUpperCase).zipWithIndex.toMap\n        val class_name_map\
    \ = class_name.zipWithIndex.toMap\n        val extensions_count = extensions_map.size\n\
    \        val class_name_count = class_name_map.size\n        val strength = extensions_count\
    \ - class_name_count\n        val extensions_sorted = extensions_map.toSeq.sortBy(_._2).reverse\n\
    \        val class_name_sorted = class_name_map.toSeq.sortBy(_._2).reverse\n \
    \       val extensions_first = extensions_sorted.head._1\n        val class_name_first\
    \ = class_name_sorted.head._1\n        val extensions_last = extensions_sorted.last._1\n\
    \        val class_name_last = class_name_sorted.last._1\n        val extensions_first_index\
    \ = extensions_sorted.indexOf((extensions_first, 0))\n        val class_name_first_index\
    \ = class_name_sorted.indexOf((class_name_first, 0))\n        val extensions_last_index\
    \ = extensions_sorted.indexOf((extensions_last, 0))\n        val class_name_last_index\
    \ = class_name_sorted.indexOf((class_name_last, 0))\n        val extensions_first_strength\
    \ = extensions_sorted.take(extensions_first_index).last._2\n        val class_name_first_strength\
    \ = class_name_sorted.take(class_name_first_index).last._2\n        val extensions_last_strength\
    \ = extensions_sorted.take(extensions_last_index).last._2\n        val class_name_last_strength\
    \ = class_name_sorted.take(class_name_last_index).last._2\n        val extensions_first_strength_int\
    \ = extensions_first_strength.toInt\n        val class_name_first_strength_int\
    \ = class_name_first_strength.toInt\n        val extensions_last_strength_int\
    \ = extensions_last_strength.toInt\n        val class_name_last_strength_int =\
    \ class_name_last_strength.toInt\n        val strength_int = strength.toInt\n\
    \        val extensions_first_strength_str = extensions_first_strength_int.toString\n\
    \        val class_name_first_strength_str = class_name_first_strength_int.toString\n\
    \        val extensions_last_strength_str = extensions_last_strength_int.toString\n\
    \        val class_name_last_strength_str = class_name_last_strength_int.toString\n\
    \        val extensions_first_strength_str_upper = extensions_first_strength_str.toUpperCase\n\
    \        val class_name_first_strength_str_upper = class_name_first_strength_str.toUpperCase\n\
    \        val extensions_last_strength_str_upper = extensions_last_strength_str.toUpperCase\n\
    \        val class_name_last_strength_str_upper = class_name_last_strength_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyeyerif6.scala:52:49 ------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mclass_name_last_strength_str_upper\e\
    [0m = class_name_last_strength_\n\e[31m\e[31m   |\e[0m                       \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                 Not found: class_name_last_strength_\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyeyerif6.scala:53:5 ---------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009609
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase).zipWithIndex.toMap\n        val class_name_map\
    \ = class_name.zipWithIndex.toMap\n        val strength = extensions_map.foldLeft(0)((s,\
    \ e) => s + (class_name_map(e._2) - class_name_map(e._1)))\n        val extensions_sorted\
    \ = extensions_map.toSeq.sortBy(_._2).reverse\n        val extensions_sorted =\
    \ extensions_sorted.takeWhile(_._2 != strength)\n        val extensions_sorted\
    \ = extensions_sorted.map(_._1).toList + extensions_sorted.last\n        extensions_sorted.mkString(class_name\
    \ + \".\")\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp52_qi6i7.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 != strength)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e[35mextensions_sorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp52_qi6i7.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m = extensions_sorted.map(_._1).toList\
    \ + extensions_sorted.last\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp52_qi6i7.scala:23:82 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.foldLeft(\e\
    [31m0\e[0m)((\e[36ms\e[0m, \e[36me\e[0m) => s + (class_name_map(e._2) - class_name_map(e._1)))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                        ^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                                Found:    Int\n\e[31m   |\e[0m              \
    \                                            Required: Char\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp52_qi6i7.scala:23:105 -------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.foldLeft(\e\
    [31m0\e[0m)((\e[36ms\e[0m, \e[36me\e[0m) => s + (class_name_map(e._2) - class_name_map(e._1)))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  "
  stdout: ''
  timestamp: 1660009610
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.getOrElse(class_name, 0)\n        val extensions_sorted\
    \ = extensions_map.toSeq.sortBy(_._1).reverse\n        val extension_first = extensions_sorted.head._2\n\
    \        val extension_last = extensions_sorted.last._2\n        val extension_strength\
    \ = extensions_map.getOrElse(class_name, 0)\n        val extension_strength_sorted\
    \ = extensions_map.toSeq.sortBy(_._1).reverse\n        val extension_strength_first\
    \ = extensions_strength_sorted.head._2\n        val extension_strength_last =\
    \ extensions_strength_sorted.last._2\n        val extension_strength_strength\
    \ = extensions_map.getOrElse(class_name, 0)\n        val extension_strength_strength_sorted\
    \ = extensions_map.toSeq.sortBy(_._1).reverse\n        val extension_strength_strength_first\
    \ = extensions_strength_strength_sorted.head._2\n        val extension_strength_strength_last\
    \ = extensions_strength_strength_sorted.last._2\n        val extension_strength_strength_strength\
    \ = extensions_map.getOrElse(class_name, 0)\n        val extension_strength_strength_strength_sorted\
    \ = extensions_map.toSeq.sortBy(_._1).reverse\n        val extension_strength_strength_strength_first\
    \ = extensions_strength_strength_strength_sorted.head._2\n        val extension_strength_strength_strength_last\
    \ = extensions_strength_strength_strength_sorted.last._2\n        val extension_strength_strength_strength_strength\
    \ = extensions_map.getOrElse(class_name, 0)\n        val extension_strength_strength_strength_strength_sorted\
    \ = extensions_map.toSeq.sortBy(_._1).reverse\n        val extension_strength_strength_strength_strength_first\
    \ = extensions_strength_strength_strength_strength_sorted.head._2\n        val\
    \ extension_strength_strength_strength_strength_last = extensions_strength_strength_strength_sorted.last._2\n\
    \        val extension_strength_strength_strength_strength_strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val extension_strength_strength_strength_strength_strength_sorted\
    \ = extensions_map.toSeq.sortBy(_._1).reverse\n        val extension_strength_strength_strength_strength_strength_first\
    \ = extensions_strength_\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpautl40jg.scala:22:48\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.getOrElse(class_name, \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                                                ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                         Found:    (class_name : String)\n\e\
    [31m   |\e[0m                                         Required: Int\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpautl40jg.scala:26:58 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextension_strength\e[0m\
    \ = extensions_map.getOrElse(class_name, \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                                                          ^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                         Found:    (class_name :\
    \ String)\n\e[31m   |\e[0m                                         Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpautl40jg.scala:28:39\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mextension_strength_first\e[0m = extensions_strength_sorted.head._2\n\e[31m\e\
    [31m   |\e[0m                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   Not found: extensions_strength_sorted\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpautl40jg.scala:29:38\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mextension_strength_last\e[0m = extensions_strength_sorted.last._2\n\e[31m\e\
    [31m   |\e[0m                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   Not found: extensions_strength_sorted\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tm"
  stdout: ''
  timestamp: 1660009610
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((a, b) => math.max(a, b))\n \
    \       val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n  \
    \      val extension_strength = extensions_sorted.head._2\n        val extension_class\
    \ = extensions_sorted.head._1\n        val extension_class_name = extension_class.split(\"\
    \\\\W\").last\n        val extension_class_name_with_extension = extension_class_name\
    \ + extension_extension\n        val extension_class_name_with_extension_strength\
    \ = extension_class_name_with_extension + extension_strength\n        val extension_class_name_with_extension_strength_sorted\
    \ = extension_class_name_with_extension_strength.split(\"\\\\W\").last\n     \
    \   val extension_class_name_with_extension_strength_sorted_with_extension = extension_class_name_with_extension_strength_sorted\
    \ + extension_extension\n        val extension_class_name_with_extension_strength_sorted_with_extension_sorted\
    \ = extension_class_name_with_extension_strength_sorted_with_extension.split(\"\
    \\\\W\").last\n        val extension_class_name_with_extension_strength_sorted_with_extension_sorted_with_extension\
    \ = extension_class_name_with_extension_strength_sorted_with_extension_sorted\
    \ + extension_extension\n        val extension_class_name_with_extension_strength_sorted_with_extension_sorted_with_extension_sorted\
    \ = extension_class_name_with_extension_strength_sorted_with_extension_sorted_with_extension\
    \ + extension_extension\n        val extension_class_name_with_extension_strength_sorted_with_extension_sorted_with_extension_sorted_with_extension\
    \ = extension_class_name_with_extension_strength_sorted_with_extension_sorted_with_extension_sorted\
    \ + extension_extension\n        val extension_class_name_with_extension_strength_sorted_with_extension_sorted_with_extension_sorted_with_extension_sorted\
    \ = extension_class_name_with_extension_strength_sorted_with_extension_sorted_with_extension_sorted_with_extension\
    \ + extension_extension\n        val extension_class_name_with_extension_strength_sorted_with_extension_sorted_with_extension_sorted_with_extension_sorted_with_extension\
    \ = extension_class_name_with_extension_strength_sorted_with_extension_sorted_with_extension_sorted_with_extension_sorted_with_extension\
    \ + extension_extension\n        val extension_class_name_with_extension_strength_sorted_with_extension_sorted_with_extension_sorted_with_extension_sorted_with_extension_sorted_with_extension\
    \ = extension_class_name_with_extension_strength_sorted_with_extension_sorted_with_extension_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpphfd5lss.scala:26:51 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextension_class_name\e[0m\
    \ = extension_class.split(\e[31m\"\\\\W\"\e[0m).last\n\e[31m\e[31m   |\e[0m  \
    \                                 ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                   value split is not a member of Int\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpphfd5lss.scala:36:147 --------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mextension_class_name_with_extension_strength_sorted_with_extension_sorted_with_extension_sorted_with_extension_sorted_with_extension\e\
    [0m = extension_class_name_with_extension_strength_sorted_with_extension_sorted_with_extension_sorted_with_extension_sorted_with_extension\
    \ + extension_extension\n\e[31m\e[31m   |\e[0m                               \
    \                                                                            \
    \                                        ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35m\n\e[31m   |\e[0m  extension_class_name_with_extension_strength_sorted_with_extension_sorted_with_extension_sorted_with_extension_sorted_with_extension\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpphfd5lss.scala:37:169 -----------------------\e[0m\e[0m\n\e[31m37 |\e\
    [0m        \e[33mval\e[0m \e[36mextension_class_name_with_extension_strength_sorted_with_extension_sorted_with_extension_sorted_with_extension_sorted_with_extension_sorted_with_extension\e\
    [0m = extension_class_name_with_extension_strength_sorted_with_extension_sorted_with_extension_\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: extension_class_name_with_extension_strength_sorted_with_extension_sorte"
  stdout: ''
  timestamp: 1660009613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = class_name_map.foldLeft(0) { (acc, x) => acc + (x._2 - x._1) }\n        val\
    \ extensions_sorted = extensions_map.toSeq.sortBy(x => x._2).reverse\n       \
    \ val extension_strength = extensions_sorted.foldLeft(0) { (acc, x) => acc + (x._2\
    \ - x._1) }\n        val strength_diff = strength - extension_strength\n     \
    \   val extension_sorted = extensions_sorted.takeWhile(x => strength_diff >= x._2).reverse\n\
    \        val extension_sorted = extension_sorted.take(1).mkString.concat(\".\"\
    ).concat(extension_sorted.last)\n        class_name_map.get(extension_sorted)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppuuhdie3.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextension_sorted\e[0m =\
    \ extension_sorted.take(\e[31m1\e[0m).mkString.concat(\e[31m\".\"\e[0m).concat(extension_sorted.last)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextension_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmppuuhdie3.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmppuuhdie3.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppuuhdie3.scala:23:76\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = class_name_map.foldLeft(\e[31m0\e[0m) { (\e[36macc\e[0m, \e\
    [36mx\e[0m) => acc + (x._2 - x._1) }\n\e[31m\e[31m   |\e[0m                  \
    \                                                     ^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue - is not a member of Nothing, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.b"
  stdout: ''
  timestamp: 1660009615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.filter(_._2 > class_name_map.get(_._2)).map(_._1).length\n\
    \        val extension = extensions_map.filter(_._2 == class_name_map.get(_._2)).map(_._1).head\n\
    \        s\"$class_name.$extension\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptdvtjjjp.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmptdvtjjjp.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmptdvtjjjp.scala:23:71\
    \ -----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e\
    [0m \e[36mstrength\e[0m = extensions_map.filter(_._2 > class_name_map.get(_._2)).map(_._1).length\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$2 of expanded\
    \ function:\n\e[31m   |\e[0m   _$2 => _$2._2.\n\e[31m\e[31m-- [E081] Type Error:\
    \ /tmp/tmptdvtjjjp.scala:24:73 -----------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mextension\e[0m = extensions_map.filter(_._2\
    \ == class_name_map.get(_._2)).map(_._1).head\n\e[31m\e[31m   |\e[0m         \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could\
    \ not infer the type of the parameter _$5 of expanded function:\n\e[31m   |\e\
    [0m   _$5 => _$5._2.\n4 errors found\n"
  stdout: ''
  timestamp: 1660009613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase - x.toLowerCase -> x)).toMap\n        val\
    \ class_name_map = class_name.map(x => (x.toUpperCase - x.toLowerCase -> x)).toMap\n\
    \        val strength = extensions_map.values.foldLeft(0)((x, y) => if (x == -1)\
    \ y else x + y)\n        val class_name_with_strength = class_name_map.filter(_._2\
    \ > strength).sortBy(_._1).map(_._1).mkString(\".\") + extensions_map.filter(_._2\
    \ > strength).sortBy(_._1).map(_._2).mkString(\".\") + class_name_map.filter(_._2\
    \ > strength).sortBy(_._1).map(_._2).mkString(\".\") + extensions_map.filter(_._2\
    \ > strength).sortBy(_._1).map(_._1).mkString(\".\") + extensions_map.filter(_._2\
    \ > strength).sortBy(_._1).map(_._2).mkString(\".\") + class_name_map.filter(_._2\
    \ > strength).sortBy(_._1).map(_._2).mkString(\".\") + extensions_map.filter(_._2\
    \ > strength).sortBy(_._1).map(_._1).mkString(\".\") + extensions_map.filter(_._2\
    \ > strength).sortBy(_._1).map(_._2).mkString(\".\") + class_name_map.filter(_._2\
    \ > strength).sortBy(_._1).map(_._2).mkString(\".\") + extensions_map.filter(_._2\
    \ > strength).sortBy(_._1).map(_._1).mkString(\".\") + extensions_map.filter(_._2\
    \ > strength).sortBy(_._1).map(_._2).mkString(\".\") + class_name_map.filter(_._2\
    \ > strength).sortBy(_._1).map(_._2).mkString(\".\") + extensions_map.filter(_._2\
    \ > strength).sortBy(_._1).map(_._1).mkString(\".\") + extensions_map.filter(_._2\
    \ > strength).sortBy(_._1).map(_._2).mkString(\".\") + class_name_map.filter(_._2\
    \ > strength).sortBy(_._1).map(_._2).mkString(\".\") + extensions_map.filter(_._2\
    \ > strength).sortBy(_._1).map(_._1).mkString(\".\") + extensions_map.filter(_._2\
    \ > strength).sortBy(_._1).map(_._2).mkString(\".\") + class_name_map.filter(_._2\
    \ > strength).sortBy(_._1).map(_._2).mkString(\".\") + extensions_\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"\
    ), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcjnz769n.scala:21:64 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36mx\e[0m => (x.toUpperCase - x.toLowerCase -> x)).toMap\n\e[31m\e[31m   |\e\
    [0m                                                  ^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue - is not a member of String, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcjnz769n.scala:22:52\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mx\e[0m => (x.toUpperCase - x.toLowerCase\
    \ -> x)).toMap\n\e[31m\e[31m   |\e[0m                                        \
    \          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               value\
    \ toUpperCase is not a member of Char\n\e[31m\e[31m-- [E051] Reference Error:\
    \ /tmp/tmpcjnz769n.scala:23:89 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.foldLeft(\e\
    [31m0\e[0m)((\e[36mx\e[0m, \e[36my\e[0m) => \e[33mif\e[0m (x == -\e[31m1\e[0m)\
    \ y \e[33melse\e[0m x + y)\n\e[31m\e[31m   |\e[0m                            \
    \                                                           ^^^\e[0m\n\e[31m \
    \  |\e[0mAmbiguous overload. The overloaded alternatives of \e[33mmethod\e[0m\
    \ \e[35m+\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m\
    \ (x: Int): Int\n\e[31m   |\e[0m (x: Char): Int\n\e[31m   |\e[0m (x: Short): Int\n\
    \e[31m   |\e[0m (x: Byte): Int\n\e[31m   |\e[0mall match arguments ((y : Nothing))\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcjnz769n.scala:25:5\
    \ ---------------------\e[0m\e[0m\n\e[31m25 |\e[0m    }\n\e[31m\e"
  stdout: ''
  timestamp: 1660009614
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val sorted_extensions = extensions_map.toSeq.sortBy(_._2).reverse\n\
    \        val first_extension = sorted_extensions.head._1\n        val second_extension\
    \ = sorted_extensions.last._1\n        if (strength == 0) first_extension\n  \
    \      else if (strength == 1) second_extension\n        else class_name + \"\
    .\" + first_extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpmmxndan6.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n1 error found\n"
  stdout: ''
  timestamp: 1660009613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.get(x) - x.toUpperCase.length).max\n\
    \        val extension = extensions_map.getOrElse(strength, \"\")\n        class_name\
    \ + extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdlxljlns.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpdlxljlns.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdlxljlns.scala:23:73\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => class_name_map.get(x) - x.toUpperCase.length).max\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \              Found:    (x : String)\n\e[31m   |\e[0m                       \
    \                           Required: Nothing\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmpdlxljlns.scala:23:103 ----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e\
    [36mx\e[0m => class_name_map.get(x) - x.toUpperCase.length).max\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                                    ^\e[0m\n\e[31m   |\e[0mambiguous given instances:\
    \ both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35mmax\e[0m\
    \ in \e[33mtrait\e[0m"
  stdout: ''
  timestamp: 1660009614
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val extensions_count_diff = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_diff_upper = extensions_count_upper - extensions_count_diff\n\
    \        val extensions_count_diff_lower = extensions_count_lower - extensions_count_diff\n\
    \        val extensions_count_diff_diff_upper = extensions_count_diff_upper -\
    \ extensions_count_diff_lower\n        val extensions_count_diff_diff_lower =\
    \ extensions_count_diff_lower - extensions_count_diff_upper\n        val extensions_count_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_upper - extensions_count_diff_diff_lower\n    \
    \    val extensions_count_diff_diff_diff_lower = extensions_count_diff_diff_lower\
    \ - extensions_count_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_upper - extensions_count_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_diff_diff_diff_upper\n        val\
    \ extensions_count_diff_diff_diff_\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpll4rx2mx.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpll4rx2mx.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_diff_diff_diff_upper\e[0m = extensions_count_diff_diff_diff_diff_upper\
    \ - extensions_count_diff_diff_diff_diff_lower\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_upper is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_upper\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpll4rx2mx.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_lower is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_lower\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpll4rx2mx.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_diff_diff_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009614
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase)\n\
    \        val extensions_map_sorted = extensions_map.toSeq.sortWith(_._2 > _._2)\n\
    \        val extensions_map_sorted = extensions_map_sorted.toMap\n        val\
    \ extensions_map_sorted = extensions_map_sorted.filter(_._2 > 0)\n        val\
    \ extensions_map_sorted = extensions_map_sorted.toSeq.sortWith(_._1 > _._1)\n\
    \        val extensions_map_sorted = extensions_map_sorted.toMap\n        val\
    \ extensions_map_sorted = extensions_map_sorted.filter(_._1 > 0)\n        val\
    \ extensions_map_sorted = extensions_map_sorted.toSeq.sortWith(_._2 > _._2)\n\
    \        val extensions_map_sorted = extensions_map_sorted.toMap\n        val\
    \ extensions_map_sorted = extensions_map_sorted.filter(_._2 > 0)\n        val\
    \ extensions_map_sorted = extensions_map_sorted.toSeq.sortWith(_._1 > _._1)\n\
    \        val extensions_map_sorted = extensions_map_sorted.toMap\n        val\
    \ extensions_map_sorted = extensions_map_sorted.filter(_._1 > 0)\n        val\
    \ extensions_map_sorted = extensions_map_sorted.toSeq.sortWith(_._2 > _._2)\n\
    \        val extensions_map_sorted = extensions_map_sorted.toMap\n        val\
    \ extensions_map_sorted = extensions_map_sorted.filter(_._2 > 0)\n        val\
    \ extensions_map_sorted = extensions_map_sorted.toSeq.sortWith(_._1 > _._1)\n\
    \        val extensions_map_sorted = extensions_map_sorted.toMap\n        val\
    \ extensions_map_sorted = extensions_map_sorted.filter(_._1 > 0)\n        val\
    \ extensions_map_sorted = extensions_map_sorted.toSeq.sortWith(_._2 > _._2)\n\
    \        val extensions_map_sorted = extensions_map_sorted.toMap\n        val\
    \ extensions_map_sorted = extensions_map_sorted.filter(_._2 > 0)\n        val\
    \ extensions_map_sorted = extensions_map_sorted.toSeq.sortWith(_._1 > _._1)\n\
    \        val extensions_map_sorted = extensions_map_sorted.toMap\n        val\
    \ extensions_map_sorted = extensions_map_sorted.filter(_._1 > 0)\n        val\
    \ extensions_map_sorted = extensions_map_sorted.toSeq.sortWith(_._2 > _._2)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9dznv_bl.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_map_sorted\e\
    [0m = extensions_map_sorted.toMap\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_map_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_map_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9dznv_bl.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_map_sorted\e\
    [0m = extensions_map_sorted.filter(_._2 > \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_map_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_map_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9dznv_bl.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_map_sorted\e\
    [0m = extensions_map_sorted.toSeq.sortWith(_._1 > _._1)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_map_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_map_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9dznv_bl.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_map_sorted\e\
    [0m = extensions_map_sorted.toMap\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_map_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_map_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same"
  stdout: ''
  timestamp: 1660009615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase).toMap\n\
    \        val class_name_map = class_name.map(c => c.toUpperCase.charAt(0) -> c.toUpperCase.charAt(1).toLowerCase).toMap\n\
    \        val strength = extensions_map.values.map(e => class_name_map.get(e) -\
    \ class_name_map.get(e.head)).sum\n        val extension = extensions_map.values.find(e\
    \ => class_name_map.get(e) == strength).get\n        s\"$class_name.$extension\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps3oeh7_8.scala:21:100 -----------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.charAt(\e[31m0\e[0m) -> e.toUpperCase.charAt(\e[31m1\e\
    [0m).toLowerCase).toMap\n\e[31m\e[31m   |\e[0m                               \
    \                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps3oeh7_8.scala:22:51\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mc\e[0m => c.toUpperCase.charAt(\e\
    [31m0\e[0m) -> c.toUpperCase.charAt(\e[31m1\e[0m).toLowerCase).toMap\n\e[31m\e\
    [31m   |\e[0m                                                 ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toUpperCase is not a\
    \ member of Char\n\e[31m\e[31m-- Error: /tmp/tmps3oeh7_8.scala:23:109 ----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e\
    [36me\e[0m => class_name_map.get(e) - class_name_map.get(e.head)).sum\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mBigDecimalIsFractional\e[0m in\
    \ \e[33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mByteIsIntegral\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter\
    \ num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660009615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase.size, e.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((a, b) => math.max(a, b))\n \
    \       val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n  \
    \      val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 \n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"\
    ), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp73ccgvys.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp73ccgvys.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions_sorted.takeWhile(_._2 > \e[31m0\e\
    [0m).map(_._1)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp73ccgvys.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp73ccgvys.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp73ccgvys.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009614
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase)\n\
    \        val extensions_sorted = extensions_map.toSeq.sortBy(_._2)\n        val\
    \ extensions_sorted = extensions_sorted.takeWhile(_._2 != extensions_sorted.last._2).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.map(e => class_name + \".\"\
    \ + e)\n        extensions_sorted.head\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd5lsx1lo.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 != extensions_sorted.last._2).map(_._1)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpd5lsx1lo.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36me\e[0m => class_name + \e[31m\".\"\e[0m + e)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpd5lsx1lo.scala:21:100 -----------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.charAt(\e[31m0\e[0m) -> e.toUpperCase.charAt(\e[31m1\e\
    [0m).toLowerCase)\n\e[31m\e[31m   |\e[0m                                     \
    \                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- Error: /tmp/tmpd5lsx1lo.scala:22:65 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_map.toSeq.sortBy(_._2)\n\e[31m\e[31m   |\e[0m                   \
    \                                              ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mShort\e[0m in \e[3"
  stdout: ''
  timestamp: 1660009613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val extensions_sorted\
    \ = extensions_map.toSeq.sortBy(_._1).reverse\n        val extensions_sorted =\
    \ extensions_sorted.takeWhile(_._2 > 0).map(_._1).mkString(\".\")\n        val\
    \ extensions_sorted = extensions_sorted.dropRight(1)\n        class_name + \"\
    .\" + extensions_sorted\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0h90qt1x.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0h90qt1x.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- Error: /tmp/tmp0h90qt1x.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n3 errors found\n"
  stdout: ''
  timestamp: 1660009614
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_length = class_name.length\n\
    \        val extension_length = extensions_count.toDouble / class_name_length\n\
    \        val strength = extension_length.toInt\n        val extensions_sorted\
    \ = extensions.sortWith((a, b) => a.length < b.length)\n        val extension_sorted\
    \ = extensions_sorted.head\n        val extension_length = extension_sorted.length\n\
    \        val extension_strength = extension_length.toDouble / class_name_length\n\
    \        val extension_strength_rounded = extension_strength.toInt\n        val\
    \ extension_strength_rounded_rounded = extension_strength_rounded + 1\n      \
    \  val extension_strength_rounded_rounded_rounded = extension_strength_rounded_rounded\
    \ + 1\n        val extension_strength_rounded_rounded_rounded_rounded = extension_strength_rounded_rounded_rounded\
    \ + 1\n        val extension_strength_rounded_rounded_rounded_rounded_rounded\
    \ = extension_strength_rounded_rounded_rounded_rounded + 1\n        val extension_strength_rounded_rounded_rounded_rounded_rounded_rounded\
    \ = extension_strength_rounded_rounded_rounded_rounded_rounded + 1\n        val\
    \ extension_strength_rounded_rounded_rounded_rounded_rounded_rounded_rounded =\
    \ extension_strength_rounded_rounded_rounded_rounded_rounded_rounded + 1\n   \
    \     val extension_strength_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded\
    \ = extension_strength_rounded_rounded_rounded_rounded_rounded_rounded + 1\n \
    \       val extension_strength_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded\
    \ = extension_strength_rounded_rounded_rounded_rounded_rounded_rounded_rounded\
    \ + 1\n        val extension_strength_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded\
    \ = extension_strength_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded\
    \ + 1\n        val extension_strength_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded\
    \ = extension_strength_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded\
    \ + 1\n        val extension_strength_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded\
    \ = extension_strength_rounded_rounded_rounded_rounded_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp06y5ua6b.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextension_length\e[0m =\
    \ extension_sorted.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_length is already defined as \e[33mvalue\e[0m \e\
    [35mextension_length\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp06y5ua6b.scala:40:153 -----------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mextension_strength_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded_rounded\e\
    [0m = extension_strength_rounded_rounded_rounded_rounded_\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                                                            \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \          Not found: extension_strength_rounded_rounded_rounded_rounded_\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp06y5ua6b.scala:41:5\
    \ ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length = extensions_count_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sum = extensions_count_sorted_length.sum\n\
    \        val extensions_count_sorted_length_sum_sorted = extensions_count_sorted_length.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sum_sorted_length = extensions_count_sorted_length_sum_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum = extensions_count_sorted_length_sum_sorted_length.sum\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted = extensions_count_sorted_length_sum_sorted_length.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length.sum\n \
    \       val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length.sum\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum.sum\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpt3dnpdnq.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt3dnpdnq.scala:26:111\
    \ -----------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_sorted_length_sum_sorted_length\e[0m = extensions_count_sorted_length_sum_sorted.map(_.length)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                     ^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                     value length is not a member of Int\n\
    \e[31m\e[31m-- Error: /tmp/tmpt3dnpdnq.scala:27:119 ----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sum_sorted_length_sum\e\
    [0m = extensions_count_sorted_length_sum_sorted_length.sum\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mDoubleIsFractional\e[0m in \e\
    [33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mBigDecimalIsFractional\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter\
    \ num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt3dnpdnq.scala:28:134 -----------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sum_sorted_length_sum_sorted\e\
    [0m = extensions_count_sorted_length_sum_sorted_length.sortWith(_ < _)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                    ^^^\e[0m\n\
    \e[31m   |\e[0mvalue < is not a member of Nothing, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e["
  stdout: ''
  timestamp: 1660009617
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase).map(_.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase).map(_.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val strength_upper = strength.toDouble / extensions_count.toDouble\n    \
    \    val strength_lower = strength.toDouble / extensions_count.toDouble\n    \
    \    val extensions_count_sorted = extensions.sortWith((a, b) => strength_lower\
    \ > strength_upper)\n        val extensions_count_sorted_upper = extensions_sorted.map(_.toUpperCase).map(_.length).sum\n\
    \        val extensions_count_sorted_lower = extensions_sorted.map(_.toLowerCase).map(_.length).sum\n\
    \        val strength_sorted = extensions_count_sorted_upper - extensions_count_sorted_lower\n\
    \        val strength_sorted_upper = strength_sorted.toDouble / extensions_count.toDouble\n\
    \        val strength_sorted_lower = strength_sorted.toDouble / extensions_count.toDouble\n\
    \        val extensions_count_sorted_sorted = extensions_sorted.sortWith((a, b)\
    \ => strength_sorted_lower > strength_sorted_upper)\n        val extensions_count_sorted_sorted_upper\
    \ = extensions_sorted_sorted.map(_.toUpperCase).map(_.length).sum\n        val\
    \ extensions_count_sorted_sorted_lower = extensions_sorted_sorted.map(_.toLowerCase).map(_.length).sum\n\
    \        val strength_sorted_sorted = extensions_count_sorted_sorted_upper - extensions_count_sorted_sorted_lower\n\
    \        val strength_sorted_sorted_upper = strength_sorted_sorted.toDouble /\
    \ extensions_count.toDouble\n        val strength_sorted_sorted_lower = strength_sorted_sorted.toDouble\
    \ / extensions_count.toDouble\n        val extensions_count_sorted_sorted_sorted\
    \ = extensions_sorted_sorted.sortWith((a, b) => strength_sorted_sorted_lower >\
    \ strength_sorted_sorted_upper)\n        val extensions_count_sorted_sorted_sorted_upper\
    \ = extensions_sorted_sorted_sorted.map(_.toUpperCase).map(_.length).sum\n   \
    \     val extensions_count_sorted_sorted_sorted_lower = extensions_sorted_sorted_sorted.map(_.toLowerCase).map(_.length).sum\n\
    \        val strength_sorted_sorted_sorted = extensions_count_sorted_sorted_sorted_upper\
    \ - extensions_count_sorted_sorted_sorted_lower\n        val strength_sorted_sorted_sorted_upper\
    \ = strength_sorted_sorted_sorted.toDouble / extensions_count.toDouble\n     \
    \   val strength_sorted_sorted_sorted_lower = strength\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgqtb3fi2.scala:28:44 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_upper\e\
    [0m = extensions_sorted.map(_.toUpperCase).map(_.length).sum\n\e[31m\e[31m   |\e\
    [0m                                            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                            Not found: extensions_sorted\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgqtb3fi2.scala:29:44\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_sorted_lower\e[0m = extensions_sorted.map(_.toLowerCase).map(_.length).sum\n\
    \e[31m\e[31m   |\e[0m                                            ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Not found: extensions_sorted\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgqtb3fi2.scala:33:45\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_sorted_sorted\e[0m = extensions_sorted.sortWith((\e[36ma\e\
    [0m, \e[36mb\e[0m) => strength_sorted_lower > strength_sorted_upper)\n\e[31m\e\
    [31m   |\e[0m                                             ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Not found: extensions_sorted\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgqtb3fi2.scala:34:51\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_sorted_sorted_upper\e[0m = extensions_sorted_sorted.map(_.toUpperCase).map(_.length).sum\n\
    \e[31m\e[31m   |\e[0m                                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Not found: extensions_sorted_sorted\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not"
  stdout: ''
  timestamp: 1660009614
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.getOrElse(x, 0) - x.toUpperCase.length).toArray\n\
    \        val max_strength = strength.max\n        val max_key = extensions_map.keys.max\n\
    \        val max_value = extensions_map.values.max\n        val max_key_lower\
    \ = class_name_map.keys.max\n        val max_value_lower = class_name_map.values.max\n\
    \        val max_key_upper = extensions_map.keys.max\n        val max_value_upper\
    \ = extensions_map.values.max\n        val max_key_upper = extensions_map.keys.max\n\
    \        val max_value_upper = extensions_map.values.max\n        val max_key_lower\
    \ = extensions_map.keys.max\n        val max_value_lower = extensions_map.values.max\n\
    \        val max_key_upper = extensions_map.keys.max\n        val max_value_upper\
    \ = extensions_map.values.max\n        val max_key_lower = extensions_map.keys.max\n\
    \        val max_value_lower = extensions_map.values.max\n        val max_key_upper\
    \ = extensions_map.keys.max\n        val max_value_upper = extensions_map.values.max\n\
    \        val max_key_lower = extensions_map.keys.max\n        val max_value_lower\
    \ = extensions_map.values.max\n        val max_key_upper = extensions_map.keys.max\n\
    \        val max_value_upper = extensions_map.values.max\n        val max_key_lower\
    \ = extensions_map.keys.max\n        val max_value_lower = extensions_map.values.max\n\
    \        val max_key_upper = extensions_map.keys.max\n        val max_value_upper\
    \ = extensions_map.values.max\n        val max_key_lower = extensions_map.keys.max\n\
    \        val max_value_lower = extensions_map.values.max\n        val max_key_upper\
    \ = extensions_map.keys.max\n        val max_value_upper = extensions_map.values.max\n\
    \        val max_key_lower = extensions_map.keys.max\n        val max_value_lower\
    \ = extensions_map.values.max\n        val max_key_upper = extensions_map.keys.max\n\
    \        val max_value_upper = extensions_map.values.max\n        val max_key_lower\
    \ = extensions_map.keys.max\n        val max_value_lower = extensions_map.values.max\n\
    \        val max_key_upper = extensions_map.keys.max\n        val max_value_upper\
    \ = extensions_map.values.max\n        val max_key_lower = extensions_map.\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx7uw77ki.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpx7uw77ki.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36mmax_key_upper\e[0m = extensions_map.keys.max\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmax_key_upper is already defined as \e[33mvalue\e[0m \e[35mmax_key_upper\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpx7uw77ki.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mmax_value_upper\e[0m = extensions_map.values.max\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_value_upper is already defined as \e[33mvalue\e[0m \e\
    [35mmax_value_upper\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpx7uw77ki.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mmax_key_lower\e[0m = extensions_map.keys.max\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmax_key_lower is already defined as \e[33mvalue\e[0m \e[35mmax_key_lower\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpx7uw77ki.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mmax_value_lower\e[0m = extensions_map.values.max\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_value_lower is already defined as \e[33mvalue\e[0m \e\
    [35mmax_value_lower\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of "
  stdout: ''
  timestamp: 1660009616
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val extensions_sorted\
    \ = extensions_map.toSeq.sortWith((a, b) => extensions_map(b) - extensions_map(a))\n\
    \        val strongest_extension = extensions_sorted.head\n        class_name\
    \ + \".\" + strongest_extension\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpf4vmsffb.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n1 error found\n"
  stdout: ''
  timestamp: 1660009614
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase).toMap\n\
    \        val class_name_map = class_name.map(c => c.toUpperCase.charAt(0) -> c.toUpperCase.charAt(1).toLowerCase).toMap\n\
    \        val strength = class_name_map.foldLeft(0)((s, c) => s + extensions_map.getOrElse(c,\
    \ 0))\n        val extensions_sorted = extensions.sortWith((a, b) => strength\
    \ - extensions_map.getOrElse(b, 0))\n        val extensions_sorted = extensions_sorted.map(e\
    \ => class_name_map.getOrElse(e, e)).mkString(\".\") + extensions_sorted.last\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3w44356b.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36me\e[0m => class_name_map.getOrElse(e, e)).mkString(\e\
    [31m\".\"\e[0m) + extensions_sorted.last\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp3w44356b.scala:21:100 -----------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.charAt(\e[31m0\e[0m) -> e.toUpperCase.charAt(\e[31m1\e\
    [0m).toLowerCase).toMap\n\e[31m\e[31m   |\e[0m                               \
    \                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3w44356b.scala:22:51\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mc\e[0m => c.toUpperCase.charAt(\e\
    [31m0\e[0m) -> c.toUpperCase.charAt(\e[31m1\e[0m).toLowerCase).toMap\n\e[31m\e\
    [31m   |\e[0m                                                 ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toUpperCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3w44356b.scala:26:5\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.count\n        val extensions_count_upper = extensions.count(_.toUpperCase\
    \ == _)\n        val extensions_count_lower = extensions.count(_.toLowerCase ==\
    \ _)\n        val extensions_count_diff = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_diff_upper = extensions_count_diff / extensions_count_upper\n\
    \        val extensions_count_diff_lower = extensions_count_diff / extensions_count_lower\n\
    \        val extensions_count_diff_diff_upper = extensions_count_diff_upper /\
    \ extensions_count_upper\n        val extensions_count_diff_diff_lower = extensions_count_diff_lower\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_upper / extensions_count_upper\n        val extensions_count_diff_diff_lower\
    \ = extensions_count_diff_diff_lower / extensions_count_lower\n        val extensions_count_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_upper / extensions_count_upper\n        val\
    \ extensions_count_diff_diff_diff_lower = extensions_count_diff_diff_diff_lower\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_upper / extensions_count_upper\n    \
    \    val extensions_count_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_lower\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_upper / extensions_count_upper\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_upper / extensions_count_upper\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_diff_lower\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_upper / extensions_count_upper\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_diff_lower\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_diff_diff_upper / extensions_count_upper\n\
    \        val extensions_count_diff_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_diff_diff_diff_lower\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_diff_diff_diff_diff_diff_upper\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpylk6jlta.scala:43:71 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_diff_diff_diff_upper\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \         expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpylk6jlta.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_lower / extensions_count_lower\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_lower is already defined as \e\
    [33mvalue\e[0m \e[35mextensions_count_diff_diff_lower\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpylk6jlta.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_diff_diff_upper\e[0m = extensions_count_diff_diff_diff_upper\
    \ / extensions_count_upper\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_upper is already defined as\
    \ \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_upper\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpylk6jlta.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_diff_diff_lower\e[0m = extensions_count_diff_diff_diff_diff_lower\
    \ / extensions_count_lower\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs).max\n    \
    \    val extensions_sorted = extensions_map.values.sortWith((x, y) => strength\
    \ - y)\n        val extensions_sorted = extensions_sorted.take(1)\n        class_name\
    \ match {\n            case x if x.toUpperCase == extensions_sorted.head => extensions_sorted.head\n\
    \            case _ => \"\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfhxmmoay.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.take(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpfhxmmoay.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpfhxmmoay.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfhxmmoay.scala:23:57\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = extensions_map.values.map(\e[36mx\e[0m => (x - class_name_map.get(x)).abs).max\n\
    \e[31m\e[31m   |\e[0m                                                       ^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- "
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.values.max\n\
    \        val extensions_sorted = extensions_map.toSeq.sortBy(_._2).reverse\n \
    \       val extensions_sorted_sorted = extensions_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted = extensions_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted = extensions_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted = extensions_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted = extensions_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted = extensions_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwh0z04rf.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwh0z04rf.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpwh0z04rf.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  extensions_sorted_sorted_sorted_sorted_sorted_so"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val strength_upper = extensions_count_upper - strength\n        val strength_lower\
    \ = extensions_count_lower - strength\n        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase).sum\n    \
    \    val strength_upper = extensions_count_upper - strength_upper\n        val\
    \ strength_lower = extensions_count_lower - strength_lower\n        if (strength_upper\
    \ > strength_lower) {\n            class_name + extensions.map(_.toUpperCase).reduce(_\
    \ + _)\n        } else {\n            class_name + extensions.map(_.toLowerCase).reduce(_\
    \ + _)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprce0q7t1.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_upper\e\
    [0m = extensions.map(_.toUpperCase).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_upper is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_upper\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprce0q7t1.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_lower\e\
    [0m = extensions.map(_.toLowerCase).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_lower is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_lower\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprce0q7t1.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mstrength_upper\e[0m = extensions_count_upper\
    \ - strength_upper\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength_upper is already defined as \e[33mvalue\e[0m \e[35mstrength_upper\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprce0q7t1.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mstrength_lower\e[0m = extensions_count_lower\
    \ - strength_lower\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength_lower is already defined as \e[33mvalue\e[0m \e[35mstrength_lower\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n4 errors found\n"
  stdout: ''
  timestamp: 1660009620
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        var strongest_extension\
    \ = \"\"\n        var strongest_extension_strength = -1\n        var extension_strength\
    \ = 0\n        var extension_strength_counter = 0\n        var extension_strength_counter2\
    \ = 0\n        var extension_strength_counter3 = 0\n        var extension_strength_counter4\
    \ = 0\n        var extension_strength_counter5 = 0\n        var extension_strength_counter6\
    \ = 0\n        var extension_strength_counter7 = 0\n        var extension_strength_counter8\
    \ = 0\n        var extension_strength_counter9 = 0\n        var extension_strength_counter10\
    \ = 0\n        var extension_strength_counter11 = 0\n        var extension_strength_counter12\
    \ = 0\n        var extension_strength_counter13 = 0\n        var extension_strength_counter14\
    \ = 0\n        var extension_strength_counter15 = 0\n        var extension_strength_counter16\
    \ = 0\n        var extension_strength_counter17 = 0\n        var extension_strength_counter18\
    \ = 0\n        var extension_strength_counter19 = 0\n        var extension_strength_counter20\
    \ = 0\n        var extension_strength_counter21 = 0\n        var extension_strength_counter22\
    \ = 0\n        var extension_strength_counter23 = 0\n        var extension_strength_counter24\
    \ = 0\n        var extension_strength_counter25 = 0\n        var extension_strength_counter26\
    \ = 0\n        var extension_strength_counter27 = 0\n        var extension_strength_counter28\
    \ = 0\n        var extension_strength_counter29 = 0\n        var extension_strength_counter30\
    \ = 0\n        var extension_strength_counter31 = 0\n        var extension_strength_counter32\
    \ = 0\n        var extension_strength_counter33 = 0\n        var extension_strength_counter34\
    \ = 0\n        var extension_strength_counter35 = 0\n        var extension_strength_counter36\
    \ = 0\n        var extension_strength_counter37 = 0\n        var extension_strength_counter38\
    \ = 0\n        var extension_strength_counter39 = 0\n        var extension_strength_counter40\
    \ = 0\n        var extension_strength_counter41 = 0\n        var extension_strength_counter42\
    \ = 0\n        var extension_strength_counter43 = 0\n        var extension_strength_counter44\
    \ = 0\n        var extension_strength_counter45 = 0\n        var extension_strength_counter46\
    \ = 0\n        var extension_strength_counter47 = 0\n        var extension_strength_counter48\
    \ = 0\n        var extension_strength_counter49 = 0\n        var extension_strength_counter50\
    \ = 0\n        var extension_strength_counter51 = 0\n        var extension_strength_counter52\
    \ = 0\n        var extension_strength_counter53 = 0\n        var extension_strength_counter54\
    \ = 0\n        var extension_strength_counter\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpew93cfja.scala:79:4 ----------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpew93cfja.scala:79:5 ---------------------\e[0m\e[0m\n\e[31m79 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase)\n\
    \        val extensions_count = extensions.map(e => extensions_map(e).size)\n\
    \        val extensions_sum = extensions_count.sum\n        val strength = extensions_sum\
    \ / extensions_count.size\n        val extensions_sorted = extensions_count.sortWith(_\
    \ < _)\n        val extensions_sorted = extensions_sorted.take(extensions_sorted.size\
    \ - 1).sortWith(_ < _)\n        val extensions_sorted = extensions_sorted.take(extensions_sorted.size\
    \ - 1).sortWith(_ < _)\n        val extensions_sorted = extensions_sorted.take(extensions_sorted.size\
    \ - 1).sortWith(_ < _)\n        val extensions_sorted = extensions_sorted.take(extensions_sorted.size\
    \ - 1).sortWith(_ < _)\n        val extensions_sorted = extensions_sorted.take(extensions_sorted.size\
    \ - 1).sortWith(_ < _)\n        val extensions_sorted = extensions_sorted.take(extensions_sorted.size\
    \ - 1).sortWith(_ < _)\n        val extensions_sorted = extensions_sorted.take(extensions_sorted.size\
    \ - 1).sortWith(_ < _)\n        val extensions_sorted = extensions_sorted.take(extensions_sorted.size\
    \ - 1).sortWith(_ < _)\n        val extensions_sorted = extensions_sorted.take(extensions_sorted.size\
    \ - 1).sortWith(_ < _)\n        val extensions_sorted = extensions_sorted.take(extensions_sorted.size\
    \ - 1).sortWith(_ < _)\n        val extensions_sorted = extensions_sorted.take(extensions_sorted.size\
    \ - 1).sortWith(_ < _)\n        val extensions_sorted = extensions_sorted.take(extensions_sorted.size\
    \ - 1).sortWith(_ < _)\n        val extensions_sorted = extensions_sorted.take(extensions_sorted.size\
    \ - 1).sortWith(_ < _)\n        val extensions_sorted = extensions_sorted.take(extensions_sorted.size\
    \ - 1).sortWith(_ < _)\n        val extensions_sorted = extensions_sorted.take(extensions_sorted.size\
    \ - 1).sortWith(_ < _)\n        val extensions_sorted = extensions_sorted.take(extensions_sorted.size\
    \ - 1).sortWith(_ < _)\n        val extensions_sorted = extensions_sorted.take(extensions_sorted.size\
    \ - 1).sortWith(_ < _)\n        val extensions_sorted = \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3hyheni5.scala:43:31 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ \n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m\
    \                               expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3hyheni5.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions_sorted.take(extensions_sorted.size\
    \ - \e[31m1\e[0m).sortWith(_ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3hyheni5.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.take(extensions_sorted.size - \e[31m1\e[0m).sortWith(_ < _)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3hyheni5.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.take(extensions_sorted.size - \e[31m1\e[0m).sortWith(_ < _)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods m"
  stdout: ''
  timestamp: 1660009628
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.sortWith(_.length\
    \ > _.length)\n        val extensions_count_sorted_length = extensions_count_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sorted = extensions_count_sorted.sortWith(_.length\
    \ > _.length)\n        val extensions_count_sorted_length_sorted_length = extensions_count_sorted_length.sortWith(_.length\
    \ > _.length)\n        val extensions_count_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted.sortWith(_.length > _.length)\n    \
    \    val extensions_count_sorted_length_sorted_length_sorted_length = extensions_count_sorted_length_sorted_length.sortWith(_.length\
    \ > _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted.sortWith(_.length > _.length)\n\
    \        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length.sortWith(_.length\
    \ > _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ > _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ > _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ > _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ > _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ > _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ > _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ > _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ > _.length)\n        val extensions_count_sorted_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8cyvk16z.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8cyvk16z.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\e\
    [0m = extensions_count_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ > _.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp8cyvk16z.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\e\
    [0m = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ > _.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group"
  stdout: ''
  timestamp: 1660009626
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_count = class_name.length\n\
    \        val strength = extensions_count - class_name_count\n        val extensions_sorted\
    \ = extensions.sortWith(_.length > _.length)\n        val extensions_first_sorted\
    \ = extensions_sorted.head\n        val extensions_first_sorted_length = extensions_first_sorted.length\n\
    \        val extensions_first_sorted_first_letter = extensions_first_sorted.charAt(0)\n\
    \        val extensions_first_sorted_first_letter_count = extensions_first_sorted_first_letter.length\n\
    \        val extensions_first_sorted_first_letter_strength = extensions_first_sorted_first_letter.toCharArray().map(_.toUpperCase).count(_\
    \ == 'A') - extensions_first_sorted_first_letter.toCharArray().map(_.toLowerCase).count(_\
    \ == 'a')\n        val extensions_first_sorted_first_letter_strength_sum = extensions_first_sorted_first_letter_strength\
    \ * extensions_first_sorted_first_letter_count\n        val extensions_first_sorted_first_letter_strength_product\
    \ = extensions_first_sorted_first_letter_strength_sum / extensions_first_sorted_first_letter_count\n\
    \        val extensions_first_sorted_first_letter_strength_product2 = extensions_first_sorted_first_letter_strength_product\
    \ * extensions_first_sorted_first_letter_count\n        val extensions_first_sorted_first_letter_strength_product3\
    \ = extensions_first_sorted_first_letter_strength_product2 * extensions_first_sorted_first_letter_count\n\
    \        val extensions_first_sorted_first_letter_strength_product4 = extensions_first_sorted_first_letter_strength_product3\
    \ * extensions_first_sorted_first_letter_count\n        val extensions_first_sorted_first_letter_strength_product5\
    \ = extensions_first_sorted_first_letter_strength_product4 * extensions_first_sorted_first_letter_count\n\
    \        val extensions_first_sorted_first_letter_strength_product6 = extensions_first_sorted_first_letter_strength_product5\
    \ * extensions_first_sorted_first_letter_count\n        val extensions_first_sorted_first_letter_strength_product7\
    \ = extensions_first_sorted_first_letter_strength_product6 * extensions_first_sorted_first_letter_count\n\
    \        val extensions_first_sorted_first_letter_strength_product8 = extensions_first_sorted_first_letter_strength_product7\
    \ * extensions_first_sorted_first_letter_count\n        val extensions_first_sorted_first_letter_strength_product9\
    \ = extensions_first_sorted_first_letter_strength_product8 * extensions_first_sorted_first_letter_count\n\
    \        val extensions_first_sorted_first_letter_strength_product10 = extensions_first_sorted_first_letter_strength_product9\
    \ * extensions_first_sorted_first_letter_count\n        val extensions_first_sorted_first_letter_strength_product11\
    \ = extensions_first_sorted_first_letter_strength_product10 * extensions_\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq_eyom1h.scala:28:94 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_first_sorted_first_letter_count\e\
    [0m = extensions_first_sorted_first_letter.length\n\e[31m\e[31m   |\e[0m     \
    \                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    value length is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq_eyom1h.scala:29:97\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_first_sorted_first_letter_strength\e[0m = extensions_first_sorted_first_letter.toCharArray().map(_.toUpperCase).count(_\
    \ == \e[31m'A'\e[0m) - extensions_first_sorted_first_letter.toCharArray().map(_.toLowerCase).count(_\
    \ == \e[31m'a'\e[0m)\n\e[31m\e[31m   |\e[0m                                  \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toCharArray is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq_eyom1h.scala:42:5\
    \ ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val extensions_count\
    \ = extensions_map.size\n        val class_name_count = class_name_map.size\n\
    \        val strength = extensions_count - class_name_count\n        if (strength\
    \ == 0) class_name\n        else if (strength == -1) class_name + extensions_map.keys.toList.head\n\
    \        else class_name + extensions_map.keys.toList.take(strength).mkString(\"\
    .\")\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt03g6jl3.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpt03g6jl3.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1660009626
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((a, b) => math.max(a, b))\n \
    \       val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n  \
    \      val extension_strength = extensions_sorted.head._2\n        val extension_name\
    \ = extensions_sorted.head._1\n        val extension_class = extension_strength.toDouble\
    \ / strength.toDouble\n        val extension_class_name = extension_class * class_name\
    \ + extension_name\n        extension_class_name\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmprepw8gww.scala:27:51 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextension_class_name\e[0m\
    \ = extension_class * class_name + extension_name\n\e[31m\e[31m   |\e[0m     \
    \                              ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e\
    [0m \e[35mDouble\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m\
    \   |\e[0m (x: Float): Double\n\e[31m   |\e[0m (x: Long): Double\n\e[31m   |\e\
    [0m (x: Int): Double\n\e[31m   |\e[0m (x: Char): Double\n\e[31m   |\e[0m (x: Short):\
    \ Double\n\e[31m   |\e[0m (x: Byte): Double\n\e[31m   |\e[0mmatch arguments ((class_name\
    \ : String))\n1 error found\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase - e.toLowerCase + 1)).toMap\n        val\
    \ strength = extensions_map.values.max\n        val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphwya4gl2.scala:44:76 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \  ^\e[0m\n\e[31m   |\e[0m                                   an identifier expected,\
    \ but '_' found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphwya4gl2.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions_sorted.takeWhile(_._2 > \e[31m0\e\
    [0m).map(_._1)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmphwya4gl2.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmphwya4gl2.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defin"
  stdout: ''
  timestamp: 1660009627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    if (extensions_count > 1) {\n            val extensions_sorted = extensions.sortBy(_.length)\n\
    \            val extensions_sorted = extensions.sortBy(_.toUpperCase)\n      \
    \      val extensions_sorted = extensions.sortBy(_.toLowerCase)\n            val\
    \ extensions_sorted = extensions.sortBy(_.length)\n            val extensions_sorted\
    \ = extensions.sortBy(_.toUpperCase)\n            val extensions_sorted = extensions.sortBy(_.toLowerCase)\n\
    \            val extensions_sorted = extensions.sortBy(_.length)\n           \
    \ val extensions_sorted = extensions.sortBy(_.toUpperCase)\n            val extensions_sorted\
    \ = extensions.sortBy(_.toLowerCase)\n            val extensions_sorted = extensions.sortBy(_.length)\n\
    \            val extensions_sorted = extensions.sortBy(_.toUpperCase)\n      \
    \      val extensions_sorted = extensions.sortBy(_.toLowerCase)\n            val\
    \ extensions_sorted = extensions.sortBy(_.length)\n            val extensions_sorted\
    \ = extensions.sortBy(_.toUpperCase)\n            val extensions_sorted = extensions.sortBy(_.toLowerCase)\n\
    \            val extensions_sorted = extensions.sortBy(_.length)\n           \
    \ val extensions_sorted = extensions.sortBy(_.toUpperCase)\n            val extensions_sorted\
    \ = extensions.sortBy(_.toLowerCase)\n            val extensions_sorted = extensions.sortBy(_.length)\n\
    \            val extensions_sorted = extensions.sortBy(_.toUpperCase)\n      \
    \      val extensions_sorted = extensions.sortBy(_.toLowerCase)\n            val\
    \ extensions_sorted = extensions.sortBy(_.length)\n            val extensions_sorted\
    \ = extensions.sortBy(_.toUpperCase)\n            val extensions_sorted = extensions.sortBy(_.toLowerCase)\n\
    \            val extensions_sorted = extensions.sortBy(_.length)\n           \
    \ val extensions_sorted = extensions.sortBy(_.toUpperCase)\n            val extensions_sorted\
    \ = extensions.sortBy(_.toLowerCase)\n            val extensions_sorted = extensions.sortBy(_.length)\n\
    \            val extensions_sorted = extensions.sortBy(_.toUpperCase)\n      \
    \      val extensions_sorted = extensions.sortBy(_.toLowerCase)\n            val\
    \ extensions_sorted = extensions.sortBy(_.length)\n            val extensions_sorted\
    \ = extensions.sortBy(_.toUpperCase)\n            val extensions_sorted = extensions.sortBy(_.toLowerCase)\n\
    \            val extensions_sorted = extensions.sortBy(_.length)\n           \
    \ val extensions_sorted = extensions.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxdx4gj98.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpxdx4gj98.scala:75:0 ----------------------------\e[0m\e[0m\n\e[31m75\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxdx4gj98.scala:27:16 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mextensions_sorted\e\
    [0m = extensions.sortBy(_.toUpperCase)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxdx4gj98.scala:28:16 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mextensions_sorted\e\
    [0m = extensions.sortBy(_.toLowerCase)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxdx4gj98.scala:29:16 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36mextensions_sorted\e\
    [0m = extensions.sortBy(_.length)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxdx4gj98.scala:30:16 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e[0m \e[36mextensions_sorted\e\
    [0m = exte"
  stdout: ''
  timestamp: 1660009627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.getOrElse(x, 0) - x.toString.toUpperCase.length).toArray\n\
    \        val max_strength = strength.max\n        val max_key = extensions_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = class_name_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = extensions_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = class_name_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = extensions_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = class_name_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = extensions_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = class_name_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = extensions_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = class_name_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = extensions_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = class_name_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = extensions_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = class_name_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = extensions_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = class_name_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = extensions_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = class_name_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = extensions_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = class_name_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = extensions_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key = class_name_map.keys.toArray.max\n\
    \        val max_\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnqlg6yej.scala:69:4 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnqlg6yej.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmax_key\e[0m = class_name_map.keys.toArray.max\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmax_key\
    \ is already defined as \e[33mvalue\e[0m \e[35mmax_key\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnqlg6yej.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmax_value\e[0m = strength.max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_value is already defined as \e[33mvalue\e[0m \e[35mmax_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnqlg6yej.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mmax_key\e[0m = extensions_map.keys.toArray.max\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmax_key is already defined as \e[33mvalue\e[0m \e[35mmax_key\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnqlg6yej.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mmax_value\e[0m = strength.max\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmax_value\
    \ is already defined as \e[33mvalue\e[0m \e[35mmax_value\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnqlg6yej.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m3"
  stdout: ''
  timestamp: 1660009628
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.sortBy(_.length).reverse\n\
    \        val extensions_count_sorted_length = extensions_count_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sum = extensions_count_sorted_length.sum\n\
    \        val extensions_count_sorted_length_sum_sorted = extensions_count_sorted_length.sortBy(_.sum).reverse\n\
    \        val extensions_count_sorted_length_sum_sorted_length = extensions_count_sorted_length_sum_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum = extensions_count_sorted_length_sum_sorted_length.sum\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted = extensions_count_sorted_length_sum_sorted_length.sortBy(_.sum).reverse\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length.sum\n \
    \       val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length.sortBy(_.sum).reverse\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length.sum\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length.sortBy(_.sum).reverse\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum.map(_.length)\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum.map(_.length)\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum.map(_.length)\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmployi92p9.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmployi92p9.scala:25:96\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_sorted_length_sum_sorted\e[0m = extensions_count_sorted_length.sortBy(_.sum).reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                      ^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                             value sum is not a member of Int\n\e[31m\e[31m--\
    \ Error: /tmp/tmployi92p9.scala:25:100 ----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sum_sorted\e\
    [0m = extensions_count_sorted_length.sortBy(_.sum).reverse\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                          ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both\
    \ \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and\
    \ \e[33mobject\e[0m \e[35mDeprecatedDoubleOrdering\e[0m in \e[33mobject\e[0m \e\
    [35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m\
    \ \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmployi92p9.scala:35:121 --------------------------\e[0m\e\
    [0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum\e\
    [0m = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum.map(_.length)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                 ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |"
  stdout: ''
  timestamp: 1660009627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs).max\n    \
    \    val extension = extensions_map.get(strength)\n        extension.getOrElse(class_name)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpve1p6yxk.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpve1p6yxk.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpve1p6yxk.scala:23:57\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = extensions_map.values.map(\e[36mx\e[0m => (x - class_name_map.get(x)).abs).max\n\
    \e[31m\e[31m   |\e[0m                                                       ^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpve1p6yxk.scala:23:78 --------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e\
    [36mx\e[0m => (x - class_name_map.get(x)).abs).max\n\e[31m\e[31m   |\e[0m    \
    \                                                                          ^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   (x : String)\n\e[31m   |\e[0m                                            \
    \      Required: Nothing\n\e[31"
  stdout: ''
  timestamp: 1660009628
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase.size, e.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((a, b) => math.max(a, b))\n \
    \       val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n  \
    \      val extensions_sorted = extensions_sorted.takeWhile(_._2 > strength)\n\
    \        val extensions_sorted = extensions_sorted.map(_._1).mkString(\".\")\n\
    \        val extensions_sorted = extensions_sorted.replaceAll(\"\\\\.\", \"\"\
    )\n        class_name + extensions_sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfptqz9xv.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > strength)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpfptqz9xv.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(_._1).mkString(\e[31m\".\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e[35mextensions_sorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfptqz9xv.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m = extensions_sorted.replaceAll(\e\
    [31m\"\\\\.\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.count\n        val extensions_count_upper = extensions.count(x\
    \ => x.toUpperCase.size == x.length).toDouble\n        val extensions_count_lower\
    \ = extensions.count(x => x.toLowerCase.size == x.length).toDouble\n        val\
    \ extensions_count_diff = extensions_count_upper - extensions_count_lower\n  \
    \      val extensions_count_diff_frac = extensions_count_diff / extensions_count_upper\n\
    \        val extensions_count_diff_frac_floor = Math.floor(extensions_count_diff_frac)\n\
    \        val extensions_count_diff_frac_ceil = Math.ceil(extensions_count_diff_frac)\n\
    \        val extensions_count_diff_frac_ceil = extensions_count_diff_frac_ceil.toInt\n\
    \        val extensions_count_diff_frac_floor = extensions_count_diff_frac_floor.toInt\n\
    \        val extensions_count_diff_frac_ceil = extensions_count_diff_frac_ceil\
    \ - extensions_count_diff_frac_floor\n        val extensions_count_diff_frac_floor\
    \ = extensions_count_diff_frac_floor.toInt\n        val extensions_count_diff_frac\
    \ = extensions_count_diff_frac.toInt\n        val extensions_count_diff_frac_floor\
    \ = extensions_count_diff_frac_floor.toInt\n        val extensions_count_diff_frac\
    \ = extensions_count_diff_frac.toInt\n        val extensions_count_diff_frac_floor\
    \ = extensions_count_diff_frac_floor.toInt\n        val extensions_count_diff_frac\
    \ = extensions_count_diff_frac.toInt\n        val extensions_count_diff_frac_floor\
    \ = extensions_count_diff_frac_floor.toInt\n        val extensions_count_diff_frac\
    \ = extensions_count_diff_frac.toInt\n        val extensions_count_diff_frac_floor\
    \ = extensions_count_diff_frac_floor.toInt\n        val extensions_count_diff_frac\
    \ = extensions_count_diff_frac.toInt\n        val extensions_count_diff_frac_floor\
    \ = extensions_count_diff_frac_floor.toInt\n        val extensions_count_diff_frac\
    \ = extensions_count_diff_frac.toInt\n        val extensions_count_diff_frac_floor\
    \ = extensions_count_diff_frac_floor.toInt\n        val extensions_count_diff_frac\
    \ = extensions_count_diff_frac.toInt\n        val extensions_count_diff_frac_floor\
    \ = extensions_count_diff_frac_floor.toInt\n        val extensions_count_diff_frac\
    \ = extensions_count_diff_frac.toInt\n        val extensions_count_diff_frac_floor\
    \ = extensions_count_diff_frac_floor.toInt\n        val extensions_count_diff_frac\
    \ = extensions_count_diff_fra\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj6lmnln8.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_frac_ceil\e\
    [0m = extensions_count_diff_frac_ceil.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_frac_ceil is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_diff_frac_ceil\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj6lmnln8.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_frac_floor\e[0m = extensions_count_diff_frac_floor.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_frac_floor is already defined as \e\
    [33mvalue\e[0m \e[35mextensions_count_diff_frac_floor\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj6lmnln8.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_frac_ceil\e[0m = extensions_count_diff_frac_ceil\
    \ - extensions_count_diff_frac_floor\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_frac_ceil is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_diff_frac_ceil\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj6lmnln8.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_frac_floor\e[0m = extensions_count_diff_frac_floor.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        var strength = 0\n\
    \        var strongest_extension = \"\"\n        for(extension <- extensions)\
    \ {\n            val cap = extension.filter(_.isUpper).length\n            val\
    \ sm = extension.filter(_.isLower).length\n            val strength = cap - sm\n\
    \            if(strength > 0) {\n                strongest_extension = extension\n\
    \                strength = cap - sm\n            }\n        }\n        class_name\
    \ + \".\" + strongest_extension\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpd3n4mfoj.scala:29:25 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                strength = cap - sm\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val strength\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        var strongest_extension\
    \ = \"\"\n        var strongest_extension_strength = -1\n        var extension_strength\
    \ = 0\n        var extension_strength_counter = 0\n        var extension_strength_counter_counter\
    \ = 0\n        var extension_strength_counter_counter_counter = 0\n        var\
    \ extension_strength_counter_counter_counter_counter = 0\n        var extension_strength_counter_counter_counter_counter_counter\
    \ = 0\n        var extension_strength_counter_counter_counter_counter_counter_counter\
    \ = 0\n        var extension_strength_counter_counter_counter_counter_counter_counter_counter\
    \ = 0\n        var extension_strength_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0\n        var extension_strength_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0\n        var extension_strength_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0\n        var extension_strength_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0\n        var extension_strength_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0\n        var extension_strength_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0\n        var extension_strength_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0\n        var extension_strength_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0\n        var extension_strength_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0\n        var extension_strength_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0\n        var extension_strength_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0\n        var extension_strength_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0\n        var extension_strength_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0\n        var extension_strength_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0\n        var extension_strength_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp51n24kao.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp51n24kao.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mextension_strength_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_strength_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ is already defined as \e[33mvariable\e[0m \e[35m\n\e[31m   |\e[0m  extension_strength_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp51n24kao.scala:46:5 ---------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase.size, e.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((a, b) => math.max(a, b))\n \
    \       val extensions_sorted = extensions_map.values.sortBy(_._1).reverse\n \
    \       val extensions_sorted = extensions_sorted.takeWhile(_._1 < strength)\n\
    \        val extensions_sorted = extensions_sorted.map(_._2).mkString(\".\")\n\
    \        className + \".\" + extensions_sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsu9asqzx.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._1 < strength)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpsu9asqzx.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(_._2).mkString(\e[31m\".\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e[35mextensions_sorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpsu9asqzx.scala:23:54 ------------------------\e[0m\e[0m\n\
    \e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m = extensions_map.values.sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           value sortBy is not a member of\
    \ Iterable[Int]\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsu9asqzx.scala:26:8\
    \ -------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        className + \e[31m\"\
    .\"\e[0m + extensions_sorted\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m        Not found: className\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val class_name_map = class_name.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n\
    \        val max_strength = extensions_map.values.max\n        val max_key = extensions_map.keys.max\n\
    \        val max_key_index = extensions_map.keys.indexOf(max_key)\n        val\
    \ max_key_value = extensions_map.get(max_key)\n        val max_key_key_index =\
    \ class_name_map.keys.indexOf(max_key_value)\n        val max_key_class_name =\
    \ class_name_map.get(max_key_value)\n        val max_key_class_name_key_index\
    \ = extensions_map.keys.indexOf(max_key_class_name)\n        val max_key_class_name_key_value\
    \ = extensions_map.get(max_key_class_name)\n        val max_key_class_name_key_key_index\
    \ = class_name_map.keys.indexOf(max_key_class_name_key_value)\n        val max_key_class_name_key_class_name\
    \ = class_name_map.get(max_key_class_name_key_value)\n        val max_key_class_name_key_class_name_key_index\
    \ = extensions_map.keys.indexOf(max_key_class_name_key_class_name)\n        val\
    \ max_key_class_name_key_class_name_key_value = extensions_map.get(max_key_class_name_key_class_name)\n\
    \        val max_key_class_name_key_class_name_key_key_index = class_name_map.keys.indexOf(max_key_class_name_key_class_name_key_value)\n\
    \        val max_key_class_name_key_class_name_key_class_name_key_index = extensions_map.keys.indexOf(max_key_class_name_key_class_name_key_class_name_key_value)\n\
    \        val max_key_class_name_key_class_name_key_class_name_key_key_index =\
    \ class_name_map.keys.indexOf(max_key_class_name_key_class_name_key_class_name_key_class_name_key_value)\n\
    \        val max_key_class_name_key_class_name_key_class_name_key_class_name_key_index\
    \ = extensions_map.keys.indexOf(max_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_value)\n\
    \        val max_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_index\
    \ = class_name_map.keys.indexOf(max_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_value)\n\
    \        val max_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_index\
    \ = extensions_map.keys.indexOf(max_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbp3tju8_.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbp3tju8_.scala:22:52\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mx\e[0m => (x.toUpperCase.size,\
    \ x.toLowerCase.size)).toMap\n\e[31m\e[31m   |\e[0m                          \
    \                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \              value toUpperCase is not a member of Char\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpbp3tju8_.scala:22:72 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \ ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               value toLowerCase\
    \ is not a member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbp3tju8_.scala:25:48\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mmax_key_index\e[0m = extensions_map.keys.indexOf(max_key)\n\e[31m\e[31m  \
    \ |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                          value indexOf is not a member of Iterable[Int]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbp3tju8_.scala:27:52 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmax_key_key_index\e[0m =\
    \ class_name_map.keys.indexOf(max_key_value)\n\e[31m\e[31m   |\e[0m          \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 value indexOf is not a member of Iterable[Nothing]\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpbp3tju8_.scala:28:52 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmax_key_class_name\e[0m\
    \ = class_name_map.get(max_key_value)\n\e[31m\e[31m   |\e[0m                 \
    \                                   ^^^^^^^^^^^^^\e[0m\n\e[31"
  stdout: ''
  timestamp: 1660009630
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase)\n\
    \        val extensions_sorted = extensions_map.toSeq.sortBy(_._2).reverse\n \
    \       val extensions_sorted = extensions_sorted.take(extensions_sorted.length\
    \ - 1).map(_._1)\n        val extensions_sorted = extensions_sorted.map(e => class_name\
    \ + \".\" + e)\n        extensions_sorted.head\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpveh3hyp9.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.take(extensions_sorted.length - \e[31m1\e[0m).map(_._1)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpveh3hyp9.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36me\e[0m => class_name + \e[31m\".\"\e[0m + e)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpveh3hyp9.scala:21:100 -----------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.charAt(\e[31m0\e[0m) -> e.toUpperCase.charAt(\e[31m1\e\
    [0m).toLowerCase)\n\e[31m\e[31m   |\e[0m                                     \
    \                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- Error: /tmp/tmpveh3hyp9.scala:22:65 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_map.toSeq.sortBy(_._2).reverse\n\e[31m\e[31m   |\e[0m           \
    \                                                      ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mBigInt\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33m"
  stdout: ''
  timestamp: 1660009627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.filter(_._2 > class_name_map.get(_._2)).map(_._1).sum\n   \
    \     val extension = extensions_map.filter(_._2 == class_name_map.get(_._2)).map(_._1).head\n\
    \        s\"$class_name.$extension\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9u8d7ph0.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp9u8d7ph0.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmp9u8d7ph0.scala:23:71\
    \ -----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e\
    [0m \e[36mstrength\e[0m = extensions_map.filter(_._2 > class_name_map.get(_._2)).map(_._1).sum\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$2 of expanded\
    \ function:\n\e[31m   |\e[0m   _$2 => _$2._2.\n\e[31m\e[31m-- Error: /tmp/tmp9u8d7ph0.scala:23:91\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \ \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.filter(_._2 > class_name_map.get(_._2)).map(_._1).sum\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                   ^\e[0m\n\e[31m   |\e[0m                No\
    \ implicit Ordering defined for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m          \
    \      where:    B is a type variable with constraint >: String\n\e[31m   |\e\
    [0m                .\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmp9u8d7ph0.scala:24:73\
    \ -----------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e\
    [0m \e[36mextension\e[0m = extensions_map.filter(_._2 == class_name_map.get(_._2)).map(_._1"
  stdout: ''
  timestamp: 1660009629
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val extensions_sorted = extensions_map.toSeq.sortBy(_._2).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpju7263i7.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpju7263i7.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions_sorted.takeWhile(_._2 > \e[31m0\e\
    [0m).map(_._1)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpju7263i7.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpju7263i7.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpju7263i7.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009631
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs)\n        val\
    \ max_strength = strength.max\n        val max_key = strength.maxBy(x => x)\n\
    \        val max_key_index = strength.indexOf(max_key)\n        val max_key_value\
    \ = extensions_map.get(max_key)\n        val max_key_key_value = max_key_value._1\n\
    \        val max_key_key_index = max_key_value._2\n        val max_key_key_value\
    \ = max_key_value._1\n        val max_key_key_index = max_key_value._2\n     \
    \   val max_key_key_value = max_key_value._1\n        val max_key_key_index =\
    \ max_key_value._2\n        val max_key_key_value = max_key_value._1\n       \
    \ val max_key_key_index = max_key_value._2\n        val max_key_key_value = max_key_value._1\n\
    \        val max_key_key_index = max_key_value._2\n        val max_key_key_value\
    \ = max_key_value._1\n        val max_key_key_index = max_key_value._2\n     \
    \   val max_key_key_value = max_key_value._1\n        val max_key_key_index =\
    \ max_key_value._2\n        val max_key_key_value = max_key_value._1\n       \
    \ val max_key_key_index = max_key_value._2\n        val max_key_key_value = max_key_value._1\n\
    \        val max_key_key_index = max_key_value._2\n        val max_key_key_value\
    \ = max_key_value._1\n        val max_key_key_index = max_key_value._2\n     \
    \   val max_key_key_value = max_key_value._1\n        val max_key_key_index =\
    \ max_key_value._2\n        val max_key_key_value = max_key_value._1\n       \
    \ val max_key_key_index = max_key_value._2\n        val max_key_key_value = max_key_value._1\n\
    \        val max_key_key_index = max_key_value._2\n        val max_key_key_value\
    \ = max_key_value._1\n        val max_key_key_index = max_key_value._2\n     \
    \   val max_key_key_value = max_key_value._1\n        val max_key_key_index =\
    \ max_key_value._2\n        val max_key_key_value = max_key_value._1\n       \
    \ val max_key_key_index = max_key_value._2\n        val max_key_key_value = max_key_value._1\n\
    \        val max_key_key_index = max_key_value._2\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9i4l2mvi.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmax_key_key_value\e[0m =\
    \ max_key_value._1\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_key_key_value is already defined as \e[33mvalue\e[0m \e\
    [35mmax_key_key_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9i4l2mvi.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmax_key_key_index\e[0m =\
    \ max_key_value._2\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_key_key_index is already defined as \e[33mvalue\e[0m \e\
    [35mmax_key_key_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9i4l2mvi.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmax_key_key_value\e[0m =\
    \ max_key_value._1\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_key_key_value is already defined as \e[33mvalue\e[0m \e\
    [35mmax_key_key_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9i4l2mvi.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mmax_key_key_index\e[0m =\
    \ max_key_value._2\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_key_key_index is already defined as \e[33mvalue\e[0m \e\
    [35mmax_key_key_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9i4l2mvi.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mmax_key_key_value\e[0m =\
    \ max_key_value._1\n\e[31m\e[31m   |\e[0"
  stdout: ''
  timestamp: 1660009635
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.values.max\n\
    \        val extension = extensions_map.values.min\n        val extension_str\
    \ = extensions_map.values.mkString(\".\")\n        val class_name_str = class_name.split(\"\
    .\").last\n        val class_name_str = class_name_str.substring(0, class_name_str.lastIndexOf(\"\
    .\"))\n        val class_name_str = class_name_str.replaceAll(\"_\", \"\")\n \
    \       val class_name_str = class_name_str.replaceAll(\"[^A-Z]\", \"\")\n   \
    \     val class_name_str = class_name_str.replaceAll(\"^\", \"\")\n        val\
    \ class_name_str = class_name_str.replaceAll(\"$\", \"\")\n        val class_name_str\
    \ = class_name_str.replaceAll(\"\\\\s\", \"\")\n        val class_name_str = class_name_str.replaceAll(\"\
    \\\\W\", \"\")\n        val class_name_str = class_name_str.replaceAll(\"\\\\\
    W\", \"\")\n        val class_name_str = class_name_str.replaceAll(\"\\\\W\",\
    \ \"\")\n        val class_name_str = class_name_str.replaceAll(\"\\\\W\", \"\"\
    )\n        val class_name_str = class_name_str.replaceAll(\"\\\\W\", \"\")\n \
    \       val class_name_str = class_name_str.replaceAll(\"\\\\W\", \"\")\n    \
    \    val class_name_str = class_name_str.replaceAll(\"\\\\W\", \"\")\n       \
    \ val class_name_str = class_name_str.replaceAll(\"\\\\W\", \"\")\n        val\
    \ class_name_str = class_name_str.replaceAll(\"\\\\W\", \"\")\n        val class_name_str\
    \ = class_name_str.replaceAll(\"\\\\W\", \"\")\n        val class_name_str = class_name_str.replaceAll(\"\
    \\\\W\", \"\")\n        val class_name_str = class_name_str.replaceAll(\"\\\\\
    W\", \"\")\n        val class_name_str = class_name_str.replaceAll(\"\\\\W\",\
    \ \"\")\n        val class_name_str = class_name_str.replaceAll(\"\\\\W\", \"\"\
    )\n        val class_name_str = class_name_str.replaceAll(\"\\\\W\", \"\")\n \
    \       val class_name_str = class_name_str.replaceAll(\"\\\\W\", \"\")\n    \
    \    val class_name_str = class_name_str.replaceAll(\"\\\\W\", \"\")\n       \
    \ val class_name_str = class_name_str.replaceAll(\"\\\\W\", \"\")\n        val\
    \ class_name_str = class_name_str.replaceAll(\"\\\\W\", \"\")\n        val class_name_str\
    \ = class_name_str.replaceAll(\"\\\\W\", \"\")\n        val class_name_str = class_name_str.replaceAll(\"\
    \\\\W\", \"\")\n        val class_name_str = class_name_str.replaceAll(\"\\\\\
    W\", \"\")\n        val class_name_str = class_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8wkcyg2l.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mclass_name_str\e[0m = class_name_str.substring(\e\
    [31m0\e[0m, class_name_str.lastIndexOf(\e[31m\".\"\e[0m))\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclass_name_str is already defined as \e[33mvalue\e[0m \e[35mclass_name_str\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8wkcyg2l.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mclass_name_str\e[0m = class_name_str.replaceAll(\e\
    [31m\"_\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclass_name_str is already defined as \e[33mvalue\e[0m \e[35mclass_name_str\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8wkcyg2l.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mclass_name_str\e[0m = class_name_str.replaceAll(\e\
    [31m\"[^A-Z]\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclass_name_str is already defined as \e[33mvalue\e[0m \e[35mclass_name_str\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8wkcyg2l.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mclass_name_str\e[0m = class_name_str.replaceAll(\e\
    [31m\"^\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclass_name_str is already defined as \e[33mvalue\e[0m \e[35mclass_name_str\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the s"
  stdout: ''
  timestamp: 1660009637
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val extensions_count_diff = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_diff_frac = extensions_count_diff / extensions_count_upper\n\
    \        val extensions_count_diff_frac_max = extensions_count_diff_frac.max\n\
    \        val extensions_count_diff_frac_max_index = extensions_count_diff_frac.indexWhere(_\
    \ == extensions_count_diff_frac_max)\n        val extensions_count_diff_frac_max_index\
    \ = extensions_count_diff_frac_max_index + extensions_count_diff_frac_max\n  \
    \      val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ / extensions_count_upper\n        val extensions_count_diff_frac_max_index =\
    \ extensions_count_diff_frac_max_index + 1\n        val extensions_count_diff_frac_max_index\
    \ = extensions_count_diff_frac_max_index / extensions_count_upper\n        val\
    \ extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ / extensions_count_upper\n        val extensions_count_diff_frac_max_index =\
    \ extensions_count_diff_frac_max_index + 1\n        val extensions_count_diff_frac_max_index\
    \ = extensions_count_diff_frac_max_index / extensions_count_upper\n        val\
    \ extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ / extensions_count_upper\n        val extensions_count_diff_frac_max_index =\
    \ extensions_count_diff_frac_max_index + 1\n        val extensions_count_diff_frac_max_index\
    \ = extensions_count_diff_frac_max_index / extensions_count_upper\n        val\
    \ extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ / extensions_count_upper\n        val extensions_count_diff_frac_max_index =\
    \ extensions_count_diff_frac_max_index + 1\n        val extensions_count_diff_frac_max_index\
    \ = extensions_count_diff_frac_max_index / extensions_count_upper\n        val\
    \ extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"\
    ), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9uzetg8_.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_frac_max_index\e\
    [0m = extensions_count_diff_frac_max_index + extensions_count_diff_frac_max\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_frac_max_index is already defined as\
    \ \e[33mvalue\e[0m \e[35mextensions_count_diff_frac_max_index\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9uzetg8_.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_frac_max_index\e[0m = extensions_count_diff_frac_max_index\
    \ / extensions_count_upper\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_frac_max_index is already defined as\
    \ \e[33mvalue\e[0m \e[35mextensions_count_diff_frac_max_index\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9uzetg8_.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_frac_max_index\e[0m = extensions_count_diff_frac_max_index\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_frac_max_index is already defined as\
    \ \e[33mvalue\e[0m \e[35mextensions_count_diff_frac_max_index\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9uzetg8_.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_frac_max_index\e[0m"
  stdout: ''
  timestamp: 1660009638
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val class_name_map = class_name.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n\
    \        val strength = extensions_map.foldLeft(0) { (acc, x) => acc + (x._1 -\
    \ x._2) }\n        val class_name_with_strength = class_name_map + (strength ->\
    \ class_name)\n        val max_strength = extensions_map.maxBy(x => x._1)._2\n\
    \        val max_class_name = class_name_map.maxBy(x => x._1)._2\n        val\
    \ max_class_name_with_strength = class_name_with_strength.maxBy(x => x._1)._2\n\
    \        val max_extension = extensions_map.maxBy(x => x._1)._2\n        val max_extension_with_strength\
    \ = extensions_map.maxBy(x => x._1)._2\n        val max_extension_strength = extensions_map.maxBy(x\
    \ => x._1)._2\n        val max_extension_strength_with_strength = extensions_map.maxBy(x\
    \ => x._1)._2\n        val max_extension_strength_with_strength_class_name = extensions_map.maxBy(x\
    \ => x._1)._2\n        val max_extension_strength_with_strength_class_name_with_strength\
    \ = extensions_map.maxBy(x => x._1)._2\n        val max_extension_strength_with_strength_class_name_with_strength_extension\
    \ = extensions_map.maxBy(x => x._1)._2\n        val max_extension_strength_with_strength_class_name_with_strength_extension_with_strength\
    \ = extensions_map.maxBy(x => x._1)._2\n        val max_extension_strength_with_strength_class_name_with_strength_extension_with_strength_extension\
    \ = extensions_map.maxBy(x => x._1)._2\n        val max_extension_strength_with_strength_class_name_with_strength_extension_with_strength_extension_extension\
    \ = extensions_map.maxBy(x => x._1)._2\n        val max_extension_strength_with_strength_class_name_with_strength_extension_with_strength_extension_extension_extension\
    \ = extensions_map.maxBy(x => x._1)._2\n        val max_extension_strength_with_strength_class_name_with_strength_extension_with_strength_extension_extension_extension_extension\
    \ = extensions_map.maxBy(x => x._1)._2\n        val max_extension_strength_with_strength_class_name_with_strength_extension_with_strength_extension_extension_extension_extension_extension\
    \ = extensions_map.maxBy(x => x._1)._2\n        val max_extension_strength_with_strength\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxed2ruto.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxed2ruto.scala:22:52\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mx\e[0m => (x.toUpperCase.size,\
    \ x.toLowerCase.size)).toMap\n\e[31m\e[31m   |\e[0m                          \
    \                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \              value toUpperCase is not a member of Char\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpxed2ruto.scala:22:72 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \ ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               value toLowerCase\
    \ is not a member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxed2ruto.scala:24:57\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mclass_name_with_strength\e\
    [0m = class_name_map + (strength -> class_name)\n\e[31m\e[31m   |\e[0m       \
    \                                                  ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                Found:    (Int,\
    \ String)\n\e[31m   |\e[0m                                                Required:\
    \ (Nothing, Any)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpxed2ruto.scala:26:60\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mmax_class_name\e[0m = class_name_map.maxBy(\e[36mx\e[0m\
    \ => x._1)._2\n\e[31m\e[31m   |\e[0m                                         \
    \                   ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e\
    [33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e\
    [33mobject\e[0m \e[35mBigInt\e[0m in \e[33mobject"
  stdout: ''
  timestamp: 1660009638
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x.toInt - class_name_map.get(x).toInt, x))\n\
    \        val strength_sorted = strength.sortBy(x => x._1).reverse\n        strength_sorted.head._2\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqjt0n0u3.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpqjt0n0u3.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqjt0n0u3.scala:23:84\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => (x.toInt - class_name_map.get(x).toInt,\
    \ x))\n\e[31m\e[31m   |\e[0m                                                 \
    \                                   ^\e[0m\n\e[31m   |\e[0m                  \
    \                                Found:    (x : String)\n\e[31m   |\e[0m     \
    \                                             Required: Nothing\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqjt0n0u3.scala:24:39 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mstrength_sorted\e[0m = strength.sortBy(\e\
    [36mx\e[0m => x._1).reverse\n\e[31m\e[31m   |\e[0m                           \
    \   ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             value sortBy is not a member\
    \ of Iterable[(Nothing, String)]\n4 errors found\n"
  stdout: ''
  timestamp: 1660009638
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        var strongest_extension\
    \ = \"\"\n        var strongest_extension_strength = -1\n        var extensions_with_same_strength\
    \ = List[String]()\n        for(extension <- extensions){\n            val cap\
    \ = extension.filter(x => x.isUpper).length\n            val sm = extension.filter(x\
    \ => x.isLower).length\n            val strength = cap - sm\n            if(strength\
    \ > strongest_extension_strength){\n                strongest_extension_strength\
    \ = strength\n                strongest_extension = extension\n            }\n\
    \            else if(strength == strongest_extension_strength){\n            \
    \    extensions_with_same_strength += extension\n            }\n        }\n  \
    \      if(extensions_with_same_strength.length > 1){\n            extensions_with_same_strength.sortWith((x,y)\
    \ => x.toString.compareTo(y.toString))\n            strongest_extension = extensions_with_same_strength(0)\n\
    \        }\n        class_name + \".\" + strongest_extension\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkm9jdp6e.scala:33:46 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                extensions_with_same_strength += extension\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkm9jdp6e.scala:37:80 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            extensions_with_same_strength.sortWith((\e\
    [36mx\e[0m,\e[36my\e[0m) => x.toString.compareTo(y.toString))\n\e[31m\e[31m  \
    \ |\e[0m                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                       Found:\
    \    Int\n\e[31m   |\e[0m                                                    \
    \   Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009638
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_count = class_name.length\n\
    \        val strength = extensions_count - class_name_count\n        if (strength\
    \ > 0) extensions(0) else \"\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjlrg3qzc.scala:27)\n\tat Problem.main(tmpjlrg3qzc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009640
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_length = class_name.length\n\
    \        val extension_length = extensions_count.toDouble / class_name_length\n\
    \        val extension_strength = extension_length - extensions_count.toDouble\n\
    \        val extension_strength_str = extension_strength.toString.replaceAll(\"\
    \\\\.\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    \\\\D\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^0\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_str = extension_strength_str.replaceAll(\"\
    ^-\", \"\")\n        val extension_strength_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmps15xwegw.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps15xwegw.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextension_strength_str\e[0m = extension_strength_str.replaceAll(\e[31m\"\
    \\\\D\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_strength_str is already defined as \e[33mvalue\e\
    [0m \e[35mextension_strength_str\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps15xwegw.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextension_strength_str\e\
    [0m = extension_strength_str.replaceAll(\e[31m\"^0\"\e[0m, \e[31m\"\"\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_strength_str is already defined as \e[33mvalue\e\
    [0m \e[35mextension_strength_str\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps15xwegw.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextension_strength_str\e\
    [0m = extension_strength_str.replaceAll(\e[31m\"^-\"\e[0m, \e[31m\"\"\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_strength_str is already defined as \e[33mvalue\e\
    [0m \e[35mextension_strength_str\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps15xwegw.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mextension_strength_str\e\
    [0m = extension_strength_str."
  stdout: ''
  timestamp: 1660009638
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.max\n        val extensions_sorted =\
    \ extensions_map.values.sortWith(_ < _)\n        val extensions_sorted = extensions_sorted.takeWhile(_\
    \ < strength)\n        val extensions_sorted = extensions_sorted.mkString(\"\"\
    ) + \".\"\n        val extensions_sorted = extensions_sorted.dropRight(1)\n  \
    \      class_name + extensions_sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4e_mbunu.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_ < strength)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4e_mbunu.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\"\"\e[0m) + \e[31m\".\"\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4e_mbunu.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp4e_mbunu.scala:23:54 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_map.values.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m               \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                  value sortWith is not a member of Iterable[Int]\n4 errors found\n"
  stdout: ''
  timestamp: 1660009640
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase - e.toLowerCase -> 1)).toMap\n        val\
    \ class_name_map = class_name.map(c => (c.toUpperCase -> 1)).toMap\n        val\
    \ max_strength = extensions_map.values.max\n        val max_key = extensions_map.keys.max\n\
    \        val max_key_index = extensions_map.keys.indexOf(max_key)\n        val\
    \ max_key_value = extensions_map.get(max_key)\n        val max_key_value_map =\
    \ max_key_value.map(c => (c.toUpperCase -> 1)).toMap\n        val max_key_value_map_keys\
    \ = max_key_value_map.keys\n        val max_key_value_map_values = max_key_value_map.values\n\
    \        val max_key_value_map_keys_index = max_key_value_map_keys.indexOf(max_key_value)\n\
    \        val max_key_value_map_values_index = max_key_value_map_values.indexOf(max_key_value)\n\
    \        val max_key_value_map_keys_value = max_key_value_map_keys.get(max_key_value_map_keys_index)\n\
    \        val max_key_value_map_values_value = max_key_value_map_values.get(max_key_value_map_values_index)\n\
    \        val max_key_value_map_keys_value_map = max_key_value_map_keys_value.map(c\
    \ => (c.toUpperCase -> 1)).toMap\n        val max_key_value_map_keys_value_map_keys\
    \ = max_key_value_map_keys_value_map.keys\n        val max_key_value_map_keys_value_map_values\
    \ = max_key_value_map_keys_value_map.values\n        val max_key_value_map_keys_value_map_keys_index\
    \ = max_key_value_map_keys_value_map_keys.indexOf(max_key_value_map_values_value)\n\
    \        val max_key_value_map_keys_value_map_values_index = max_key_value_map_keys_value_map_values.indexOf(max_key_value_map_values_value)\n\
    \        val max_key_value_map_keys_value_map_keys_value = max_key_value_map_keys_value_map_keys.get(max_key_value_map_keys_value_map_keys_index)\n\
    \        val max_key_value_map_keys_value_map_values_value = max_key_value_map_keys_value_map_values.get(max_key_value_map_keys_value_map_values_index)\n\
    \        val max_key_value_map_keys_value_map_keys_value_map = max_key_value_map_keys_value_map_keys_value.map(c\
    \ => (c.toUpperCase -> 1)).toMap\n        val max_key_value_map_keys_value_map_keys_value_map_keys\
    \ = max_key_value_map_keys_value_map_keys_value_map.keys\n        val max_key_value_map_keys_value_map_keys_value_map_values\
    \ = max_key_value_map_keys_value_map_keys_value_map.values\n        val max_key_value_map_keys_value_map_keys_value_map_keys_index\
    \ = max_key_value_map_keys_value_map_keys_value_map_keys.indexOf(max_key_value_map_keys_value_map_values_value)\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7upi4p_s.scala:21:64 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => (e.toUpperCase - e.toLowerCase -> \e[31m1\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                  ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp7upi4p_s.scala:22:52 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mc\e[0m => (c.toUpperCase -> \e[31m1\e[0m)).toMap\n\e[31m\e[31m   |\e[0m  \
    \                                                ^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                               value toUpperCase is not a member of Char\n\
    \e[31m\e[31m-- Error: /tmp/tmp7upi4p_s.scala:23:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mmax_strength\e[0m = extensions_map.values.max\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mBigInt\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- Error: /tmp/tmp7upi4p_s.scala:24:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmax_key\e[0m = extensions_map.keys.max\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e[0m in\
    \ \e[33mobject\e[0m \e"
  stdout: ''
  timestamp: 1660009641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val extensions_count_upper_ratio = extensions_count_upper / extensions_count.toDouble\n\
    \        val extensions_count_lower_ratio = extensions_count_lower / extensions_count.toDouble\n\
    \        val extensions_count_ratio = extensions_count_upper / extensions_count_lower\n\
    \        val extensions_count_ratio2 = extensions_count_upper_ratio / extensions_count_lower_ratio\n\
    \        val extensions_count_ratio3 = extensions_count_ratio * extensions_count_ratio2\n\
    \        val extensions_count_ratio4 = extensions_count_ratio3 * extensions_count_ratio\n\
    \        val extensions_count_ratio5 = extensions_count_ratio4 * extensions_count_ratio3\n\
    \        val extensions_count_ratio6 = extensions_count_ratio5 * extensions_count_ratio4\n\
    \        val extensions_count_ratio7 = extensions_count_ratio6 * extensions_count_ratio5\n\
    \        val extensions_count_ratio8 = extensions_count_ratio7 * extensions_count_ratio6\n\
    \        val extensions_count_ratio9 = extensions_count_ratio8 * extensions_count_ratio7\n\
    \        val extensions_count_ratio10 = extensions_count_ratio9 * extensions_count_ratio8\n\
    \        val extensions_count_ratio11 = extensions_count_ratio10 * extensions_count_ratio9\n\
    \        val extensions_count_ratio12 = extensions_count_ratio11 * extensions_count_ratio10\n\
    \        val extensions_count_ratio13 = extensions_count_ratio12 * extensions_count_ratio11\n\
    \        val extensions_count_ratio14 = extensions_count_ratio13 * extensions_count_ratio12\n\
    \        val extensions_count_ratio15 = extensions_count_ratio14 * extensions_count_ratio13\n\
    \        val extensions_count_ratio16 = extensions_count_ratio15 * extensions_count_ratio14\n\
    \        val extensions_count_ratio17 = extensions_count_ratio16 * extensions_count_ratio15\n\
    \        val extensions_count_ratio18 = extensions_count_ratio17 * extensions_count_ratio16\n\
    \        val extensions_count_ratio19 = extensions_count_ratio18 * extensions_count_ratio17\n\
    \        val extensions_count_ratio20 = extensions_count_ratio19 * extensions_count_ratio18\n\
    \        val extensions_count_ratio21 = extensions_count_ratio20 * extensions_count_ratio19\n\
    \        val extensions_count_ratio22 = extensions_count_ratio21 * extensions_count_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz_setx5n.scala:48:66 ------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_ratio22\e\
    [0m = extensions_count_ratio21 * extensions_count_\n\e[31m\e[31m   |\e[0m    \
    \                                                              ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Not found: extensions_count_\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz_setx5n.scala:49:5\
    \ ---------------------\e[0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009639
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.map(_.length).sort\n\
    \        val strength = extensions_count_sorted.last.toDouble / extensions_count.toDouble\n\
    \        val extensions_count_sorted_sorted = extensions_count_sorted.sort\n \
    \       val extensions_count_sorted_sorted_sorted = extensions_count_sorted_sorted.reverse\n\
    \        val extensions_count_sorted_sorted_sorted_sorted = extensions_count_sorted_sorted_sorted.reverse\n\
    \        val extensions_count_sorted_sorted_sorted_sorted_sorted = extensions_count_sorted_sorted_sorted_sorted.reverse\n\
    \        val extensions_count_sorted_sorted_sorted_sorted_sorted_sorted = extensions_count_sorted_sorted_sorted_sorted_sorted.reverse\n\
    \        val extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted_sorted_sorted_sorted_sorted.reverse\n     \
    \   val extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted = extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted.reverse\n\
    \        val extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.reverse\n\
    \        val extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.reverse\n\
    \        val extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.reverse\n\
    \        val extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.reverse\n\
    \        val extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.reverse\n\
    \        val extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.reverse\n\
    \        val extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.reverse\n\
    \        val extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.reverse\n\
    \        val extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.reverse\n\
    \        val extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwuou0ry9.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpwuou0ry9.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m = extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35mextensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpwuou0ry9.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m = extensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35mextensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpwuou0ry9.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m = extensions_count_sorted_sorted_sorted_sorted_sorte"
  stdout: ''
  timestamp: 1660009641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.getOrElse(x, 0) - x.toUpperCase.length).max\n\
    \        val extension = extensions_map.getOrElse(strength, \"\")\n        extension\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk5__ztcf.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpk5__ztcf.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk5__ztcf.scala:23:79\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => class_name_map.getOrElse(x, \e\
    [31m0\e[0m) - x.toUpperCase.length).max\n\e[31m\e[31m   |\e[0m               \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0m                                                  Found:    (x : String)\n\
    \e[31m   |\e[0m                                                  Required: Nothing\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk5__ztcf.scala:24:49\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextension\e\
    [0m = extensions_map.getOrElse(strength, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                                 ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                              Found:    (strength : Int)\n\e\
    [31m   |\e[0m                                              Required: String\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.split(\"\\\\.\").toMap\n        val strength = class_name_map.getOrElse(\"\
    \", \"\").length\n        val extensions_strength = extensions_map.getOrElse(\"\
    \", \"\").length\n        val strength_diff = strength - extensions_strength\n\
    \        val extensions_names = extensions_map.keys.toList\n        val extensions_names_sorted\
    \ = extensions_names.sortWith((a, b) => strength_diff * a.compareTo(b))\n    \
    \    val extensions_names_sorted = extensions_names_sorted.takeWhile(x => class_name_map.getOrElse(x,\
    \ \"\").length != 0).mkString(\".\")\n        val extensions_names_sorted = extensions_names_sorted.replaceFirst(\"\
    \\\\.\", \"\")\n        val extensions_names_sorted = extensions_names_sorted.replaceFirst(\"\
    ^\", \"\")\n        val extensions_names_sorted = extensions_names_sorted.replaceFirst(\"\
    \\\\.\", \"\")\n        val extensions_names_sorted = extensions_names_sorted.replaceFirst(\"\
    ^\", \"\")\n        val extensions_names_sorted = extensions_names_sorted.replaceFirst(\"\
    \\\\.\", \"\")\n        val extensions_names_sorted = extensions_names_sorted.replaceFirst(\"\
    ^\", \"\")\n        val extensions_names_sorted = extensions_names_sorted.replaceFirst(\"\
    \\\\.\", \"\")\n        val extensions_names_sorted = extensions_names_sorted.replaceFirst(\"\
    ^\", \"\")\n        val extensions_names_sorted = extensions_names_sorted.replaceFirst(\"\
    \\\\.\", \"\")\n        val extensions_names_sorted = extensions_names_sorted.replaceFirst(\"\
    ^\", \"\")\n        val extensions_names_sorted = extensions_names_sorted.replaceFirst(\"\
    \\\\.\", \"\")\n        val extensions_names_sorted = extensions_names_sorted.replaceFirst(\"\
    ^\", \"\")\n        val extensions_names_sorted = extensions_names_sorted.replaceFirst(\"\
    \\\\.\", \"\")\n        val extensions_names_sorted = extensions_names_sorted.replaceFirst(\"\
    ^\", \"\")\n        val extensions_names_sorted = extensions_names_sorted.replaceFirst(\"\
    \\\\.\", \"\")\n        val extensions_names_sorted = extensions_names_sorted.replaceFirst(\"\
    ^\", \"\")\n        val extensions_names_sorted = extensions_names_sorted.replaceFirst(\"\
    \\\\.\", \"\")\n        val extensions_names_sorted = extensions_names_sorted.replaceFirst(\"\
    ^\", \"\")\n        val extension\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptim3j579.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptim3j579.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_names_sorted\e[0m = extensions_names_sorted.takeWhile(\e[36mx\e\
    [0m => class_name_map.getOrElse(x, \e[31m\"\"\e[0m).length != \e[31m0\e[0m).mkString(\e\
    [31m\".\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_names_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_names_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmptim3j579.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mextensions_names_sorted\e\
    [0m = extensions_names_sorted.replaceFirst(\e[31m\"\\\\.\"\e[0m, \e[31m\"\"\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_names_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_names_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmptim3j579.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mextensions_names_sorted\e\
    [0m = extensions_names_sorted.replaceFirst(\e[31m\"^\"\e[0m, \e[31m\"\"\e[0m)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_names_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_names_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp"
  stdout: ''
  timestamp: 1660009640
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.count\n        val extensions_count_upper = extensions.count(_.toUpperCase)\n\
    \        val extensions_count_lower = extensions.count(_.toLowerCase)\n      \
    \  val extensions_count_diff = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_diff_upper = extensions_count_diff / extensions_count_upper\n\
    \        val extensions_count_diff_lower = extensions_count_diff / extensions_count_lower\n\
    \        val extensions_count_diff_diff_upper = extensions_count_diff_upper /\
    \ extensions_count_upper\n        val extensions_count_diff_diff_lower = extensions_count_diff_lower\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_upper / extensions_count_upper\n        val extensions_count_diff_diff_lower\
    \ = extensions_count_diff_diff_lower / extensions_count_lower\n        val extensions_count_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_upper / extensions_count_upper\n        val\
    \ extensions_count_diff_diff_diff_lower = extensions_count_diff_diff_diff_lower\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_upper / extensions_count_upper\n    \
    \    val extensions_count_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_lower\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_upper / extensions_count_upper\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_upper / extensions_count_upper\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_diff_lower\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_diff_upper / extensions_count_upper\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_diff_diff_upper / extensions_count_upper\n\
    \        val extensions_count_diff_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_diff_diff_diff_lower\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb7y044c7.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_lower / extensions_count_lower\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_lower is already defined as \e\
    [33mvalue\e[0m \e[35mextensions_count_diff_diff_lower\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb7y044c7.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_diff_diff_upper\e[0m = extensions_count_diff_diff_diff_upper\
    \ / extensions_count_upper\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_upper is already defined as\
    \ \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_upper\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb7y044c7.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_diff_diff_lower\e[0m = extensions_count_diff_diff_diff_diff_lower\
    \ / extensions_count_lower\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_lower is already defined as\
    \ \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_lower\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb7y044c7.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_dif"
  stdout: ''
  timestamp: 1660009642
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase - x.toLowerCase + 1)).toMap\n        val\
    \ strength = extensions_map.getOrElse(class_name, 0)\n        val sorted_extensions\
    \ = extensions_map.values.toList.sortWith(_ < _)\n        val first_extension\
    \ = sorted_extensions.head\n        val class_name_with_first_extension = class_name\
    \ + first_extension\n        val class_name_with_first_extension_strength = class_name_with_first_extension\
    \ + first_extension.substring(class_name_with_first_extension.length - 1)\n  \
    \      val class_name_with_first_extension_strength_strength = class_name_with_first_extension_strength\
    \ + first_extension.substring(class_name_with_first_extension_strength.length\
    \ - 1)\n        val class_name_with_first_extension_strength_strength_strength\
    \ = class_name_with_first_extension_strength_strength + first_extension.substring(class_name_with_first_extension_strength_strength.length\
    \ - 1)\n        val class_name_with_first_extension_strength_strength_strength_strength\
    \ = class_name_with_first_extension_strength_strength_strength + first_extension.substring(class_name_with_first_extension_strength_strength_strength.length\
    \ - 1)\n        val class_name_with_first_extension_strength_strength_strength_strength_strength\
    \ = class_name_with_first_extension_strength_strength_strength_strength + first_extension.substring(class_name_with_first_extension_strength_strength_strength_strength.length\
    \ - 1)\n        val class_name_with_first_extension_strength_strength_strength_strength_strength_strength\
    \ = class_name_with_first_extension_strength_strength_strength_strength_strength\
    \ + first_extension.substring(class_name_with_first_extension_strength_strength_strength_strength_strength_strength.length\
    \ - 1)\n        val class_name_with_first_extension_strength_strength_strength_strength_strength_strength_strength\
    \ = class_name_with_first_extension_strength_strength_strength_strength_strength_strength_strength\
    \ + first_extension.substring(class_name_with_first_extension_strength_strength_strength_strength_strength_strength_strength.length\
    \ - 1)\n        val class_name_with_first_extension_strength_strength_strength_strength_strength_strength_strength_strength\
    \ = class_name_with_first_extension_strength_strength_strength_strength_strength_strength_strength_strength\
    \ + first_extension.substring(class_name_with_first_extension_strength_strength_strength_strength_strength_strength_strength_strength_strength.length\
    \ - 1)\n        val class_name_with_first_extension_strength_strength_strength_strength_strength_strength_strength_strength_strength_strength\
    \ = class_name_\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwhgf3t2y.scala:21:64 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36mx\e[0m => (x.toUpperCase - x.toLowerCase + \e[31m1\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                  ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpwhgf3t2y.scala:22:48 --------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.getOrElse(class_name,\
    \ \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                       \
    \         ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                   \
    \      Found:    (class_name : String)\n\e[31m   |\e[0m                      \
    \                   Required: Nothing\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpwhgf3t2y.scala:23:72 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36msorted_extensions\e[0m = extensions_map.values.toList.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                                                \
    \                      ^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member of Nothing,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import Byte.byte2float\n\
    \e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import Byte.byte2long\n\
    \e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import Char.char2double\n\
    \e[31m   |\e[0m  import Char.char2float\n\e[31m "
  stdout: ''
  timestamp: 1660009643
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.getOrElse(x, 0) - x.toUpperCase.length).max\n\
    \        val extensions_sorted = extensions_map.values.sortBy(x => x.toUpperCase.length).reverse\n\
    \        val extensions_sorted_sorted = extensions_sorted.sortBy(x => x.toUpperCase.length).reverse\n\
    \        val extensions_sorted_sorted_sorted = extensions_sorted_sorted.sortBy(x\
    \ => x.toUpperCase.length).reverse\n        val extensions_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted.sortBy(x => x.toUpperCase.length).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted = extensions_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toUpperCase.length).reverse\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted.sortBy(x => x.toUpperCase.length).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted = extensions_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toUpperCase.length).reverse\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x => x.toUpperCase.length).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toUpperCase.length).reverse\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toUpperCase.length).reverse\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toUpperCase.length).reverse\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toUpperCase.length).reverse\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.toUpperCase.length).reverse\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprnm5qytl.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(\e\
    [36mx\e[0m => x.toUpperCase.length).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmprnm5qytl.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmprnm5qytl.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprnm5qytl.scala:23:79\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => class_name_map.getOrElse(x, \e\
    [31m0\e["
  stdout: ''
  timestamp: 1660009642
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((a, b) => math.max(a, b))\n \
    \       val extensions_sorted = extensions_map.values.sortWith((a, b) => a > b)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < strength).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 1).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 2).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 3).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 4).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 5).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 6).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 7).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 8).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 9).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 10).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 11).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 12).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 13).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 14).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 15).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 16).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 17).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 18).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 19).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 20).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 21).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 22).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 23).reverse\n\
    \        val extensions_sorted = extensions_sor\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptauq7nbu.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_ > \e[31m0\e[0m).reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmptauq7nbu.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_ < strength).reverse\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmptauq7nbu.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_ < \e[31m1\e[0m).reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmptauq7nbu.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_ < \e[31m2\e[0m).reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all "
  stdout: ''
  timestamp: 1660009643
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.sortBy(_.length)\n\
    \        val extensions_count_sorted_reversed = extensions_count_sorted.reverse\n\
    \        val extensions_count_sorted_reversed_length = extensions_count_sorted_reversed.map(_.length)\n\
    \        val extensions_count_sorted_reversed_length_sum = extensions_count_sorted_reversed_length.sum\n\
    \        val extensions_count_sorted_reversed_length_sum_sorted = extensions_count_sorted_reversed_length.sortBy(_.sum)\n\
    \        val extensions_count_sorted_reversed_length_sum_sorted_reversed = extensions_count_sorted_reversed_length_sum_sorted.reverse\n\
    \        val extensions_count_sorted_reversed_length_sum_sorted_reversed_length\
    \ = extensions_count_sorted_reversed_length_sum_sorted_reversed.map(_.length)\n\
    \        val extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum\
    \ = extensions_count_sorted_reversed_length_sum_sorted_reversed_length.sum\n \
    \       val extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted\
    \ = extensions_count_sorted_reversed_length_sum_sorted_reversed_length.sortBy(_.sum)\n\
    \        val extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed\
    \ = extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed.reverse\n\
    \        val extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length\
    \ = extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length.map(_.length)\n\
    \        val extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sum\
    \ = extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sum.sum\n\
    \        val extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted\
    \ = extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length.sortBy(_.sum)\n\
    \        val extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed\
    \ = extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed.reverse\n\
    \        val extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length\
    \ = extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length.map(_.length)\n\
    \        val extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sum\
    \ = extensions_count_sorted_reversed_length_sum_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9jah8ntc.scala:26:114 -----------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_reversed_length_sum_sorted\e\
    [0m = extensions_count_sorted_reversed_length.sortBy(_.sum)\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                      ^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                             value sum is not a member of Int\n\e[31m\e[31m--\
    \ Error: /tmp/tmp9jah8ntc.scala:26:118 ----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_reversed_length_sum_sorted\e\
    [0m = extensions_count_sorted_reversed_length.sortBy(_.sum)\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                            ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mShort\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmp9jah8ntc.scala:31:101 --------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed\e\
    [0m = extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed.reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                             ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp9jah8ntc.scala:32:108 --------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_reversed_leng"
  stdout: ''
  timestamp: 1660009643
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs)\n        val\
    \ max_strength = strength.max\n        val max_key = strength.indexWhere(x =>\
    \ x == max_strength)\n        val max_key = max_key match {\n            case\
    \ Some(i) => extensions_map.getOrElse(extensions_map.keys.apply(i), \"\")\n  \
    \          case None => \"\"\n        }\n        val max_key = max_key match {\n\
    \            case Some(class_name) => class_name\n            case None => \"\"\
    \n        }\n        max_key + extensions_map.getOrElse(max_key, \"\")\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"\
    ), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuhztyfmm.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax_key\e[0m = max_key \e\
    [33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0mmax_key\
    \ is already defined as \e[33mvalue\e[0m \e[35mmax_key\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m27 |\e[0m            \e[33mcase\e[0m Some(i)\
    \ => extensions_map.getOrElse(extensions_map.keys.apply(i), \e[31m\"\"\e[0m)\n\
    \e[31m28 |\e[0m            \e[33mcase\e[0m None => \e[31m\"\"\e[0m\n\e[31m29 |\e\
    [0m        }\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuhztyfmm.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmax_key\e[0m = max_key \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m     \
    \   ^\e[0m\n\e[31m   |\e[0mmax_key is already defined as \e[33mvalue\e[0m \e[35mmax_key\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m31 |\e[0m         \
    \   \e[33mcase\e[0m Some(class_name) => class_name\n\e[31m32 |\e[0m          \
    \  \e[33mcase\e[0m None => \e[31m\"\"\e[0m\n\e[31m33 |\e[0m        }\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpuhztyfmm.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpuhztyfmm.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuhztyfmm.scala:23:57\
    \ ---------------"
  stdout: ''
  timestamp: 1660009643
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.filter(_._2.length == class_name_map.get(_._2)).length\n  \
    \      val extension = extensions_map.filter(_._2.length == class_name_map.get(_._2)).head._1\n\
    \        val extension_map = extensions_map.filter(_._2.length == class_name_map.get(_._2)).head._2\n\
    \        val extension_strength = extension_map.filter(_._2.length == class_name_map.get(_._2)).length\n\
    \        val extension_strength_map = extension_map.filter(_._2.length == class_name_map.get(_._2)).head._2\n\
    \        val extension_strength_map_sorted = extension_strength_map.sortBy(x =>\
    \ x._1)\n        val extension_strength_map_sorted_sorted = extension_strength_map_sorted.sortBy(x\
    \ => x._2)\n        val extension_strength_map_sorted_sorted_sorted = extension_strength_map_sorted_sorted.sortBy(x\
    \ => x._1)\n        val extension_strength_map_sorted_sorted_sorted_sorted = extension_strength_map_sorted_sorted_sorted.sortBy(x\
    \ => x._2)\n        val extension_strength_map_sorted_sorted_sorted_sorted_sorted\
    \ = extension_strength_map_sorted_sorted_sorted_sorted.sortBy(x => x._1)\n   \
    \     val extension_strength_map_sorted_sorted_sorted_sorted_sorted_sorted = extension_strength_map_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x._2)\n        val extension_strength_map_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extension_strength_map_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x._1)\n        val extension_strength_map_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extension_strength_map_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x._2)\n        val extension_strength_map_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extension_strength_map_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x._1)\n        val extension_strength_map_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extension_strength_map_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x._2)\n        val extension_strength_map_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extension_strength_map_sorted_sorted_sorted_sorted_sorted_\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfc1gyz1e.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpfc1gyz1e.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpfc1gyz1e.scala:23:79\
    \ -----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e\
    [0m \e[36mstrength\e[0m = extensions_map.filter(_._2.length == class_name_map.get(_._2)).length\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                       ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$2\
    \ of expanded function:\n\e[31m   |\e[0m   _$2 => _$2._2.\n\e[31m\e[31m-- [E081]\
    \ Type Error: /tmp/tmpfc1gyz1e.scala:24:80 -----------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextension\e[0m = extensions_map.filter(_._2.length\
    \ == class_name_map.get(_._2)).head._1\n\e[31m\e[31m   |\e[0m                \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could\
    \ not infer the type of the parameter _$4 of expanded function:\n\e[31m   |\e\
    [0m   _$4 => _$4._2.\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpfc1gyz1e.scala:25:84\
    \ -----------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e\
    [0m \e[36mextension_map\e[0m = extensions_map.filter(_._2.length == class_name_map.get(_._2)).head._2\n\
    \e[31m\e[31m   "
  stdout: ''
  timestamp: 1660009644
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase).map(_.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase).map(_.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper_lower = extensions.map(_.toUpperCase).map(_.toLowerCase).map(_.length).sum\n\
    \        val extensions_count_lower_upper = extensions.map(_.toLowerCase).map(_.toUpperCase).map(_.length).sum\n\
    \        val strength_lower = extensions_count_lower_upper - extensions_count_upper\n\
    \        val strength_upper = extensions_count_upper - extensions_count_lower\n\
    \        val strength_upper_to_lower = extensions_count_upper_lower - extensions_count_lower\n\
    \        val strength_lower_to_upper = extensions_count_lower_upper - extensions_count_upper\n\
    \        val strength_upper_to_lower_to_lower = extensions_count_upper_lower_lower\
    \ - extensions_count_lower_upper\n        val strength_lower_to_upper_to_lower\
    \ = extensions_count_lower_upper_lower - extensions_count_upper_lower\n      \
    \  val strength_upper_to_lower_to_lower_to_upper = extensions_count_upper_lower_lower_upper\
    \ - extensions_count_lower_upper_lower\n        val strength_lower_to_upper_to_lower_to_upper\
    \ = extensions_count_lower_upper_lower_upper - extensions_count_upper_lower_lower\n\
    \        val strength_upper_to_lower_to_lower_to_upper_to_lower = extensions_count_upper_lower_lower_upper_lower\
    \ - extensions_count_lower_upper_lower_upper\n        val strength_lower_to_upper_to_lower_to_upper_to_lower_to_upper\
    \ = extensions_count_lower_upper_lower_upper_lower_upper - extensions_count_upper_lower_lower_upper_lower\n\
    \        val strength_upper_to_lower_to_lower_to_upper_to_lower_to_upper_to_lower\
    \ = extensions_count_upper_lower_lower_upper_lower_upper_lower - extensions_count_upper_lower_lower_upper_lower_upper\n\
    \        val strength_lower_to_upper_to_lower_to_upper_to_lower_to_upper_to_lower_to_upper\
    \ = extensions_count_lower_upper_lower_upper_lower_upper_lower_upper_lower - extensions_count_upper_lower_lower_upper_lower_upper_lower_upper\n\
    \        val strength_upper_to_lower_to_lower_to_upper_to_lower_to_upper_to_lower_to_upper_to_lower\
    \ = extensions_count_upper_lower_lower_upper_lower_upper_lower_upper_lower - extensions_count_upper_lower_lower_upper_lower_upper_lower_upper\n\
    \        val strength_lower_to_upper_to_lower_to_upper_to_lower_to_upper\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpz3j6l1cg.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz3j6l1cg.scala:33:47\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength_upper_to_lower_to_lower\e[0m = extensions_count_upper_lower_lower\
    \ - extensions_count_lower_upper\n\e[31m\e[31m   |\e[0m                      \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           Not found: extensions_count_upper_lower_lower\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz3j6l1cg.scala:34:47\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength_lower_to_upper_to_lower\e[0m = extensions_count_lower_upper_lower\
    \ - extensions_count_upper_lower\n\e[31m\e[31m   |\e[0m                      \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           Not found: extensions_count_lower_upper_lower\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz3j6l1cg.scala:35:56\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength_upper_to_lower_to_lower_to_upper\e[0m = extensions_count_upper_lower_lower_upper\
    \ - extensions_count_lower_upper_lower\n\e[31m\e[31m   |\e[0m                \
    \                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: extensions_count_upper_lower_lower_upper\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz3j6l1cg.scala:36:56\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength_lower_to_upper_to_lower_to_upper\e[0m = extensions_count_lower_upper_lower_upper\
    \ - extensions_count_upper_lower_"
  stdout: ''
  timestamp: 1660009645
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val extensions_sorted = extensions_map.toSeq.sortWith((a, b) =>\
    \ strength - a._2).map(_._1)\n        val extensions_sorted = extensions_sorted.take(1).mkString.concat(\"\
    .\").concat(extensions_sorted.last)\n        extensions_sorted\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps_yp9ymn.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.take(\e[31m1\e[0m).mkString.concat(\e[31m\".\"\e[0m).concat(extensions_sorted.last)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- Error: /tmp/tmps_yp9ymn.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n2 errors found\n"
  stdout: ''
  timestamp: 1660009645
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val sorted_extensions = extensions_map.toSeq.sortBy(_._2).reverse\n\
    \        val first_extension = sorted_extensions.head\n        val extension_str\
    \ = first_extension._1 + \".\" + first_extension._2\n        if (strength == 0)\
    \ extension_str\n        else if (strength > 0) extension_str\n        else if\
    \ (strength < 0) extension_str + extensions_map.getOrElse(class_name, \"\")\n\
    \        else \"\"\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpyp33qdei.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n1 error found\n"
  stdout: ''
  timestamp: 1660009648
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.getOrElse(class_name, 0)\n        val extensions_sorted\
    \ = extensions_map.toSeq.sortBy(_._1).reverse\n        val extensions_sorted =\
    \ extensions_sorted.takeWhile(_._2 > strength).map(_._1)\n        val extensions_sorted\
    \ = extensions_sorted.mkString(\"\")\n        class_name + extensions_sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9ijshutb.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > strength).map(_._1)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9ijshutb.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp9ijshutb.scala:22:48 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.getOrElse(class_name,\
    \ \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                       \
    \         ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                   \
    \      Found:    (class_name : String)\n\e[31m   |\e[0m                      \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009650
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.values.max\n\
    \        val extensions_sorted = extensions_map.toSeq.sortBy(_._2).reverse\n \
    \       val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpzjnfwgo7.scala:44:11 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpzjnfwgo7.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzjnfwgo7.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzjnfwgo7.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzjnfwgo7.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions"
  stdout: ''
  timestamp: 1660009651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val extensions_count_diff = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_diff_upper = extensions_count_upper - extensions_count_diff\n\
    \        val extensions_count_diff_lower = extensions_count_lower - extensions_count_diff\n\
    \        val extensions_count_diff_diff_upper = extensions_count_diff_upper -\
    \ extensions_count_diff_lower\n        val extensions_count_diff_diff_lower =\
    \ extensions_count_diff_lower - extensions_count_diff_upper\n        val extensions_count_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_upper - extensions_count_diff_diff_lower\n    \
    \    val extensions_count_diff_diff_diff_lower = extensions_count_diff_diff_lower\
    \ - extensions_count_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_upper - extensions_count_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_diff_diff_diff_upper\n        val\
    \ extensions_count_diff_diff_diff_\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpll4rx2mx.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpll4rx2mx.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_diff_diff_diff_upper\e[0m = extensions_count_diff_diff_diff_diff_upper\
    \ - extensions_count_diff_diff_diff_diff_lower\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_upper is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_upper\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpll4rx2mx.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_lower is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_lower\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpll4rx2mx.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_diff_diff_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009614
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_low\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpeyrb48xe.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpeyrb48xe.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_upper\e[0m = extensions.map(_.toUpperCase.length).sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_upper is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_upper\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpeyrb48xe.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_lower\e\
    [0m = extensions.map(_.toLowerCase.length).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_lower is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_lower\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpeyrb48xe.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_count_upper\
    \ - extensions_count_lower\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength is already defined as \e[33mvalue\e[0m \e[35mstrength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpeyrb48xe.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mclass_name_upper\e[0m = class_name.toUpperCase\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mclass_name_upper is already defin"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.getOrElse(x, 0) - x.toUpperCase.length).toArray\n\
    \        val max_strength = strength.max\n        val max_key = extensions_map.keys.toArray.max\n\
    \        val max_value = strength.max\n        val max_key_value = class_name_map.getOrElse(max_key,\
    \ 0)\n        val max_key_value_length = max_key_value.length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = max_key_value_length + max_key_value_length\n        val max_key_value_length\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpqr_8tayi.scala:53:34 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e[36mmax_key_value_length\e[0m\
    \ = \n\e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m  \
    \ |\e[0m                                  expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqr_8tayi.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmax_key_value_length\e[0m = max_key_value_length + max_key_value_length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_key_value_length is already defined as \e[33mvalue\e[0m\
    \ \e[35mmax_key_value_length\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpqr_8tayi.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmax_key_value_length\e[0m\
    \ = max_key_value_length + max_key_value_length\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmax_key_value_length is already defined as \e[33mvalue\e[0m \e\
    [35mmax_key_value_length\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpqr_8tayi.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmax_key_value_length\e[0m\
    \ = max_key_value_length + max_key_value_length\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmax_key_value_length is already defined as \e[33mvalue\e[0m \e\
    [35mmax_key_value_length\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpqr_8tayi.scala:32"
  stdout: ''
  timestamp: 1660009652
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val extensions_sorted = extensions.sortWith(_.length > _.length)\n      \
    \  val extensions_sorted = extensions.sortWith(_.toUpperCase.length > _.toUpperCase.length)\n\
    \        val extensions_sorted = extensions.sortWith(_.toLowerCase.length > _.toLowerCase.length)\n\
    \        val extensions_sorted = extensions.sortWith(_.length < _.length)\n  \
    \      val extensions_sorted = extensions.sortWith(_.toUpperCase.length < _.toUpperCase.length)\n\
    \        val extensions_sorted = extensions.sortWith(_.toLowerCase.length < _.toLowerCase.length)\n\
    \        val extensions_sorted = extensions.sortWith(_.length < _.length)\n  \
    \      val extensions_sorted = extensions.sortWith(_.toUpperCase.length < _.toUpperCase.length)\n\
    \        val extensions_sorted = extensions.sortWith(_.toLowerCase.length < _.toLowerCase.length)\n\
    \        val extensions_sorted = extensions.sortWith(_.length < _.length)\n  \
    \      val extensions_sorted = extensions.sortWith(_.toUpperCase.length < _.toUpperCase.length)\n\
    \        val extensions_sorted = extensions.sortWith(_.toLowerCase.length < _.toLowerCase.length)\n\
    \        val extensions_sorted = extensions.sortWith(_.length < _.length)\n  \
    \      val extensions_sorted = extensions.sortWith(_.toUpperCase.length < _.toUpperCase.length)\n\
    \        val extensions_sorted = extensions.sortWith(_.toLowerCase.length < _.toLowerCase.length)\n\
    \        val extensions_sorted = extensions.sortWith(_.length < _.length)\n  \
    \      val extensions_sorted = extensions.sortWith(_.toUpperCase.length < _.toUpperCase.length)\n\
    \        val extensions_sorted = extensions.sortWith(_.toLowerCase.length < _.toLowerCase.length)\n\
    \        val extensions_sorted = extensions.sortWith(_.length < _.length)\n  \
    \      val extensions_sorted = extensions.sortWith(_.toUpperCase.length < _.toUpperCase.length)\n\
    \        val extensions_sorted = extensions.sortWith(_.toLowerCase.length < _.toLowerCase.length)\n\
    \        val extensions_sorted = extensions.sortWith(_.length < _.length)\n  \
    \      val extensions_sorted = extensions.sortWith(_.toUpperCase.length < _.toUpperCase.length)\n\
    \        val extensions_sorted = extensions.sortWith(_.toLowerCase.length < _.toLowerCase.length)\n\
    \        val extensions_sorted = extensions.sortWith(\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpyxg10tkm.scala:49:52 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith(\n\e[31m\e[31m   |\e[0m                                \
    \                    ^\e[0m\n\e[31m   |\e[0m                                 \
    \      expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpyxg10tkm.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith(_.toUpperCase.length > _.toUpperCase.length)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpyxg10tkm.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith(_.toLowerCase.length > _.toLowerCase.length)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpyxg10tkm.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith(_.length < _.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group o"
  stdout: ''
  timestamp: 1660009651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase)\n\
    \        val extensions_sorted = extensions_map.toSeq.sortBy(_._2).reverse\n \
    \       val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.map(e => class_name + \".\"\
    \ + e)\n        extensions_sorted.head\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzr5wz3zs.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzr5wz3zs.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36me\e[0m => class_name + \e[31m\".\"\e[0m + e)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpzr5wz3zs.scala:21:100 -----------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.charAt(\e[31m0\e[0m) -> e.toUpperCase.charAt(\e[31m1\e\
    [0m).toLowerCase)\n\e[31m\e[31m   |\e[0m                                     \
    \                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- Error: /tmp/tmpzr5wz3zs.scala:22:65 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_map.toSeq.sortBy(_._2).reverse\n\e[31m\e[31m   |\e[0m           \
    \                                                      ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mShort\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mString\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m "
  stdout: ''
  timestamp: 1660009651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n     \
    \   val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_ == '_').drop(1)\n\
    \        class_name + extensions_sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwxh9nfol.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpwxh9nfol.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.dropWhile(_ == \e[31m'_'\e[0m).drop(\e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009649
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.filter(_._2 > class_name_map.get(_._2)).map(_._1).sum\n   \
    \     val extension = extensions_map.filter(_._2 == class_name_map.get(_._2)).map(_._1).head\n\
    \        s\"$class_name.$extension\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9u8d7ph0.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp9u8d7ph0.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmp9u8d7ph0.scala:23:71\
    \ -----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e\
    [0m \e[36mstrength\e[0m = extensions_map.filter(_._2 > class_name_map.get(_._2)).map(_._1).sum\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$2 of expanded\
    \ function:\n\e[31m   |\e[0m   _$2 => _$2._2.\n\e[31m\e[31m-- Error: /tmp/tmp9u8d7ph0.scala:23:91\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \ \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.filter(_._2 > class_name_map.get(_._2)).map(_._1).sum\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                   ^\e[0m\n\e[31m   |\e[0m                No\
    \ implicit Ordering defined for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m          \
    \      where:    B is a type variable with constraint >: String\n\e[31m   |\e\
    [0m                .\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmp9u8d7ph0.scala:24:73\
    \ -----------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e\
    [0m \e[36mextension\e[0m = extensions_map.filter(_._2 == class_name_map.get(_._2)).map(_._1"
  stdout: ''
  timestamp: 1660009629
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strengths\
    \ = extensions_map.filter(_._2 > class_name_map.get(_._2)).map(_._1)\n       \
    \ val strength = strengths.maxBy(x => x.length)\n        val class_name = class_name_map.getOrElse(strength,\
    \ \"\")\n        val extension = extensions_map.getOrElse(strength, \"\")\n  \
    \      class_name + extension\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzmxlnbkb.scala:25:25 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mclass_name\e[0m = class_name_map.getOrElse(strength,\
    \ \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m\
    \   |\e[0m                         Recursive \e[33mvalue\e[0m \e[35mclass_name_map\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009648
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n     \
    \   val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.toList\n        val extensions_sorted\
    \ = extensions_sorted.map(x => class_name + x).mkString(\".\")\n        extensions_sorted.head\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi5_96pt8.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpi5_96pt8.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpi5_96pt8.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36mx\e[0m => class_name + x).mkString(\e[31m\".\"\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpi5_96pt8.scala:26:26 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        extensions_sorted.head\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (Int, Int)\n\
    \e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase, e.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(c => (c.toUpperCase, c.toLowerCase)).toMap\n        val extensions_sorted\
    \ = extensions_map.toSeq.sortBy(_._2).reverse\n        val class_name_sorted =\
    \ class_name_map.toSeq.sortBy(_._2).reverse\n        val class_name_length = class_name_sorted.head._2.length\n\
    \        val extensions_length = extensions_sorted.head._2.length\n        val\
    \ strength = extensions_length - class_name_length\n        if (strength == 0)\
    \ class_name_sorted.head._1\n        else if (strength > 0) class_name_sorted.head._1\n\
    \        else extensions_sorted.head._1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw5w329yh.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mc\e[0m => (c.toUpperCase, c.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpw5w329yh.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mc\e[0m => (c.toUpperCase, c.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- Error: /tmp/tmpw5w329yh.scala:24:65 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mclass_name_sorted\e[0m =\
    \ class_name_map.toSeq.sortBy(_._2).reverse\n\e[31m\e[31m   |\e[0m           \
    \                                                      ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660009654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((a, b) => math.max(a, b))\n \
    \       val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n  \
    \      val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.replaceAll(\"(.)\\\\1\"\
    , \"$1\")\n        class_name + \".\" + extensions_sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpltk6h4s2.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpltk6h4s2.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.replaceAll(\e[31m\"(.)\\\\1\"\e[0m, \e[31m\"$1\"\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009650
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strengths\
    \ = extensions_map.values.map(x => (x, class_name_map.get(x)))\n        val max_strength\
    \ = strengths.maxBy(x => x._1)\n        val max_key = max_strength._2\n      \
    \  val max_value = max_strength._1\n        val max_key = max_key.substring(0,\
    \ max_key.indexOf(\"_\"))\n        val max_value = max_value.substring(0, max_value.indexOf(\"\
    _\"))\n        class_name + \".\" + max_key + max_value\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph6kq3pr9.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmax_key\e[0m = max_key.substring(\e\
    [31m0\e[0m, max_key.indexOf(\e[31m\"_\"\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_key is already defined as \e[33mvalue\e[0m \e[35mmax_key\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmph6kq3pr9.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mmax_value\e[0m = max_value.substring(\e\
    [31m0\e[0m, max_value.indexOf(\e[31m\"_\"\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mmax_value is already defined as \e[33mvalue\e[0m \e[35mmax_value\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmph6kq3pr9.scala:22:52 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e[36mx\e\
    [0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m          \
    \                                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                              value toUpperCase is not a member of Char\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmph6kq3pr9.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph6kq3pr9.scala:23:78\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrengths\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => (x, class_name_map.get(x)))\n\e\
    [31m\e[31m   "
  stdout: ''
  timestamp: 1660009655
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.foldLeft(0) { (acc, x) => acc + (class_name_map(x._1) - class_name_map(x._2))\
    \ }\n        val strongest_extension = extensions_map.maxBy(_._1)\n        val\
    \ strongest_extension_class = class_name_map(strongest_extension._1)\n       \
    \ val strongest_extension_strength = strongest_extension._2\n        val strongest_extension_class_name\
    \ = strongest_extension_class + \".\" + strongest_extension_strength\n       \
    \ val strongest_extension_class_name_map = strongest_extension_class_name.map(x\
    \ => (x.toUpperCase, x.toLowerCase)).toMap\n        val strongest_extension_class_name_strength\
    \ = strongest_extension_class_name_map(strongest_extension_strength)\n       \
    \ val strongest_extension_class_name_strength_map = strongest_extension_class_name_strength.map(x\
    \ => (x.toUpperCase, x.toLowerCase)).toMap\n        val strongest_extension_class_name_strength_strength\
    \ = strongest_extension_class_name_strength_map(strongest_extension_strength)\n\
    \        val strongest_extension_class_name_strength_strength_map = strongest_extension_class_name_strength_strength.map(x\
    \ => (x.toUpperCase, x.toLowerCase)).toMap\n        val strongest_extension_class_name_strength_strength_strength_map\
    \ = strongest_extension_class_name_strength_strength_strength.map(x => (x.toUpperCase,\
    \ x.toLowerCase)).toMap\n        val strongest_extension_class_name_strength_strength_strength_map\
    \ = strongest_extension_class_name_strength_strength_strength.map(x => (x.toUpperCase,\
    \ x.toLowerCase)).toMap\n        val strongest_extension_class_name_strength_strength_strength_map\
    \ = strongest_extension_class_name_strength_strength_strength.map(x => (x.toUpperCase,\
    \ x.toLowerCase)).toMap\n        val strongest_extension_class_name_strength_strength_strength_map\
    \ = strongest_extension_class_name_strength_strength_strength.map(x => (x.toUpperCase,\
    \ x.toLowerCase)).toMap\n        val strongest_extension_class_name_strength_strength_strength_map\
    \ = strongest_extension_class_name_strength_strength_strength.map(x => (x.toUpperCase,\
    \ x.toLowerCase\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphj2vzfg_.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphj2vzfg_.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstrongest_extension_class_name_strength_strength_strength_map\e[0m = strongest_extension_class_name_strength_strength_strength.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrongest_extension_class_name_strength_strength_strength_map\
    \ is already defined as \e[33mvalue\e[0m \e[35mstrongest_extension_class_name_strength_strength_strength_map\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphj2vzfg_.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mstrongest_extension_class_name_strength_strength_strength_map\e\
    [0m = strongest_extension_class_name_strength_strength_strength.map(\e[36mx\e\
    [0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrongest_extension_class_name_strength_strength_strength_map\
    \ is already defined as \e[33mvalue\e[0m \e[35mstrongest_extension_class_name_strength_strength_strength_map\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphj2vzfg_.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mstrongest_extension_class_name_strength_strength_strength_map\e\
    [0m = str"
  stdout: ''
  timestamp: 1660009657
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase - x.toLowerCase -> x)).toMap\n        val\
    \ extensions_list_sorted = extensions_map.values.toList.sortWith(_._1 < _._1)\n\
    \        val extensions_list_sorted = extensions_list_sorted.take(extensions_list_sorted.length-1)\n\
    \        val extensions_list_sorted.map(x => class_name + x._1).mkString(\".\"\
    ) + \".\" + extensions_list_sorted.map(x => x._2).mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4dnchwyk.scala:24:41 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m extensions_list_sorted.map(x =>\
    \ class_name + x._1).mkString(\e[31m\".\"\e[0m) + \e[31m\".\"\e[0m + extensions_list_sorted.map(x\
    \ => x._2).mkString\n\e[31m\e[31m   |\e[0m                                   \
    \      ^^\e[0m\n\e[31m   |\e[0m                                         ')' expected,\
    \ but '=>' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4dnchwyk.scala:24:62\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ extensions_list_sorted.map(x => class_name + x._1).mkString(\e[31m\".\"\e[0m)\
    \ + \e[31m\".\"\e[0m + extensions_list_sorted.map(x => x._2).mkString\n\e[31m\e\
    [31m   |\e[0m                                                              ^\e\
    [0m\n\e[31m   |\e[0m                                             '=' expected,\
    \ but '.' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4dnchwyk.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_list_sorted\e[0m = extensions_list_sorted.take(extensions_list_sorted.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_list_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_list_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4dnchwyk.scala:21:64 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36mx\e[0m => (x.toUpperCase - x.toLowerCase -> x)).toMap\n\e[31m\e[31m   |\e\
    [0m                                                  ^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue - is not a member of String, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n"
  stdout: ''
  timestamp: 1660009655
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val extensions_sorted = extensions.sortWith((a, b) => strength - a.length\
    \ - b.length)\n        val extensions_sorted = extensions.sortWith((a, b) => strength\
    \ - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgyxp6hv0.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength - a.length - b.length)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpgyxp6hv0.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength - a.length - b.length)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpgyxp6hv0.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength - a.length - b.length)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpgyxp6hv0.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength - a.length - b.length)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009657
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase.size, e.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((a, b) => if (a > b) a else b)\n\
    \        val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n \
    \       val extensions_sorted = extensions_sorted.takeWhile(_._1 < strength)\n\
    \        val extensions_sorted = extensions_sorted.map(_._2).mkString(\"\")\n\
    \        class_name + \".\" + extensions_sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdkdyonkt.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._1 < strength)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpdkdyonkt.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(_._2).mkString(\e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e[35mextensions_sorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n2 errors found\n"
  stdout: ''
  timestamp: 1660009652
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.filter(_._2.length == class_name_map.getOrElse(_._2, 0)).length\n\
    \        val extension = extensions_map.filter(_._2.length == class_name_map.getOrElse(_._2,\
    \ 0)).head._1\n        class_name_map.getOrElse(extension, \"\") + extension\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvgxunngl.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpvgxunngl.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpvgxunngl.scala:23:85\
    \ -----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e\
    [0m \e[36mstrength\e[0m = extensions_map.filter(_._2.length == class_name_map.getOrElse(_._2,\
    \ \e[31m0\e[0m)).length\n\e[31m\e[31m   |\e[0m                               \
    \                                                      ^\e[0m\n\e[31m   |\e[0m\
    \   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer\
    \ the type of the parameter _$2 of expanded function:\n\e[31m   |\e[0m   _$2 =>\
    \ _$2._2.\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpvgxunngl.scala:24:86 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextension\e[0m = extensions_map.filter(_._2.length\
    \ == class_name_map.getOrElse(_._2, \e[31m0\e[0m)).head._1\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \            ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m   I could not infer the type of the parameter _$4 of expanded\
    \ function:\n\e[31m   |\e[0m   _$4 => _$4._2.\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpvgxunngl.scala:25:33 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        class_name_map.getOrElse(extension, \e[31m\"\"\e[0m) + extension\n\
    \e[31m\e[31m   "
  stdout: ''
  timestamp: 1660009656
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((x, y) => x.toDouble - y.toDouble)\n\
    \        val extensions_sorted = extensions_map.values.sortBy(x => -x)\n     \
    \   val extensions_sorted = extensions_sorted.takeWhile(x => x < strength)\n \
    \       val extensions_sorted = extensions_sorted.map(x => class_name + x.toString)\n\
    \        extensions_sorted.head\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq50mz_e5.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mx\e[0m => x < strength)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpq50mz_e5.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36mx\e[0m => class_name + x.toString)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpq50mz_e5.scala:22:62 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.reduce((\e\
    [36mx\e[0m, \e[36my\e[0m) => x.toDouble - y.toDouble)\n\e[31m\e[31m   |\e[0m \
    \                                                             ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                        Found:\
    \    Double\n\e[31m   |\e[0m                                                 \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq50mz_e5.scala:23:54\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_sorted\e[0m = extensions_map.values.sortBy(\e[36mx\e[0m => -x)\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           value sortBy is not a member of\
    \ Iterable[I"
  stdout: ''
  timestamp: 1660009656
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strengths\
    \ = extensions_map.map(x => class_name_map(x._1) - x._2).toList\n        val strengths_sorted\
    \ = strengths.sortWith(_ < _)\n        val strengths_sorted = strengths_sorted.takeWhile(_\
    \ > 0).reverse\n        val strengths_sorted.headOption.getOrElse(class_name_map(class_name_map.keys.head))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxv3qp2b5.scala:27:4 ----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxv3qp2b5.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstrengths_sorted\e[0m = strengths_sorted.takeWhile(_ > \e[31m0\e[0m).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrengths_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mstrengths_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpxv3qp2b5.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpxv3qp2b5.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxv3qp2b5.scala:23:65\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrengths\e\
    [0m = extensions_map.map(\e[36mx\e[0m => class_name_map(x._1) - x._2).toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \       ^^^^\e[0m\n\e[31m   |\e[0m                                           \
    \            Found:    String\n\e[31m   |\e[0m                               \
    \                        Required: Nothing\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanati"
  stdout: ''
  timestamp: 1660009656
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = class_name_map.foldLeft(0) { (s, x) =>\n            val extension = extensions_map.getOrElse(x,\
    \ \"\")\n            val extension_length = extension.length\n            val\
    \ class_name_length = x.length\n            val strength_length = extension_length\
    \ - class_name_length\n            s + strength_length\n        }\n        val\
    \ class_name_with_strength = class_name_map.foldLeft(\"\") { (s, x) =>\n     \
    \       val extension = extensions_map.getOrElse(x, \"\")\n            val extension_length\
    \ = extension.length\n            val class_name_length = x.length\n         \
    \   val strength_length = extension_length - class_name_length\n            s\
    \ + x.toUpperCase + extension.substring(class_name_length) + x.toLowerCase\n \
    \       }\n        val strength_str = strength.toString\n        val class_name_with_strength_str\
    \ = class_name_with_strength + strength_str\n        class_name_with_strength_str\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpra2g0v0r.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpra2g0v0r.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpra2g0v0r.scala:24:53\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e\
    [36mextension\e[0m = extensions_map.getOrElse(x, \e[31m\"\"\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                                                     ^\e[0m\n\e[31m\
    \   |\e[0m                                      Found:    (x : (Nothing, Nothing))\n\
    \e[31m   |\e[0m                                      Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpra2g0v0r.scala:26:38 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36mclass_name_length\e\
    [0m = x.length\n\e[31m\e[31m   |\e[0m                                    ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue length is not a member of (Nothing, Nothing), but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import concurrent.duration.pairIntToDuration\n\e[31m   |\e[0m  import concurrent.duration.pairLongToDuration\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpra2g0v0r.scala:31:53\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval"
  stdout: ''
  timestamp: 1660009659
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length = extensions_count_sorted.map(_.length).sum\n\
    \        val extensions_count_sorted_length_sorted = extensions_count_sorted.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length = extensions_count_sorted_length.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length = extensions_count_sorted_length.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted_length = extensions_count_sorted_length.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp275vgj3l.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp275vgj3l.scala:25:90\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_sorted_length_sorted_length\e[0m = extensions_count_sorted_length.sortWith(_.length\
    \ < _.length)\n\e[31m\e[31m   |\e[0m                                         \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                   value sortWith is not a member of Int\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp275vgj3l.scala:26:97 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sorted_length_sorted\e\
    [0m = extensions_count_sorted_length.sortWith(_.length < _.length)\n\e[31m\e[31m\
    \   |\e[0m                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   value sortWith is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp275vgj3l.scala:27:104\
    \ -----------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_sorted_length_sorted_length_sorted_length\e[0m = extensions_count_sorted_length.sortWith(_.length\
    \ < _.length)\n\e[31m\e[31m   |\e[0m                                         \
    \                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                   value sortWith is not a member\
    \ of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp275vgj3l.scala:28:111\
    \ -----------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_sorted_length_sorted_length_sorted_length_sorted\e[0m = extensions_count_sorted_length.sortWith(_.length\
    \ < _.length)\n\e[31m\e[31m   |\e[0m                                         \
    \                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  "
  stdout: ''
  timestamp: 1660009658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase)\n\
    \        val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n \
    \       val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.map(e => class_name + \".\"\
    \ + e)\n        extensions_sorted.head\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0p7ybr81.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0p7ybr81.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36me\e[0m => class_name + \e[31m\".\"\e[0m + e)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp0p7ybr81.scala:21:100 -----------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.charAt(\e[31m0\e[0m) -> e.toUpperCase.charAt(\e[31m1\e\
    [0m).toLowerCase)\n\e[31m\e[31m   |\e[0m                                     \
    \                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0p7ybr81.scala:25:26\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m        extensions_sorted.head\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \    Found:    (Char, Nothing)\n\e[31m   |\e[0m        Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_length = extensions_count_sorted.map(_.length).sum\n\
    \        val extensions_count_sorted_length_sorted = extensions_count_sorted.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith((a, b) => b.length - a.length)\n \
    \       val extensions_count_sorted_length_sorted_length_sorted = extensions_count_sorted_length_sorted.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length.sortWith((a, b) => b.length -\
    \ a.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted.sortWith((a, b) => b.length\
    \ - a.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length.sortWith((a, b)\
    \ => b.length - a.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"\
    ), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuf5uc4l9.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpuf5uc4l9.scala:22:68 --------------------\e[0m\e[0m\n\e[31m22 |\e[0m\
    \        \e[33mval\e[0m \e[36mextensions_count_sorted\e[0m = extensions.sortWith((\e\
    [36ma\e[0m, \e[36mb\e[0m) => b.length - a.length)\n\e[31m\e[31m   |\e[0m     \
    \                                                               ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                       Found:\
    \    Int\n\e[31m   |\e[0m                                                    \
    \   Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuf5uc4l9.scala:24:95\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sorted\e\
    [0m = extensions_count_sorted.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => b.length\
    \ - a.length)\n\e[31m\e[31m   |\e[0m                                         \
    \                                                      ^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                       Found: \
    \   Int\n\e[31m   |\e[0m                                                     \
    \  Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuf5uc4l9.scala:25:90\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_sorted_length_sorted_length\e[0m = extensions_count_sorted_length.sortWith((\e\
    [36ma\e[0m, \e[36mb\e[0m) => b.length - a.length)\n\e[31m\e[31m   |\e[0m     \
    \                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   value sortWith is not a\
    \ member of Int\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuf5uc4l9.scala:26:123\
    \ -------------------\e[0m\e[0m\n\e[31m26 |\e[0m"
  stdout: ''
  timestamp: 1660009660
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size, x)).toMap\n \
    \       val strength = extensions_map.values.reduce((a, b) => if (a > b) a else\
    \ b)\n        val extensions_sorted = extensions_map.values.sortWith((a, b) =>\
    \ a > b)\n        val extensions_sorted = extensions_sorted.takeWhile(_ < strength)\n\
    \        val extensions_sorted.map(x => class_name + x._1 + x._2).mkString(\"\
    .\") + \".\"\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpna2x42ri.scala:25:36 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m extensions_sorted.map(x => class_name\
    \ + x._1 + x._2).mkString(\e[31m\".\"\e[0m) + \e[31m\".\"\e[0m\n\e[31m\e[31m \
    \  |\e[0m                                    ^^\e[0m\n\e[31m   |\e[0m        \
    \                            ')' expected, but '=>' found\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpna2x42ri.scala:25:64 ---------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m        \e[33mval\e[0m extensions_sorted.map(x => class_name\
    \ + x._1 + x._2).mkString(\e[31m\".\"\e[0m) + \e[31m\".\"\e[0m\n\e[31m\e[31m \
    \  |\e[0m                                                                ^\e[0m\n\
    \e[31m   |\e[0m                                             '=' expected, but\
    \ '.' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpna2x42ri.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions_sorted.takeWhile(_ < strength)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- Error: /tmp/tmpna2x42ri.scala:21:99 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36mx\e[0m => (x.toUpperCase.size, x.toLowerCase.size, x)).toMap\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                                ^\e[0m\n\e[31m   |\e[0m                     \
    \    Cannot prove that (Int, Int, String) <:< (K, V)\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m                         where:    K is a type variable\n\e[31m   |\e\
    [0m                                   V is a type variable\n\e[31m   |\e[0m  \
    \                       .\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpna2x42ri.scala:26:5\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e["
  stdout: ''
  timestamp: 1660009663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_length = class_name.length\n\
    \        val strength = extensions_count - class_name_length\n        val extensions_sorted\
    \ = extensions.sortWith(_.length > _.length)\n        val extension_length = extensions_sorted.map(_.length).sum\n\
    \        val extension_strength = extension_length - class_name_length\n     \
    \   val extension_sorted = extensions_sorted.sortWith(_.length > _.length)\n \
    \       val extension_first = extension_sorted.head\n        val extension_last\
    \ = extension_sorted.last\n        val extension_first = extension_first.toLowerCase\
    \ + extension_first\n        val extension_last = extension_last.toLowerCase +\
    \ extension_last\n        val extension_strength_first = extension_strength -\
    \ class_name_length\n        val extension_strength_last = extension_strength\
    \ - extension_first.length\n        val extension_strength_first = extension_strength_first.toLowerCase\
    \ + extension_strength_first\n        val extension_strength_last = extension_strength_last.toLowerCase\
    \ + extension_strength_last\n        val extension_strength_first = extension_strength_first.toLowerCase\
    \ + extension_strength_first\n        val extension_strength_last = extension_strength_last.toLowerCase\
    \ + extension_strength_last\n        val extension_strength_first = extension_strength_first.toLowerCase\
    \ + extension_strength_first\n        val extension_strength_last = extension_strength_last.toLowerCase\
    \ + extension_strength_last\n        val extension_strength_first = extension_strength_first.toLowerCase\
    \ + extension_strength_first\n        val extension_strength_last = extension_strength_last.toLowerCase\
    \ + extension_strength_last\n        val extension_strength_first = extension_strength_first.toLowerCase\
    \ + extension_strength_first\n        val extension_strength_last = extension_strength_last.toLowerCase\
    \ + extension_strength_last\n        val extension_strength_first = extension_strength_first.toLowerCase\
    \ + extension_strength_first\n        val extension_strength_last = extension_strength_last.toLowerCase\
    \ + extension_strength_last\n        val extension_strength_first = extension_strength_first.toLowerCase\
    \ + extension_strength_first\n        val extension_strength_last = extension_strength_last.toLowerCase\
    \ + extension_strength_last\n        val extension_strength_first = extension_strength_first.toLowerCase\
    \ + extension_strength_first\n        val extension_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplnzfpxpn.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplnzfpxpn.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextension_first\e[0m = extension_first.toLowerCase + extension_first\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_first is already defined as \e[33mvalue\e[0m \e\
    [35mextension_first\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplnzfpxpn.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mextension_last\e[0m = extension_last.toLowerCase\
    \ + extension_last\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_last is already defined as \e[33mvalue\e[0m \e[35mextension_last\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmplnzfpxpn.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mextension_strength_first\e[0m = extension_strength_first.toLowerCase\
    \ + extension_strength_first\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_strength_first is already defined as \e[33mvalue\e\
    [0m \e[35mextension_strength_first\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmplnzfpxpn.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mextension_strength_last\e\
    [0m = extension_strength_last.toLowerCase + extension_strength_last\n\e[31m\e\
    [31m   |\e[0m      "
  stdout: ''
  timestamp: 1660009661
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase.size, e.toLowerCase.size)).toMap\n    \
    \    val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n     \
    \   val extensions_sorted = extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1)\n\
    \        val extensions_sorted = extensions_sorted.map(_._2)\n        val extensions_sorted\
    \ = extensions_sorted.mkString(\".\")\n        class_name + extensions_sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjcrmthad.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpjcrmthad.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(_._2)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpjcrmthad.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\".\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.max\n        val extensions_sorted =\
    \ extensions_map.toSeq.sortBy(_._1).reverse\n        val extensions_sorted = extensions_sorted.takeWhile(_._2\
    \ > strength).map(_._1)\n        val extensions_sorted = extensions_sorted.mkString(\"\
    \") + \".\" + extensions_sorted.last\n        class_name+\".\"+extensions_sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi_dctekc.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > strength).map(_._1)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpi_dctekc.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\"\"\e[0m) + \e[31m\".\"\e[0m + extensions_sorted.last\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009660
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val extensions_sorted\
    \ = extensions_map.toSeq.sortBy(_._1).reverse\n        val strongest_extension\
    \ = extensions_sorted.head._2\n        class_name + \".\" + strongest_extension\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpzb14acqx.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n1 error found\n"
  stdout: ''
  timestamp: 1660009663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.getOrElse(x, 0) - x.toString.toUpperCase.length).max\n\
    \        val extensions_sorted = extensions_map.values.sortBy(x => x.toString.toUpperCase.length).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x.toString.toUpperCase.length\
    \ <= strength).reverse\n        val extensions_sorted = extensions_sorted.takeWhile(x\
    \ => x.toString.toUpperCase.length <= strength).reverse\n        val extensions_sorted\
    \ = extensions_sorted.takeWhile(x => x.toString.toUpperCase.length <= strength).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x.toString.toUpperCase.length\
    \ <= strength).reverse\n        val extensions_sorted = extensions_sorted.takeWhile(x\
    \ => x.toString.toUpperCase.length <= strength).reverse\n        val extensions_sorted\
    \ = extensions_sorted.takeWhile(x => x.toString.toUpperCase.length <= strength).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x.toString.toUpperCase.length\
    \ <= strength).reverse\n        val extensions_sorted = extensions_sorted.takeWhile(x\
    \ => x.toString.toUpperCase.length <= strength).reverse\n        val extensions_sorted\
    \ = extensions_sorted.takeWhile(x => x.toString.toUpperCase.length <= strength).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x.toString.toUpperCase.length\
    \ <= strength).reverse\n        val extensions_sorted = extensions_sorted.takeWhile(x\
    \ => x.toString.toUpperCase.length <= strength).reverse\n        val extensions_sorted\
    \ = extensions_sorted.takeWhile(x => x.toString.toUpperCase.length <= strength).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x.toString.toUpperCase.length\
    \ <= strength).reverse\n        val extensions_sorted = extensions_sorted.takeWhile(x\
    \ => x.toString.toUpperCase.length <= strength).reverse\n        val extensions_sorted\
    \ = extensions_sorted.takeWhile(x => x.toString.toUpperCase.length <= strength).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x.toString.toUpperCase.length\
    \ <= strength).reverse\n        val extensions_sor\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf__cfitf.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpf__cfitf.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions_sorted.takeWhile(\e[36mx\e[0m => x.toString.toUpperCase.length\
    \ <= strength).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpf__cfitf.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mx\e[0m => x.toString.toUpperCase.length <=\
    \ strength).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpf__cfitf.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mx\e[0m => x.toString.toUpperCase.length <=\
    \ strength).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/"
  stdout: ''
  timestamp: 1660009666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length = extensions_count_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sorted = extensions_count_sorted.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length = extensions_count_sorted_length.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length = extensions_count_sorted_length.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted_length = extensions_count_sorted_length.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_.length < _.length)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_hzivkvy.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_hzivkvy.scala:25:101\
    \ -----------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_sorted_length_sorted_length\e[0m = extensions_count_sorted_length.sortWith(_.length\
    \ < _.length)\n\e[31m\e[31m   |\e[0m                                         \
    \                                                          ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                     value length is not a member of\
    \ Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_hzivkvy.scala:26:108 -----------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sorted_length_sorted\e\
    [0m = extensions_count_sorted_length.sortWith(_.length < _.length)\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                                       ^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                              value length is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp_hzivkvy.scala:27:115 -----------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sorted_length_sorted_length\e\
    [0m = extensions_count_sorted_length.sortWith(_.length < _.length)\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                                              ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                     value length is not a member of Int\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp_hzivkvy.scala:28:122 -----------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sorted_length_sorted_length_sorted\e\
    [0m = extensions_count_sorted_length.sortWith(_.length < _.length)\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                                                     ^^^^^^^^"
  stdout: ''
  timestamp: 1660009666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val strength_upper = strength / extensions_count_upper\n        val strength_lower\
    \ = strength / extensions_count_lower\n        val strength_sum = strength_upper\
    \ + strength_lower\n        val strength_max = if (strength_sum > 0) strength_sum\
    \ else 0\n        val strength_min = if (strength_sum < 0) -strength_sum else\
    \ 0\n        val strength_average = if (strength_sum > 0) (strength_sum / extensions_count_upper)\
    \ else 0\n        val strength_average_lower = if (strength_sum < 0) (strength_sum\
    \ / extensions_count_lower) else 0\n        val strength_average_max = if (strength_sum\
    \ > 0) (strength_sum / extensions_count_upper) else 0\n        val strength_average_min\
    \ = if (strength_sum < 0) (strength_sum / extensions_count_lower) else 0\n   \
    \     val strength_average_average = if (strength_sum > 0) (strength_sum / extensions_count_upper)\
    \ else 0\n        val strength_average_average_lower = if (strength_sum < 0) (strength_sum\
    \ / extensions_count_lower) else 0\n        val strength_average_average_max =\
    \ if (strength_sum > 0) (strength_sum / extensions_count_upper) else 0\n     \
    \   val strength_average_average_min = if (strength_sum < 0) (strength_sum / extensions_count_lower)\
    \ else 0\n        val strength_average_average_average = if (strength_sum > 0)\
    \ (strength_sum / extensions_count_upper) else 0\n        val strength_average_average_average_lower\
    \ = if (strength_sum < 0) (strength_sum / extensions_count_lower) else 0\n   \
    \     val strength_average_average_average_max = if (strength_sum > 0) (strength_sum\
    \ / extensions_count_upper) else 0\n        val strength_average_average_average_min\
    \ = if (strength_sum < 0) (strength_sum / extensions_count_lower) else 0\n   \
    \     val strength_average_average_average_average = if (strength_sum > 0) (strength_sum\
    \ / extensions_count_upper) else 0\n        val strength_average_average_average_average_lower\
    \ = if (strength_sum < 0) (strength_sum / extensions_count_lower) else 0\n   \
    \     val strength_average_average_average_average_max = if (strength_sum > 0)\
    \ (strength_sum / extensions_count_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp85zu8xeg.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp85zu8xeg.scala:44:97\
    \ ------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength_average_average_average_average_max\e[0m = \e[33mif\e[0m (strength_sum\
    \ > \e[31m0\e[0m) (strength_sum / extensions_count_\n\e[31m\e[31m   |\e[0m   \
    \                                                                            \
    \                  ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                         Not found: extensions_count_\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp85zu8xeg.scala:45:5 ---------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs)\n        val\
    \ strength_sorted = strength.sortWith((x, y) => x < y)\n        val strength_sorted_list\
    \ = strength_sorted.toList\n        val strength_sorted_list_sorted = strength_sorted_list.sortWith((x,\
    \ y) => x < y)\n        val strength_sorted_list_sorted_first = strength_sorted_list_sorted.head\n\
    \        val strength_sorted_list_sorted_first_upper = strength_sorted_list_sorted.map(x\
    \ => x.toUpperCase).head\n        val strength_sorted_list_sorted_first_lower\
    \ = strength_sorted_list_sorted.map(x => x.toLowerCase).head\n        val strength_sorted_list_sorted_first_first_upper\
    \ = strength_sorted_list_sorted.map(x => x.toUpperCase).map(x => x.toUpperCase).head\n\
    \        val strength_sorted_list_sorted_first_first_lower = strength_sorted_list_sorted.map(x\
    \ => x.toLowerCase).map(x => x.toLowerCase).head\n        val strength_sorted_list_sorted_first_first_first_upper\
    \ = strength_sorted_list_sorted.map(x => x.toUpperCase).map(x => x.toUpperCase).map(x\
    \ => x.toUpperCase).head\n        val strength_sorted_list_sorted_first_first_first_lower\
    \ = strength_sorted_list_sorted.map(x => x.toLowerCase).map(x => x.toLowerCase).map(x\
    \ => x.toLowerCase).head\n        val strength_sorted_list_sorted_first_first_first_first_upper\
    \ = strength_sorted_list_sorted.map(x => x.toUpperCase).map(x => x.toUpperCase).map(x\
    \ => x.toUpperCase).map(x => x.toUpperCase).head\n        val strength_sorted_list_sorted_first_first_first_lower\
    \ = strength_sorted_list_sorted.map(x => x.toLowerCase).map(x => x.toLowerCase).map(x\
    \ => x.toLowerCase).map(x => x.toLowerCase).head\n        val strength_sorted_list_sorted_first_first_first_first_upper\
    \ = strength_sorted_list_sorted.map(x => x.toUpperCase).map(x => x.toUpperCase).map(x\
    \ => x.toUpperCase).map(x => x.toUpperCase).map(x => x.toUpperCase).head\n   \
    \     val strength_sorted_list_sorted_first_first_first_lower = strength_sorted_list_sorted.map(x\
    \ => x.toLowerCase).map(x => x.toLowerCase).map(x => x.toLowerCase).map(x => x.toLowerCase).map(x\
    \ => x.\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyaq5dx84.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpyaq5dx84.scala:35:12 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        \e[33mval\e[0m \e[36mstrength_sorted_list_sorted_first_first_first_lower\e\
    [0m = strength_sorted_list_sorted.map(\e[36mx\e[0m => x.toLowerCase).map(\e[36mx\e\
    [0m => x.toLowerCase).map(\e[36mx\e[0m => x.toLowerCase).map(\e[36mx\e[0m => x.toLowerCase).head\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength_sorted_list_sorted_first_first_first_lower is already\
    \ defined as \e[33mvalue\e[0m \e[35mstrength_sorted_list_sorted_first_first_first_lower\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyaq5dx84.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mstrength_sorted_list_sorted_first_first_first_first_upper\e\
    [0m = strength_sorted_list_sorted.map(\e[36mx\e[0m => x.toUpperCase).map(\e[36mx\e\
    [0m => x.toUpperCase).map(\e[36mx\e[0m => x.toUpperCase).map(\e[36mx\e[0m => x.toUpperCase).map(\e\
    [36mx\e[0m => x.toUpperCase).head\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength_sorted_list_sorted_first_first_first_first_upper\
    \ is already defined as \e[33mvalue\e[0m \e[35mstrength_sorted_list_sorted_first_first_first_first_upper\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyaq5dx"
  stdout: ''
  timestamp: 1660009667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.count\n        val extensions_count_upper = extensions.count(_.toUpperCase\
    \ == _)\n        val extensions_count_lower = extensions.count(_.toLowerCase ==\
    \ _)\n        val extensions_count_diff = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_diff_frac = extensions_count_diff / extensions_count\n\
    \        val extensions_count_diff_frac_max = extensions_count_diff_frac.max\n\
    \        val extensions_count_diff_frac_max_index = extensions_count_diff_frac.indexOf(extensions_count_diff_frac_max)\n\
    \        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ - 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ - 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ - 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ - 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ - 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ - 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ - 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ - 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ - 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4x8x49v3.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_frac_max_index\e\
    [0m = extensions_count_diff_frac_max_index + \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_frac_max_index is already defined as\
    \ \e[33mvalue\e[0m \e[35mextensions_count_diff_frac_max_index\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4x8x49v3.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_frac_max_index\e[0m = extensions_count_diff_frac_max_index\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_frac_max_index is already defined as\
    \ \e[33mvalue\e[0m \e[35mextensions_count_diff_frac_max_index\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4x8x49v3.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_frac_max_index\e[0m = extensions_count_diff_frac_max_index\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_frac_max_index is already defined as\
    \ \e[33mvalue\e[0m \e[35mextensions_count_diff_frac_max_index\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4x8x49v3.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_frac_max_index\e[0m = extensions_count_diff_frac_max_index\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^"
  stdout: ''
  timestamp: 1660009666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (class_name_map.get(x) - extensions_map.get(x)).abs).reduce(_\
    \ + _)\n        val strongest_extension = extensions_map.values.filter(x => class_name_map.get(x)\
    \ == x).head\n        s\"$class_name.$strongest_extension\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpoqzbu0rr.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpoqzbu0rr.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoqzbu0rr.scala:23:74\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => (class_name_map.get(x) - extensions_map.get(x)).abs).reduce(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                                                \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \                       Found:    (x : String)\n\e[31m   |\e[0m              \
    \                                    Required: Nothing\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpoqzbu0rr.scala:23:116 -----------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e\
    [36mx\e[0m => (class_name_map.get(x) - extensions_map.get(x)).abs).reduce(_ +\
    \ _)\n\e[31m\e[31m   |\e[0m                                                  \
    \                                                                ^^^\e[0m\n\e\
    [31m   |\e[0mvalue + is not a member of Any, but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |"
  stdout: ''
  timestamp: 1660009668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.map(_.length).sort\n\
    \        val extensions_count_sorted_reversed = extensions_count_sorted.reverse\n\
    \        val extensions_count_sorted_reversed_sorted = extensions_count_sorted_reversed.sort\n\
    \        val extensions_count_sorted_reversed_sorted_reversed = extensions_count_sorted_reversed_sorted.reverse\n\
    \        val extensions_count_sorted_reversed_sorted_reversed_sorted = extensions_count_sorted_reversed_sorted_reversed.sort\n\
    \        val extensions_count_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = extensions_count_sorted_reversed_sorted_reversed_sorted.reverse\n        val\
    \ extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed.sort\n\
    \        val extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sort\n\
    \        val extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sort\n\
    \        val extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed.sort\n\
    \        val extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \        val extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt35w_45w.scala:22:63 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions.map(_.length).sort\n\e[31m\e[31m   |\e[0m                   \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue sort\
    \ is not a member of List[Int] - did you mean List[Int].sortBy?\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpt35w_45w.scala:35:150 --------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\e\
    [0m = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted.reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                  ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e\
    [31m   |\e[0m  extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpt35w_45w.scala:36:166 -----------------------\e[0m\e[0m\n\e[31m36 |\e\
    [0m        \e[33mval\e[0m \e[36mextensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\e\
    [0m = extensions_count_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: extensions_count_sorted_reve"
  stdout: ''
  timestamp: 1660009668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.getOrElse(x, 0) - x.toUpperCase.length).max\n\
    \        val extensions_sorted = extensions_map.values.sortBy(x => class_name_map.getOrElse(x,\
    \ 0) - x.toUpperCase.length)\n        val extensions_sorted = extensions_sorted.takeWhile(x\
    \ => x.toUpperCase.length <= class_name_map.getOrElse(x, 0) - strength)\n    \
    \    val extensions_sorted = extensions_sorted.map(x => class_name_map.getOrElse(x,\
    \ 0) + x.toUpperCase.length).mkString(\".\") + extensions_sorted.last\n      \
    \  extensions_sorted\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnqdhr5n7.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mx\e[0m => x.toUpperCase.length <= class_name_map.getOrElse(x,\
    \ \e[31m0\e[0m) - strength)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpnqdhr5n7.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36mx\e[0m => class_name_map.getOrElse(x, \e[31m0\e\
    [0m) + x.toUpperCase.length).mkString(\e[31m\".\"\e[0m) + extensions_sorted.last\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpnqdhr5n7.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpnqdhr5n7.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                          "
  stdout: ''
  timestamp: 1660009670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.getOrElse(x, 0) - x.toString.toString.toUpperCase.length).max\n\
    \        val extension = extensions_map.getOrElse(strength, \"\")\n        class_name\
    \ + extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpigkj6e8o.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpigkj6e8o.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpigkj6e8o.scala:23:79\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => class_name_map.getOrElse(x, \e\
    [31m0\e[0m) - x.toString.toString.toUpperCase.length).max\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \     ^\e[0m\n\e[31m   |\e[0m                                                \
    \  Found:    (x : String)\n\e[31m   |\e[0m                                   \
    \               Required: Nothing\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpigkj6e8o.scala:24:49 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mextension\e[0m = extensions_map.getOrElse(strength,\
    \ \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                                    \
    \             ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 \
    \             Found:    (strength : Int)\n\e[31m   |\e[0m                    \
    \                          Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val extensions_count_upper_ratio = extensions_count_upper / extensions_count.toDouble\n\
    \        val extensions_count_lower_ratio = extensions_count_lower / extensions_count.toDouble\n\
    \        val extensions_count_ratio = extensions_count_upper / extensions_count_lower\n\
    \        val extensions_count_ratio2 = extensions_count_upper_ratio / extensions_count_lower_ratio\n\
    \        val extensions_count_ratio3 = extensions_count_ratio / extensions_count_ratio2\n\
    \        val extensions_count_ratio4 = extensions_count_ratio3 / extensions_count_ratio\n\
    \        val extensions_count_ratio5 = extensions_count_ratio4 / extensions_count_ratio3\n\
    \        val extensions_count_ratio6 = extensions_count_ratio5 / extensions_count_ratio4\n\
    \        val extensions_count_ratio7 = extensions_count_ratio6 / extensions_count_ratio5\n\
    \        val extensions_count_ratio8 = extensions_count_ratio7 / extensions_count_ratio6\n\
    \        val extensions_count_ratio9 = extensions_count_ratio8 / extensions_count_ratio7\n\
    \        val extensions_count_ratio10 = extensions_count_ratio9 / extensions_count_ratio8\n\
    \        val extensions_count_ratio11 = extensions_count_ratio10 / extensions_count_ratio9\n\
    \        val extensions_count_ratio12 = extensions_count_ratio11 / extensions_count_ratio10\n\
    \        val extensions_count_ratio13 = extensions_count_ratio12 / extensions_count_ratio11\n\
    \        val extensions_count_ratio14 = extensions_count_ratio13 / extensions_count_ratio12\n\
    \        val extensions_count_ratio15 = extensions_count_ratio14 / extensions_count_ratio13\n\
    \        val extensions_count_ratio16 = extensions_count_ratio15 / extensions_count_ratio14\n\
    \        val extensions_count_ratio17 = extensions_count_ratio16 / extensions_count_ratio15\n\
    \        val extensions_count_ratio18 = extensions_count_ratio17 / extensions_count_ratio16\n\
    \        val extensions_count_ratio19 = extensions_count_ratio18 / extensions_count_ratio17\n\
    \        val extensions_count_ratio20 = extensions_count_ratio19 / extensions_count_ratio18\n\
    \        val extensions_count_ratio21 = extensions_count_ratio20 / extensions_count_ratio19\n\
    \        val extensions_count_ratio22 = extensions_count_ratio\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzeveg0fw.scala:49:5\
    \ ---------------------\e[0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.split(\"\\\\.\").toMap\n        val class_name_length = class_name_map.size\n\
    \        val extensions_length = extensions_map.size\n        val strength = extensions_length\
    \ - class_name_length\n        if (strength > 0) {\n            val extension_strength\
    \ = extensions_map.getOrElse(class_name_map.getOrElse(class_name_length, -1),\
    \ 0)\n            val extension_strength_sum = extension_strength * strength\n\
    \            val extension_strength_max = extension_strength_sum / extensions_length\n\
    \            val extension_strength_max_index = extensions_map.values.toList.zipWithIndex.\n\
    \                filter(_._2 == extension_strength_max).map(_._1).min\n      \
    \      val extension_strength_max_key = extensions_map.get(extension_strength_max_index)\n\
    \            val extension_strength_max_value = extension_strength_max_key._2\n\
    \            val extension_strength_max_key_length = extension_strength_max_key._1.length\n\
    \            val extension_strength_max_value_length = extension_strength_max_value.length\n\
    \            val extension_strength_max_key_length_diff = extension_strength_max_key_length\
    \ - extension_strength_max_value_length\n            val extension_strength_max_value_length_diff\
    \ = extension_strength_max_value_length - extension_strength_max_key_length_diff\n\
    \            val extension_strength_max_key_length_diff_percent = extension_strength_max_key_length_diff\
    \ / extension_strength_max_key_length\n            val extension_strength_max_value_length_diff_percent\
    \ = extension_strength_max_value_length_diff / extension_strength_max_value_length\n\
    \            val extension_strength_max_key_length_diff_percent_sum = extension_strength_max_key_length_diff_percent\
    \ * extension_strength_max_key_length\n            val extension_strength_max_value_length_diff_percent_sum\
    \ = extension_strength_max_value_length_diff_percent * extension_strength_max_value_length\n\
    \            val extension_strength_max_key_length_diff_percent_sum_diff = extension_strength_max_key_length_diff_percent_sum\
    \ - extension_strength_max_value_length_diff_percent_sum\n            val extension_strength_max_value_length_diff_percent_sum_diff\
    \ = extension_strength_max_value_length_diff_percent_sum - extension_strength_max_key_length_diff_percent_sum_diff\n\
    \            val extension_strength_max_key_length_diff_percent_sum_diff_percent\
    \ = extension_strength_max_key_length_diff_percent_sum_diff / extension_strength_max_key_length_diff_percent\n\
    \            val extension\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplokej606.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplokej606.scala:60:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m60 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- Error: /tmp/tmplokej606.scala:22:58\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \ \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.split(\e[31m\"\\\\.\"\e\
    [0m).toMap\n\e[31m\e[31m   |\e[0m                                            \
    \              ^\e[0m\n\e[31m   |\e[0m                                     Cannot\
    \ prove that String <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m             \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                          V is a type variable\n\e[31m   |\e\
    [0m                                     .\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmplokej606.scala:28:60 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m            \e[33mval\e[0m \e[36mextension_strength_sum\e[0m = extension_strength\
    \ * strength\n\e[31m\e[31m   |\e[0m                                         ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue * is not a member of Matchable, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmplokej606.scala:33:74 ------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36mextension_strength_max_value\e\
    [0m = extension_strength_max_key._2\n\e[31m\e[31m   |\e[0m                   \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              value _2 is not a member "
  stdout: ''
  timestamp: 1660009671
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase, e.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(c => (c.toUpperCase, c.toLowerCase)).toMap\n        val extensions_count\
    \ = extensions_map.size\n        val class_name_count = class_name_map.size\n\
    \        val strength = extensions_count - class_name_count\n        val extension\
    \ = extensions_map.getOrElse(class_name_map.getOrElse(\"\", \"\"))\n        val\
    \ extension_str = extension.mkString.toLowerCase\n        val class_name = class_name_map.getOrElse(\"\
    \", \"\")\n        val class_name_str = class_name.mkString.toLowerCase\n    \
    \    if (extension_str != class_name_str) {\n            val strength_str = strength.mkString.toLowerCase\n\
    \            val extension_str = extension.mkString.toLowerCase\n            val\
    \ class_name_str = class_name.mkString.toLowerCase\n            val strength_str\
    \ = strength_str.substring(0, strength_str.lastIndexOf(\".\"))\n            val\
    \ extension_str = extension_str.substring(0, extension_str.lastIndexOf(\".\"))\n\
    \            val class_name_str = class_name_str.substring(0, class_name_str.lastIndexOf(\"\
    .\"))\n            val strength_str = strength_str + \".\" + extension_str + \"\
    .\" + class_name_str\n            val class_name_str = class_name_str + \".\"\
    \ + extension_str + \".\" + strength_str\n            val extension_str = extension_str\
    \ + \".\" + strength_str + \".\" + class_name_str\n            val class_name_str\
    \ = class_name_str + \".\" + extension_str + \".\" + strength_str\n          \
    \  val extension_str = extension_str + \".\" + strength_str + \".\" + class_name_str\n\
    \            val class_name_str = class_name_str + \".\" + extension_str + \"\
    .\" + strength_str\n            val extension_str = extension_str + \".\" + strength_str\
    \ + \".\" + class_name_str\n            val class_name_str = class_name_str +\
    \ \".\" + extension_str + \".\" + strength_str\n            val extension_str\
    \ = extension_str + \".\" + strength_str + \".\" + class_name_str\n          \
    \  val class_name_str = class_name_str + \".\" + extension_str + \".\" + strength_str\n\
    \            val extension_str = extension_str + \".\" + strength_str + \".\"\
    \ + class_name_str\n            val class_name_str = class_name_str + \".\" +\
    \ extension_str + \".\" + strength_str\n            val extension_str = extension_str\
    \ + \".\" + strength_str + \".\" + class_name_str\n            val class_name_str\
    \ = class_name_str + \".\" + extension_str + \".\" + strength_str\n          \
    \  val extension_str = extension_str + \".\" + strength_str + \".\" + class_name_str\n\
    \            val class_name_str = \n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpm5ooqtt8.scala:52:32 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m            \e[33mval\e[0m \e[36mclass_name_str\e[0m\
    \ = \n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e\
    [0m                                expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm5ooqtt8.scala:67:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m67 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpm5ooqtt8.scala:28:25 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mclass_name\e[0m = class_name_map.getOrElse(\e\
    [31m\"\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                       \
    \  ^\e[0m\n\e[31m   |\e[0m                         Recursive \e[33mvalue\e[0m\
    \ \e[35mclass_name_map\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpm5ooqtt8.scala:26:48 -----------------------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextension\e[0m = extensions_map.getOrElse(class_name_map.getOrElse(\e\
    [31m\"\"\e[0m, \e[31m\"\"\e[0m))\n\e[31m\e[31m   |\e[0m                      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmissing argument for parameter default of \e[33mmethod\e[0m \e[35mgetOrElse\e\
    [0m in \e[33mtrait\e[0m \e[35mMapOps\e[0m: (key: String, default: => V1): V1\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm5ooqtt8.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mstrength_str\e[0m =\
    \ strength_str.substring(\e[31m0\e[0m, strength_str.lastIndexOf(\e[31m\".\"\e\
    [0m))\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength_str is already defined as \e[33mvalue\e[0m \e[35mstrength_str\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel d"
  stdout: ''
  timestamp: 1660009670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_count = class_name.length\n\
    \        val strength = extensions_count - class_name_count\n        val extensions_sorted\
    \ = extensions.sortWith((a, b) => strength - a.length - b.length)\n        val\
    \ extensions_sorted = extensions_sorted.take(1)\n        val extensions_sorted\
    \ = extensions_sorted.mkString(\".\") + extensions_sorted.last\n        class_name+\"\
    .\"+extensions_sorted\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxq3aoavx.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.take(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxq3aoavx.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\".\"\e[0m) + extensions_sorted.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpxq3aoavx.scala:24:62 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength - a.length - b.length)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                                     Found:    Int\n\e[31m   |\e[0m         \
    \                                              Required: Boolean\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val sorted_extensions = extensions_map.toSeq.sortBy(_._1).reverse\n\
    \        val first_extension = sorted_extensions.head\n        val first_extension_strength\
    \ = extensions_map.get(first_extension)\n        if (first_extension_strength\
    \ == strength) {\n            class_name + first_extension\n        } else {\n\
    \            class_name + first_extension + sorted_extensions.last\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpy0bkhff4.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n1 error found\n"
  stdout: ''
  timestamp: 1660009669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase).toMap\n\
    \        val class_name_map = class_name.map(c => c.toUpperCase.charAt(0) -> c.toUpperCase.charAt(1).toLowerCase).toMap\n\
    \        val strength = extensions_map.values.map(c => class_name_map.get(c) -\
    \ class_name_map.get(c)).reduce(_ + _)\n        val extensions_sorted = extensions_map.values.sortBy(c\
    \ => class_name_map.get(c) - class_name_map.get(c))\n        val extensions_sorted\
    \ = extensions_map.values.sortBy(c => class_name_map.get(c) - class_name_map.get(c))\n\
    \        val extensions_sorted = extensions_map.values.sortBy(c => class_name_map.get(c)\
    \ - class_name_map.get(c))\n        val extensions_sorted = extensions_map.values.sortBy(c\
    \ => class_name_map.get(c) - class_name_map.get(c))\n        val extensions_sorted\
    \ = extensions_map.values.sortBy(c => class_name_map.get(c) - class_name_map.get(c))\n\
    \        val extensions_sorted = extensions_map.values.sortBy(c => class_name_map.get(c)\
    \ - class_name_map.get(c))\n        val extensions_sorted = extensions_map.values.sortBy(c\
    \ => class_name_map.get(c) - class_name_map.get(c))\n        val extensions_sorted\
    \ = extensions_map.values.sortBy(c => class_name_map.get(c) - class_name_map.get(c))\n\
    \        val extensions_sorted = extensions_map.values.sortBy(c => class_name_map.get(c)\
    \ - class_name_map.get(c))\n        val extensions_sorted = extensions_map.values.sortBy(c\
    \ => class_name_map.get(c) - class_name_map.get(c))\n        val extensions_sorted\
    \ = extensions_map.values.sortBy(c => class_name_map.get(c) - class_name_map.get(c))\n\
    \        val extensions_sorted = extensions_map.values.sortBy(c => class_name_map.get(c)\
    \ - class_name_map.get(c))\n        val extensions_sorted = extensions_map.values.sortBy(c\
    \ => class_name_map.get(c) - class_name_map.get(c))\n        val extensions_sorted\
    \ = extensions_map.values.sortBy(c => class_name_map.get(c) - class_name_map.get(c))\n\
    \        val extensions_sorted = extensions_map.values.sortBy(c => class_name_map.get(c)\
    \ - class_name_map.get(c))\n        val extensions_sorted = extensions_map.values.sortBy(c\
    \ => class_name_map.get(c) - class_name_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcu42pqeu.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcu42pqeu.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions_map.values.sortBy(\e[36mc\e[0m =>\
    \ class_name_map.get(c) - class_name_map.get(c))\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpcu42pqeu.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_map.values.sortBy(\e[36mc\e[0m => class_name_map.get(c) - class_name_map.get(c))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpcu42pqeu.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_map.values.sortBy(\e[36mc\e[0m => class_name_map.get(c) - class_name_map.get(c))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpcu42pqeu.scala:"
  stdout: ''
  timestamp: 1660009672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase).zipWithIndex.toMap\n        val class_name_map\
    \ = class_name.zipWithIndex.toMap\n        val extensions_count = extensions_map.size\n\
    \        val class_name_count = class_name_map.size\n        val extensions_strength\
    \ = extensions_count - class_name_count\n        val class_name_strength = class_name_map.get(extensions_strength).getOrElse(-1)\n\
    \        val extensions_strength_str = extensions_strength.toString\n        val\
    \ class_name_strength_str = class_name_strength.toString\n        val class_name_strength_str_with_extension\
    \ = class_name_strength_str + extensions_strength_str\n        class_name_map.get(class_name_strength_str_with_extension).getOrElse(class_name)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphblno_ps.scala:26:53\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mclass_name_strength\e\
    [0m = class_name_map.get(extensions_strength).getOrElse(-\e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                                     ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   Found:    (extensions_strength\
    \ : Int)\n\e[31m   |\e[0m                                   Required: Char\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphblno_ps.scala:30:27\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        class_name_map.get(class_name_strength_str_with_extension).getOrElse(class_name)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    (class_name_strength_str_with_extension\
    \ : String)\n\e[31m   |\e[0m             Required: Char\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase - e.toLowerCase -> 1)).toMap\n        val\
    \ class_name_map = class_name.map(c => (c.toUpperCase - c.toLowerCase -> 1)).toMap\n\
    \        val max_strength = extensions_map.values.max\n        val max_extension\
    \ = extensions_map.keys.max\n        val max_class_name = class_name_map.keys.max\n\
    \        val max_extension_name = extensions_map.keys.max\n        val max_extension_strength\
    \ = extensions_map.values.max\n        val max_extension_class_name = class_name_map.values.max\n\
    \        val max_extension_extension = extensions_map.values.max\n        val\
    \ max_extension_class_name_extension = class_name_map.values.max\n        val\
    \ max_extension_class_name_extension_extension = extensions_map.values.max\n \
    \       val max_extension_class_name_extension_extension_extension = extensions_map.values.max\n\
    \        val max_extension_class_name_extension_extension_extension_extension\
    \ = extensions_map.values.max\n        val max_extension_class_name_extension_extension_extension_extension_extension\
    \ = extensions_map.values.max\n        val max_extension_class_name_extension_extension_extension_extension_extension_extension\
    \ = extensions_map.values.max\n        val max_extension_class_name_extension_extension_extension_extension_extension_extension_extension\
    \ = extensions_map.values.max\n        val max_extension_class_name_extension_extension_extension_extension_extension_extension_extension_extension\
    \ = extensions_map.values.max\n        val max_extension_class_name_extension_extension_extension_extension_extension_extension_extension_extension_extension\
    \ = extensions_map.values.max\n        val max_extension_class_name_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension\
    \ = extensions_map.values.max\n        val max_extension_class_name_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension\
    \ = extensions_map.values.max\n        val max_extension_class_name_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension\
    \ = extensions_map.values.max\n        val max_extension_class_name_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension\
    \ = extensions_map.values.max\n        val max_extension_class_name_extension_extension_extension_extension_extension_extension_extension_extension_extension_extension_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptxkilhqm.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptxkilhqm.scala:21:64\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_map\e[0m = extensions.map(\e[36me\e[0m => (e.toUpperCase - e.toLowerCase\
    \ -> \e[31m1\e[0m)).toMap\n\e[31m\e[31m   |\e[0m                             \
    \                     ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member\
    \ of String, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmptxkilhqm.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mc\e[0m => (c.toUpperCase - c.toLowerCase -> \e[31m1\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                  ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toUpperCase is not a\
    \ member of Char\n\e[31m\e[31m-- Error: /tmp/tmptxkilhqm.scala:23:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mmax_strength\e[0m = extensions_map.values.max\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mString\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mBoolean\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- Error: /tmp/tmptxkilhqm.scala:24:51 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e["
  stdout: ''
  timestamp: 1660009674
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs).max\n    \
    \    val extension = extensions_map.getOrElse(strength, \"\")\n        class_name\
    \ + extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjrhd6u0n.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpjrhd6u0n.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjrhd6u0n.scala:23:57\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = extensions_map.values.map(\e[36mx\e[0m => (x - class_name_map.get(x)).abs).max\n\
    \e[31m\e[31m   |\e[0m                                                       ^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpjrhd6u0n.scala:23:78 --------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e\
    [36mx\e[0m => (x - class_name_map.get(x)).abs).max\n\e[31m\e[31m   |\e[0m    \
    \                                                                          ^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   (x : String)\n\e[31m   |\e[0m                                            \
    \      Required: Nothing\n\e[31"
  stdout: ''
  timestamp: 1660009674
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        var strongest_extension\
    \ = \"\"\n        var strength = -1\n        extensions.foreach(e => {\n     \
    \       val c = e.toUpperCase\n            val l = e.toLowerCase\n           \
    \ val cap = c.length\n            val sm = l.length\n            val strength\
    \ = cap - sm\n            if (strength > 0) {\n                if (strength >\
    \ strongest_extension.length) {\n                    strongest_extension = e\n\
    \                }\n            }\n        })\n        class_name + strongest_extension\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdc0ppzz.scala:38)\n\tat Problem.main(tmpgdc0ppzz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009674
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val extensions_sorted = extensions_map.toSeq.sortWith((a, b) =>\
    \ strength - a._2).map(e => s\"$class_name.$e\")\n        if (extensions_sorted.size\
    \ == 1) extensions_sorted.head else extensions_sorted.head\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp__idqa7y.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n1 error found\n"
  stdout: ''
  timestamp: 1660009673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase).toMap\n\
    \        val class_name_map = class_name.map(c => c.toUpperCase.charAt(0) -> c.toUpperCase.charAt(1).toLowerCase).toMap\n\
    \        val strength = extensions_map.values.map(c => class_name_map.get(c) -\
    \ class_name_map.get(c)).sum\n        val extensions_sorted = extensions_map.values.sortBy(c\
    \ => class_name_map.get(c) - class_name_map.get(c))\n        val extensions_sorted\
    \ = extensions_sorted.takeWhile(c => class_name_map.get(c) - class_name_map.get(c)\
    \ > 0)\n        val extensions_sorted = extensions_sorted.takeWhile(c => class_name_map.get(c)\
    \ - class_name_map.get(c) > 0)\n        val extensions_sorted = extensions_sorted.takeWhile(c\
    \ => class_name_map.get(c) - class_name_map.get(c) > 0)\n        val extensions_sorted\
    \ = extensions_sorted.takeWhile(c => class_name_map.get(c) - class_name_map.get(c)\
    \ > 0)\n        val extensions_sorted = extensions_sorted.takeWhile(c => class_name_map.get(c)\
    \ - class_name_map.get(c) > 0)\n        val extensions_sorted = extensions_sorted.takeWhile(c\
    \ => class_name_map.get(c) - class_name_map.get(c) > 0)\n        val extensions_sorted\
    \ = extensions_sorted.takeWhile(c => class_name_map.get(c) - class_name_map.get(c)\
    \ > 0)\n        val extensions_sorted = extensions_sorted.takeWhile(c => class_name_map.get(c)\
    \ - class_name_map.get(c) > 0)\n        val extensions_sorted = extensions_sorted.takeWhile(c\
    \ => class_name_map.get(c) - class_name_map.get(c) > 0)\n        val extensions_sorted\
    \ = extensions_sorted.takeWhile(c => class_name_map.get(c) - class_name_map.get(c)\
    \ > 0)\n        val extensions_sorted = extensions_sorted.takeWhile(c => class_name_map.get(c)\
    \ - class_name_map.get(c) > 0)\n        val extensions_sorted = extensions_sorted.takeWhile(c\
    \ => class_name_map.get(c) - class_name_map.get(c) > 0)\n        val extensions_sorted\
    \ = extensions_sorted.takeWhile(c => class_name_map.get(c) - class_name_map.get(c)\
    \ > 0)\n        val extensions_sorted = extensions_sorted.takeWhile(c => class_name_map.get(c)\
    \ - class_name_map.get(c\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo_ivs0st.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo_ivs0st.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions_sorted.takeWhile(\e[36mc\e[0m => class_name_map.get(c)\
    \ - class_name_map.get(c) > \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpo_ivs0st.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mc\e[0m => class_name_map.get(c) - class_name_map.get(c)\
    \ > \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpo_ivs0st.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mc\e[0m => class_name_map.get(c) - class_name_map.get(c)\
    \ > \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m--"
  stdout: ''
  timestamp: 1660009676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs).max\n    \
    \    val extensions_sorted = extensions_map.values.sortBy(x => x - class_name_map.get(x))\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x < strength).mkString(\"\
    .\")\n        extensions_sorted + class_name\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_s2cgl5g.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mx\e[0m => x < strength).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp_s2cgl5g.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp_s2cgl5g.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_s2cgl5g.scala:23:57\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = extensions_map.values.map(\e[36mx\e[0m => (x - class_name_map.get(x)).abs).max\n\
    \e[31m\e[31m   |\e[0m                                                       ^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |"
  stdout: ''
  timestamp: 1660009677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count - extensions_count_upper - extensions_count_lower\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplv48zpex.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplv48zpex.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions.sortWith((\e[36ma\e[0m, \e[36mb\e\
    [0m) => strength.compareTo(a.compareTo(b)))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplv48zpex.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength.compareTo(a.compareTo(b)))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplv48zpex.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength.compareTo(a.compareTo(b)))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplv48zpex.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        "
  stdout: ''
  timestamp: 1660009677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val extensions_count_cap = extensions.map(_.toUpperCase.length).sum -\
    \ extensions.map(_.toLowerCase.length).sum\n        val extensions_count_sm =\
    \ extensions.map(_.toLowerCase.length).sum - extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_diff = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_diff_upper = extensions_count_upper - extensions_count_cap\n\
    \        val extensions_count_diff_lower = extensions_count_lower - extensions_count_sm\n\
    \        val extensions_count_diff_diff = extensions_count_diff_upper - extensions_count_diff_lower\n\
    \        val extensions_count_diff_diff_upper = extensions_count_diff_upper -\
    \ extensions_count_diff\n        val extensions_count_diff_diff_lower = extensions_count_diff_lower\
    \ - extensions_count_diff\n        val extensions_count_diff_diff_diff = extensions_count_diff_diff_upper\
    \ - extensions_count_diff_diff_lower\n        val extensions_count_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_upper - extensions_count_diff_diff\n        val\
    \ extensions_count_diff_diff_lower = extensions_count_diff_diff_lower - extensions_count_diff_diff\n\
    \        val extensions_count_diff_diff_diff = extensions_count_diff_diff_diff_upper\
    \ - extensions_count_diff_diff_diff_lower\n        val extensions_count_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_upper - extensions_count_diff_diff_diff\n\
    \        val extensions_count_diff_diff_diff_lower = extensions_count_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff\n        val extensions_count_diff_diff_diff_diff\
    \ = extensions_count_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_upper = extensions_count_diff_diff_diff_diff_upper\
    \ - extensions_count_diff_diff_diff_diff_lower\n        val extensions_count_diff_diff_diff_diff_lower\
    \ = extensions_count_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_diff\n\
    \        val extensions_count_diff_diff_diff_diff_diff_upper = extensions_count_diff_diff_diff_diff_diff_upper\
    \ - extensions_count_diff_diff_diff_diff_diff_lower\n        val extensions_count_diff_diff_diff_diff_diff_lower\
    \ = extensions_count_diff_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_diff_diff\n\
    \        val extensions_count_diff_diff_diff_diff_diff_diff_upper = extensions_count_diff_diff_diff_diff_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpifaqxv1r.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_lower - extensions_count_diff_diff\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_lower is already defined as \e\
    [33mvalue\e[0m \e[35mextensions_count_diff_diff_lower\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpifaqxv1r.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_diff_diff\e[0m = extensions_count_diff_diff_diff_upper\
    \ - extensions_count_diff_diff_diff_lower\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_diff_diff_diff\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpifaqxv1r.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_diff_diff_upper\e[0m = extensions_count_diff_diff_diff_upper\
    \ - extensions_count_diff_diff_diff\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_upper is already defined as\
    \ \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_upper\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpifaqxv1r.scala:37:52\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mext"
  stdout: ''
  timestamp: 1660009676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_length = extensions_count_sorted.map(_.length).sum\n\
    \        val extensions_count_sorted_length_sorted = extensions_count_sorted.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith((a, b) => b.length - a.length)\n \
    \       val extensions_count_sorted_length_sorted_length_sorted = extensions_count_sorted_length_sorted.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length.sortWith((a, b) => b.length -\
    \ a.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted.sortWith((a, b) => b.length\
    \ - a.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length.sortWith((a, b)\
    \ => b.length - a.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"\
    ), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuf5uc4l9.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpuf5uc4l9.scala:22:68 --------------------\e[0m\e[0m\n\e[31m22 |\e[0m\
    \        \e[33mval\e[0m \e[36mextensions_count_sorted\e[0m = extensions.sortWith((\e\
    [36ma\e[0m, \e[36mb\e[0m) => b.length - a.length)\n\e[31m\e[31m   |\e[0m     \
    \                                                               ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                       Found:\
    \    Int\n\e[31m   |\e[0m                                                    \
    \   Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuf5uc4l9.scala:24:95\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sorted\e\
    [0m = extensions_count_sorted.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => b.length\
    \ - a.length)\n\e[31m\e[31m   |\e[0m                                         \
    \                                                      ^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                       Found: \
    \   Int\n\e[31m   |\e[0m                                                     \
    \  Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuf5uc4l9.scala:25:90\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_sorted_length_sorted_length\e[0m = extensions_count_sorted_length.sortWith((\e\
    [36ma\e[0m, \e[36mb\e[0m) => b.length - a.length)\n\e[31m\e[31m   |\e[0m     \
    \                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   value sortWith is not a\
    \ member of Int\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuf5uc4l9.scala:26:123\
    \ -------------------\e[0m\e[0m\n\e[31m26 |\e[0m"
  stdout: ''
  timestamp: 1660009660
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map(x._1) - class_name_map(x._2)).sum\n\
    \        val extensions_sorted = extensions_map.toSeq.sortBy(x => x._1).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt_9aiyfx.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mx\e[0m => x._2 > \e[31m0\e[0m).reverse\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpt_9aiyfx.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mx\e[0m => x._2 > \e[31m0\e[0m).reverse\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpt_9aiyfx.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mx\e[0m => x._2 > \e[31m0\e[0m).reverse\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpt_9aiyfx.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mx\e[0m => x._2 > \e[31m0\e[0m).reverse\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e["
  stdout: ''
  timestamp: 1660009682
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.map(_.length).sort\n\
    \        val strength = extensions_count_sorted.last\n        val extensions_count_sorted\
    \ = extensions.map(_.length).sort\n        val strength_sorted = extensions_count_sorted.last\n\
    \        val extensions_count_sorted = extensions.map(_.length).sort\n       \
    \ val strength_sorted = extensions_count_sorted.last\n        val extensions_count_sorted\
    \ = extensions.map(_.length).sort\n        val strength_sorted = extensions_count_sorted.last\n\
    \        val extensions_count_sorted = extensions.map(_.length).sort\n       \
    \ val strength_sorted = extensions_count_sorted.last\n        val extensions_count_sorted\
    \ = extensions.map(_.length).sort\n        val strength_sorted = extensions_count_sorted.last\n\
    \        val extensions_count_sorted = extensions.map(_.length).sort\n       \
    \ val strength_sorted = extensions_count_sorted.last\n        val extensions_count_sorted\
    \ = extensions.map(_.length).sort\n        val strength_sorted = extensions_count_sorted.last\n\
    \        val extensions_count_sorted = extensions.map(_.length).sort\n       \
    \ val strength_sorted = extensions_count_sorted.last\n        val extensions_count_sorted\
    \ = extensions.map(_.length).sort\n        val strength_sorted = extensions_count_sorted.last\n\
    \        val extensions_count_sorted = extensions.map(_.length).sort\n       \
    \ val strength_sorted = extensions_count_sorted.last\n        val extensions_count_sorted\
    \ = extensions.map(_.length).sort\n        val strength_sorted = extensions_count_sorted.last\n\
    \        val extensions_count_sorted = extensions.map(_.length).sort\n       \
    \ val strength_sorted = extensions_count_sorted.last\n        val extensions_count_sorted\
    \ = extensions.map(_.length).sort\n        val strength_sorted = extensions_count_sorted.last\n\
    \        val extensions_count_sorted = extensions.map(_.length).sort\n       \
    \ val strength_sorted = extensions_count_sorted.last\n        val extensions_count_sorted\
    \ = extensions.map(_.length).sort\n        val strength_sorted = extensions_count_sorted.last\n\
    \        val extensions_count_sorted = extensions.map(_.length).sort\n       \
    \ val strength_sorted = extensions_count_sorted.last\n        val extensions_count_sorted\
    \ = extensions.map(_.length).sort\n        val strength_sorted = extensions_count_sorted.last\n\
    \        val extensions_count_sorted = extensions.map(_.length).sort\n       \
    \ val \n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp7nup19rv.scala:59:11 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp7nup19rv.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions.map(_.length).sort\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7nup19rv.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions.map(_.length).sort\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7nup19rv.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mstrength_sorted\e[0m = extensions_count_sorted.last\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mstrength_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7nup19rv.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions.map(_.length).sort\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009681
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val extensions_count_diff = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_diff_upper = extensions_count_upper - extensions_count_diff\n\
    \        val extensions_count_diff_lower = extensions_count_lower - extensions_count_diff\n\
    \        val extensions_count_diff_diff_upper = extensions_count_diff_upper -\
    \ extensions_count_diff_lower\n        val extensions_count_diff_diff_lower =\
    \ extensions_count_diff_lower - extensions_count_diff_upper\n        val extensions_count_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_upper - extensions_count_diff_diff_lower\n    \
    \    val extensions_count_diff_diff_diff_lower = extensions_count_diff_diff_lower\
    \ - extensions_count_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_upper - extensions_count_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_diff_diff_diff_upper\n        val\
    \ extensions_count_diff_diff_diff_\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpll4rx2mx.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpll4rx2mx.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_diff_diff_diff_upper\e[0m = extensions_count_diff_diff_diff_diff_upper\
    \ - extensions_count_diff_diff_diff_diff_lower\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_upper is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_upper\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpll4rx2mx.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_lower is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_lower\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpll4rx2mx.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_diff_diff_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009614
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.count\n        val extensions_count_upper = extensions.count(_.toUpperCase.size\
    \ == extensions_count)\n        val extensions_count_lower = extensions.count(_.toLowerCase.size\
    \ == extensions_count)\n        val extensions_count_diff = extensions_count_upper\
    \ - extensions_count_lower\n        val extensions_count_diff_upper = extensions_count_diff\
    \ / extensions_count\n        val extensions_count_diff_lower = extensions_count_diff\
    \ % extensions_count\n        val extensions_count_diff_diff_upper = extensions_count_diff_upper\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_lower = extensions_count_diff_lower\
    \ % extensions_count_lower\n        val extensions_count_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_upper / extensions_count_count_lower\n        val\
    \ extensions_count_diff_diff_diff_lower = extensions_count_diff_diff_lower % extensions_count_count_lower\n\
    \        val extensions_count_diff_diff_diff_diff_upper = extensions_count_diff_diff_diff_upper\
    \ / extensions_count_count_count_lower\n        val extensions_count_diff_diff_diff_diff_lower\
    \ = extensions_count_diff_diff_diff_lower % extensions_count_count_count_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_upper = extensions_count_diff_diff_diff_diff_upper\
    \ / extensions_count_count_count_count_lower\n        val extensions_count_diff_diff_diff_diff_lower\
    \ = extensions_count_diff_diff_diff_diff_lower % extensions_count_count_count_count_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_upper = extensions_count_diff_diff_diff_diff_diff_upper\
    \ / extensions_count_count_count_count_count_lower\n        val extensions_count_diff_diff_diff_diff_diff_lower\
    \ = extensions_count_diff_diff_diff_diff_diff_lower % extensions_count_count_count_count_count_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_diff_upper = extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ / extensions_count_count_count_count_count_count_lower\n        val extensions_count_diff_diff_diff_diff_diff_lower\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_lower % extensions_count_count_count_count_count_count_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_diff_upper = extensions_count_diff_diff_diff_diff_diff_diff_diff_upper\
    \ / extensions_count_count_count_count_count_count_count_lower\n        val extensions_count_diff_diff_diff_diff_diff_diff_lower\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_diff_lower % extensions_count_count_count_count_count_count_count_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_diff_diff_upper = extensions_count_diff_diff_diff_diff_diff_diff_diff_diff_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8vqcm2n0.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_lower % extensions_count_count_count_count_lower\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_lower is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_lower\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8vqcm2n0.scala:35:12 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_diff_upper\e\
    [0m = extensions_count_diff_diff_diff_diff_diff_upper / extensions_count_count_count_count_count_lower\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_diff_upper is already\
    \ defined as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_diff_upper\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8vqcm2n0.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_diff_diff_lower % extensions_count_count_count_count_count_count_lower\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_diff_lower is already\
    \ defined as \e[33mvalue\e[0m \e[35mextension"
  stdout: ''
  timestamp: 1660009681
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((a, b) => math.max(a, b))\n \
    \       val strongest_extension = extensions_map.values.find(x => x == strength).head\n\
    \        s\"$class_name.$strongest_extension\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd1bdik12.scala:27)\n\tat Problem.main(tmpd1bdik12.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009683
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.get(x) - x.toUpperCase.length).max\n\
    \        val extension = extensions_map.getOrElse(strength, \"\")\n        class_name\
    \ + extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdlxljlns.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpdlxljlns.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdlxljlns.scala:23:73\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => class_name_map.get(x) - x.toUpperCase.length).max\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \              Found:    (x : String)\n\e[31m   |\e[0m                       \
    \                           Required: Nothing\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmpdlxljlns.scala:23:103 ----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e\
    [36mx\e[0m => class_name_map.get(x) - x.toUpperCase.length).max\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                                    ^\e[0m\n\e[31m   |\e[0mambiguous given instances:\
    \ both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35mmax\e[0m\
    \ in \e[33mtrait\e[0m"
  stdout: ''
  timestamp: 1660009614
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs)\n        val\
    \ max_strength = strength.max\n        val max_key = strength.maxBy(x => x)\n\
    \        val max_key_index = strength.indexOf(max_key)\n        val max_key_name\
    \ = extensions_map.get(max_key_index)\n        val max_key_name_map = max_key_name.map(x\
    \ => (x.toUpperCase, x.toLowerCase)).toMap\n        val max_key_name_strength\
    \ = max_key_name_map.values.map(x => (x - class_name_map.get(x)).abs)\n      \
    \  val max_key_name_max_strength = max_key_name_strength.max\n        val max_key_name_max_key\
    \ = max_key_name_strength.maxBy(x => x)\n        val max_key_name_max_key_index\
    \ = max_key_name_strength.indexOf(max_key_name_max_key)\n        val max_key_name_max_key_name\
    \ = extensions_map.get(max_key_name_max_key_index)\n        val max_key_name_max_key_name_map\
    \ = max_key_name_max_key_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n\
    \        val max_key_name_max_key_name_strength = max_key_name_max_key_name_map.values.map(x\
    \ => (x - class_name_map.get(x)).abs)\n        val max_key_name_max_key_name_max_strength\
    \ = max_key_name_max_key_name_max_strength.max\n        val max_key_name_max_key_name_max_key\
    \ = max_key_name_max_key_name_max_strength.maxBy(x => x)\n        val max_key_name_max_key_name_max_key_index\
    \ = max_key_name_max_key_name_max_strength.indexOf(max_key_name_max_key_name_max_key)\n\
    \        val max_key_name_max_key_name_max_key_name = extensions_map.get(max_key_name_max_key_name_max_key_index)\n\
    \        val max_key_name_max_key_name_max_key_name_map = max_key_name_max_key_name_max_key_name.map(x\
    \ => (x.toUpperCase, x.toLowerCase)).toMap\n        val max_key_name_max_key_name_max_key_name_strength\
    \ = max_key_name_max_key_name_max_key_name_max_key_name_map.values.map(x => (x\
    \ - class_name_map.get(x)).abs)\n        val max_key_name_max_key_name_max_key_name_max_strength\
    \ = max_key_name_max_key_name_max_key_name_max_key_name_max_strength.max\n   \
    \     val max_key_name_max_key_name_max_key_name_max_key = max_key_name_max_key_name_max_key_name_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu8qpeod3.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpu8qpeod3.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu8qpeod3.scala:23:57\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = extensions_map.values.map(\e[36mx\e[0m => (x - class_name_map.get(x)).abs)\n\
    \e[31m\e[31m   |\e[0m                                                       ^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpu8qpeod3.scala:23:78 --------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e\
    [36mx\e[0m => (x - class_name_map.get(x)).abs)\n\e[31m\e[31m   |\e[0m        \
    \                                                                      ^\e[0m\n\
    \e[31m   |\e[0m                                                  Found:    (x\
    \ : String)\n\e[31m   |\e[0m                                                 \
    \ Required: Nothing\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1660009684
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x.toInt - class_name_map.get(x).toInt, x))\n\
    \        strength.sortBy(x => x._1).head._2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgaxpk19x.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpgaxpk19x.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgaxpk19x.scala:23:84\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => (x.toInt - class_name_map.get(x).toInt,\
    \ x))\n\e[31m\e[31m   |\e[0m                                                 \
    \                                   ^\e[0m\n\e[31m   |\e[0m                  \
    \                                Found:    (x : String)\n\e[31m   |\e[0m     \
    \                                             Required: Nothing\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgaxpk19x.scala:24:17 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        strength.sortBy(\e[36mx\e[0m => x._1).head._2\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value\
    \ sortBy is not a member of Iterable[(Nothing, String)]\n4 errors found\n"
  stdout: ''
  timestamp: 1660009683
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase - x.toLowerCase + 1).toInt)\n        val\
    \ max_strength = extensions_map.max\n        val max_extension = extensions_map.filter(_\
    \ == max_strength).head\n        s\"$class_name.$max_extension\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8n5iwomv.scala:21:64 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36mx\e[0m => (x.toUpperCase - x.toLowerCase + \e[31m1\e[0m).toInt)\n\e[31m\e\
    [31m   |\e[0m                                                  ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp8n5iwomv.scala:22:45 -----------------------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mmax_strength\e[0m = extensions_map.max\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e[0m in\
    \ \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mDeprecatedFloatOrdering\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660009683
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase - x.toLowerCase + 1)).toMap\n        val\
    \ strength = extensions_map.getOrElse(class_name, 0)\n        val sorted_extensions\
    \ = extensions_map.toSeq.sortBy(_._1).reverse\n        val extension_name = sorted_extensions.head._2\n\
    \        val extension_strength = sorted_extensions.head._1\n        val class_name_with_extension\
    \ = class_name + extension_name\n        val extension_class_name = extension_name\
    \ + class_name\n        if (extension_strength > strength) {\n            class_name_with_extension\n\
    \        } else if (extension_strength == strength) {\n            extension_class_name\n\
    \        } else {\n            StrongestExtension(class_name_with_extension, extensions)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3nyik0s4.scala:21:64 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36mx\e[0m => (x.toUpperCase - x.toLowerCase + \e[31m1\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                  ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp3nyik0s4.scala:22:48 --------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.getOrElse(class_name,\
    \ \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                       \
    \         ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                   \
    \      Found:    (class_name : String)\n\e[31m   |\e[0m                      \
    \                   Required: Nothing\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp3nyik0s4.scala:23:65 -----------------------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36msorted_extensions\e[0m = extensions_map.toSeq.sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \         ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m\
    \ \e[35mSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660009683
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase.size, e.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((a, b) => if (a > b) a else b)\n\
    \        val extensions_sorted = extensions_map.values.sortWith((a, b) => a >\
    \ b)\n        val extensions_sorted = extensions_sorted.takeWhile(_ < strength)\n\
    \        val extensions_sorted = extensions_sorted.mkString(\".\")\n        class_name\
    \ + extensions_sorted\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5co4vev7.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_ < strength)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp5co4vev7.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\".\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp5co4vev7.scala:23:54 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_map.values.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => a > b)\n\e[31m\e\
    [31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         value sortWith is not a member of\
    \ Iterable[Int]\n3 errors found\n"
  stdout: ''
  timestamp: 1660009682
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase)\n\
    \        val extensions_count = extensions_map.filter(_._2.toInt == 0).length\n\
    \        val extensions_count_map = extensions_map.filter(_._2.toInt == 1).map(e\
    \ => (e._1, e._2.toInt)).toMap\n        val extensions_count_sorted = extensions_count_map.toSeq.sortBy(_._1).reverse\n\
    \        val extensions_count_sorted = extensions_count_sorted.take(extensions_count)\n\
    \        val extensions_count_sorted = extensions_count_sorted.filter(_._2 > 0)\n\
    \        val extensions_count_sorted = extensions_count_sorted.map(_._1)\n   \
    \     val extensions_count_sorted = extensions_count_sorted.toList\n        val\
    \ extensions_count_sorted = extensions_count_sorted.map(e => e + \".\" + extensions_count_map.get(e)._1)\n\
    \        val extensions_count_sorted = extensions_count_sorted.mkString(\"\")\n\
    \        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\\\
    \\.\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\+\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\-\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\*\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\?\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\*\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\?\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\*\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\?\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\*\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\?\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\*\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\?\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\*\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\?\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\*\", \"\")\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcp3ttdxm.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions_count_sorted.take(extensions_count)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcp3ttdxm.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions_count_sorted.filter(_._2 > \e[31m0\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcp3ttdxm.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions_count_sorted.map(_._1)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcp3ttdxm.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions_count_sorted.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ ov"
  stdout: ''
  timestamp: 1660009686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x.toInt - class_name_map.get(x).toInt, x))\n\
    \        strength.sortBy(x => x._1).head._2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgaxpk19x.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpgaxpk19x.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgaxpk19x.scala:23:84\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => (x.toInt - class_name_map.get(x).toInt,\
    \ x))\n\e[31m\e[31m   |\e[0m                                                 \
    \                                   ^\e[0m\n\e[31m   |\e[0m                  \
    \                                Found:    (x : String)\n\e[31m   |\e[0m     \
    \                                             Required: Nothing\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgaxpk19x.scala:24:17 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        strength.sortBy(\e[36mx\e[0m => x._1).head._2\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value\
    \ sortBy is not a member of Iterable[(Nothing, String)]\n4 errors found\n"
  stdout: ''
  timestamp: 1660009683
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase, e.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(c => (c.toUpperCase, c.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(_.length - class_name_map.values.map(_.length)).sum\n\
    \        val extensions_sorted = extensions_map.values.sortBy(_.length - class_name_map.values.map(_.length).sum)\n\
    \        val class_name_sorted = class_name_map.values.sortBy(_.length)\n    \
    \    val extension_sorted = extensions_sorted.find(e => class_name_sorted.contains(e._1))\n\
    \        val extension_str = extension_sorted._1 + \".\" + extension_sorted._2\n\
    \        extension_str\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnauvabdo.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mc\e[0m => (c.toUpperCase, c.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpnauvabdo.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mc\e[0m => (c.toUpperCase, c.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnauvabdo.scala:23:88\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = extensions_map.values.map(_.length - class_name_map.values.map(_.length)).sum\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                              ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue length is not\
    \ a member of Nothing, but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration\
    \ AsScalaIterator\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.enumeration\
    \ AsScalaIterator\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.iterator\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import concurrent.duration.pairIntToDuration\n\
    \e[31m   |\e[0m  import concurrent.duration.pairLongToDuration\n\e[31m   |\e[0m\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmp"
  stdout: ''
  timestamp: 1660009685
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs)\n        val\
    \ strength_sorted = strength.sortWith(_ < _)\n        val strength_sorted = strength_sorted.take(1).mkString.concat(\"\
    .\").concat(strength_sorted.last)\n        val strength_sorted = strength_sorted.replaceAll(\"\
    (.)\\\\1\", \"$1\")\n        class_name_map.get(strength_sorted)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptvwx7lhy.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mstrength_sorted\e[0m = strength_sorted.take(\e\
    [31m1\e[0m).mkString.concat(\e[31m\".\"\e[0m).concat(strength_sorted.last)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mstrength_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmptvwx7lhy.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mstrength_sorted\e[0m = strength_sorted.replaceAll(\e\
    [31m\"(.)\\\\1\"\e[0m, \e[31m\"$1\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mstrength_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmptvwx7lhy.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmptvwx7lhy.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptvwx7lhy.scala:23:57\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33m"
  stdout: ''
  timestamp: 1660009686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n     \
    \   val extensions_sorted = extensions_sorted.take(extensions_sorted.length-1)\n\
    \        val extensions_sorted = extensions_sorted.map(_._2).mkString(\".\")\n\
    \        val extensions_sorted = extensions_sorted.replaceAll(\"(.)\", \"$1\"\
    )\n        class_name + extensions_sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgf5awenn.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.take(extensions_sorted.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpgf5awenn.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(_._2).mkString(\e[31m\".\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e[35mextensions_sorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgf5awenn.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m = extensions_sorted.replaceAll(\e\
    [31m\"(.)\"\e[0m, \e[31m\"$1\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009683
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val strength_str = if (strength == 0) \"0\" else strength.toString\n    \
    \    val extensions_str = extensions.map(_.toString).mkString(\".\")\n       \
    \ val class_name_str = class_name.replaceAll(\"\\\\.\", \"_\")\n        val class_name_with_extension\
    \ = class_name_str + extensions_str\n        val class_name_with_extension_str\
    \ = class_name_with_extension.replaceAll(\"_\", \"\")\n        val class_name_with_extension_str_with_extension\
    \ = class_name_with_extension_str + extensions_str\n        val class_name_with_extension_str_with_extension_str\
    \ = class_name_with_extension_str_with_extension.replaceAll(\"_\", \"\")\n   \
    \     val class_name_with_extension_str_with_extension_str_with_extension = class_name_with_extension_str_with_extension_str\
    \ + extensions_str\n        val class_name_with_extension_str_with_extension_str_with_extension_str\
    \ = class_name_with_extension_str_with_extension_str_with_extension.replaceAll(\"\
    _\", \"\")\n        val class_name_with_extension_str_with_extension_str_with_extension_str_with_extension\
    \ = class_name_with_extension_str_with_extension_str_with_extension_str + extensions_str\n\
    \        val class_name_with_extension_str_with_extension_str_with_extension_str_with_extension_str\
    \ = class_name_with_extension_str_with_extension_str_with_extension_str_with_extension.replaceAll(\"\
    _\", \"\")\n        val class_name_with_extension_str_with_extension_str_with_extension_str_with_extension_str_with_extension\
    \ = class_name_with_extension_str_with_extension_str_with_extension_str_with_extension_str_with_extension.replaceAll(\"\
    _\", \"\")\n        val class_name_with_extension_str_with_extension_str_with_extension_str_with_extension_str_with_extension_str\
    \ = class_name_with_extension_str_with_extension_str_with_extension_str_with_extension_str_with_extension.replaceAll(\"\
    _\", \"\")\n        val class_name_with_extension_str_with_extension_str_with_extension_str_with_extension_str_with_extension_str_with_extension\
    \ = class_name_with_extension_str_with_extension_str_with_extension_str_with_extension_str_with_extension_str_with_extension_str.replaceAll(\"\
    _\", \"\")\n        val class_name_with_extension_str_with_extension_str_with_extension_str_with_extension_str_with_extension_str_with_extension_str_with_extension\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpoipwu8na.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpoipwu8na.scala:36:116\
    \ --------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclass_name_with_extension_str_with_extension_str_with_extension_str_with_extension_str_with_extension\e\
    [0m = class_name_with_extension_str_with_extension_str_with_extension_str_with_extension_str_with_extension.replaceAll(\e\
    [31m\"_\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \                                                                            \
    \                  ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e\
    [31m   |\e[0m  class_name_with_extension_str_with_extension_str_with_extension_str_with_extension_str_with_extension\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpoipwu8na.scala:38:135 -----------------------\e[0m\e[0m\n\e[31m38 |\e\
    [0m        \e[33mval\e[0m \e[36mclass_name_with_extension_str_with_extension_str_with_extension_str_with_extension_str_with_extension_str_with_extension\e\
    [0m = class_name_with_extension_str_with_extension_str_with_extension_str_with_extension_str_with_extension_str_with_extension_str.replaceAll(\e\
    [31m\"_\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                      \
    \                                                                            \
    \                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: class_name_with_extension_str_with_extension_str_with_extension_str_with_extension_str_with_extension_str_with_extension_str\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoipwu8na.scala:40:5\
    \ ---------------------\e[0m\e[0m\n\e[31m40"
  stdout: ''
  timestamp: 1660009685
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val extensions_count_diff = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_diff_upper = extensions_count_upper - extensions_count_diff\n\
    \        val extensions_count_diff_lower = extensions_count_lower - extensions_count_diff\n\
    \        val extensions_count_diff_diff_upper = extensions_count_diff_upper -\
    \ extensions_count_diff_lower\n        val extensions_count_diff_diff_lower =\
    \ extensions_count_diff_lower - extensions_count_diff_upper\n        val extensions_count_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_upper - extensions_count_diff_diff_lower\n    \
    \    val extensions_count_diff_diff_diff_lower = extensions_count_diff_diff_lower\
    \ - extensions_count_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_upper - extensions_count_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_diff_diff_diff_upper\n        val\
    \ extensions_count_diff_diff_diff_\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpll4rx2mx.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpll4rx2mx.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_diff_diff_diff_upper\e[0m = extensions_count_diff_diff_diff_diff_upper\
    \ - extensions_count_diff_diff_diff_diff_lower\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_upper is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_upper\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpll4rx2mx.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_lower is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_lower\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpll4rx2mx.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_diff_diff_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009614
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val extensions_count_diff = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_diff_upper = extensions_count_upper - extensions_count_diff\n\
    \        val extensions_count_diff_lower = extensions_count_lower - extensions_count_diff\n\
    \        val extensions_count_diff_diff_upper = extensions_count_diff_upper -\
    \ extensions_count_diff_lower\n        val extensions_count_diff_diff_lower =\
    \ extensions_count_diff_lower - extensions_count_diff_upper\n        val extensions_count_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_upper - extensions_count_diff_diff_lower\n    \
    \    val extensions_count_diff_diff_diff_lower = extensions_count_diff_diff_lower\
    \ - extensions_count_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_upper - extensions_count_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_diff_diff_diff_upper\n        val\
    \ extensions_count_diff_diff_diff_\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpll4rx2mx.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpll4rx2mx.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_diff_diff_diff_upper\e[0m = extensions_count_diff_diff_diff_diff_upper\
    \ - extensions_count_diff_diff_diff_diff_lower\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_upper is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_upper\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpll4rx2mx.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_lower is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_lower\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpll4rx2mx.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_diff_diff_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009614
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((x, y) => if (x == y) x else\
    \ y - x)\n        val extension = extensions_map.maxBy(x => x._1)\n        val\
    \ extension_name = extension._2\n        val class_name_with_extension = class_name\
    \ + extension_name\n        val extension_strength = extensions_map.get(extension_name)._1\n\
    \        if (extension_strength == strength) class_name_with_extension else class_name\
    \ + extension_name + \".\" + extension_strength\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk6d_osgl.scala:26:68 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextension_strength\e[0m\
    \ = extensions_map.get(extension_name)._1\n\e[31m\e[31m   |\e[0m             \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                 value _1 is not a member of Option[Int]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660009686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_length = class_name.length\n\
    \        val extensions_length_sum = extensions.map(_.length).sum\n        val\
    \ extensions_length_average = extensions_length_sum / extensions_count.toDouble\n\
    \        val extensions_length_difference = extensions_length_average - class_name_length\n\
    \        val strength = extensions_length_difference.toInt\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val extensions_length_difference\
    \ = extensions_length_average - class_name_length\n        val \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp6w5t7oo4.scala:54:11 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp6w5t7oo4.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_length_difference\e\
    [0m = extensions_length_average - class_name_length\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_length_difference is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_length_difference\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6w5t7oo4.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_length_difference\e\
    [0m = extensions_length_average - class_name_length\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_length_difference is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_length_difference\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6w5t7oo4.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mextensions_length_difference\e\
    [0m = extensions_length_average - class_name_length\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_length_difference is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_length_difference\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6w5t7oo4.scal"
  stdout: ''
  timestamp: 1660009686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val extensions_sorted = extensions_map.toSeq.sortBy(_._2).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropWhile\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6yrfeqty.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6yrfeqty.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.dropWhile(_ == \e[31m'.'\e[0m).dropRight(\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6yrfeqty.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.dropWhile(_ == \e[31m'.'\e[0m).dropRight(\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6yrfeqty.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.dropWhile(_ == \e[31m'.'\e[0m).dropRight(\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already d"
  stdout: ''
  timestamp: 1660009687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase - x.toLowerCase + 1)).toMap\n        val\
    \ class_name_map = class_name.map(x => (x.toUpperCase - x.toLowerCase + 1)).toMap\n\
    \        val max_value = extensions_map.values.max\n        val max_key = extensions_map.keys.max\n\
    \        val max_key_value = class_name_map.get(max_key)\n        val max_key_key_value\
    \ = class_name_map.get(max_key_value)\n        val max_key_key_key_value = class_name_map.get(max_key_key_value)\n\
    \        val max_key_key_key_key_value = class_name_map.get(max_key_key_key_value)\n\
    \        val max_key_key_key_key_key_value = class_name_map.get(max_key_key_key_key_value)\n\
    \        val max_key_key_key_key_key_key_value = class_name_map.get(max_key_key_key_key_key_key_value)\n\
    \        val max_key_key_key_key_key_key_key_value = class_name_map.get(max_key_key_key_key_key_key_key_value)\n\
    \        val max_key_key_key_key_key_key_key_value = class_name_map.get(max_key_key_key_key_key_key_key_key_value)\n\
    \        val max_key_key_key_key_key_key_key_key_value = class_name_map.get(max_key_key_key_key_key_key_key_key_key_value)\n\
    \        val max_key_key_key_key_key_key_key_key_key_value = class_name_map.get(max_key_key_key_key_key_key_key_key_key_key_value)\n\
    \        val max_key_key_key_key_key_key_key_key_key_key_value = class_name_map.get(max_key_key_key_key_key_key_key_key_key_key_key_value)\n\
    \        val max_key_key_key_key_key_key_key_key_key_key_key_value = class_name_map.get(max_key_key_key_key_key_key_key_key_key_key_key_key_value)\n\
    \        val max_key_key_key_key_key_key_key_key_key_key_key_key_value = class_name_map.get(max_key_key_key_key_key_key_key_key_key_key_key_key_key_key_value)\n\
    \        val max_key_key_key_key_key_key_key_key_key_key_key_key_key_key_value\
    \ = class_name_map.get(max_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_value)\n\
    \        val max_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_value\
    \ = class_name_map.get(max_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_value)\n\
    \        val max_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_value\
    \ = class_name_map.get(max_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_key_value)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpt9so459q.scala:41:11 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpt9so459q.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmax_key_key_key_key_key_key_key_value\e\
    [0m = class_name_map.get(max_key_key_key_key_key_key_key_key_value)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_key_key_key_key_key_key_key_value is already defined as\
    \ \e[33mvalue\e[0m \e[35mmax_key_key_key_key_key_key_key_value\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt9so459q.scala:21:64\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_map\e[0m = extensions.map(\e[36mx\e[0m => (x.toUpperCase - x.toLowerCase\
    \ + \e[31m1\e[0m)).toMap\n\e[31m\e[31m   |\e[0m                              \
    \                    ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member\
    \ of String, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpt9so459q.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase - x.toLowerCase + \e[31m1\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                  ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           "
  stdout: ''
  timestamp: 1660009687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_count = class_name.length\n\
    \        val strength = extensions_count - class_name_count\n        val extensions_sorted\
    \ = extensions.sortWith((a, b) => strength - a.length - b.length)\n        extensions_sorted.head\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw5hn8vlf.scala:24:62\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e\
    [0m = extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength - a.length\
    \ - b.length)\n\e[31m\e[31m   |\e[0m                                         \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                                    Found:    Int\n\e[31m   |\e\
    [0m                                                       Required: Boolean\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val extensions_count_upper_sm = extensions_count_upper - extensions_count_lower\
    \ * strength / extensions_count.toDouble\n        val extensions_count_lower_sm\
    \ = extensions_count_lower - extensions_count_upper * strength / extensions_count.toDouble\n\
    \        val extensions_count_sm = extensions_count_upper - extensions_count_lower\
    \ * strength / extensions_count.toDouble\n        val extensions_count_upper_cap\
    \ = extensions_count_upper - extensions_count_lower * strength / extensions_count.toDouble\
    \ * extensions_count_sm\n        val extensions_count_lower_cap = extensions_count_lower\
    \ - extensions_count_upper * strength / extensions_count.toDouble * extensions_count_sm\n\
    \        val extensions_count_cap = extensions_count_upper - extensions_count_lower\
    \ * strength / extensions_count.toDouble * extensions_count_sm * extensions_count_sm\n\
    \        val extensions_count_upper_smcap = extensions_count_upper - extensions_count_lower\
    \ * strength / extensions_count.toDouble * extensions_count_sm * extensions_count_cap\n\
    \        val extensions_count_lower_smcap = extensions_count_lower - extensions_count_upper\
    \ * strength / extensions_count.toDouble * extensions_count_sm * extensions_count_cap\n\
    \        val extensions_count_smcap = extensions_count_upper - extensions_count_lower\
    \ * strength / extensions_count.toDouble * extensions_count_sm * extensions_count_cap\
    \ * extensions_count_cap\n        val extensions_count_upper_capsmcap = extensions_count_upper\
    \ - extensions_count_lower * strength / extensions_count.toDouble * extensions_count_sm\
    \ * extensions_count_cap * extensions_count_cap\n        val extensions_count_lower_capsmcap\
    \ = extensions_count_lower - extensions_count_upper * strength / extensions_count.toDouble\
    \ * extensions_count_sm * extensions_count_cap * extensions_count_cap\n      \
    \  val extensions_count_capsmcap = extensions_count_upper - extensions_count_lower\
    \ * strength / extensions_count.toDouble * extensions_count_sm * extensions_count_cap\
    \ * extensions_count_cap * extensions_count_cap\n        val extensions_count_upper_smcapsmcap\
    \ = extensions_count_upper - extensions_count_lower * strength / extension\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2p6yg_6a.scala:37:109 -----------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_upper_smcapsmcap\e\
    [0m = extensions_count_upper - extensions_count_lower * strength / extension\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                     ^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                                    Not found: extension\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2p6yg_6a.scala:38:5\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.values.max\n\
    \        val extensions_sorted = extensions_map.toSeq.sortWith((a, b) => strength\
    \ - a)\n        val extensions_sorted = extensions_sorted.take(1).mkString(\"\
    .\")\n        class_name + extensions_sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0b5e4e29.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.take(\e[31m1\e[0m).mkString(\e[31m\".\"\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- Error: /tmp/tmp0b5e4e29.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n2 errors found\n"
  stdout: ''
  timestamp: 1660009688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = class_name_map.foldLeft(0)((acc, x) => acc + (extensions_map.getOrElse(x,\
    \ 0) - class_name_map.getOrElse(x, 0)))\n        val strongest_extension = extensions_map.getOrElse(strength,\
    \ \"\")\n        class_name + \".\" + strongest_extension\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgdyyro1r.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpgdyyro1r.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgdyyro1r.scala:23:94\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = class_name_map.foldLeft(\e[31m0\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) =>\
    \ acc + (extensions_map.getOrElse(x, \e[31m0\e[0m) - class_name_map.getOrElse(x,\
    \ \e[31m0\e[0m)))\n\e[31m\e[31m   |\e[0m                                     \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0m                                      Found:    (x : (Nothing, Nothing))\n\e\
    [31m   |\e[0m                                      Required: String\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgdyyro1r.scala:23:127 -------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = class_name_map.foldLeft(\e\
    [31m0\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) => acc + (extensions_map.getOrElse(x,\
    \ \e[31m0\e[0m) - class_name_map.getOrElse(x, \e[31m0\e[0m)))\n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \                                                          ^\e[0m\n\e[31m   |\e\
    [0m                                      Found:    (x : (Nothing, Nothing))\n\e\
    [31m   |\e[0m       "
  stdout: ''
  timestamp: 1660009689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs).max\n    \
    \    val extensions_sorted = extensions_map.values.sortWith(_ < _)\n        val\
    \ extensions_sorted_sorted = extensions_sorted.sortWith(_ < _)\n        val extensions_sorted_sorted_sorted\
    \ = extensions_sorted_sorted.sortWith(_ < _)\n        val extensions_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted.sortWith(_ < _)\n        val extensions_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted.sortWith(_ < _)\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted.sortWith(_ < _)\n        val\
    \ extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted = extensions_sorted_sorted_sorted_sorted_sorted_sorted.sortWith(_\
    \ < _)\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortWith(_ < _)\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortWith(_\
    \ < _)\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortWith(_\
    \ < _)\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortWith(_\
    \ < _)\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortWith(_\
    \ < _)\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortWith(_\
    \ < _)\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortWith(_\
    \ < _)\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortWith(_\
    \ < _)\n        val extensions_sorted_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcpk9veum.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcpk9veum.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpcpk9veum.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpcpk9veum.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcpk9veum.sca"
  stdout: ''
  timestamp: 1660009689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase)\n\
    \        val extensions_count = extensions.map(e => extensions_map(e).length).sum\n\
    \        val extensions_count_map = extensions.map(e => extensions_map(e).count(_\
    \ == extensions_map(e).head))\n        val extensions_count_map_sorted = extensions_count_map.sortBy(_._1).reverse\n\
    \        val extensions_count_map_sorted_first = extensions_count_map_sorted.head\n\
    \        val extensions_count_map_sorted_first_value = extensions_count_map_sorted_first._2\n\
    \        val extensions_count_map_sorted_first_key = extensions_count_map_sorted_first._1\n\
    \        val extensions_count_map_sorted_first_key_value = extensions_count_map_sorted_first_key._2\n\
    \        val extensions_count_map_sorted_first_key_value_length = extensions_count_map_sorted_first_key_value.length\n\
    \        val extensions_count_map_sorted_first_key_value_length_sorted = extensions_count_map_sorted_first_key_value_length.sortBy(_._1).reverse\n\
    \        val extensions_count_map_sorted_first_key_value_length_sorted_first =\
    \ extensions_count_map_sorted_first_key_value_length_sorted.head\n        val\
    \ extensions_count_map_sorted_first_key_value_length_sorted_first_value = extensions_count_map_sorted_first_key_value_length_sorted_first._2\n\
    \        val extensions_count_map_sorted_first_key_value_length_sorted_first_key\
    \ = extensions_count_map_sorted_first_key_value_length_sorted_first._1\n     \
    \   val extensions_count_map_sorted_first_key_value_length_sorted_first_key_value\
    \ = extensions_count_map_sorted_first_key_value_length_sorted_first_key._2\n \
    \       val extensions_count_map_sorted_first_key_value_length_sorted_first_key_value_length\
    \ = extensions_count_map_sorted_first_key_value_length_sorted_first_key_value.length\n\
    \        val extensions_count_map_sorted_first_key_value_length_sorted_first_key_value_length_sorted\
    \ = extensions_count_map_sorted_first_key_value_length_sorted_first_key_value_length.sortBy(_._1).reverse\n\
    \        val extensions_count_map_sorted_first_key_value_length_sorted_first_key_value_length_sorted_first\
    \ = extensions_count_map_sorted_first_key_value_length_sorted_first_key_value_length_sorted.head\n\
    \        val extensions_count_map_sorted_first_key_value_length_sorted_first_key_value_length_sorted_first_value\
    \ = extensions_count_map_sorted_first_key_value_length_sorted_first_key_value_length_sorted_first._2\n\
    \        val extensions_count_map_sorted_first_key_value_length_sorted_first_key_value_length_sorted_first_key\
    \ = extensions_count_map_sorted_first_key_value_length_sorted_first_key_value_length_sorted_first._1\n\
    \        val extensions_count_map_sorted_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9f__5obv.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9f__5obv.scala:21:100\
    \ -----------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_map\e[0m = extensions.map(\e[36me\e[0m => e.toUpperCase.charAt(\e\
    [31m0\e[0m) -> e.toUpperCase.charAt(\e[31m1\e[0m).toLowerCase)\n\e[31m\e[31m \
    \  |\e[0m                                                                    \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                    value toLowerCase is not a member of Char\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp9f__5obv.scala:22:66 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mextensions_count\e[0m =\
    \ extensions.map(\e[36me\e[0m => extensions_map(e).length).sum\n\e[31m\e[31m \
    \  |\e[0m                                                                  ^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   (e : String)\n\e[31m   |\e[0m                                            \
    \      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp9f__5obv.scala:22:80\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \ \e[33mval\e[0m \e[36mextensions_count\e[0m = extensions.map(\e[36me\e[0m =>\
    \ extensions_map(e).length).sum\n\e[31m\e[31m   |\e[0m                       \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0mambiguous given instances: both \e[33mobject\e[0m \e[35mShortIsIntegral\e[0m\
    \ in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mCharIsIntegral\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter\
    \ num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9f__5obv.scala:23:70 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_map\e[0m\
    \ = e"
  stdout: ''
  timestamp: 1660009690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.values.max\n\
    \        val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n \
    \       val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp_ihcylhf.scala:44:11 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp_ihcylhf.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_ihcylhf.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_ihcylhf.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_ihcylhf.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions"
  stdout: ''
  timestamp: 1660009690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length = extensions_count_sorted.map(_.length).sum\n\
    \        val extensions_count_sorted_length_sorted = extensions_count_sorted.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sorted_length = extensions_count_sorted_length.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sorted_length_sorted = extensions_count_sorted_length_sorted.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length.sortWith(_ < _)\n        val\
    \ extensions_count_sorted_length_sorted_length_sorted_length_sorted = extensions_count_sorted_length_sorted_length_sorted.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length.sortWith(_ < _)\n\
    \        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb0f5kad_.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\e\
    [0m = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpb0f5kad_.scala:25:90 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sorted_length\e\
    [0m = extensions_count_sorted_length.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m  \
    \                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   value sortWith is not a\
    \ member of Int\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb0f5kad_.scala:35:136\
    \ --------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\e\
    [0m = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                                                \
    \                                                                    "
  stdout: ''
  timestamp: 1660009690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length = extensions_count_sorted.map(_.length).sum\n\
    \        val extensions_count_sorted_length_sorted = extensions_count_sorted.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sorted_length = extensions_count_sorted_length.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sorted_length_sorted = extensions_count_sorted_length.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpewjyujj5.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpewjyujj5.scala:25:90\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_sorted_length_sorted_length\e[0m = extensions_count_sorted_length.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                                                \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                               value sortWith is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpewjyujj5.scala:26:97 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sorted_length_sorted\e\
    [0m = extensions_count_sorted_length.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m  \
    \                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   value sortWith is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpewjyujj5.scala:27:104\
    \ -----------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_sorted_length_sorted_length_sorted_length\e[0m = extensions_count_sorted_length.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                                                \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                   value sortWith is not a member of\
    \ Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpewjyujj5.scala:28:111 -----------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sorted_length_sorted_length_sorted\e\
    [0m = extensions_count_sorted_length.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m  \
    \                                                                            \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                      value sortWith is not a member of Int\n\e"
  stdout: ''
  timestamp: 1660009691
