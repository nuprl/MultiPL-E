name: HumanEval_100_make_a_pile
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, you have to make a pile of n levels of stones.\n\
  \    // The first level has n stones.\n    // The number of stones in the next level\
  \ is:\n    // - the next odd number if n is odd.\n    // - the next even number\
  \ if n is even.\n    // Return the number of stones in each level in a list, where\
  \ element at index\n    // i represents the number of stones in the level (i+1).\n\
  \    // Examples:\n    // >>> makeAPile((3l))\n    // (List[Long](3l.toLong, 5l.toLong,\
  \ 7l.toLong))\n    def makeAPile(n : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(makeAPile((3l)).equals((List[Long](3l.toLong,\
  \ 5l.toLong, 7l.toLong))));\n    assert(makeAPile((4l)).equals((List[Long](4l.toLong,\
  \ 6l.toLong, 8l.toLong, 10l.toLong))));\n    assert(makeAPile((5l)).equals((List[Long](5l.toLong,\
  \ 7l.toLong, 9l.toLong, 11l.toLong, 13l.toLong))));\n    assert(makeAPile((6l)).equals((List[Long](6l.toLong,\
  \ 8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong))));\n    assert(makeAPile((8l)).equals((List[Long](8l.toLong,\
  \ 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong, 18l.toLong, 20l.toLong, 22l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        val nums = mutable.ListBuffer[Long]()\n        val odd = if\
    \ (n % 2 == 0) n / 2 else n / 2 + 1\n        val even = if (n % 2 == 0) n / 2\
    \ else n / 2\n        val nextLevel = if (n % 2 == 0) odd else even\n        nums\
    \ += nextLevel\n        n -= 1\n        while (n > 0) {\n            val nextLevel\
    \ = if (n % 2 == 0) odd else even\n            nums += nextLevel\n           \
    \ n -= 1\n        }\n        nums.toList", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += if (n % 2 == 0) stones.last.last else\
    \ stones.last.last + 1\n        stones", "        val result = new mutable.ListBuffer[Long]()\n\
    \        var nextLevel = 0\n        while(n > 0) {\n            nextLevel = nextLevel\
    \ + math.min(math.ceil(n/2), math.floor(n/2))\n            n -= nextLevel\n  \
    \          result += nextLevel.toLong\n        }\n        result.toList", "  \
    \      val levels = mutable.ListBuffer[Long]()\n        val nextLevel = if (n\
    \ % 2 == 0) n.toLong + 1 else n.toLong\n        levels += nextLevel\n        n\
    \ -= 1\n        while (n > 0) {\n            val nextLevel = if (n % 2 == 0) n.toLong\
    \ + 1 else n.toLong\n            levels += nextLevel\n            n -= 1\n   \
    \     }\n        levels.toList", "        val stones = mutable.ListBuffer[Long]()\n\
    \        var stonesCount = 0\n        var nextLevel = n.toLong\n        while\
    \ (nextLevel > 0) {\n            stonesCount += nextLevel\n            nextLevel\
    \ = nextLevel.toLong match {\n                case x if x % 2 == 0 => nextLevel.toLong\
    \ + 1\n                case x if x % 2 == 1 => nextLevel.toLong\n            \
    \    case _ => nextLevel.toLong\n            }\n            stones += stonesCount\n\
    \        }\n        stones.toList", "        val nums = mutable.ListBuffer[Long]()\n\
    \        val odd = n.toInt\n        val even = n.toInt\n        val nextOdd =\
    \ if (odd % 2 == 0) odd + 1\n        else odd - 1\n        val nextEven = if (even\
    \ % 2 == 0) even + 1\n        else even - 1\n        val nextLevel = if (nextEven\
    \ > nextOdd) nextEven\n        else nextOdd\n        val nextLevelNum = nextLevel.toLong\n\
    \        nums += nextLevelNum\n        makeAPile(nums)", "        val pile = mutable.ListBuffer[Long]()\n\
    \        var nextLevel = n.toLong\n        while (nextLevel > 0) {\n         \
    \   pile.append(nextLevel)\n            nextLevel = nextLevel.toLong % 2 == 0\
    \ ? nextLevel.toLong + 2 : nextLevel.toLong\n        }\n        pile", "     \
    \   val stones = mutable.ListBuffer(n)\n        stones += stones.head\n      \
    \  stones += stones.tail.filter(_ % 2 == 1).head\n        stones += stones.tail.filter(_\
    \ % 2 == 0).head\n        stones.toList", "        val stones = mutable.ListBuffer.empty[Long]\n\
    \        var nextLevel = 0\n        var nextOdd = 0\n        var nextEven = 0\n\
    \        stones += nextLevel\n        nextLevel = nextLevel + n\n        if (nextLevel\
    \ % 2 == 0) {\n            nextEven = nextLevel / 2\n            nextLevel = nextLevel\
    \ / 2\n        } else {\n            nextOdd = nextLevel / 2\n            nextLevel\
    \ = nextLevel / 2\n        }\n        stones += nextLevel\n        nextLevel =\
    \ nextLevel + n\n        if (nextLevel % 2 == 0) {\n            nextEven = nextLevel\
    \ / 2\n            nextLevel = nextLevel / 2\n        } else {\n            nextOdd\
    \ = nextLevel / 2\n            nextLevel = nextLevel / 2\n        }\n        stones\
    \ += nextLevel\n        nextLevel = nextLevel + n\n        if (nextLevel % 2 ==\
    \ 0) {\n            nextEven = nextLevel / 2\n            nextLevel = nextLevel\
    \ / 2\n        } else {\n            nextOdd = nextLevel / 2\n            nextLevel\
    \ = nextLevel / 2\n        }\n        stones += nextLevel\n        nextLevel =\
    \ nextLevel + n\n        if (nextLevel % 2 == 0) {\n            nextEven = nextLevel\
    \ / 2\n            nextLevel = nextLevel / 2\n        } else {\n            nextOdd\
    \ = nextLevel / 2\n            nextLevel = nextLevel / 2\n        }\n        stones\
    \ += nextLevel\n        nextLevel = nextLevel + n\n        if (nextLevel % 2 ==\
    \ 0) {\n            nextEven = nextLevel / 2\n            nextLevel = nextLevel\
    \ / 2\n        } else {\n            nextOdd = nextLevel / 2\n            nextLevel\
    \ = nextLevel / 2\n        }\n        stones += nextLevel\n        nextLevel =\
    \ nextLevel + n\n        if (nextLevel % 2 == 0) {\n            nextEven = nextLevel\
    \ / 2\n            nextLevel = nextLevel / 2\n        } else {\n            nextOdd\
    \ = nextLevel / 2\n            nextLevel = nextLevel / 2\n        }\n        stones\
    \ += nextLevel\n        nextLevel = nextLevel + n\n        if (nextLevel % 2 ==\
    \ 0) {\n            nextEven = nextLevel / 2\n            nextLevel = nextLevel\
    \ / 2\n        } else {\n            nextOdd = nextLevel / 2\n            nextLevel\
    \ = nextLevel / 2\n        }\n        stones += nextLevel\n        nextLevel =\
    \ nextLevel + n\n        if (nextLevel % 2 == 0) {\n            nextEven = nextLevel\
    \ / 2\n            nextLevel = nextLevel / 2\n        } else {\n            nextOdd\
    \ = nextLevel / 2\n            nextLevel = nextLevel / 2\n        }\n        stones\
    \ += nextLevel\n        nextLevel = nextLevel + n\n        if (nextLevel % 2 == ",
  "        val nums = mutable.ListBuffer.empty[Long]\n        val odd = if (n % 2\
    \ == 0) n / 2 else n / 2 + 1\n        val even = if (n % 2 == 0) n / 2 else n\n\
    \        val nums = for (i <- 0 until n) yield {\n            if (i % 2 == 0)\
    \ odd else even\n        }\n        nums.toList", "        val levels = mutable.ListBuffer[Long]()\n\
    \        var currentLevel = n.toLong\n        var nextLevel = n.toLong\n     \
    \   while(currentLevel > 0) {\n            levels += currentLevel\n          \
    \  nextLevel = nextLevel % 2 == 0 ? nextLevel + 1 : nextLevel\n            currentLevel\
    \ = nextLevel\n        }\n        levels.toList", "        val nums = mutable.ArrayBuffer.empty[Long]\n\
    \        val odd = if (n % 2 == 0) n else n + 1 \n        val even = if (n % 2\
    \ == 1) n else n + 1 \n        val nums = for (i <- 1 to n) yield {\n        \
    \    if (i % 2 == 0) odd else even\n        }\n        nums.toList", "       \
    \ val levels = mutable.ListBuffer[Long]()\n        var i = 0\n        while (i\
    \ < n) {\n            levels += n\n            i += 2\n        }\n        levels.toList",
  "        val stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones\
    \ += n % 2 == 0 ? stones.head + 1 : stones.head + 1\n        stones.toList", " \
    \       val stones = mutable.ListBuffer[Long]()\n        stones += n\n       \
    \ stones += (if (n % 2 == 0) n else n + 2)\n        stones", "        val levels\
    \ = mutable.ListBuffer[Long]()\n        var i = 0\n        while (i < n) {\n \
    \           if (n % 2 == 0) {\n                levels += n.toLong\n          \
    \      i += 2\n            } else {\n                levels += n.toLong\n    \
    \            i += 1\n            }\n        }\n        levels.toList", "     \
    \   val stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones\
    \ += if (n % 2 == 0) stones.head + 1 else stones.head + 1\n        stones.toList",
  "        val stones = mutable.ListBuffer.empty[Long]\n        stones += n\n    \
    \    stones += if (n % 2 == 0) n else n + 2\n        stones", "        val nums\
    \ = mutable.ListBuffer[Long]()\n        val odd = n.toInt\n        val even =\
    \ n.toInt / 2\n        val nextOdd = if (odd % 2 == 0) odd + 1 else odd\n    \
    \    val nextEven = if (even % 2 == 0) even + 1 else even\n        val nextNum\
    \ = if (nextEven > nextOdd) nextEven else nextOdd\n        nums += nextNum\n \
    \       makeAPile(nums)", "        val stones = mutable.ListBuffer[Long]()\n \
    \       stones += n\n        stones += n / 2\n        stones += n / 3\n      \
    \  stones"]
stop_tokens:
- "\n    }\n"
