name: HumanEval_100_make_a_pile
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, you have to make a pile of n levels of stones.\n\
  \    // The first level has n stones.\n    // The number of stones in the next level\
  \ is:\n    // - the next odd number if n is odd.\n    // - the next even number\
  \ if n is even.\n    // Return the number of stones in each level in a list, where\
  \ element at index\n    // i represents the number of stones in the level (i+1).\n\
  \    // Examples:\n    // >>> makeAPile((3l))\n    // (List[Long](3l.toLong, 5l.toLong,\
  \ 7l.toLong))\n    def makeAPile(n : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(makeAPile((3l)).equals((List[Long](3l.toLong,\
  \ 5l.toLong, 7l.toLong))));\n    assert(makeAPile((4l)).equals((List[Long](4l.toLong,\
  \ 6l.toLong, 8l.toLong, 10l.toLong))));\n    assert(makeAPile((5l)).equals((List[Long](5l.toLong,\
  \ 7l.toLong, 9l.toLong, 11l.toLong, 13l.toLong))));\n    assert(makeAPile((6l)).equals((List[Long](6l.toLong,\
  \ 8l.toLong, 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong))));\n    assert(makeAPile((8l)).equals((List[Long](8l.toLong,\
  \ 10l.toLong, 12l.toLong, 14l.toLong, 16l.toLong, 18l.toLong, 20l.toLong, 22l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        val nums = mutable.ListBuffer[Long]()\n        val odd = if\
    \ (n % 2 == 0) n / 2 else n / 2 + 1\n        val even = if (n % 2 == 0) n / 2\
    \ else n / 2\n        val nextLevel = if (n % 2 == 0) odd else even\n        nums\
    \ += nextLevel\n        n -= 1\n        while (n > 0) {\n            val nextLevel\
    \ = if (n % 2 == 0) odd else even\n            nums += nextLevel\n           \
    \ n -= 1\n        }\n        nums.toList", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += if (n % 2 == 0) stones.last.last else\
    \ stones.last.last + 1\n        stones", "        val result = new mutable.ListBuffer[Long]()\n\
    \        var nextLevel = 0\n        while(n > 0) {\n            nextLevel = nextLevel\
    \ + math.min(math.ceil(n/2), math.floor(n/2))\n            n -= nextLevel\n  \
    \          result += nextLevel.toLong\n        }\n        result.toList", "  \
    \      val levels = mutable.ListBuffer[Long]()\n        val nextLevel = if (n\
    \ % 2 == 0) n.toLong + 1 else n.toLong\n        levels += nextLevel\n        n\
    \ -= 1\n        while (n > 0) {\n            val nextLevel = if (n % 2 == 0) n.toLong\
    \ + 1 else n.toLong\n            levels += nextLevel\n            n -= 1\n   \
    \     }\n        levels.toList", "        val stones = mutable.ListBuffer[Long]()\n\
    \        var stonesCount = 0\n        var nextLevel = n.toLong\n        while\
    \ (nextLevel > 0) {\n            stonesCount += nextLevel\n            nextLevel\
    \ = nextLevel.toLong match {\n                case x if x % 2 == 0 => nextLevel.toLong\
    \ + 1\n                case x if x % 2 == 1 => nextLevel.toLong\n            \
    \    case _ => nextLevel.toLong\n            }\n            stones += stonesCount\n\
    \        }\n        stones.toList", "        val nums = mutable.ListBuffer[Long]()\n\
    \        val odd = n.toInt\n        val even = n.toInt\n        val nextOdd =\
    \ if (odd % 2 == 0) odd + 1\n        else odd - 1\n        val nextEven = if (even\
    \ % 2 == 0) even + 1\n        else even - 1\n        val nextLevel = if (nextEven\
    \ > nextOdd) nextEven\n        else nextOdd\n        val nextLevelNum = nextLevel.toLong\n\
    \        nums += nextLevelNum\n        makeAPile(nums)", "        val pile = mutable.ListBuffer[Long]()\n\
    \        var nextLevel = n.toLong\n        while (nextLevel > 0) {\n         \
    \   pile.append(nextLevel)\n            nextLevel = nextLevel.toLong % 2 == 0\
    \ ? nextLevel.toLong + 2 : nextLevel.toLong\n        }\n        pile", "     \
    \   val stones = mutable.ListBuffer(n)\n        stones += stones.head\n      \
    \  stones += stones.tail.filter(_ % 2 == 1).head\n        stones += stones.tail.filter(_\
    \ % 2 == 0).head\n        stones.toList", "        val stones = mutable.ListBuffer.empty[Long]\n\
    \        var nextLevel = 0\n        var nextOdd = 0\n        var nextEven = 0\n\
    \        stones += nextLevel\n        nextLevel = nextLevel + n\n        if (nextLevel\
    \ % 2 == 0) {\n            nextEven = nextLevel / 2\n            nextLevel = nextLevel\
    \ / 2\n        } else {\n            nextOdd = nextLevel / 2\n            nextLevel\
    \ = nextLevel / 2\n        }\n        stones += nextLevel\n        nextLevel =\
    \ nextLevel + n\n        if (nextLevel % 2 == 0) {\n            nextEven = nextLevel\
    \ / 2\n            nextLevel = nextLevel / 2\n        } else {\n            nextOdd\
    \ = nextLevel / 2\n            nextLevel = nextLevel / 2\n        }\n        stones\
    \ += nextLevel\n        nextLevel = nextLevel + n\n        if (nextLevel % 2 ==\
    \ 0) {\n            nextEven = nextLevel / 2\n            nextLevel = nextLevel\
    \ / 2\n        } else {\n            nextOdd = nextLevel / 2\n            nextLevel\
    \ = nextLevel / 2\n        }\n        stones += nextLevel\n        nextLevel =\
    \ nextLevel + n\n        if (nextLevel % 2 == 0) {\n            nextEven = nextLevel\
    \ / 2\n            nextLevel = nextLevel / 2\n        } else {\n            nextOdd\
    \ = nextLevel / 2\n            nextLevel = nextLevel / 2\n        }\n        stones\
    \ += nextLevel\n        nextLevel = nextLevel + n\n        if (nextLevel % 2 ==\
    \ 0) {\n            nextEven = nextLevel / 2\n            nextLevel = nextLevel\
    \ / 2\n        } else {\n            nextOdd = nextLevel / 2\n            nextLevel\
    \ = nextLevel / 2\n        }\n        stones += nextLevel\n        nextLevel =\
    \ nextLevel + n\n        if (nextLevel % 2 == 0) {\n            nextEven = nextLevel\
    \ / 2\n            nextLevel = nextLevel / 2\n        } else {\n            nextOdd\
    \ = nextLevel / 2\n            nextLevel = nextLevel / 2\n        }\n        stones\
    \ += nextLevel\n        nextLevel = nextLevel + n\n        if (nextLevel % 2 ==\
    \ 0) {\n            nextEven = nextLevel / 2\n            nextLevel = nextLevel\
    \ / 2\n        } else {\n            nextOdd = nextLevel / 2\n            nextLevel\
    \ = nextLevel / 2\n        }\n        stones += nextLevel\n        nextLevel =\
    \ nextLevel + n\n        if (nextLevel % 2 == 0) {\n            nextEven = nextLevel\
    \ / 2\n            nextLevel = nextLevel / 2\n        } else {\n            nextOdd\
    \ = nextLevel / 2\n            nextLevel = nextLevel / 2\n        }\n        stones\
    \ += nextLevel\n        nextLevel = nextLevel + n\n        if (nextLevel % 2 == ",
  "        val nums = mutable.ListBuffer.empty[Long]\n        val odd = if (n % 2\
    \ == 0) n / 2 else n / 2 + 1\n        val even = if (n % 2 == 0) n / 2 else n\n\
    \        val nums = for (i <- 0 until n) yield {\n            if (i % 2 == 0)\
    \ odd else even\n        }\n        nums.toList", "        val levels = mutable.ListBuffer[Long]()\n\
    \        var currentLevel = n.toLong\n        var nextLevel = n.toLong\n     \
    \   while(currentLevel > 0) {\n            levels += currentLevel\n          \
    \  nextLevel = nextLevel % 2 == 0 ? nextLevel + 1 : nextLevel\n            currentLevel\
    \ = nextLevel\n        }\n        levels.toList", "        val nums = mutable.ArrayBuffer.empty[Long]\n\
    \        val odd = if (n % 2 == 0) n else n + 1 \n        val even = if (n % 2\
    \ == 1) n else n + 1 \n        val nums = for (i <- 1 to n) yield {\n        \
    \    if (i % 2 == 0) odd else even\n        }\n        nums.toList", "       \
    \ val levels = mutable.ListBuffer[Long]()\n        var i = 0\n        while (i\
    \ < n) {\n            levels += n\n            i += 2\n        }\n        levels.toList",
  "        val stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones\
    \ += n % 2 == 0 ? stones.head + 1 : stones.head + 1\n        stones.toList", " \
    \       val stones = mutable.ListBuffer[Long]()\n        stones += n\n       \
    \ stones += (if (n % 2 == 0) n else n + 2)\n        stones", "        val levels\
    \ = mutable.ListBuffer[Long]()\n        var i = 0\n        while (i < n) {\n \
    \           if (n % 2 == 0) {\n                levels += n.toLong\n          \
    \      i += 2\n            } else {\n                levels += n.toLong\n    \
    \            i += 1\n            }\n        }\n        levels.toList", "     \
    \   val stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones\
    \ += if (n % 2 == 0) stones.head + 1 else stones.head + 1\n        stones.toList",
  "        val stones = mutable.ListBuffer.empty[Long]\n        stones += n\n    \
    \    stones += if (n % 2 == 0) n else n + 2\n        stones", "        val nums\
    \ = mutable.ListBuffer[Long]()\n        val odd = n.toInt\n        val even =\
    \ n.toInt / 2\n        val nextOdd = if (odd % 2 == 0) odd + 1 else odd\n    \
    \    val nextEven = if (even % 2 == 0) even + 1 else even\n        val nextNum\
    \ = if (nextEven > nextOdd) nextEven else nextOdd\n        nums += nextNum\n \
    \       makeAPile(nums)", "        val stones = mutable.ListBuffer[Long]()\n \
    \       stones += n\n        stones += n / 2\n        stones += n / 3\n      \
    \  stones", "        val result = new mutable.ListBuffer[Long]()\n        val\
    \ even = if (n % 2 == 0) n / 2 else 3 * n + 1\n        val odd = if (n % 2 ==\
    \ 0) n / 2 else 3 * n\n        result ++= List(even.toLong, odd.toLong)\n    \
    \    result.toList", "        val pile = mutable.ListBuffer[Long]()\n        pile.append(n)\n\
    \        val odd = if (n%2 == 0) n else n+1\n        val even = if (n%2 == 1)\
    \ n else n+1\n        pile.append(odd)\n        pile.append(even)\n        pile",
  "        val stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones\
    \ += if (n % 2 == 0) n / 2 else n * 3\n        stones", "        val levels =\
    \ mutable.ListBuffer[Long]()\n        val odd = n.toInt\n        val even = n.toInt\
    \ / 2\n        val nextLevel = odd + (even % 2)\n        levels += nextLevel\n\
    \        while(nextLevel < n) {\n            val nextOdd = nextLevel.toInt\n \
    \           val nextEven = nextLevel.toInt / 2\n            val nextLevel = nextOdd\
    \ + (nextEven % 2)\n            levels += nextLevel\n        }\n        levels.toList",
  "        val stones = mutable.ListBuffer(n.toLong)\n        stones.update(1, stones.last.filter(_\
    \ % 2 == 1).sum)\n        stones.update(1, stones.last.filter(_ % 2 == 0).sum)\n\
    \        stones.toList", "        val levels = mutable.ListBuffer[Long]()\n  \
    \      var nextLevel = 0\n        while(n > 0) {\n            levels += nextLevel\n\
    \            nextLevel = nextLevel + math.min(math.ceil(n/2), math.floor(n/2))\n\
    \            n -= nextLevel\n        }\n        levels.toList", "        val stones\
    \ = mutable.ListBuffer[Long]()\n        stones += n\n        stones += n / 2\n\
    \        stones += n / 3\n        stones", "        val nums = mutable.ListBuffer[Long]()\n\
    \        var num = 0\n        while(num < n) {\n            num += 1\n       \
    \     if(num % 2 == 0) {\n                nums += num\n            }\n       \
    \     else {\n                nums += num + 1\n            }\n        }\n    \
    \    nums.toList", "        val levels = mutable.ListBuffer[Long]()\n        val\
    \ odd = n.toInt\n        val even = n.toInt\n        val nextOdd = odd + 1\n \
    \       val nextEven = even + 1\n        levels += n\n        levels += nextOdd\n\
    \        levels += nextEven\n        levels.toList", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += n / 2\n        stones += n / 3\n     \
    \   stones", "        val stones = mutable.ListBuffer[Long]()\n        stones\
    \ += n\n        stones += if (n % 2 == 0) n else n + 2\n        stones", "   \
    \     val nums = mutable.ListBuffer[Long]()\n        val even = if (n % 2 == 0)\
    \ n else n + 2\n        val odd = if (n % 2 == 1) n else n - 2\n        for (i\
    \ = 1 to even) {\n            nums += i\n        }\n        for (i = 1 to odd)\
    \ {\n            nums += i\n        }\n        nums.toList", "        val levels\
    \ = mutable.ListBuffer[Long]()\n        val odd = if (n % 2 == 0) n / 2 else n\
    \ / 2 + 1\n        val even = if (n % 2 == 0) n / 2 else n / 2\n        levels\
    \ += n\n        levels += odd\n        levels += even\n        levels.toList",
  "        val nums = mutable.ListBuffer[Long]()\n        val odd = n.toInt\n    \
    \    val even = n.toInt\n        val nextOdd = if (odd % 2 == 0) odd + 1\n   \
    \     else odd\n        val nextEven = if (even % 2 == 0) even + 1\n        else\
    \ even\n        val nextLevel = if (nextOdd > nextEven) nextOdd else nextEven\n\
    \        val numOfLevels = nextLevel.toLong\n        val numOfLevelsPlusOne =\
    \ numOfLevels + 1\n        for (i<- 1 to numOfLevelsPlusOne) {\n            nums\
    \ += i.toLong\n        }\n        nums.toList", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += if (n % 2 == 0) (n / 2l) else (3 * n +\
    \ 1l)\n        stones", "        val stones = mutable.ListBuffer[Long]()\n   \
    \     stones += n\n        stones += if (n % 2 == 0) stones.last.nextDouble else\
    \ stones.last.nextEven\n        stones", "        val nums = mutable.ListBuffer.empty[Long]\n\
    \        val odd = if (n % 2 == 0) n / 2 else n / 2 + 1\n        val even = if\
    \ (n % 2 == 0) n / 2 else n / 2\n        for (i <- 0 until n) {\n            if\
    \ (i % 2 == 0) {\n                nums += even\n            } else {\n       \
    \         nums += odd\n            }\n        }\n        nums.toList", "     \
    \   val stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones\
    \ += if (n % 2 == 0) n / 2 else 3 * n\n        stones", "        val pile = mutable.ListBuffer[Long]()\n\
    \        pile.append(n)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.to", "        val levels\
    \ = mutable.ListBuffer[Long]()\n        var currentLevel = n.toLong\n        while(currentLevel\
    \ > 0) {\n            levels += currentLevel\n            currentLevel = if (currentLevel\
    \ % 2 == 0) (currentLevel + 2).toLong else (currentLevel + 3).toLong\n       \
    \ }\n        levels.toList", "        val nums = mutable.ListBuffer(n.toLong)\n\
    \        val odd = nums.lastOption\n        val even = nums.dropRight(1).lastOption\n\
    \        odd.map(_ + even.map(_ + 1)).getOrElse(List(nums.last))", "        val\
    \ nums = mutable.ListBuffer[Long]()\n        val odd = if (n % 2 == 0) n / 2 else\
    \ n / 2 + 1\n        val even = if (n % 2 == 0) n / 2 else n / 2\n        for\
    \ (i <- 0 until n) {\n            if (i % 2 == 0) {\n                nums += even\n\
    \            } else {\n                nums += odd\n            }\n        }\n\
    \        nums.toList", "        val levels = mutable.ListBuffer[Long]()\n    \
    \    val even = if (n % 2 == 0) n else n + 1 // next even number\n        val\
    \ odd = if (n % 2 == 1) n else n + 1 // next odd number\n        levels += n //\
    \ first level\n        levels += odd // next level\n        levels += even //\
    \ next level\n        levels.toList", "        val result = new mutable.ListBuffer[Long]()\n\
    \        val odd = if (n % 2 == 0) n / 2 else n / 2 + 1\n        val even = n\
    \ / 2\n        result += n\n        result += (odd * 2l.toLong)\n        result\
    \ += (even * 2l.toLong)\n        result.toList", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += if (n % 2 == 0) n / 2 else 3 * n\n   \
    \     stones.toList", "        val stones = mutable.ListBuffer(n)\n        val\
    \ odd = if (n % 2 == 0) n / 2 else n / 2 + 1\n        val even = n / 2\n     \
    \   stones ++= makeAPile(odd)\n        stones ++= makeAPile(even)\n        stones.toList",
  "        val stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones\
    \ += if (n % 2 == 0) n / 2 else n / 2 + 1\n        stones", "        val nums\
    \ = mutable.ListBuffer[Long]()\n        var i = 0\n        while(i < n) {\n  \
    \          val nextNum = if (n % 2 == 0) (n + 1) else (n + 1)\n            nums\
    \ += nextNum\n            i += 2\n        }\n        nums.toList", "        val\
    \ levels = mutable.ListBuffer[Long]()\n        var level = 0\n        var stones\
    \ = 0\n        while (stones < n) {\n            stones = stones + if (n % 2 ==\
    \ 0) 2 else 1\n            level += stones\n            levels += level.toLong\n\
    \            n -= 1\n        }\n        levels.toList", "        val pile = mutable.ListBuffer[Long]()\n\
    \        pile.append(n)\n        pile.append(n / 2)\n        pile.append(n / 3)\n\
    \        pile.append(n / 4)\n        pile.append(n / 5)\n        pile.append(n\
    \ / 6)\n        pile.append(n / 7)\n        pile.append(n / 8)\n        pile.append(n\
    \ / 9)\n        pile.append(n / 10)\n        pile.append(n / 11)\n        pile.append(n\
    \ / 12)\n        pile.append(n / 13)\n        pile.append(n / 14)\n        pile.append(n\
    \ / 15)\n        pile.append(n / 16)\n        pile.append(n / 17)\n        pile.append(n\
    \ / 18)\n        pile.append(n / 19)\n        pile.append(n / 20)\n        pile.append(n\
    \ / 21)\n        pile.append(n / 22)\n        pile.append(n / 23)\n        pile.append(n\
    \ / 24)\n        pile.append(n / 25)\n        pile.append(n / 26)\n        pile.append(n\
    \ / 27)\n        pile.append(n / 28)\n        pile.append(n / 29)\n        pile.append(n\
    \ / 30)\n        pile.append(n / 31)\n        pile.append(n / 32)\n        pile.append(n\
    \ / 33)\n        pile.append(n / 34)\n        pile.append(n / 35)\n        pile.append(n\
    \ / 36)\n        pile.append(n / 37)\n        pile.append(n / 38)\n        pile.append(n\
    \ / 39)\n        pile.append(n / 40)\n        pile.append(n / 41)\n        pile.append(n\
    \ / 42)\n        pile.append(n / 43)\n        pile.append(n / 44)\n        pile.append(n\
    \ / 45)\n        pile.append(n / 46)\n        pile.append(n / 47)\n        pile.append(n\
    \ / 48)\n        pile.append(n / 49)\n        pile.append(n / 50)\n        pile.append(n\
    \ / 51)\n        pile.append(n / 52)\n        pile.append(n / 53)\n        pile.append(n\
    \ / 54)\n        pile.append(n / 55)\n        pile.append(n / 56)\n        pile.append(n\
    \ / 57)\n        pile.append(n / 58)\n        pile.append(n / ", "        val\
    \ nums = mutable.ListBuffer[Long]()\n        val even = if (n % 2 == 0) n else\
    \ n + 2\n        val odd = if (n % 2 == 1) n else n - 1\n        val numsEven\
    \ = makeAPile(even)\n        val numsOdd = makeAPile(odd)\n        numsOdd foreach\
    \ { nums += _ }\n        numsEven foreach { nums += _ }\n        nums", "    \
    \    val pile = mutable.ListBuffer.empty[Long]\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.", "        val levels = mutable.ListBuffer[Long]()\n        val\
    \ odd = if (n % 2 == 0) n / 2 else n / 2 + 1\n        val even = n / 2\n     \
    \   levels += odd.toLong\n        levels += even.toLong\n        levels.toList",
  "        val result = new mutable.ListBuffer[Long]()\n        var i = 0\n      \
    \  while (i < n) {\n            val nextOdd = if (n % 2 == 0) (n + 1) else n\n\
    \            val nextEven = if (n % 2 == 0) (n + 2) else n\n            result\
    \ += nextOdd.toLong :: nextEven.toLong :: Nil\n            i += 2\n        }\n\
    \        result.toList", "        val stones = mutable.ListBuffer[Long]()\n  \
    \      stones += n\n        stones += if (n % 2 == 0) (n / 2l) else (3 * n + 1l)\n\
    \        stones.toList", "        val stones = mutable.ListBuffer[Long]()\n  \
    \      stones += n\n        stones += (if (n % 2 == 0) n / 2 else 3 * n + 1)\n\
    \        stones", "        val stones = mutable.ListBuffer(n.toLong)\n       \
    \ stones ++= makeAPile(n/2, stones)\n        stones ++= makeAPile(n/2, stones)\n\
    \        stones.toList", "        val stones = mutable.ListBuffer[Long]()\n  \
    \      stones += n\n        stones += if (n % 2 == 0) stones.last + 1 else stones.last\
    \ + 1\n        stones", "        val stones = mutable.ListBuffer[Long]()\n   \
    \     stones += n\n        stones += if (n % 2 == 0) n / 2 else n / 2 + 1\n  \
    \      stones", "        val levels = mutable.ListBuffer[Long]()\n        var\
    \ level = 0\n        var stones = n\n        while (stones > 0) {\n          \
    \  levels += stones\n            stones = stones % 2 == 0 ? stones / 2 : stones\
    \ / 2 + 1\n            level += 1\n        }\n        levels.toList", "      \
    \  val stones = mutable.ListBuffer[Long]()\n        var nextLevel = 0\n      \
    \  var nextLevelStones = 0\n        var nextLevelEvenStones = 0\n        var nextLevelOddStones\
    \ = 0\n        stones += n.toLong\n        while (stones.size < n) {\n       \
    \     nextLevel = nextLevel + 1\n            nextLevelStones = nextLevelStones\
    \ + stones.last\n            nextLevelEvenStones = nextLevelEvenStones + stones.last/2\n\
    \            nextLevelOddStones = nextLevelOddStones + stones.last/2\n       \
    \     if (nextLevel % 2 == 0) {\n                stones += nextLevelEvenStones\n\
    \            } else {\n                stones += nextLevelOddStones\n        \
    \    }\n        }\n        stones.toList", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += (if (n % 2 == 0) (n / 2l.toLong) else\
    \ (3 * n + 1l.toLong))\n        stones", "        val levels = mutable.ListBuffer[Long]()\n\
    \        val odd = if (n % 2 == 0) n / 2 else n / 2 + 1\n        val even = if\
    \ (n % 2 == 0) n / 2 else n / 2\n        levels += n\n        while (levels.size\
    \ < n) levels += odd\n        while (levels.size < n) levels += even\n       \
    \ levels.toList", "        val stones = mutable.ListBuffer[Long]()\n        stones\
    \ += n\n        stones += if (n % 2 == 0) stones.head + 1 else stones.head + 1\n\
    \        stones.toList", "        val result = new mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        while (i < n) {\n            if (n % 2 == 0) {\n \
    \               result += n.toLong\n                i += 2\n            } else\
    \ {\n                result += n.toLong\n                i += 1\n            }\n\
    \        }\n        result.toList", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += if (n % 2 == 0) stones.head + 1 else stones.head\
    \ + 1\n        stones", "        val stones = mutable.ListBuffer.empty[Long]\n\
    \        stones += n\n        stones += if (n % 2 == 0) stones.last.last else\
    \ stones.last.head + stones.last.last\n        stones", "        val stones =\
    \ mutable.ListBuffer[Long]()\n        stones += n\n        stones += if (n % 2\
    \ == 0) stones.last + 1 else stones.last + 1\n        stones", "        val stones\
    \ = mutable.ListBuffer[Long]()\n        stones += n\n        stones += if (n %\
    \ 2 == 0) n / 2 else 3 * n\n        stones", "        val levels = mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        while (i < n) {\n            if (n % 2 == 0) {\n \
    \               levels += n.toLong\n                i += 2\n            } else\
    \ {\n                levels += n.toLong\n                i += 1\n            }\n\
    \        }\n        levels.toList", "        val stones = mutable.ListBuffer(n.toLong)\n\
    \        val even = if (n % 2 == 0) stones.head else stones.last\n        val\
    \ odd = if (n % 2 == 1) stones.last else stones.last\n        stones.drop(1).dropRight(1).map(n\
    \ => if (n % 2 == 0) even else odd)", "        val pile = mutable.ListBuffer[Long]()\n\
    \        pile.append(n)\n        pile.append(n / 2)\n        pile.append(n / 4)\n\
    \        pile.append(n / 8)\n        pile.append(n / 16)\n        pile.append(n\
    \ / 32)\n        pile.append(n / 64)\n        pile.append(n / 128)\n        pile.append(n\
    \ / 256)\n        pile.append(n / 512)\n        pile.append(n / 1024)\n      \
    \  pile.append(n / 2048)\n        pile.append(n / 4096)\n        pile.append(n\
    \ / 8192)\n        pile.append(n / 16384)\n        pile.append(n / 32768)\n  \
    \      pile.append(n / 65536)\n        pile.append(n / 131072)\n        pile.append(n\
    \ / 262144)\n        pile.append(n / 524288)\n        pile.append(n / 1048576)\n\
    \        pile.append(n / 2097152)\n        pile.append(n / 4194304)\n        pile.append(n\
    \ / 8388608)\n        pile.append(n / 16777216)\n        pile.append(n / 33554432)\n\
    \        pile.append(n / 67108864)\n        pile.append(n / 134217728)\n     \
    \   pile.append(n / 268435456)\n        pile.append(n / 536870912)\n        pile.append(n\
    \ / 1073741824)\n        pile.append(n / 2147483648)\n        pile.append(n /\
    \ 4294967296)\n        pile.append(n / 8589934592)\n        pile.append(n / 17179869184)\n\
    \        pile.append(n / 34359738368)\n        pile.append(n / 68719476736)\n\
    \        pile.append(n / 137438953472)\n        pile.append(n / 274877906944)\n\
    \        pile.append(n / 549755813888)\n        pile.append(n / 1099511627776)\n\
    \        pile.append(n / 2199023255552)\n        pile.append(n / 4398046511104)\n\
    \        pile.append(n / 8796093022208)\n        pile.append(n / 17592186044416)\n\
    \        pile.append(n / 35184372088832)\n        pile.append(n ", "        val\
    \ levels = mutable.ListBuffer[Long]()\n        val odd = if (n % 2 == 0) n / 2\
    \ else (n / 2) + 1\n        val even = if (n % 2 == 0) n / 2 else (n / 2)\n  \
    \      levels.append (odd)\n        levels.append (even)\n        levels.toList",
  "        val stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones\
    \ += if (n % 2 == 0) n / 2 else n / 2 + 1\n        stones", "        val result\
    \ = new mutable.ListBuffer[Long]()\n        val nextLevel = if (n % 2 == 0) n\
    \ / 2 else n / 2 + 1\n        result.add(nextLevel)\n        makeAPile(nextLevel)\n\
    \        result.toList", "        val levels = mutable.ListBuffer[Long]()\n  \
    \      var nextLevel = n.toLong\n        while (nextLevel > 0) {\n           \
    \ levels += nextLevel\n            nextLevel = nextLevel match {\n           \
    \     case x if x % 2 == 0 => x.toLong + 1\n                case x if x % 2 ==\
    \ 1 => x.toLong\n            }\n        }\n        levels.toList", "        val\
    \ stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones +=\
    \ if (n % 2 == 0) n / 2 else n / 2 + 1\n        stones", "        val stones =\
    \ mutable.ListBuffer[Long]()\n        stones += n\n        stones += if (n % 2\
    \ == 0) n / 2 else n / 2 + 1\n        stones", "        val levels = mutable.ListBuffer.empty[Long]\n\
    \        val nextLevel = if (n % 2 == 0) n / 2 else 3 * n + 1\n        levels\
    \ += nextLevel\n        while (nextLevel <= n) {\n            val nextLevel =\
    \ if (nextLevel % 2 == 0) nextLevel / 2 else 3 * nextLevel + 1\n            levels\
    \ += nextLevel\n        }\n        levels.toList", "        val pile = mutable.ListBuffer[Long]()\n\
    \        pile.append(n)\n        pile.append(if (n % 2 == 0) n.toLong else n.toLong\
    \ + n.toLong)\n        pile", "        val list = mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        while(i < n) {\n            list.add(n.toLong)\n \
    \           i = i + 2\n        }\n        list.toList", "        val stones =\
    \ mutable.ListBuffer[Long]()\n        var stoneCount = 0\n        var nextLevel\
    \ = 0\n        while(stoneCount < n) {\n            stoneCount += nextLevel\n\
    \            nextLevel = nextLevel % 2 == 0 ? 2 : 3\n            stones += stoneCount\n\
    \        }\n        stones.toList", "        val stones = mutable.ListBuffer[Long]()\n\
    \        var nextLevel = n.toInt\n        while(nextLevel > 0) {\n           \
    \ stones += nextLevel\n            nextLevel = nextLevel.toInt % 2 == 0 ? nextLevel.toInt\
    \ + 1 : nextLevel.toInt\n        }\n        stones.toList", "        val levels\
    \ = mutable.ListBuffer[Long]()\n        var nextLevel = n.toLong\n        while\
    \ (nextLevel > 0) {\n            if (nextLevel % 2 == 0) {\n                levels\
    \ += nextLevel.toLong\n            } else {\n                levels += nextLevel.toLong\
    \ + 1\n            }\n            nextLevel = nextLevel / 2\n        }\n     \
    \   levels.toList", "        val stones = mutable.ListBuffer[Long]()\n       \
    \ stones += n\n        stones += if (n % 2 == 0) n / 2 else (n / 2).toLong\n \
    \       stones", "        val levels = mutable.ListBuffer.empty[Long]\n      \
    \  var level = 0\n        var nextLevel = 0\n        while (level < n) {\n   \
    \         if (n % 2 == 0) {\n                nextLevel = nextLevel + 2\n     \
    \       } else {\n                nextLevel = nextLevel + 1\n            }\n \
    \           levels += nextLevel\n            level = level + 1\n            nextLevel\
    \ = 0\n        }\n        levels.toList", "        val levels = mutable.ListBuffer[Long]()\n\
    \        var nextLevel = 0\n        var nextLevelStones = 0\n        while(nextLevel\
    \ < n) {\n            nextLevelStones = nextLevel % 2 == 0 ? nextLevelStones +\
    \ 1 : nextLevelStones\n            nextLevel = nextLevel + 1\n            levels\
    \ += nextLevelStones\n        }\n        levels.toList", "        val stones =\
    \ mutable.ListBuffer[Long]()\n        stones += n\n        stones += n / 2\n \
    \       stones += n / 3\n        stones", "        val nums = mutable.ListBuffer[Long]()\n\
    \        val even = if (n % 2 == 0) n else n + 2\n        val odd = if (n % 2\
    \ == 1) n else n - 1\n        for (i <- 0 until n) {\n            if (i % 2 ==\
    \ 0) {\n                nums += even\n            } else {\n                nums\
    \ += odd\n            }\n        }\n        nums.toList", "        val pile =\
    \ mutable.ListBuffer[Long]()\n        pile.append(n)\n        pile.append(if (n\
    \ % 2 == 0) n / 2 else 3 * n + 1)\n        pile", "        val stones = mutable.ListBuffer(n)\n\
    \        val even = if (n % 2 == 0) n else n + 1 \n        val odd = if (n % 2\
    \ == 1) n else n + 1 \n        stones ++= makeAPile(even)\n        stones ++=\
    \ makeAPile(odd)\n        stones.toList", "        val levels = mutable.ListBuffer[Long]()\n\
    \        val even = if (n % 2 == 0) n / 2 else 3 * n + 1\n        val odd = if\
    \ (n % 2 == 1) n / 2 else 3 * n + 1\n        levels += even\n        levels +=\
    \ odd\n        levels.toList", "        val levels = mutable.ListBuffer[Long]()\n\
    \        var level = 0\n        var stones = 0\n        while (stones < n) {\n\
    \            stones += if (n % 2 == 0) 2 else 1\n            level += 1\n    \
    \        levels += level.toLong\n            n -= 1\n        }\n        levels.toList",
  "        val list = mutable.ListBuffer[Long]()\n        val odd = if (n % 2 == 0)\
    \ n / 2 else n / 2 + 1\n        val even = if (n % 2 == 0) n / 2 else n / 2\n\
    \        list += odd.toLong\n        list += even.toLong\n        list.toList",
  "        val stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones\
    \ += if (n % 2 == 0) n / 2 else n / 2 + 1\n        stones.toList", "        val\
    \ levels = mutable.ListBuffer[Long]()\n        val odd = if (n % 2 == 0) n / 2\
    \ else n / 2 + 1\n        val even = if (n % 2 == 0) n / 2 else n / 2\n      \
    \  levels += n\n        levels += odd\n        levels += even\n        levels.toList",
  "        val stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones\
    \ += if (n % 2 == 0) (n / 2l.toLong) else (n / 2l.toLong + 1l.toLong)\n      \
    \  stones", "        val stones = mutable.ListBuffer[Long]()\n        stones +=\
    \ n\n        stones += if (n % 2 == 0) stones.last.last.last else stones.last.last.last.last\n\
    \        stones", "        val stones = mutable.ListBuffer[Long]()\n        stones\
    \ += n\n        stones += if (n % 2 == 0) n / 2 else n * 3\n        stones", " \
    \       val stones = mutable.ListBuffer[Long]()\n        var nextLevel = n.toLong\n\
    \        var nextOdd = 0\n        var nextEven = 0\n        while (nextLevel >\
    \ 0) {\n            if (nextLevel % 2 == 0) {\n                nextEven = nextEven\
    \ * 2 + 1\n            } else {\n                nextOdd = nextOdd * 2 + 1\n \
    \           }\n            nextLevel = nextLevel / 2\n        }\n        stones\
    \ += nextOdd\n        stones += nextEven\n        stones.toList", "        val\
    \ stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones +=\
    \ n / 2\n        stones += n / 3\n        stones", "        val levels = mutable.ListBuffer[Long]()\n\
    \        var nextLevel = 0\n        var nextOdd = 0\n        var nextEven = 0\n\
    \        var currentLevel = nextLevel\n        var currentOdd = nextOdd\n    \
    \    var currentEven = nextEven\n        while(n > 0) {\n            levels +=\
    \ currentLevel\n            nextLevel = nextLevel + currentOdd + currentEven\n\
    \            nextOdd = nextOdd + 2\n            nextEven = nextEven + 2\n    \
    \        currentLevel = nextLevel\n            currentOdd = nextOdd\n        \
    \    currentEven = nextEven\n            n -= 1\n        }\n        levels.toList",
  "        val stones = mutable.ListBuffer.empty[Long]\n        stones += n\n    \
    \    stones += if (n % 2 == 0) stones.last + 1 else stones.last + 1\n        stones",
  "        val levels = mutable.ListBuffer[Long]()\n        var level = 0\n      \
    \  var nextLevel = 0\n        while(nextLevel < n) {\n            level += 1\n\
    \            nextLevel = if (n % 2 == 0) (2 * n) else (3 * n)\n            levels\
    \ += level.toLong\n        }\n        levels.toList", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += n / 2\n        stones += n / 3\n     \
    \   stones", "        val stones = mutable.ListBuffer[Long]()\n        var level\
    \ = 0\n        var nextLevel = 0\n        var nextLevelStones = 0\n        var\
    \ nextLevelEven = 0\n        var nextLevelOdd = 0\n        var even = 0\n    \
    \    var odd = 0\n        while (n < 0l) {\n            nextLevel = math.min(math.ceil(n/2),\
    \ nextLevel)\n            nextLevelStones = math.min(n-level*nextLevel, nextLevelStones)\n\
    \            nextLevelEven = math.min(n-level*nextLevel, nextLevelEven)\n    \
    \        nextLevelOdd = math.min(n-level*nextLevel, nextLevelOdd)\n          \
    \  stones += nextLevelStones\n            even = math.min(nextLevelEven, even)\n\
    \            odd = math.min(nextLevelOdd, odd)\n            level += 1\n     \
    \       nextLevelStones = 0\n            nextLevelEven = 0\n            nextLevelOdd\
    \ = 0\n        }\n        stones.toList", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += if (n % 2 == 0) stones.last.last else\
    \ stones.last.head + stones.last.last\n        stones", "        val result =\
    \ new mutable.ListBuffer[Long]()\n        val even = if (n % 2 == 0) n / 2 else\
    \ n / 2 + 1\n        val odd = if (n % 2 == 1) n / 2 else n / 2\n        val nextEven\
    \ = if (even % 2 == 0) even / 2 else even / 2 + 1\n        val nextOdd = if (odd\
    \ % 2 == 1) odd / 2 else odd / 2\n        val nextNextEven = if (nextEven % 2\
    \ == 0) nextEven / 2 else nextEven / 2 + 1\n        val nextNextOdd = if (nextOdd\
    \ % 2 == 1) nextOdd / 2 else nextOdd / 2\n        val nextNextNextEven = if (nextNextEven\
    \ % 2 == 0) nextNextEven / 2 else nextNextEven / 2 + 1\n        val nextNextNextOdd\
    \ = if (nextNextOdd % 2 == 1) nextNextOdd / 2 else nextNextOdd / 2\n        val\
    \ nextNextNextNextEven = if (nextNextNextEven % 2 == 0) nextNextNextEven / 2 else\
    \ nextNextNextEven / 2 + 1\n        val nextNextNextNextOdd = if (nextNextNextOdd\
    \ % 2 == 1) nextNextNextOdd / 2 else nextNextNextOdd / 2\n        val nextNextNextNextNextEven\
    \ = if (nextNextNextNextEven % 2 == 0) nextNextNextNextEven / 2 else nextNextNextNextEven\
    \ / 2 + 1\n        val nextNextNextNextNextOdd = if (nextNextNextNextOdd % 2 ==\
    \ 1) nextNextNextNextOdd / 2 else nextNextNextNextOdd / 2\n        val nextNextNextNextNextNextEven\
    \ = if (nextNextNextNextNextEven % 2 == 0) nextNextNextNextNextEven / 2 else nextNextNextNextNextEven\
    \ / 2 + 1\n        val nextNextNextNextNextNextOdd = if (nextNextNextNextNextOdd\
    \ % 2 == 1) nextNextNextNextNextOdd / 2 else nextNextNextNextNextOdd / 2\n   \
    \     val nextNextNextNextNextNextNextEven = if (nextNextNextNextNextNextEven\
    \ % 2 == 0) nextNextNextNextNextNextEven / 2 else nextNextNextNextNextNextEven\
    \ / 2 + 1\n        val nextNextNextNextNextNextNextOdd = if (nextNextNextNextNextNextOdd\
    \ % 2 == 1) nextNextNextNextNextNextOdd / 2 else nextNextNextNextNextNextOdd /\
    \ 2\n        val nextNextNextNextNextNextNextNextEven = if (nextNextNextNextNextNextNextEven\
    \ % 2 == 0) nextNextNextNextNextNext", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += if (n % 2 == 0) (n / 2l) else (n / 2l)\
    \ + 1\n        stones.toList", "        val levels = mutable.ListBuffer.empty[Long]\n\
    \        var i = 0\n        while (i < n) {\n            levels += n\n       \
    \     i += 2\n        }\n        levels.toList", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += if (n % 2 == 0) n / 2 else n / 2 + 1\n\
    \        stones.toList", "        val stones = mutable.ListBuffer[Long]()\n  \
    \      stones += n\n        stones += if (n % 2 == 0) n else n + 2\n        stones",
  "        val stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones\
    \ += if (n % 2 == 0) stones.last + 1 else stones.last + 1\n        stones.toList",
  "        val levels = mutable.ListBuffer[Long]()\n        var level = 0\n      \
    \  while(level < n) {\n            levels += level\n            level += 1\n \
    \       }\n        levels.toList", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += if (n % 2 == 0) n / 2 else n / 2 + 1\n\
    \        stones", "        val levels = mutable.ListBuffer[Long]()\n        val\
    \ odd = if (n % 2 == 0) n / 2 else n / 2 + 1\n        val even = n / 2\n     \
    \   levels += n\n        levels += odd\n        levels += even\n        levels.toList",
  "        val stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones\
    \ += n / 2\n        stones += n / 3\n        stones", "        val levels = mutable.ListBuffer[Long]()\n\
    \        var level = 0\n        var nextLevel = 0\n        while (n > 0) {\n \
    \           if (n % 2 == 0) {\n                nextLevel = nextLevel + 1\n   \
    \         } else {\n                nextLevel = nextLevel - 1\n            }\n\
    \            levels += nextLevel\n            n = n - 1\n        }\n        levels.toList",
  "        val levels = mutable.ListBuffer[Long]()\n        val odd = if (n % 2 ==\
    \ 0) n / 2 else n / 2 + 1\n        val even = if (n % 2 == 0) n / 2 else n / 2\n\
    \        for (i <- 0 until n) {\n            levels += if (i % 2 == 0) even else\
    \ odd\n        }\n        levels.toList", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += n / 2\n        stones += n / 3\n     \
    \   stones", "        val pile : List[Long] = List(n).reverse\n        val odd\
    \ = if (n % 2 == 0) n / 2 else n / 2 + 1\n        val even = if (n % 2 == 0) n\
    \ / 2 else n / 2\n        val nextLevel = List(odd, even)\n        val nextLevelCount\
    \ = nextLevel.foldLeft(0)(_ + _)\n        pile.zip(nextLevel).map { case (count,\
    \ nextLevelCount) =>\n            count + nextLevelCount\n        }", "      \
    \  val stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones\
    \ += if (n % 2 == 0) n / 2 else (n / 2).toLong\n        stones", "        val\
    \ stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones +=\
    \ if (n % 2 == 0) stones.head + 1 else stones.head + 1\n        stones", "   \
    \     val stones = mutable.ListBuffer(n.toLong)\n        stones ++= makeAPile(n/2,\
    \ stones)\n        stones ++= makeAPile(n/2, stones)\n        stones", "     \
    \   val stones = mutable.ListBuffer[Long]()\n        var nextLevel = 0\n     \
    \   var nextOdd = 0\n        var nextEven = 0\n        stones += n\n        while\
    \ (stones.size > 0) {\n            nextLevel = stones.head.toLong\n          \
    \  nextOdd = nextLevel % 2\n            nextEven = nextLevel % 2\n           \
    \ if (nextOdd > nextEven) {\n                stones += nextOdd\n            }\
    \ else {\n                stones += nextEven\n            }\n        }\n     \
    \   stones.toList", "        val levels = mutable.ListBuffer.empty[Long]\n   \
    \     val odd = if (n % 2 == 0) n / 2 else n / 2 + 1\n        val even = if (n\
    \ % 2 == 0) n / 2 else n / 2\n        levels += n\n        levels += odd\n   \
    \     levels += even\n        levels.toList", "        val numOfLevels = n.toInt\n\
    \        val numOfStones = n.toLong\n        val numOfLevelsStones = numOfLevels.toLong\
    \ * numOfStones\n        val numOfLevelsStonesArray = Array.ofDim[Long](numOfLevels)\n\
    \        val numOfLevelsStonesArrayIterator = numOfLevelsStonesArray.iterator\n\
    \        val numOfLevelsStonesArrayIteratorNext = numOfLevelsStonesArrayIterator.next\n\
    \        val numOfLevelsStonesArrayIteratorNextNext = numOfLevelsStonesArrayIteratorNext.next\n\
    \        val numOfLevelsStonesArrayIteratorNextNextNext = numOfLevelsStonesArrayIteratorNextNext.next\n\
    \        val numOfLevelsStonesArrayIteratorNextNextNextNext = numOfLevelsStonesArrayIteratorNextNextNext.next\n\
    \        val numOfLevelsStonesArrayIteratorNextNextNextNextNext = numOfLevelsStonesArrayIteratorNextNextNextNext.next\n\
    \        val numOfLevelsStonesArrayIteratorNextNextNextNextNext = numOfLevelsStonesArrayIteratorNextNextNextNext.next\n\
    \        val numOfLevelsStonesArrayIteratorNextNextNextNextNextNext = numOfLevelsStonesArrayIteratorNextNextNextNextNext.next\n\
    \        val numOfLevelsStonesArrayIteratorNextNextNextNextNextNextNext = numOfLevelsStonesArrayIteratorNextNextNextNextNextNext.next\n\
    \        val numOfLevelsStonesArrayIteratorNextNextNextNextNextNextNextNext =\
    \ numOfLevelsStonesArrayIteratorNextNextNextNextNextNextNext.next\n        val\
    \ numOfLevelsStonesArrayIteratorNextNextNextNextNextNextNextNext = numOfLevelsStonesArrayIteratorNextNextNextNextNextNextNextNext.next\n\
    \        val numOfLevelsStonesArrayIteratorNextNextNextNextNextNextNextNextNext\
    \ = numOfLevelsStonesArrayIteratorNextNextNextNextNextNextNextNextNextNext.next\n\
    \        val numOfLevelsStonesArrayIteratorNextNextNextNextNextNextNextNextNextNext\
    \ = numOfLevelsStonesArrayIteratorNextNextNextNextNextNextNextNextNextNextNext.next\n\
    \        val numOfLevelsStone", "        val levels = mutable.ListBuffer[Long]()\n\
    \        val odd = if (n % 2 == 0) n / 2 else n / 2 + 1\n        val even = if\
    \ (n % 2 == 0) n / 2 else n / 2\n        levels += n\n        while (levels.size\
    \ < n) levels += odd\n        while (levels.size < n) levels += even\n       \
    \ levels.toList", "        val stones = mutable.ListBuffer[Long]()\n        var\
    \ nextLevel = 0\n        stones += n\n        while (stones.size < n) {\n    \
    \        nextLevel = nextLevel + math.min(stones.size, n).toLong\n           \
    \ stones += nextLevel\n        }\n        stones.toList", "        val stones\
    \ = mutable.ListBuffer[Long]()\n        stones += n\n        stones += (if (n\
    \ % 2 == 0) n else n + 2)\n        stones", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += if (n % 2 == 0) stones.last.last.last\
    \ else stones.last.last.last.last\n        stones", "        val pile : List[Long]\
    \ = List(n).toList\n        val odd = if (n % 2 == 0) n / 2 else n / 2 + 1\n \
    \       val even = if (n % 2 == 0) n / 2 else n / 2\n        val nextLevel = odd\
    \ :: even :: pile.take(odd)\n        pile.take(even).reverse ++ nextLevel", " \
    \       val pile : List[Long] = List(0l)\n        var i = 0\n        while (i\
    \ < n) {\n            pile.append(i+1l)\n            i += 2\n        }\n     \
    \   pile", "        val levels = mutable.ListBuffer[Long]()\n        val odd =\
    \ if (n % 2 == 0) n / 2 else n / 2 + 1\n        val even = n / 2\n        levels\
    \ += n\n        levels += odd\n        levels += even\n        levels.toList",
  "        val levels = mutable.ListBuffer[Long]()\n        val odd = if (n % 2 ==\
    \ 0) n / 2 else n / 2 + 1\n        val even = if (n % 2 == 0) n / 2 else n\n \
    \       levels += n\n        levels += odd\n        levels += even\n        levels.toList",
  "        val stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones\
    \ += if (n % 2 == 0) n / 2 else n / 2 + 1\n        stones.toList", "        val\
    \ stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones +=\
    \ n / 2\n        stones += n / 3\n        stones", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += if (n % 2 == 0) (n / 2l.toLong) else (3\
    \ * n + 1l.toLong)\n        stones", "        val nums = mutable.ListBuffer[Long]()\n\
    \        val odd = if (n % 2 == 0) n / 2 else n / 2 + 1\n        val even = if\
    \ (n % 2 == 0) n / 2 else n / 2\n        val nums = for {\n            i <- 1\
    \ to n\n        } yield {\n            if (i % 2 == 0) even else odd\n       \
    \ }\n        nums.toList", "        val pile : List[Long] = List(n)\n        val\
    \ odd = n\n        val even = n\n        val nextOdd = if (n % 2 == 0) odd + 1\
    \ else odd\n        val nextEven = if (n % 2 == 0) even + 1 else even\n      \
    \  pile.append(nextOdd)\n        pile.append(nextEven)\n        pile", "     \
    \   val nums = mutable.ArrayBuffer.empty[Long]\n        var i = 0\n        while\
    \ (i < n) {\n            if (n % 2 == 0) {\n                nums += n.toLong\n\
    \                i += 2\n            } else {\n                nums += n.toLong\n\
    \                i += 1\n            }\n        }\n        nums", "        val\
    \ result = new mutable.ListBuffer[Long]()\n        val nextLevel = if (n % 2 ==\
    \ 0) n / 2 else 3 * n + 1\n        result.add(nextLevel)\n        makeAPile(nextLevel)",
  "        val pile = mutable.ListBuffer.empty[Long]\n        pile.append(n)\n   \
    \     pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.to", "        val levels = mutable.ListBuffer.empty[Long]\n\
    \        val odd = if (n % 2 == 0) n / 2 else (n / 2) + 1\n        val even =\
    \ if (n % 2 == 0) n / 2 else (n / 2)\n        levels += n\n        levels += odd\n\
    \        levels += even\n        levels.toList", "        val nums = mutable.ListBuffer[Long]()\n\
    \        val odd = if (n % 2 == 0) n / 2 else n / 2 + 1\n        val even = if\
    \ (n % 2 == 0) n / 2 else n / 2\n        for (i<- 1 to odd) nums += i.toLong\n\
    \        for (i<- 1 to even) nums += i.toLong\n        nums.toList", "       \
    \ val stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones\
    \ += n / 2\n        stones += n / 3\n        stones += n / 4\n        stones +=\
    \ n / 5\n        stones += n / 6\n        stones += n / 7\n        stones += n\
    \ / 8\n        stones += n / 9\n        stones += n / 10\n        stones += n\
    \ / 11\n        stones += n / 12\n        stones += n / 13\n        stones +=\
    \ n / 14\n        stones += n / 15\n        stones += n / 16\n        stones +=\
    \ n / 17\n        stones += n / 18\n        stones += n / 19\n        stones +=\
    \ n / 20\n        stones += n / 21\n        stones += n / 22\n        stones +=\
    \ n / 23\n        stones += n / 24\n        stones += n / 25\n        stones +=\
    \ n / 26\n        stones += n / 27\n        stones += n / 28\n        stones +=\
    \ n / 29\n        stones += n / 30\n        stones += n / 31\n        stones +=\
    \ n / 32\n        stones += n / 33\n        stones += n / 34\n        stones +=\
    \ n / 35\n        stones += n / 36\n        stones += n / 37\n        stones +=\
    \ n / 38\n        stones += n / 39\n        stones += n / 40\n        stones +=\
    \ n / 41\n        stones += n / 42\n        stones += n / 43\n        stones +=\
    \ n / 44\n        stones += n / 45\n        stones += n / 46\n        stones +=\
    \ n / 47\n        stones += n / 48\n        stones += n / 49\n        stones +=\
    \ n / 50\n        stones += n / 51\n        stones += n / 52\n        stones +=\
    \ n / 53\n        stones += n / 54\n        stones += n / 55\n        stones +=\
    \ n / 56\n        stones += n / 57\n        stones += n / 58\n        stones +=\
    \ n / 59\n        stones += n / 60\n        stones += n / 61\n        stones +=\
    \ n / 62\n        stones += n / 63\n        stones += n / 64\n        stones +=\
    \ n / 65\n        stones += n / 66\n        stones += n / 67\n        stones +=\
    \ n / 68\n        stones += n / 69\n        stones += n / 70\n        stones +=\
    \ n / 71\n        stones += n ", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += if (n % 2 == 0) stones.head + 1 else stones.head\
    \ + 1\n        stones", "        val pile = mutable.ListBuffer[Long]()\n     \
    \   var nextLevel = n.toLong\n        var nextLevelCount = 0\n        while (nextLevel\
    \ > 0) {\n            if (nextLevel % 2 == 0) {\n                nextLevelCount\
    \ += nextLevel\n            } else {\n                nextLevelCount += nextLevel.toLong\n\
    \            }\n            pile.append(nextLevelCount)\n            nextLevel\
    \ = nextLevel.toLong / 2\n            nextLevelCount = 0\n        }\n        pile.toList",
  "        val levels = mutable.ListBuffer.empty[Long]\n        var i = 0\n      \
    \  while (i < n) {\n            if (n % 2 == 0) {\n                levels += n.toLong\n\
    \                i += 2\n            } else {\n                levels += n.toLong\n\
    \                i += 1\n            }\n        }\n        levels.toList", " \
    \       val pile : List[Long] = List(n,n,n)\n        val odd = if (n % 2 == 0)\
    \ n / 2 else n / 2 + 1\n        val even = if (n % 2 == 0) n / 2 else n / 2\n\
    \        val nextLevel = List(odd, even)\n        pile.zip(nextLevel).map { case\
    \ (pile,nextLevel) => nextLevel.toLong }", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += (if (n % 2 == 0) n / 2 else n / 2 + 1)\n\
    \        stones.toList", "        val stones = mutable.ListBuffer[Long]()\n  \
    \      stones += n\n        stones += n / 2\n        stones += n / 4\n       \
    \ stones += n / 8\n        stones += n / 16\n        stones += n / 32\n      \
    \  stones += n / 64\n        stones += n / 128\n        stones += n / 256\n  \
    \      stones += n / 512\n        stones += n / 1024\n        stones += n / 2048\n\
    \        stones += n / 4096\n        stones += n / 8192\n        stones += n /\
    \ 16384\n        stones += n / 32768\n        stones += n / 65536\n        stones\
    \ += n / 131072\n        stones += n / 262144\n        stones += n / 524288\n\
    \        stones += n / 1048576\n        stones += n / 2097152\n        stones\
    \ += n / 4194304\n        stones += n / 8388608\n        stones += n / 16777216\n\
    \        stones += n / 33554432\n        stones += n / 67108864\n        stones\
    \ += n / 134217728\n        stones += n / 268435456\n        stones += n / 536870912\n\
    \        stones += n / 1073741824\n        stones += n / 2147483648\n        stones\
    \ += n / 4294967296\n        stones += n / 8589934592\n        stones += n / 17179869184\n\
    \        stones += n / 34359738368\n        stones += n / 68719476736\n      \
    \  stones += n / 137438953472\n        stones += n / 274877906944\n        stones\
    \ += n / 549755813888\n        stones += n / 1099511627776\n        stones +=\
    \ n / 2199023255552\n        stones += n / 4398046511104\n        stones += n\
    \ / 8796093022208\n        stones += n / 17592186044416\n        stones += n /\
    \ 35184372088832\n        stones += n / 70368744177664\n        stones += n /\
    \ 140737488355328\n        stones += n / 281474976710656\n        stones += n\
    \ / 562949953421312\n        stones += n / 1125899906842624\n        stones +=\
    \ n / 22517998136", "        val result = new mutable.ListBuffer[Long]()\n   \
    \     var nextLevel = n.toLong\n        var nextLevelCount = 1\n        while\
    \ (nextLevel > 0) {\n            if (nextLevel % 2 == 0) {\n                nextLevelCount\
    \ += 1\n            } else {\n                nextLevelCount += 2\n          \
    \  }\n            nextLevel = nextLevel / 2\n        }\n        result.addAll(nextLevelCount.toList.map(_.toLong))\n\
    \        return result.toList", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += if (n % 2 == 0) stones.last + 1 else stones.last\
    \ + 1\n        stones", "        val stones = mutable.ListBuffer[Long]()\n   \
    \     stones += n\n        stones += if (n % 2 == 0) n / 2 else n / 2 + 1\n  \
    \      stones", "        val pile = mutable.ListBuffer[Long]()\n        pile.append(n)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.toLong)\n        pile.append(n.toLong)\n        pile.append(n.toLong)\n\
    \        pile.append(n.to", "        val nums = mutable.ListBuffer(n)\n      \
    \  val even = nums.takeRight(math.ceil(n/2))\n        val odd = nums.drop(math.ceil(n/2))\n\
    \        val evenCount = even.count(_%2 == 0)\n        val oddCount = odd.count(_%2\
    \ == 0)\n        val evenList = even.takeRight(evenCount)\n        val oddList\
    \ = odd.takeRight(oddCount)\n        evenList ++ oddList", "        val levels\
    \ = mutable.ListBuffer[Long]()\n        var i = 0\n        while (i < n) {\n \
    \           levels += n\n            i += 2\n        }\n        levels.toList",
  "        val levels = mutable.ListBuffer[Long]()\n        var currentLevel = n.toLong\n\
    \        var currentLevelCount = 1\n        while(currentLevel > 0) {\n      \
    \      currentLevelCount += 1\n            currentLevel = currentLevel >> 1\n\
    \            levels += currentLevelCount\n        }\n        levels.toList", " \
    \       val levels = mutable.ListBuffer[Long]()\n        val odd = if (n % 2 ==\
    \ 0) n / 2 else n / 2 + 1\n        val even = n / 2\n        levels += n\n   \
    \     levels += odd\n        levels += even\n        levels.toList", "       \
    \ val nums = mutable.ListBuffer[Long]()\n        var num = 0\n        var next\
    \ = 0\n        while(n > 0) {\n            num += 1\n            next += (n%2\
    \ == 0) ? 1 : 0\n            n /= 2\n        }\n        nums += num\n        nums\
    \ += next\n        nums.toList", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += if (n % 2 == 0) n / 2 else n / 2 + 1\n\
    \        stones.toList", "        val nums = mutable.ListBuffer[Long]()\n    \
    \    val odd = if (n % 2 == 0) n / 2 else n / 2 + 1\n        val even = if (n\
    \ % 2 == 0) n / 2 else n / 2\n        val nums = for (i <- 1 to n) yield {\n \
    \           if (i % 2 == 0) even else odd\n        }\n        nums.toList", " \
    \       val levels = mutable.ListBuffer[Long]()\n        val odd = if (n % 2 ==\
    \ 0) n / 2 else n / 2 + 1\n        val even = if (n % 2 == 0) n / 2 else n / 2\n\
    \        levels += n\n        levels += odd\n        levels += even\n        levels.toList",
  "        val nums = mutable.ListBuffer[Long]()\n        val odd = if (n % 2 == 0)\
    \ n / 2 else n / 2 + 1\n        val even = if (n % 2 == 0) n / 2 else n / 2\n\
    \        val nextLevel = if (n % 2 == 0) even else odd\n        val nextLevelNum\
    \ = nextLevel.toLong\n        val nextLevelNums = List(nextLevelNum, nextLevelNum\
    \ * 2, nextLevelNum * 3)\n        val numsIterator = nextLevelNums.iterator\n\
    \        while (nextLevelNums.hasNext) {\n            val nextLevelNum = nextLevelNums.next()\n\
    \            val nums = nums.updated(nextLevelNum, nextLevelNums.size)\n     \
    \   }\n        nums.toList", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += if (n % 2 == 0) n else n + 2\n       \
    \ stones", "        val list = mutable.ListBuffer[Long]()\n        val odd = if\
    \ (n % 2 == 0) n / 2 else n / 2 + 1\n        val even = if (n % 2 == 0) n / 2\
    \ else n / 2\n        list += n\n        list += odd\n        list += even\n \
    \       list.toList", "        val levels = mutable.ListBuffer[Long]()\n     \
    \   var nextLevel = n.toLong\n        var nextLevelCount = 1\n        while (nextLevel\
    \ > 0) {\n            if (nextLevel % 2 == 0) {\n                nextLevelCount\
    \ += 1\n            } else {\n                nextLevelCount += nextLevel\n  \
    \          }\n            nextLevel = nextLevel / 2\n            levels += nextLevelCount\n\
    \        }\n        levels.toList", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += n % 2 == 0 ? n : n % 2 == 1 ? n + 1 :\
    \ n + 2\n        stones.toList", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += if (n % 2 == 0) n / 2 else n / 2 + 1\n\
    \        stones", "        val stones = mutable.ListBuffer[Long]()\n        stones\
    \ += n\n        stones += if (n % 2 == 0) n / 2 else n / 2 + 1\n        stones",
  "        val levels = mutable.ListBuffer[Long]()\n        var nextLevel = n.toLong\n\
    \        var nextOdd = 0\n        var nextEven = 0\n        while (nextLevel >\
    \ 0) {\n            nextOdd = nextOdd + (nextLevel % 2).toLong\n            nextEven\
    \ = nextEven + (nextLevel % 2).toLong\n            levels += nextOdd\n       \
    \     levels += nextEven\n            nextLevel = nextLevel / 2\n        }\n \
    \       levels.toList", "        val levels = mutable.ListBuffer[Long]()\n   \
    \     var i = 0\n        while (i < n) {\n            levels += n\n          \
    \  i += 2\n        }\n        levels.toList", "        val nums = mutable.ListBuffer[Long]()\n\
    \        val odd = if (n % 2 == 0) n / 2 else n / 2 + 1\n        val even = if\
    \ (n % 2 == 0) n / 2 else n / 2\n        for (i <- 0 until n) {\n            if\
    \ (i % 2 == 0) {\n                nums += even\n            } else {\n       \
    \         nums += odd\n            }\n        }\n        nums.toList", "     \
    \   val nums = mutable.ListBuffer[Long]()\n        val odd = if (n % 2 == 0) n\
    \ / 2 else n / 2 + 1\n        val even = n / 2\n        for (i <- 0 until n) {\n\
    \            if (i % 2 == 0) {\n                nums += even\n            } else\
    \ {\n                nums += odd\n            }\n        }\n        nums.toList",
  "        val result = new mutable.ListBuffer[Long]()\n        val odd = if (n %\
    \ 2 == 0) n / 2 else n / 2 + 1\n        val even = if (n % 2 == 0) n / 2 else\
    \ n / 2\n        val nextLevel = odd * 2\n        val nextLevel2 = even + 1\n\
    \        result ++= List(nextLevel, nextLevel2)\n        result.toList", "   \
    \     val stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones\
    \ += n / 2\n        stones += n / 3\n        stones", "        val nums = mutable.ListBuffer[Long]()\n\
    \        val even = if (n % 2 == 0) n / 2 else (n / 2) + 1\n        val odd =\
    \ if (n % 2 == 1) n / 2 else (n / 2) - 2\n        val num = (even, odd)\n    \
    \    nums += num._1\n        nums += num._2\n        nums.toList", "        val\
    \ stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones +=\
    \ if (n % 2 == 0) n / 2 else n * 3\n        stones", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += (if (n % 2 == 0) n / 2 else n / 2 + 1)\n\
    \        stones", "        val result = new mutable.ListBuffer[Long]()\n     \
    \   val odd = if (n % 2 == 0) n / 2 else n / 2 + 1\n        val even = if (n %\
    \ 2 == 0) n / 2 else n / 2\n        val nextLevel = if (n % 2 == 0) even else\
    \ odd\n        val nextLevelCount = nextLevel.foldLeft(0l) { (sum, nextLevel)\
    \ =>\n            val nextLevelCount = nextLevel.foldLeft(0l) { (sum, nextLevel)\
    \ =>\n                val nextLevelCount = nextLevel.foldLeft(0l) { (sum, nextLevel)\
    \ =>\n                    val nextLevelCount = nextLevel.foldLeft(0l) { (sum,\
    \ nextLevel) =>\n                        val nextLevelCount = nextLevel.foldLeft(0l)\
    \ { (sum, nextLevel) =>\n                            val nextLevelCount = nextLevel.foldLeft(0l)\
    \ { (sum, nextLevel) =>\n                                val nextLevelCount =\
    \ nextLevel.foldLeft(0l) { (sum, nextLevel) =>\n                             \
    \       val nextLevelCount = nextLevel.foldLeft(0l) { (sum, nextLevel) =>\n  \
    \                                      val nextLevelCount = nextLevel.foldLeft(0l)\
    \ { (sum, nextLevel) =>\n                                            val nextLevelCount\
    \ = nextLevel.foldLeft(0l) { (sum, nextLevel) =>\n                           \
    \                     val nextLevelCount = nextLevel.foldLeft(0l) { (sum, nextLevel)\
    \ =>\n                                                    val nextLevelCount =\
    \ nextLevel.foldLeft(0l) { (sum, nextLevel) =>\n                             \
    \                           val nextLevelCount = nextLevel.foldLeft(0l) { (sum,\
    \ nextLevel) =>\n                                                            val\
    \ nextLevelCount = nextLevel.foldLeft(0l) { (sum, nextLevel) =>\n            \
    \                                                    val nextLevelCount = nextLevel.foldLeft(0l)\
    \ { (sum, nextLevel) =>\n                                                    \
    \                val nextLevelCount = nextLevel.foldLeft(0l) { (sum, nextLevel)\
    \ =>\n                                                                       \
    \ val nextLevelCount = nextLevel.foldLeft(0l) { (sum, nextLevel) =>\n        \
    \                                                                    val nextLevelCount\
    \ = nextLevel.foldLeft(0l) { (sum, nextLevel) =>\n                           \
    \                                                     val nextLevelCount = nextLevel.foldLeft(0l)\
    \ { (sum, nextLevel) =>\n                                                    \
    \                                val nextLevelCount = nextLevel.foldLeft(0l) {\
    \ (sum, nextLevel) =>\n                                                      \
    \                                  val nextLevelCount = nextLevel.foldLeft(0l)\
    \ { (sum, nextLevel) =>\n                                                    \
    \                                        val nextLevelCount = nextLevel.", " \
    \       val levels = mutable.ListBuffer[Long]()\n        var i = 0\n        while\
    \ (i < n) {\n            levels += n\n            i += 2\n        }\n        levels.toList",
  "        val stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones\
    \ += if (n % 2 == 0) n else n + 2\n        stones", "        val levels = mutable.ListBuffer[Long]()\n\
    \        val odd = if (n % 2 == 0) n / 2 else n / 2 + 1\n        val even = if\
    \ (n % 2 == 0) n / 2 else n / 2\n        levels += n\n        levels += odd\n\
    \        levels += even\n        levels.toList", "        val stones = mutable.ListBuffer.empty[Long]\n\
    \        stones += n\n        stones += n / 2\n        stones += n / 3\n     \
    \   stones", "        val levels = mutable.ListBuffer[Long]()\n        var nextLevel\
    \ = n.toInt\n        while (nextLevel > 0) {\n            if (nextLevel % 2 ==\
    \ 0) {\n                levels += nextLevel.toLong\n            } else {\n   \
    \             levels += nextLevel.toLong + 1\n            }\n            nextLevel\
    \ = nextLevel / 2\n        }\n        levels.toList", "        val levels = mutable.ListBuffer[Long]()\n\
    \        val nextLevel = if (n % 2 == 0) n.toLong + 1 else n.toLong\n        levels\
    \ += nextLevel\n        levels += nextLevel\n        levels", "        val stones\
    \ = mutable.ListBuffer[Long]()\n        var nextLevel = n.toInt\n        var nextLevelCount\
    \ = stones.size + n.toInt\n        while(nextLevelCount > 0) {\n            nextLevel\
    \ = nextLevel % 2 == 0 ? nextLevel + 1 : nextLevel\n            nextLevelCount\
    \ = nextLevelCount - nextLevel.toInt\n            stones += nextLevel.toLong\n\
    \        }\n        stones.toList", "        val levels = mutable.ListBuffer[Long]()\n\
    \        val odd = if (n % 2 == 0) n / 2 else n / 2 + 1\n        val even = if\
    \ (n % 2 == 0) n / 2 else n\n        levels.+=(n+1)\n        levels.+=((odd).toLong)\n\
    \        levels.+=((even).toLong)\n        levels.toList", "        val levels\
    \ = mutable.ListBuffer[Long]()\n        var i = 0\n        while (i < n) {\n \
    \           levels += i.toLong\n            i += 2\n        }\n        levels.toList",
  "        val levels = mutable.ListBuffer[Long]()\n        var i = 0\n        while\
    \ (i < n) {\n            levels += n\n            i += 2\n        }\n        levels.toList",
  "        val levels = mutable.ListBuffer[Long]()\n        var i = 0\n        while\
    \ (i < n) {\n            levels += n\n            i += 2\n        }\n        levels.toList",
  "        val stones = mutable.ListBuffer[Long]()\n        stones += n\n        stones\
    \ += n / 2\n        stones += n / 3\n        stones", "        val stones = mutable.ListBuffer[Long]()\n\
    \        stones += n\n        stones += n / 2\n        stones += n / 3\n     \
    \   stones", "        val stones = mutable.ListBuffer[Long]()\n        stones\
    \ += n\n        stones += n % 2 == 0 ? n : n % 2 == 1 ? n + 1 : n + 1\n      \
    \  stones.toList", "        val stones = mutable.ListBuffer[Long]()\n        stones\
    \ += n\n        stones += if (n % 2 == 0) stones.last + 2 else stones.last + 1\n\
    \        stones.toList", "        val stones = mutable.ListBuffer.empty[Long]\n\
    \        var nextLevel = n.toLong\n        while(nextLevel > 0) {\n          \
    \  stones += nextLevel\n            nextLevel = nextLevel.toLong % 2 == 0 ? nextLevel.toLong\
    \ + 1 : nextLevel.toLong\n        }\n        stones.toList", "        val stones\
    \ = mutable.ListBuffer(n.toLong)\n        val odd = if (n % 2 == 0) n / 2 else\
    \ n / 2 + 1\n        val even = if (n % 2 == 0) n / 2 else n / 2\n        stones\
    \ ++= makeAPile(odd)\n        stones ++= makeAPile(even)\n        stones.toList",
  "        val stones = mutable.ListBuffer[Long]()\n        var i = 0\n        while\
    \ (i < n) {\n            stones += n\n            i += 2\n        }\n        stones.toList",
  "        val list = mutable.ListBuffer[Long]()\n        val odd = if (n % 2 == 0)\
    \ n / 2 else n / 2 + 1\n        val even = if (n % 2 == 0) n / 2 else n / 2\n\
    \        list += n\n        list += odd\n        list += even\n        list.toList"]
stop_tokens:
- "\n    }\n"
