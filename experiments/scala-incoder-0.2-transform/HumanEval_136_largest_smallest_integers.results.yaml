language: scala
name: HumanEval_136_largest_smallest_integers
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyywnaf0.scala:28)\n\tat Problem.main(tmpuyywnaf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty) None\n        else if (positive.isEmpty) Some(negative.minOption)\n\
    \        else if (negative.isEmpty) Some(positive.maxOption)\n        else (Some(positive.maxOption),\
    \ Some(negative.minOption))\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo_413hb7.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (positive.isEmpty\
    \ && negative.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpo_413hb7.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positive.isEmpty) Some(negative.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo_413hb7.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (negative.isEmpty) Some(positive.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo_413hb7.scala:21:19 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m (Some(positive.maxOption), Some(negative.minOption))\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                "
  stdout: ''
  timestamp: 1659798754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty || positive.isEmpty)\
    \ Some(None) else None\n        else {\n            val maxNegative = negative.max\n\
    \            val minPositive = positive.min\n            if (maxNegative < minPositive)\
    \ Some(None) else None\n            else Some(maxNegative) :: Some(minPositive)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp82mw2t2u.scala:20:8 ------------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m {\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^\e[0m\n\e[31m   |\e[0m        end of statement expected but 'else' found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp82mw2t2u.scala:18:50 --------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty && positive.isEmpty)\
    \ None\n\e[31m\e[31m   |\e[0m                                                \
    \  ^^^^\e[0m\n\e[31m   |\e[0m                                  Found:    None.type\n\
    \e[31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp82mw2t2u.scala:19:59\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (negative.isEmpty || positive.isEmpty) Some(None) \e[33melse\e[0m None\n\e\
    [31m\e[31m   |\e[0m                                                       ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    Some[None.type]\n\
    \e[31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp82mw2t2u.scala:19:71\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (negative.isEmpty || positive.isEmpty) Some(None) \e[33melse\e[0m None\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \             ^^^^\e[0m\n\e[31m   |\e[0m                                  Found:\
    \    None.type\n\e[31m   |\e[0m                                  Required: (Option[Long],\
    \ Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659798967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ None\n        else if (positives.isEmpty) None\n        else {\n           \
    \ val largest = negatives.max\n            val smallest = positives.min\n    \
    \        (Some(largest), Some(smallest))\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmujhit52.scala:18:31\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negatives.isEmpty)\
    \ None\n\e[31m\e[31m   |\e[0m                               ^^^^\e[0m\n\e[31m\
    \   |\e[0m                               Found:    None.type\n\e[31m   |\e[0m\
    \                               Required: (Option[Long], Option[Long])\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmujhit52.scala:19:36 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positives.isEmpty)\
    \ None\n\e[31m\e[31m   |\e[0m                                    ^^^^\e[0m\n\e\
    [31m   |\e[0m                                  Found:    None.type\n\e[31m   |\e\
    [0m                                  Required: (Option[Long], Option[Long])\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798966
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7f6v53g1.scala:28)\n\tat Problem.main(tmp7f6v53g1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.min.toLong)\n\
    \        else if (positive.isEmpty) Some(negative.min.toLong)\n        else (Some(negative.min.toLong),\
    \ Some(positive.min.toLong))\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8zn9lhd5.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp8zn9lhd5.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.min.toLong)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    Some[Long]\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8zn9lhd5.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.min.toLong)\n\e[31m\e[31m   |\e[0m      \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                  Found:    Some[Long]\n\e[31m   |\e[0m     \
    \                             Required: (Option[Long], Option[Long])\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798967
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpa9egihwy.scala:21)\n\tat Problem$.main(tmpa9egihwy.scala:28)\n\
    \tat Problem.main(tmpa9egihwy.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798779
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkbznzq0k.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (Some(negative.maxOption),\
    \ Some(positive.minOption))\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4j8o6kq5.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp4j8o6kq5.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4j8o6kq5.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4j8o6kq5.scala:21:19 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m (Some(negative.maxOption), Some(positive.minOption))\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                "
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        val a = negative.maxBy(_)\n\
    \        val b = positive.minBy(_)\n        (a.toOption, b)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp13vazz47.scala:18:33 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36ma\e[0m = negative.maxBy(_)\n\
    \e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0mNo\
    \ implicit Ordering defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m    scala.math.Ordering.comparatorToOrdering[\e[35mAny\e[0m](\n\
    \e[31m   |\e[0m      /* missing */summon[java.util.Comparator[Any]]\n\e[31m  \
    \ |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found\
    \ that match type java.util.Comparator[Any].\n\e[31m\e[31m-- Error: /tmp/tmp13vazz47.scala:19:33\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m19 |\e[0m       \
    \ \e[33mval\e[0m \e[36mb\e[0m = positive.minBy(_)\n\e[31m\e[31m   |\e[0m     \
    \                            ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering defined\
    \ for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.comparatorToOrdering[\e\
    [35mAny\e[0m](\n\e[31m   |\e[0m      /* missing */summon[java.util.Comparator[Any]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type java.util.Comparator[Any].\n2 errors found\n"
  stdout: ''
  timestamp: 1659798967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl17a6ore.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.max), Some(positive.min))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpopx54y1x.scala:21)\n\tat Problem$.main(tmpopx54y1x.scala:28)\n\
    \tat Problem.main(tmpopx54y1x.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798967
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdup5424.scala:28)\n\tat Problem.main(tmpgdup5424.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        val maxNegative\
    \ = negatives.max\n        val minPositive = positives.min\n        (maxNegative,\
    \ minPositive)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqdaifnw5.scala:20:9\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         Found:\
    \    (maxNegative : Long)\n\e[31m   |\e[0m         Required: Option[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqdaifnw5.scala:20:22\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                     Found:    (minPositive : Long)\n\e[31m   |\e[0m        \
    \              Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798777
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdup5424.scala:28)\n\tat Problem.main(tmpgdup5424.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpakrtoxtj.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpakrtoxtj.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.minOption,\
    \ positive.maxOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpirl40yai.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpirl40yai.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpirl40yai.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdk2v7la1.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdk2v7la1.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdup5424.scala:28)\n\tat Problem.main(tmpgdup5424.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpigre589x.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028661
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpa9egihwy.scala:21)\n\tat Problem$.main(tmpa9egihwy.scala:28)\n\
    \tat Problem.main(tmpa9egihwy.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798779
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpd740yf9e.scala:21)\n\tat Problem$.main(tmpd740yf9e.scala:28)\n\
    \tat Problem.main(tmpd740yf9e.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjf5rv9po.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjf5rv9po.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty)\n            (None, None)\n        else if (positive.isEmpty)\n\
    \            (Some(None), Some(negative.min))\n        else if (negative.isEmpty)\n\
    \            (Some(positive.max), Some(None))\n        else\n            (Some(positive.max),\
    \ Some(negative.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9wiuq5f8.scala:21:18\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(None), Some(negative.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9wiuq5f8.scala:23:38\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            (Some(positive.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                      ^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Found:    None.type\n\
    \e[31m   |\e[0m                                      Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) \n            (None, None)\n        else if (negative.isEmpty)\
    \ \n            (Some(negative.min), Some(positive.max))\n        else if (positive.isEmpty)\
    \ \n            (Some(positive.min), Some(negative.max))\n        else\n     \
    \       (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpsx0r6jtw.scala:21)\n\tat Problem$.main(tmpsx0r6jtw.scala:28)\n\
    \tat Problem.main(tmpsx0r6jtw.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmphgn04euk.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkbznzq0k.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798740
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        val minNegative\
    \ = negative.min\n        val maxPositive = positive.max\n        (Some(minNegative),\
    \ Some(maxPositive))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpoqb5ta9a.scala:18)\n\tat Problem$.main(tmpoqb5ta9a.scala:23)\n\
    \tat Problem.main(tmpoqb5ta9a.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty) \n            (Some(None), Some(None))\n        else if\
    \ (positive.isEmpty || negative.isEmpty) \n            (None, None)\n        else\
    \ \n            (Some(positive.max), Some(negative.min))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpc0w5ugk2.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpc0w5ugk2.scala:19:30\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                              ^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Found:    None.type\n\e[31m   |\e[0m          \
    \                    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpqwru0wtm.scala:21)\n\tat Problem$.main(tmpqwru0wtm.scala:28)\n\
    \tat Problem.main(tmpqwru0wtm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty)\n            (None, None)\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), None)\n        else if (negative.isEmpty)\n\
    \            (None, Some(positive.max))\n        else\n            (Some(negative.min),\
    \ Some(positive.max))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkpifu1jj.scala:28)\n\tat Problem.main(tmpkpifu1jj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpakrtoxtj.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpakrtoxtj.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl17a6ore.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798766
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdup5424.scala:28)\n\tat Problem.main(tmpgdup5424.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpakrtoxtj.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpakrtoxtj.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ None\n        else if (positives.isEmpty) None\n        else (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf234i9gq.scala:18:31\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negatives.isEmpty)\
    \ None\n\e[31m\e[31m   |\e[0m                               ^^^^\e[0m\n\e[31m\
    \   |\e[0m                               Found:    None.type\n\e[31m   |\e[0m\
    \                               Required: (Option[Long], Option[Long])\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf234i9gq.scala:19:36 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positives.isEmpty)\
    \ None\n\e[31m\e[31m   |\e[0m                                    ^^^^\e[0m\n\e\
    [31m   |\e[0m                                  Found:    None.type\n\e[31m   |\e\
    [0m                                  Required: (Option[Long], Option[Long])\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdup5424.scala:28)\n\tat Problem.main(tmpgdup5424.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyywnaf0.scala:28)\n\tat Problem.main(tmpuyywnaf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkbznzq0k.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if(negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6u5fep2f.scala:18:49\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m(negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                 ^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    None.type\n\e[31m \
    \  |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdup5424.scala:28)\n\tat Problem.main(tmpgdup5424.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty)\n            (None, None)\n        else if (positive.isEmpty)\n\
    \            (Some(None), Some(negative.min))\n        else if (negative.isEmpty)\n\
    \            (Some(positive.max), Some(None))\n        else\n            (Some(positive.max),\
    \ Some(negative.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9wiuq5f8.scala:21:18\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(None), Some(negative.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9wiuq5f8.scala:23:38\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            (Some(positive.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                      ^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Found:    None.type\n\
    \e[31m   |\e[0m                                      Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(_\
    \ > 0l)\n        val negative = lst.filter(_ < 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty) None\n        else if (positive.isEmpty) Some(negative.minOption)\n\
    \        else if (negative.isEmpty) Some(positive.maxOption)\n        else (Some(negative.minOption),\
    \ Some(positive.maxOption))\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx9fhud8s.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (positive.isEmpty\
    \ && negative.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpx9fhud8s.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positive.isEmpty) Some(negative.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx9fhud8s.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (negative.isEmpty) Some(positive.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx9fhud8s.scala:21:19 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m (Some(negative.minOption), Some(positive.maxOption))\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                "
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmphgn04euk.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdup5424.scala:28)\n\tat Problem.main(tmpgdup5424.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ >= 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi0y10wzm.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi0y10wzm.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyywnaf0.scala:28)\n\tat Problem.main(tmpuyywnaf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmphgn04euk.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdup5424.scala:28)\n\tat Problem.main(tmpgdup5424.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpqwru0wtm.scala:21)\n\tat Problem$.main(tmpqwru0wtm.scala:28)\n\
    \tat Problem.main(tmpqwru0wtm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpakrtoxtj.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpakrtoxtj.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.minOption,\
    \ positive.maxOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpirl40yai.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpirl40yai.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpirl40yai.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ {\n            (Some(None), Some(positives.min))\n        } else if (positives.isEmpty)\
    \ {\n            (Some(negatives.max), Some(None))\n        } else {\n       \
    \     (Some(negatives.max), Some(positives.min))\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpreiwn3m5.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpreiwn3m5.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        val maxNegative\
    \ = negative.max\n        val minPositive = positive.min\n        (maxNegative,\
    \ minPositive)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzwczw5cb.scala:20:9\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         Found:\
    \    (maxNegative : Long)\n\e[31m   |\e[0m         Required: Option[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzwczw5cb.scala:20:22\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                     Found:    (minPositive : Long)\n\e[31m   |\e[0m        \
    \              Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpigre589x.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028661
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0L)\n        val negative = lst.filter(x => x > 0L)\n        if (positive.isEmpty\
    \ && negative.isEmpty)\n            (None, None)\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), None)\n        else if (negative.isEmpty)\n\
    \            (None, Some(positive.min))\n        else\n            (Some(negative.min),\
    \ Some(positive.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd9exs8l8.scala:28)\n\tat Problem.main(tmpd9exs8l8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjf5rv9po.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjf5rv9po.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        val maxNegative =\
    \ negatives.max\n        val minPositive = positives.min\n        (maxNegative,\
    \ minPositive)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl61lrowg.scala:20:9\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         Found:\
    \    (maxNegative : Long)\n\e[31m   |\e[0m         Required: Option[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl61lrowg.scala:20:22\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                     Found:    (minPositive : Long)\n\e[31m   |\e[0m        \
    \              Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl17a6ore.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfjnv4499.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x >= 0l)\n        if (negatives.isEmpty)\
    \ {\n            (Some(None), Some(positives.min))\n        } else if (positives.isEmpty)\
    \ {\n            (Some(negatives.max), Some(None))\n        } else {\n       \
    \     (Some(negatives.max), Some(positives.min))\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqdbk8t_r.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqdbk8t_r.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmphgn04euk.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkbznzq0k.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798740
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty)\n            (None, None)\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), None)\n        else if (negative.isEmpty)\n\
    \            (None, Some(positive.min))\n        else\n            (Some(negative.min),\
    \ Some(positive.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjvqbbpuh.scala:28)\n\tat Problem.main(tmpjvqbbpuh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty) None else (Some(positive.min), Some(negative.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_3xab4jp.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (positive.isEmpty\
    \ && negative.isEmpty) None \e[33melse\e[0m (Some(positive.min), Some(negative.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028662
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpqwru0wtm.scala:21)\n\tat Problem$.main(tmpqwru0wtm.scala:28)\n\
    \tat Problem.main(tmpqwru0wtm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi3wuy5i3.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.min.toLong)\n\
    \        else if (positive.isEmpty) Some(negative.max.toLong)\n        else (Some(negative.max.toLong),\
    \ Some(positive.min.toLong))\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzqbyv4fj.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpzqbyv4fj.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.min.toLong)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    Some[Long]\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzqbyv4fj.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.max.toLong)\n\e[31m\e[31m   |\e[0m      \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                  Found:    Some[Long]\n\e[31m   |\e[0m     \
    \                             Required: (Option[Long], Option[Long])\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660028675
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfjnv4499.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpqwru0wtm.scala:21)\n\tat Problem$.main(tmpqwru0wtm.scala:28)\n\
    \tat Problem.main(tmpqwru0wtm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyywnaf0.scala:28)\n\tat Problem.main(tmpuyywnaf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x >= 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty) \n            (Some(None), Some(None))\n        else if\
    \ (positive.isEmpty) \n            (Some(None), Some(negative.min))\n        else\
    \ if (negative.isEmpty) \n            (Some(positive.max), Some(None))\n     \
    \   else \n            (Some(positive.max), Some(negative.min))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp157phqfb.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp157phqfb.scala:19:30\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                              ^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Found:    None.type\n\e[31m   |\e[0m          \
    \                    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp157phqfb.scala:21:18 --------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m            (Some(None), Some(negative.min))\n\e[31m\e[31m   |\e[0m  \
    \                ^^^^\e[0m\n\e[31m   |\e[0m                  Found:    None.type\n\
    \e[31m   |\e[0m                  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp157phqfb.scala:23:38 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            (Some(positive.max), Some(None))\n\e[31m\e\
    [31m   |\e[0m                                      ^^^^\e[0m\n\e[31m   |\e[0m\
    \                                      Found:    None.type\n\e[31m   |\e[0m  \
    \                                    Required: Long\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660028676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ {\n            (Some(None), Some(positives.min))\n        } else if (positives.isEmpty)\
    \ {\n            (Some(negatives.max), Some(None))\n        } else {\n       \
    \     (Some(negatives.max), Some(positives.min))\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpghkbkgpg.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpghkbkgpg.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028675
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdup5424.scala:28)\n\tat Problem.main(tmpgdup5424.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty) \n            (Some(None), Some(None))\n        else if\
    \ (positive.isEmpty) \n            (Some(None), Some(negative.min))\n        else\
    \ if (negative.isEmpty) \n            (Some(positive.max), Some(None))\n     \
    \   else \n            (Some(positive.max), Some(negative.min))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd83qenug.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd83qenug.scala:19:30\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                              ^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Found:    None.type\n\e[31m   |\e[0m          \
    \                    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpd83qenug.scala:21:18 --------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m            (Some(None), Some(negative.min))\n\e[31m\e[31m   |\e[0m  \
    \                ^^^^\e[0m\n\e[31m   |\e[0m                  Found:    None.type\n\
    \e[31m   |\e[0m                  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpd83qenug.scala:23:38 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            (Some(positive.max), Some(None))\n\e[31m\e\
    [31m   |\e[0m                                      ^^^^\e[0m\n\e[31m   |\e[0m\
    \                                      Found:    None.type\n\e[31m   |\e[0m  \
    \                                    Required: Long\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660028675
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpdgeya1pp.scala:21)\n\tat Problem$.main(tmpdgeya1pp.scala:28)\n\
    \tat Problem.main(tmpdgeya1pp.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) \n            (Some(None), Some(None))\n        else if\
    \ (negative.isEmpty) \n            (Some(None), Some(positive.min))\n        else\
    \ if (positive.isEmpty) \n            (Some(negative.max), Some(None))\n     \
    \   else \n            (Some(negative.max), Some(positive.min))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa9dmomm8.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa9dmomm8.scala:19:30\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                              ^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Found:    None.type\n\e[31m   |\e[0m          \
    \                    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpa9dmomm8.scala:21:18 --------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m            (Some(None), Some(positive.min))\n\e[31m\e[31m   |\e[0m  \
    \                ^^^^\e[0m\n\e[31m   |\e[0m                  Found:    None.type\n\
    \e[31m   |\e[0m                  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpa9dmomm8.scala:23:38 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            (Some(negative.max), Some(None))\n\e[31m\e\
    [31m   |\e[0m                                      ^^^^\e[0m\n\e[31m   |\e[0m\
    \                                      Found:    None.type\n\e[31m   |\e[0m  \
    \                                    Required: Long\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660028676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty && positive.isDefined)\
    \ Some(positive.get)\n        else if (negative.isDefined && positive.isEmpty)\
    \ Some(negative.get)\n        else if (negative.isDefined && positive.isDefined)\
    \ Some(negative.get.max(positive.get))\n        else None\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0u7bwllm.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp0u7bwllm.scala:19:46 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty &&\
    \ positive.isDefined) Some(positive.get)\n\e[31m\e[31m   |\e[0m              \
    \                       ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue isDefined\
    \ is not a member of List[Long] - did you mean positive.isDefinedAt?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp0u7bwllm.scala:19:71 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isDefined) Some(positive.get)\n\e[31m\e[31m   |\e[0m           \
    \                                                   ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue get is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0u7bwllm.scala:20:26\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (negative.isDefined && positive.isEmpty) Some(negative.get)\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue isDefined\
    \ is not a member of List[Long] - did you mean negative.isDefinedAt?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp0u7bwllm.scala:20:71 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mi"
  stdout: ''
  timestamp: 1660028677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpigre589x.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028661
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdup5424.scala:28)\n\tat Problem.main(tmpgdup5424.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        val a = negative.maxOption\n\
    \        val b = positive.minOption\n        (a.getOrElse(None), b.getOrElse(None))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp363zacl3.scala:20:20\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (a.getOrElse(None), b.getOrElse(None))\n\
    \e[31m\e[31m   |\e[0m         ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \ Found:    Matchable\n\e[31m   |\e[0m         Required: Option[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp363zacl3.scala:20:39 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        (a.getOrElse(None), b.getOrElse(None))\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                            Found:    Matchable\n\e[31m   |\e[0m          \
    \                  Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if(negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if(positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp6b6onph.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp6b6onph.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ {\n            (Some(None), Some(positives.min))\n        } else if (positives.isEmpty)\
    \ {\n            (Some(negatives.max), Some(None))\n        } else {\n       \
    \     (Some(negatives.max), Some(positives.min))\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpghkbkgpg.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpghkbkgpg.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028675
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x >= 0l)\n        if (negatives.isEmpty)\
    \ {\n            (Some(None), Some(positives.min))\n        } else if (positives.isEmpty)\
    \ {\n            (Some(negatives.max), Some(None))\n        } else {\n       \
    \     (Some(negatives.max), Some(positives.min))\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqdbk8t_r.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqdbk8t_r.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyywnaf0.scala:28)\n\tat Problem.main(tmpuyywnaf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyywnaf0.scala:28)\n\tat Problem.main(tmpuyywnaf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty || positive.isEmpty)\
    \ Some(None)\n        else {\n            val maxNegative = negative.max\n   \
    \         val minPositive = positive.min\n            if (maxNegative < minPositive)\
    \ Some(None)\n            else Some(Some(maxNegative))\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx3de82yy.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpx3de82yy.scala:19:59 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty ||\
    \ positive.isEmpty) Some(None)\n\e[31m\e[31m   |\e[0m                        \
    \                               ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                     Found:    Some[None.type]\n\e[31m   |\e[0m             \
    \                     Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx3de82yy.scala:23:47 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (maxNegative < minPositive)\
    \ Some(None)\n\e[31m\e[31m   |\e[0m                                          \
    \ ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                  Found:   \
    \ Some[None.type]\n\e[31m   |\e[0m                                  Required:\
    \ (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpx3de82yy.scala:24:21 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m            \e[33melse\e[0m Some(Some(maxNegative))\n\e[31m\e[31m   |\e\
    [0m                 ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \     Found:    Some[Some[Long]]\n\e[31m   |\e[0m                 Required: (Option[Long],\
    \ Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660028676
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyywnaf0.scala:28)\n\tat Problem.main(tmpuyywnaf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3u6v3myj.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp3u6v3myj.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3u6v3myj.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660028676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmphgn04euk.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmphgn04euk.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.max), Some(positive.min))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpx7a2uy40.scala:21)\n\tat Problem$.main(tmpx7a2uy40.scala:28)\n\
    \tat Problem.main(tmpx7a2uy40.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl17a6ore.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty) None\n        else if (positive.isEmpty) Some(negative.minOption)\n\
    \        else if (negative.isEmpty) Some(positive.maxOption)\n        else (positive.maxOption,\
    \ negative.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqhg6e4r8.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (positive.isEmpty\
    \ && negative.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpqhg6e4r8.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positive.isEmpty) Some(negative.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqhg6e4r8.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (negative.isEmpty) Some(positive.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660028676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfjnv4499.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0L)\n        val negative = lst.filter(x => x >= 0L)\n        if (positive.isEmpty\
    \ && negative.isEmpty) \n            (None, None)\n        else if (positive.isEmpty)\
    \ \n            (Some(negative.min), None)\n        else if (negative.isEmpty)\
    \ \n            (None, Some(positive.min))\n        else \n            (Some(negative.min),\
    \ Some(positive.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1f27ic0q.scala:28)\n\tat Problem.main(tmp1f27ic0q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028678
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ Some(None) else None\n        if (positives.isEmpty) Some(None) else None\n\
    \        val maxNegative = negatives.max\n        val minPositive = positives.min\n\
    \        (Some(maxNegative), Some(minPositive))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmp6j3ekv75.scala:20)\n\tat Problem$.main(tmp6j3ekv75.scala:25)\n\
    \tat Problem.main(tmp6j3ekv75.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028678
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpigre589x.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028661
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty && positive.isDefined)\
    \ Some(positive.get)\n        else if (negative.isDefined && positive.isEmpty)\
    \ Some(negative.get)\n        else if (negative.isDefined && positive.isDefined)\
    \ Some(negative.get.max(positive.get))\n        else None\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8pljfaiu.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp8pljfaiu.scala:19:46 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty &&\
    \ positive.isDefined) Some(positive.get)\n\e[31m\e[31m   |\e[0m              \
    \                       ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue isDefined\
    \ is not a member of List[Long] - did you mean positive.isDefinedAt?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp8pljfaiu.scala:19:71 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isDefined) Some(positive.get)\n\e[31m\e[31m   |\e[0m           \
    \                                                   ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue get is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8pljfaiu.scala:20:26\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (negative.isDefined && positive.isEmpty) Some(negative.get)\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue isDefined\
    \ is not a member of List[Long] - did you mean negative.isDefinedAt?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp8pljfaiu.scala:20:71 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mi"
  stdout: ''
  timestamp: 1660028679
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfjnv4499.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty)\n            (None, None)\n        else if (positive.isEmpty)\n\
    \            (Some(None), Some(negative.min))\n        else if (negative.isEmpty)\n\
    \            (Some(positive.max), Some(None))\n        else\n            (Some(positive.max),\
    \ Some(negative.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9wiuq5f8.scala:21:18\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(None), Some(negative.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9wiuq5f8.scala:23:38\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            (Some(positive.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                      ^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Found:    None.type\n\
    \e[31m   |\e[0m                                      Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        val maxNegative\
    \ = negative.max\n        val minPositive = positive.min\n        if (maxNegative.isEmpty\
    \ && minPositive.isEmpty) None\n        else if (maxNegative.isEmpty) Some(minPositive)\n\
    \        else if (minPositive.isEmpty) Some(maxNegative)\n        else (Some(maxNegative),\
    \ Some(minPositive))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9mprbeaa.scala:20:24 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (maxNegative.isEmpty && minPositive.isEmpty)\
    \ None\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            value isEmpty is not a member of Long\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp9mprbeaa.scala:20:56 --------------------\e[0m\e[0m\n\
    \e[31m20 |\e[0m        \e[33mif\e[0m (maxNegative.isEmpty && minPositive.isEmpty)\
    \ None\n\e[31m\e[31m   |\e[0m                                                \
    \        ^^^^\e[0m\n\e[31m   |\e[0m                                  Found:  \
    \  None.type\n\e[31m   |\e[0m                                  Required: (Option[Long],\
    \ Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9mprbeaa.scala:21:29\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (maxNegative.isEmpty) Some(minPositive)\n\e[31m\e[31m   |\e[0m   \
    \              ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 value\
    \ isEmpty is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp9mprbeaa.scala:21:42 --------------------\e[0m\e[0m\n\e[31m21 |\e[0m\
    \        \e[33melse\e[0m \e[33mif\e[0m (maxNegative.isEmpty) Some(minPositive)\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    Some[Long]\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9mprbeaa.scala:22:29\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (minPositive.isEmpty) Some(maxNegative)\n\e[31m\e[31m   |\e[0m   \
    \              ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 value\
    \ isEmpty is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp9mprbeaa.scala:22:42 --------------------\e[0m\e[0m\n\e[31m22 |\e[0"
  stdout: ''
  timestamp: 1660028679
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if(negative.isEmpty)\
    \ None\n        else (Some(negative.max), Some(positive.min))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5b_wshtw.scala:18:29\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m(negative.isEmpty)\
    \ None\n\e[31m\e[31m   |\e[0m                             ^^^^\e[0m\n\e[31m  \
    \ |\e[0m                             Found:    None.type\n\e[31m   |\e[0m    \
    \                         Required: (Option[Long], Option[Long])\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660028676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        val maxNegative =\
    \ negative.max\n        val minPositive = positive.min\n        (maxNegative,\
    \ minPositive)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdp8mz5ws.scala:20:9\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         Found:\
    \    (maxNegative : Long)\n\e[31m   |\e[0m         Required: Option[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdp8mz5ws.scala:20:22\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                     Found:    (minPositive : Long)\n\e[31m   |\e[0m        \
    \              Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028678
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyywnaf0.scala:28)\n\tat Problem.main(tmpuyywnaf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        negatives.isEmpty\
    \  match {\n            case true => None\n            case false => Some(negatives.max)\n\
    \        }\n        positives.isEmpty  match {\n            case true => None\n\
    \            case false => Some(positives.min)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjhvsciaf.scala:23:25\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mcase\e[0m \e\
    [31mtrue\e[0m => None\n\e[31m\e[31m   |\e[0m                         ^^^^\e[0m\n\
    \e[31m   |\e[0m                         Found:    None.type\n\e[31m   |\e[0m \
    \                        Required: (Option[Long], Option[Long])\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjhvsciaf.scala:24:30 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m \e[31mfalse\e[0m => Some(positives.min)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                          Found:    Some[Long]\n\e[31m   |\e[0m    \
    \                      Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.min.toLong)\n\
    \        else if (positive.isEmpty) Some(negative.min.toLong)\n        else (Some(negative.min.toLong),\
    \ Some(positive.min.toLong))\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8zn9lhd5.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp8zn9lhd5.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.min.toLong)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    Some[Long]\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8zn9lhd5.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.min.toLong)\n\e[31m\e[31m   |\e[0m      \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                  Found:    Some[Long]\n\e[31m   |\e[0m     \
    \                             Required: (Option[Long], Option[Long])\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        val maxNegative\
    \ = negative.max\n        val minPositive = positive.min\n        (maxNegative,\
    \ minPositive)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzwczw5cb.scala:20:9\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         Found:\
    \    (maxNegative : Long)\n\e[31m   |\e[0m         Required: Option[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzwczw5cb.scala:20:22\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                     Found:    (minPositive : Long)\n\e[31m   |\e[0m        \
    \              Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyywnaf0.scala:28)\n\tat Problem.main(tmpuyywnaf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkbznzq0k.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798740
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdup5424.scala:28)\n\tat Problem.main(tmpgdup5424.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty) \n            (Some(None), Some(None))\n        else if\
    \ (positive.isEmpty && negative.isDefined) \n            (Some(None), negative.head)\n\
    \        else if (positive.isDefined && negative.isEmpty) \n            (positive.head,\
    \ Some(None))\n        else if (positive.isDefined && negative.isDefined) \n \
    \           (positive.head, negative.head)\n        else \n            (None,\
    \ None)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjm324jys.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjm324jys.scala:19:30\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                              ^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Found:    None.type\n\e[31m   |\e[0m          \
    \                    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpjm324jys.scala:20:46 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m        \e[33melse\e[0m \e[33mif\e[0m (positive.isEmpty && negative.isDefined)\
    \ \n\e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue isDefined is not a member of List[Long] - did you mean\
    \ negative.isDefinedAt?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjm324jys.scala:21:18\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(None), negative.head)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjm324jys.scala:21:34\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(None), negative.head)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         Found:    Long\n\e[31m   |\e[0m                  \
    \       Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpjm324jys.scala:22:26 ------------------------\e[0m\e"
  stdout: ''
  timestamp: 1660028679
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if(negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnk1viyw_.scala:18:49\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m(negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                 ^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    None.type\n\e[31m \
    \  |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028677
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if(negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if(negative.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else if(positive.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmp1yzgugkk.scala:21)\n\tat Problem$.main(tmp1yzgugkk.scala:28)\n\
    \tat Problem.main(tmp1yzgugkk.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.minOption,\
    \ positive.maxOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcnef2kya.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpcnef2kya.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcnef2kya.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660028688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        val maxNegative =\
    \ negatives.max\n        val minPositive = positives.min\n        (maxNegative,\
    \ minPositive)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl61lrowg.scala:20:9\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         Found:\
    \    (maxNegative : Long)\n\e[31m   |\e[0m         Required: Option[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl61lrowg.scala:20:22\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                     Found:    (minPositive : Long)\n\e[31m   |\e[0m        \
    \              Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdup5424.scala:28)\n\tat Problem.main(tmpgdup5424.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpigre589x.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028661
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmp2u9xrk76.scala:21)\n\tat Problem$.main(tmp2u9xrk76.scala:28)\n\
    \tat Problem.main(tmp2u9xrk76.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if(negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6u5fep2f.scala:18:49\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m(negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                 ^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    None.type\n\e[31m \
    \  |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if(negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if(positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnp9m9rm9.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnp9m9rm9.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjf5rv9po.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjf5rv9po.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ None\n        else if (positives.isEmpty) None\n        else (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf234i9gq.scala:18:31\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negatives.isEmpty)\
    \ None\n\e[31m\e[31m   |\e[0m                               ^^^^\e[0m\n\e[31m\
    \   |\e[0m                               Found:    None.type\n\e[31m   |\e[0m\
    \                               Required: (Option[Long], Option[Long])\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf234i9gq.scala:19:36 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positives.isEmpty)\
    \ None\n\e[31m\e[31m   |\e[0m                                    ^^^^\e[0m\n\e\
    [31m   |\e[0m                                  Found:    None.type\n\e[31m   |\e\
    [0m                                  Required: (Option[Long], Option[Long])\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty && positive.isDefined)\
    \ Some(positive.get)\n        else if (negative.isDefined && positive.isEmpty)\
    \ Some(negative.get)\n        else if (negative.isDefined && positive.isDefined)\
    \ Some(negative.max, positive.min)\n        else None\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_an149o8.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp_an149o8.scala:19:46 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty &&\
    \ positive.isDefined) Some(positive.get)\n\e[31m\e[31m   |\e[0m              \
    \                       ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue isDefined\
    \ is not a member of List[Long] - did you mean positive.isDefinedAt?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp_an149o8.scala:19:71 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isDefined) Some(positive.get)\n\e[31m\e[31m   |\e[0m           \
    \                                                   ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue get is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_an149o8.scala:20:26\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (negative.isDefined && positive.isEmpty) Some(negative.get)\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue isDefined\
    \ is not a member of List[Long] - did you mean negative.isDefinedAt?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp_an149o8.scala:20:71 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mi"
  stdout: ''
  timestamp: 1660028689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ >= 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptlxpztn_.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptlxpztn_.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028688
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyywnaf0.scala:28)\n\tat Problem.main(tmpuyywnaf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdup5424.scala:28)\n\tat Problem.main(tmpgdup5424.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl17a6ore.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0L)\n        val negative = lst.filter(x => x > 0L)\n        if (positive.isEmpty\
    \ && negative.isEmpty) None\n        else if (positive.isEmpty) Some(negative.minOption)\n\
    \        else if (negative.isEmpty) Some(positive.maxOption)\n        else (Some(negative.minOption),\
    \ Some(positive.maxOption))\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp35vrwmg5.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (positive.isEmpty\
    \ && negative.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp35vrwmg5.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positive.isEmpty) Some(negative.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp35vrwmg5.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (negative.isEmpty) Some(positive.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp35vrwmg5.scala:21:19 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m (Some(negative.minOption), Some(positive.maxOption))\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                "
  stdout: ''
  timestamp: 1660028688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (Some(negative.maxOption),\
    \ Some(positive.minOption))\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4j8o6kq5.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp4j8o6kq5.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4j8o6kq5.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4j8o6kq5.scala:21:19 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m (Some(negative.maxOption), Some(positive.minOption))\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                "
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ None\n        else if (positives.isEmpty) None\n        else {\n           \
    \ val max = negatives.max\n            val min = positives.min\n            (Some(max),\
    \ Some(min))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppt4mwfo9.scala:18:31\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negatives.isEmpty)\
    \ None\n\e[31m\e[31m   |\e[0m                               ^^^^\e[0m\n\e[31m\
    \   |\e[0m                               Found:    None.type\n\e[31m   |\e[0m\
    \                               Required: (Option[Long], Option[Long])\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppt4mwfo9.scala:19:36 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positives.isEmpty)\
    \ None\n\e[31m\e[31m   |\e[0m                                    ^^^^\e[0m\n\e\
    [31m   |\e[0m                                  Found:    None.type\n\e[31m   |\e\
    [0m                                  Required: (Option[Long], Option[Long])\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmphgn04euk.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmp2u9xrk76.scala:21)\n\tat Problem$.main(tmp2u9xrk76.scala:28)\n\
    \tat Problem.main(tmp2u9xrk76.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty)\n            (None, None)\n        else if (positive.isEmpty)\n\
    \            (Some(None), Some(negative.min))\n        else if (negative.isEmpty)\n\
    \            (Some(positive.max), Some(None))\n        else\n            (Some(positive.max),\
    \ Some(negative.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9wiuq5f8.scala:21:18\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(None), Some(negative.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9wiuq5f8.scala:23:38\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            (Some(positive.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                      ^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Found:    None.type\n\
    \e[31m   |\e[0m                                      Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) \n            (Some(None), Some(None))\n        else if\
    \ (negative.isEmpty) \n            (Some(None), Some(positive.min))\n        else\
    \ if (positive.isEmpty) \n            (Some(negative.max), Some(None))\n     \
    \   else \n            (Some(negative.max), Some(positive.min))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa9dmomm8.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa9dmomm8.scala:19:30\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                              ^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Found:    None.type\n\e[31m   |\e[0m          \
    \                    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpa9dmomm8.scala:21:18 --------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m            (Some(None), Some(positive.min))\n\e[31m\e[31m   |\e[0m  \
    \                ^^^^\e[0m\n\e[31m   |\e[0m                  Found:    None.type\n\
    \e[31m   |\e[0m                  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpa9dmomm8.scala:23:38 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            (Some(negative.max), Some(None))\n\e[31m\e\
    [31m   |\e[0m                                      ^^^^\e[0m\n\e[31m   |\e[0m\
    \                                      Found:    None.type\n\e[31m   |\e[0m  \
    \                                    Required: Long\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660028676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else Some(negative.maxOption)\
    \ match {\n            case Some(max) => Some(positive.minOption max max)\n  \
    \          case None => None\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpelwg80tb.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpelwg80tb.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpelwg80tb.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpelwg80tb.scala:22:58 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mcase\e[0m Some(max) => Some(positive.minOption\
    \ max max)\n\e[31m\e[31m   |\e[0m                                            \
    \              ^^^\e[0m\n\e[31m   "
  stdout: ''
  timestamp: 1660028689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else Some(negative.maxOption)\
    \ match {\n            case Some(max) => Some(positive.minOption max max)\n  \
    \          case None => None\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkwydlyer.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpkwydlyer.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkwydlyer.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkwydlyer.scala:22:58 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mcase\e[0m Some(max) => Some(positive.minOption\
    \ max max)\n\e[31m\e[31m   |\e[0m                                            \
    \              ^^^\e[0m\n\e[31m   "
  stdout: ''
  timestamp: 1660028689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty) None\n        else if (positive.isEmpty) Some(negative.minOption)\n\
    \        else if (negative.isEmpty) Some(positive.maxOption)\n        else (Some(negative.minOption),\
    \ Some(positive.maxOption))\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptd0ul278.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (positive.isEmpty\
    \ && negative.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmptd0ul278.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positive.isEmpty) Some(negative.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptd0ul278.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (negative.isEmpty) Some(positive.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptd0ul278.scala:21:19 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m (Some(negative.minOption), Some(positive.maxOption))\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                "
  stdout: ''
  timestamp: 1660028689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpakrtoxtj.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpakrtoxtj.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmphgn04euk.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty)\n            (None, None)\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), None)\n        else if (negative.isEmpty)\n\
    \            (None, Some(positive.min))\n        else\n            (Some(negative.min),\
    \ Some(positive.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjvqbbpuh.scala:28)\n\tat Problem.main(tmpjvqbbpuh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkbznzq0k.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        val maxNegative\
    \ = negative.max\n        val minPositive = positive.min\n        (maxNegative,\
    \ minPositive)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzwczw5cb.scala:20:9\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         Found:\
    \    (maxNegative : Long)\n\e[31m   |\e[0m         Required: Option[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzwczw5cb.scala:20:22\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                     Found:    (minPositive : Long)\n\e[31m   |\e[0m        \
    \              Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpqwru0wtm.scala:21)\n\tat Problem$.main(tmpqwru0wtm.scala:28)\n\
    \tat Problem.main(tmpqwru0wtm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ {\n            (None, Some(positives.min))\n        } else if (positives.isEmpty)\
    \ {\n            (Some(negatives.max), None)\n        } else {\n            (Some(negatives.max),\
    \ Some(positives.min))\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzpdkri9i.scala:27)\n\tat Problem.main(tmpzpdkri9i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if(negative.isEmpty\
    \ && positive.isEmpty) None else Some(positive.minBy(x => x)) -> Some(negative.maxBy(x\
    \ => x))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2856qjlh.scala:18:49\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m(negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m Some(positive.minBy(\e[36mx\e[0m =>\
    \ x)) -> Some(negative.maxBy(\e[36mx\e[0m => x))\n\e[31m\e[31m   |\e[0m      \
    \                                           ^^^^\e[0m\n\e[31m   |\e[0m       \
    \                           Found:    None.type\n\e[31m   |\e[0m             \
    \                     Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660028688
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpd740yf9e.scala:21)\n\tat Problem$.main(tmpd740yf9e.scala:28)\n\
    \tat Problem.main(tmpd740yf9e.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmphgn04euk.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else Some(positive.minBy(x => x)) -> Some(negative.maxBy(x\
    \ => x))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptnses1hw.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m Some(positive.minBy(\e[36mx\e[0m =>\
    \ x)) -> Some(negative.maxBy(\e[36mx\e[0m => x))\n\e[31m\e[31m   |\e[0m      \
    \                                            ^^^^\e[0m\n\e[31m   |\e[0m      \
    \                            Found:    None.type\n\e[31m   |\e[0m            \
    \                      Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660028689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ {\n            (Some(None), Some(positives.min))\n        } else if (positives.isEmpty)\
    \ {\n            (Some(negatives.max), Some(None))\n        } else {\n       \
    \     (Some(negatives.max), Some(positives.min))\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpreiwn3m5.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpreiwn3m5.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        val maxNegative\
    \ = negative.max\n        val minPositive = positive.min\n        val maxPositive\
    \ = positive.max\n        if (maxNegative.isEmpty && maxPositive.isEmpty) {\n\
    \            (None, None)\n        } else if (maxNegative.isEmpty && maxPositive.isDefined)\
    \ {\n            (Some(maxPositive), None)\n        } else if (maxNegative.isDefined\
    \ && maxPositive.isEmpty) {\n            (None, Some(maxNegative))\n        }\
    \ else if (maxNegative.isDefined && maxPositive.isDefined) {\n            (Some(maxPositive),\
    \ Some(maxNegative))\n        } else {\n            (None, None)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnul_4rgh.scala:21:24 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (maxNegative.isEmpty && maxPositive.isEmpty)\
    \ {\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value isEmpty is not a member of Long\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpnul_4rgh.scala:23:31 ------------------------\e[0m\e[0m\n\
    \e[31m23 |\e[0m        } \e[33melse\e[0m \e[33mif\e[0m (maxNegative.isEmpty &&\
    \ maxPositive.isDefined) {\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   value isEmpty is not a member of Long\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnul_4rgh.scala:25:31 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        } \e[33melse\e[0m \e[33mif\e[0m (maxNegative.isDefined\
    \ && maxPositive.isEmpty) {\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   value isDefined is not a member of Long\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnul_4rgh.scala:27:31 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        } \e[33melse\e[0m \e[33mif\e[0m (maxNegative.isDefined\
    \ && maxPositive.isDefined) {\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   value isDefined is not a member of Long\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660028690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmphgn04euk.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkbznzq0k.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmphgn04euk.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpgrl6rcwd.scala:21)\n\tat Problem$.main(tmpgrl6rcwd.scala:28)\n\
    \tat Problem.main(tmpgrl6rcwd.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028690
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ >= 0l)\n        if (negatives.isEmpty)\
    \ {\n            (None, Some(positives.min))\n        } else if (positives.isEmpty)\
    \ {\n            (Some(negatives.max), None)\n        } else {\n            (Some(negatives.max),\
    \ Some(positives.min))\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpno6izhzs.scala:27)\n\tat Problem.main(tmpno6izhzs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyywnaf0.scala:28)\n\tat Problem.main(tmpuyywnaf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpigre589x.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028661
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ >= 0l)\n        negatives.reduceLeftOption(_\
    \ max _).orElse(positives.reduceLeftOption(_ min _))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnss3wy6p.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        negatives.reduceLeftOption(_\
    \ max _).orElse(positives.reduceLeftOption(_ min _))\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Option[Long]\n\e[31m   |\e[0m        Required:\
    \ \e[1m\e[32m(\e[0mOption[Long\e[1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e\
    [0m\e[1m\e[32mOption\e[0m\e[1m\e[32m[\e[0m\e[1m\e[32mLong\e[0m]\e[1m\e[32m)\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjf5rv9po.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjf5rv9po.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpakrtoxtj.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpakrtoxtj.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798752
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyywnaf0.scala:28)\n\tat Problem.main(tmpuyywnaf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ {\n            (None, Some(positives.min))\n        } else if (positives.isEmpty)\
    \ {\n            (Some(negatives.max), None)\n        } else {\n            (Some(negatives.max),\
    \ Some(positives.min))\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8hwfx_ls.scala:27)\n\tat Problem.main(tmp8hwfx_ls.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpakrtoxtj.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpakrtoxtj.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        val maxNegative\
    \ = negatives.max\n        val minPositive = positives.min\n        (maxNegative,\
    \ minPositive)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqdaifnw5.scala:20:9\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         Found:\
    \    (maxNegative : Long)\n\e[31m   |\e[0m         Required: Option[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqdaifnw5.scala:20:22\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                     Found:    (minPositive : Long)\n\e[31m   |\e[0m        \
    \              Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798777
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty) \n            (Some(None), Some(None))\n        else if\
    \ (positive.isEmpty) \n            (Some(None), Some(negative.min))\n        else\
    \ if (negative.isEmpty) \n            (Some(positive.max), Some(None))\n     \
    \   else \n            (Some(positive.max), Some(negative.min))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd83qenug.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd83qenug.scala:19:30\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                              ^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Found:    None.type\n\e[31m   |\e[0m          \
    \                    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpd83qenug.scala:21:18 --------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m            (Some(None), Some(negative.min))\n\e[31m\e[31m   |\e[0m  \
    \                ^^^^\e[0m\n\e[31m   |\e[0m                  Found:    None.type\n\
    \e[31m   |\e[0m                  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpd83qenug.scala:23:38 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            (Some(positive.max), Some(None))\n\e[31m\e\
    [31m   |\e[0m                                      ^^^^\e[0m\n\e[31m   |\e[0m\
    \                                      Found:    None.type\n\e[31m   |\e[0m  \
    \                                    Required: Long\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660028675
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (Some(negative.maxOption),\
    \ Some(positive.minOption))\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4j8o6kq5.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp4j8o6kq5.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4j8o6kq5.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4j8o6kq5.scala:21:19 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m (Some(negative.maxOption), Some(positive.minOption))\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                "
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfjnv4499.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ >= 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi0y10wzm.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi0y10wzm.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdk2v7la1.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdk2v7la1.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmphgn04euk.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if(negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnk1viyw_.scala:18:49\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m(negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                 ^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    None.type\n\e[31m \
    \  |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660028677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty) None\n        else if (positive.isEmpty) Some(negative.minOption)\n\
    \        else if (negative.isEmpty) Some(positive.maxOption)\n        else (Some(positive.maxOption),\
    \ Some(negative.minOption))\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo_413hb7.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (positive.isEmpty\
    \ && negative.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpo_413hb7.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positive.isEmpty) Some(negative.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo_413hb7.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (negative.isEmpty) Some(positive.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo_413hb7.scala:21:19 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m (Some(positive.maxOption), Some(negative.minOption))\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                "
  stdout: ''
  timestamp: 1659798754
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) \n            (None, None)\n        else if (negative.isEmpty)\
    \ \n            (Some(negative.min), Some(positive.max))\n        else if (positive.isEmpty)\
    \ \n            (Some(positive.min), Some(negative.max))\n        else \n    \
    \        (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpyba3aj7a.scala:21)\n\tat Problem$.main(tmpyba3aj7a.scala:28)\n\
    \tat Problem.main(tmpyba3aj7a.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmphgn04euk.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdk2v7la1.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdk2v7la1.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmphgn04euk.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphgn04euk.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660028664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjf5rv9po.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjf5rv9po.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660028663
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdup5424.scala:28)\n\tat Problem.main(tmpgdup5424.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmp2u9xrk76.scala:21)\n\tat Problem$.main(tmp2u9xrk76.scala:28)\n\
    \tat Problem.main(tmp2u9xrk76.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028688
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmp2u9xrk76.scala:21)\n\tat Problem$.main(tmp2u9xrk76.scala:28)\n\
    \tat Problem.main(tmp2u9xrk76.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660028688
