language: scala
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n\
    \        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n\
    \        val stackSize = lst.size\n        val queueSize = lst.size\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n\
    \        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n\
    \        val stackSize = lst.size\n        val queueSize = lst.size\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n\
    \        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n\
    \        val stackSize = lst.size\n        val queueSize = lst.size\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n\
    \        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n\
    \        val stackSize = lst.size\n        val queueSize = lst.size\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n\
    \        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n\
    \        val stackSize = lst.size\n        val queueSize = lst.size\n        val\
    \ stack = mutable.Stack[String]()\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjge_9aeb.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstack is already defined as \e[33mvalue\e[0m \e[35mstack\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjge_9aeb.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mqueue is already defined as \e[33mvalue\e[0m \e[35mqueue\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpjge_9aeb.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Queue[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpjge_9aeb.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is already\
    \ defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjge_9aeb.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mqueueSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mqueueSize is already defined as \e[33mvalue\e[0m \e[35mqueueSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31"
  stdout: ''
  timestamp: 1659795018
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodString = mutable.Set[String]()\n        val badString = mutable.Set[String]()\n\
    \        val goodParens = mutable.Set[String]()\n        val badParens = mutable.Set[String]()\n\
    \        val goodParensString = mutable.Set[String]()\n        val badParensString\
    \ = mutable.Set[String]()\n        val goodParensParens = mutable.Set[String]()\n\
    \        val badParensParens = mutable.Set[String]()\n        val goodParensParensString\
    \ = mutable.Set[String]()\n        val badParensParensString = mutable.Set[String]()\n\
    \        val goodParensParensParens = mutable.Set[String]()\n        val badParensParensParens\
    \ = mutable.Set[String]()\n        val goodParensParensParensString = mutable.Set[String]()\n\
    \        val badParensParensParensString = mutable.Set[String]()\n        val\
    \ goodParensParensParensParens = mutable.Set[String]()\n        val badParensParensParensParens\
    \ = mutable.Set[String]()\n        val goodParensParensParensParensString = mutable.Set[String]()\n\
    \        val badParensParensParensParensString = mutable.Set[String]()\n     \
    \   val goodParensParensParensParensParens = mutable.Set[String]()\n        val\
    \ badParensParensParensParensParens = mutable.Set[String]()\n        val goodParensParensParensParensParensString\
    \ = mutable.Set[String]()\n        val badParensParensParensParensParensString\
    \ = mutable.Set[String]()\n        val goodParensParensParensParensParensParens\
    \ = mutable.Set[String]()\n        val badParensParensParensParensParensParens\
    \ = mutable.Set[String]()\n        val goodParensParensParensParensParensParensString\
    \ = mutable.Set[String]()\n        val badParensParensParensParensParensParensString\
    \ = mutable.Set[String\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphba7x9mv.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphba7x9mv.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphba7x9mv.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphba7x9mv.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mgood\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphba7x9mv.scala:21:18\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mbad\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m       \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphba7x9mv.scala:22:25\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mgoodString\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-e"
  stdout: ''
  timestamp: 1659795441
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val newStack = if (open < 0 || close < 0) stack.toList else stack.drop(open).drop(close).reverse\n\
    \            val newStr = if (open < 0 || close < 0) str else str.substring(open\
    \ + 1, close)\n            val newResult = if (newStack.isEmpty) result else result.dropRight(newStack.size)\n\
    \            val newResult2 = if (newStr.isEmpty) newResult else newResult :+\
    \ newStr\n            stack.push(newStr)\n            result += newResult2\n \
    \       }\n        if (result.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps1sgnib2.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmps1sgnib2.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    if(str == \"(\") {\n                stack.push(str)\n            } else if(str\
    \ == \")\") {\n                val popped = stack.pop()\n                if(popped\
    \ == \"(\") {\n                    result.append(\"Yes\")\n                } else\
    \ {\n                    result.append(\"No\")\n                }\n          \
    \  } else {\n                result.append(\"No\")\n            }\n        }\n\
    \        return result.toString()\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1078uj_o.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp1078uj_o.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val openCount = stack.length\n      \
    \          val closeCount = stack.length\n                while(openCount > 0\
    \ && closeCount > 0) {\n                    if(openCount > closeCount) {\n   \
    \                     stack.pop()\n                        openCount -= 1\n  \
    \                  } else {\n                        stack.pop()\n           \
    \             closeCount -= 1\n                    }\n                }\n    \
    \            val openParens = stack.length\n                val closeParens =\
    \ stack.length\n                while(openParens > 0 && closeParens > 0) {\n \
    \                   if(openParens > closeParens) {\n                        stack.pop()\n\
    \                        openParens -= 1\n                    } else {\n     \
    \                   stack.pop()\n                        closeParens -= 1\n  \
    \                  }\n                }\n                val newStack = stack.mkString(\"\
    (\", \")\")\n                if(newStack == str) {\n                    result.append(\"\
    Yes\")\n                } else {\n                    result.append(\"No\")\n\
    \                }\n            }\n        }\n        return result.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn37_2azo.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpn37_2azo.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795440
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val openCount = stack.length\n            val closeCount = stack.length\n\
    \            if(openCount > closeCount) {\n                stack += str\n    \
    \            result += \"Yes\"\n            } else if(openCount < closeCount)\
    \ {\n                stack += str\n                result += \"No\"\n        \
    \    } else {\n                result += \"No\"\n            }\n        }\n  \
    \      result.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp57at94qw.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp57at94qw.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxIndex = stackSize - 1\n        val stackMaxValue = lst(stackMaxIndex)\n\
    \        val stackMin = stackSize + 1\n        val stackMinIndex = stackSize +\
    \ 1\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue\
    \ = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n     \
    \   val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMin\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwpvc8sfy.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwpvc8sfy.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMinValue\e[0m = lst(stackMinIndex)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackMinValue is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackMinValue\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwpvc8sfy.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMinValue\e[0m = lst(stackMinIndex)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackMinValue is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackMinValue\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwpvc8sfy.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMinValue\e[0m = lst(stackMinIndex)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackMinValue is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackMinValue\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwpvc8sfy.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMinValue\e[0m = lst(stackMinIndex)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackMinValue is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackMinValue\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwpvc8sfy.sc"
  stdout: ''
  timestamp: 1659795441
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open != -1 && close != -1) {\n                val openCount\
    \ = stack.length\n                val closeCount = stack.length\n            \
    \    val openParen = str.indexOf(\"(\")\n                val closeParen = str.indexOf(\"\
    )\")\n                val openParenCount = stack.length\n                val closeParenCount\
    \ = stack.length\n                stack.push(str)\n                while(openParenCount\
    \ > closeParenCount && openParenCount > openCount && closeParenCount > closeCount)\
    \ {\n                    if(stack.size == openParenCount) {\n                \
    \        val temp = stack.pop()\n                        if(temp.equals(str))\
    \ {\n                            result.append(\"Yes\")\n                    \
    \        result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpofq68dqu.scala:110:0 ---------------------------\e\
    [0m\e[0m\n\e[31m110 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpofq68dqu.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpofq68dqu.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpofq68dqu.scala:20:8\
    \ ---------------------\e[0m\e[0m\n\e[31m 20 |\e[0m        \e[33mfor\e[0m(i <-\
    \ \e[31m0\e[0m until lst.size) {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m\
    \    |\e[0m        Found:    Unit\n\e[31m    |\e[0m        Required: String\n\e\
    [31m 21 |\e[0m            \e[33mval\e[0m \e[36mstr\e[0m = lst(i)\n\e[31m 22 |\e\
    [0m            \e[33mval\e[0m \e[36mopen\e[0m = str.indexOf(\e[31m\"(\"\e[0m)\n\
    \e[31m 23 |\e[0m            \e[33mval\e[0m \e[36mclose\e[0m = str.indexOf(\e[31m\"\
    )\"\e[0m)\n\e[31m 24 |\e[0m            \e[33mif\e[0m(open != -\e[31m1\e[0m &&\
    \ close != -\e[31m1\e[0m) {\n\e[31m 25 |\e[0m                \e[33mval\e[0m \e\
    [36mopenCount\e[0m = stack.length\n\e[31m 26 |\e[0m                \e[33mval\e\
    [0m \e[36mcloseCount\e[0m = stack.length\n\e[31m 27 |\e[0m                \e[33mval\e\
    [0m \e[36mopenParen\e[0m = str.indexOf(\e[31m\"(\"\e[0m)\n\e[31m 28 |\e[0m   \
    \             \e[33mval\e[0m \e[36mcloseParen\e[0m = str.indexOf(\e[31m\")\"\e\
    [0m)\n\e[31m 29 |\e[0m                \e[33mval\e[0m \e[36mopenParenCount\e[0m\
    \ = stack.length\n\e[31m 30 |\e[0m                \e[33mval\e[0m \e[36mcloseParenCount\e\
    [0m = stack.length\n\e[31m 31 |\e[0m            "
  stdout: ''
  timestamp: 1659795441
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x.startsWith(\"(\"\
    ) => queue.enqueue(x)\n            case x if x.startsWith(\")\") => stack.push(x)\n\
    \            case x => badStr += x\n        })\n        while(!queue.isEmpty)\
    \ {\n            val curr = queue.dequeue()\n            if(!good.contains(curr))\
    \ {\n                good += curr\n                goodStr += curr\n         \
    \   }\n            if(!bad.contains(curr)) {\n                bad += curr\n  \
    \              badStr += curr\n            }\n            if(!stack.isEmpty) {\n\
    \                val top = stack.dequeue()\n                if(!good.contains(top))\
    \ {\n                    good += top\n                    goodStr += top\n   \
    \             }\n                if(!bad.contains(top)) {\n                  \
    \  bad += top\n                    badStr += top\n                }\n        \
    \    }\n        }\n        if(good.size == lst.size) {\n            return \"\
    Yes\"\n        }\n        if(bad.size == lst.size) {\n            return \"No\"\
    \n        }\n        if(goodStr.size == lst.size) {\n            return \"Yes\"\
    \n        }\n        if(badStr.size == lst.size) {\n            return \"No\"\n\
    \        }\n        return \"No\"\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsy3g06rf.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpsy3g06rf.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpsy3g06rf.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpsy3g06rf.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpsy3g06rf.scala:22:22 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mgoodStr\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpsy3g06rf.scala:23:21 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mbadStr\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m"
  stdout: ''
  timestamp: 1659795439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.push(x)\n                }\n               \
    \ case \")(\"  => {\n                    open.push(x)\n                }\n   \
    \             case \")(\" => {\n                    stack.push(x)\n          \
    \      }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8jgqcjag.scala:128:4 ---------------------------\e\
    [0m\e[0m\n\e[31m128 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp8jgqcjag.scala:145:0 ---------------------------\e[0m\e[0m\n\e[31m145\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8jgqcjag.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8jgqcjag.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8jgqcjag.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp8jgqcjag.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmp8jgqcjag.scala:129:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m129 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0"
  stdout: ''
  timestamp: 1659795059
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        lst.foreach(x => if (x == \"\
    (\") stack.push(x) else if (x == \")\") queue.push(x) else if (stack.size == 0\
    \ && queue.size == 0) good.add(x))\n        if (good.size == 0) \"No\" else \"\
    Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv0rfzun9.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpv0rfzun9.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpv0rfzun9.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprdr94pzo.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprdr94pzo.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackSize is already defined as \e[33mvalue\e[0m \e[35mstackSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprdr94pzo.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprdr94pzo.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackSize is already defined as \e[33mvalue\e[0m \e[35mstackSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprdr94pzo.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same gro"
  stdout: ''
  timestamp: 1659795049
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String,\
    \ Int]()\n        lst.foreach(x => {\n            x match {\n                case\
    \ \")\" => {\n                    queue.enqueue(x)\n                }\n      \
    \          case \")()\" => {\n                    queue.enqueue(x)\n         \
    \           stack.push(x)\n                }\n                case \")(\" => {\n\
    \                    queue.enqueue(x)\n                    stack.push(x)\n   \
    \             }\n                case \")()()\" => {\n                    queue.enqueue(x)\n\
    \                    stack.push(x)\n                    queue.enqueue(x)\n   \
    \                 stack.push(x)\n                }\n                case \")(()\"\
    \ => {\n                    queue.enqueue(x)\n                    stack.push(x)\n\
    \                    queue.enqueue(x)\n                    stack.push(x)\n   \
    \                 queue.enqueue(x)\n                    stack.push(x)\n      \
    \          }\n                case \")()(\" => {\n                    queue.enqueue(x)\n\
    \                    stack.push(x)\n                    queue.enqueue(x)\n   \
    \                 stack.push(x)\n                    queue.enqueue(x)\n      \
    \              stack.push(x)\n                    queue.enqueue(x)\n         \
    \           stack.push(x)\n                }\n                case \")()(()\"\
    \ => {\n                    queue.enqueue(x)\n                    stack.push(x)\n\
    \                    queue.enqueue(x)\n                    stack.push(x)\n   \
    \                 queue.enqueue(x)\n                    stack.push(x)\n      \
    \              queue.enqueue(x)\n                    stack.push(x)\n         \
    \           queue.enqueue(x)\n                    stack.push(x)\n            \
    \    }\n                case \")()(()()\" => {\n                    queue.enqueue(x)\n\
    \                    stack.push(x)\n                    queue.enqueue(x)\n   \
    \                 stack.push(x)\n                    queue.enqueue(x)\n      \
    \              stack.push(x)\n                    queue.enqueue(x)\n         \
    \           stack.push(x)\n                    queue.enqueue(x)\n            \
    \        stack.push(x)\n                    queue.enqueue(x)\n               \
    \     stack.push(x)\n                    queue.enqueue(x)\n                  \
    \  stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n\
    \                    queue.enqueue(x)\n                    stack.push(x)\n   \
    \                 queue.enqueue(x)\n                    stack.push(x)\n      \
    \              queue.enqueue(x)\n                    stack.push(x)\n         \
    \           queue.enqueue(x)\n                    stack.push(x)\n            \
    \        queue.enqueue(x)\n                    stack.push(x)\n               \
    \     queue.enqueue(x)\n                    stack.push(x)\n                  \
    \  queue.en\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo399t2jt.scala:122:0 ---------------------------\e\
    [0m\e[0m\n\e[31m122 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo399t2jt.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo399t2jt.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo399t2jt.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mgood\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo399t2jt.scala:21:18\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mbad\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m       \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo399t2jt.scala:22:22\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mgoodStr\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-"
  stdout: ''
  timestamp: 1659795441
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => open.push(x)\n           \
    \     case \")(\"  => stack.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpymzfq6v3.scala:74:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m                \e[33mcase\e[0m \")\n\e[31m\e[31m   |\e\
    [0m                     ^\e[0m\n\e[31m   |\e[0m                     unclosed string\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmpymzfq6v3.scala:76:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpymzfq6v3.scala:92:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m92 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpymzfq6v3.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpymzfq6v3.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpymzfq6v3.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpymzfq6v3.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set"
  stdout: ''
  timestamp: 1659795439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        lst.foreach(x => if (x.contains(\"(\")) stack.push(x) else if (x.contains(\"\
    )\")) queue.push(x) else if (stack.size == 0 && queue.size == 0) good.add(x) else\
    \ if (stack.size > 0 && queue.size == 0) bad.add(x) else if (stack.size > 0 &&\
    \ queue.size > 0) goodStr.add(x) else if (stack.size == 0 && queue.size > 0) badStr.add(x))\n\
    \        if (good.size == 0 && bad.size == 0) \"No\" else \"Yes\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9wm2zs9x.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9wm2zs9x.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9wm2zs9x.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp9wm2zs9x.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp9wm2zs9x.scala:22:22 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mgoodStr\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9wm2zs9x.scala:23:21 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mbadStr\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m"
  stdout: ''
  timestamp: 1659795439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => stack.push(x)\n          \
    \      case \")(\"  => stack.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpqvlgfgda.scala:74:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m                \e[33mcase\e[0m \")\n\e[31m\e[31m   |\e\
    [0m                     ^\e[0m\n\e[31m   |\e[0m                     unclosed string\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmpqvlgfgda.scala:76:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqvlgfgda.scala:92:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m92 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpqvlgfgda.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpqvlgfgda.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set"
  stdout: ''
  timestamp: 1659795020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach { s =>\n            if (s.startsWith(\"(\")) {\n        \
    \        open += s\n            } else if (s.startsWith(\")\")) {\n          \
    \      close += s\n            } else {\n                stack += s\n        \
    \    }\n        }\n        val openCount = open.count\n        val closeCount\
    \ = close.count\n        if (openCount == closeCount) {\n            val openParens\
    \ = open.mkString(\"(\", \", \", \")\")\n            val closeParens = close.mkString(\"\
    (\", \", \", \")\")\n            val newStack = stack.filterNot(s => openParens.contains(s))\n\
    \            val newStack2 = stack.filterNot(s => closeParens.contains(s))\n \
    \           if (newStack.isEmpty && newStack2.isEmpty) {\n                result\
    \ += \"Yes\"\n            } else {\n                result += \"No\"\n       \
    \     }\n        } else {\n            result += \"No\"\n        }\n        result.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgxlcs4yv.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpgxlcs4yv.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpgxlcs4yv.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpgxlcs4yv.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => if (x == \"(\") stack += x else stack.pop())\n     \
    \   stack.foreach(x => if (x == \"(\") result += \"Yes\" else result += \"No\"\
    )\n        result.mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo2udhslv.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpo2udhslv.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val open = mutable.Set[String]()\n\
    \        val close = mutable.Set[String]()\n        lst.foreach {\n          \
    \  x =>\n                if (x == \"(\") open += x\n                else if (x\
    \ == \")\") close += x\n                else {\n                    if (open.contains(x))\
    \ stack += x\n                    else if (close.contains(x)) queue += x\n   \
    \                 else {\n                        if (stack.size == 0 && queue.size\
    \ == 0) result += \"Yes\"\n                        else if (stack.size == 0 &&\
    \ queue.size == 1) result += \"No\"\n                        else if (stack.size\
    \ > 0 && queue.size == 0) result += \"No\"\n                        else if (stack.size\
    \ > 0 && queue.size == 1) result += \"Yes\"\n                        else if (stack.size\
    \ == 1 && queue.size == 0) result += \"Yes\"\n                        else if\
    \ (stack.size == 1 && queue.size == 1) result += \"No\"\n                    \
    \    else result += \"No\"\n                    }\n                }\n       \
    \ }\n        result.toString()\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpywifnbmr.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpywifnbmr.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpywifnbmr.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpywifnbmr.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpywifnbmr.scala:22:20 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize -\
    \ 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stack\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2nggw4af.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2nggw4af.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMaxIndex\e[0m = stackSize - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackMaxIndex is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackMaxIndex\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2nggw4af.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMaxSize\e[0m = stackSize - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackMaxSize is already\
    \ defined as \e[33mvalue\e[0m \e[35mstackMaxSize\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2nggw4af.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMaxIndex\e[0m = stackSize - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackMaxIndex is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackMaxIndex\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2nggw4af.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMaxSize\e[0m = stackSize - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackMaxSize is already\
    \ defined as \e[33mvalue\e[0m \e[35mstackMaxSize\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2nggw4af.scala:28:12\
    \ --"
  stdout: ''
  timestamp: 1659979657
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach { s =>\n            val isOpen = s.contains(\"(\")\n    \
    \        val isClose = s.contains(\")\")\n            if (isOpen && isClose) {\n\
    \                stack += s\n            } else if (isOpen) {\n              \
    \  stack += s\n            } else if (isClose) {\n                val open = stack.pop()\n\
    \                val close = s\n                result += (open + close)\n   \
    \         }\n        }\n        if (result.size == lst.size) {\n            val\
    \ str = result.mkString\n            if (str.contains(\"(\") && str.contains(\"\
    )\")) {\n                return \"Yes\"\n            } else {\n              \
    \  return \"No\"\n            }\n        } else {\n            return \"No\"\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9tkp2wv9.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9tkp2wv9.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n\
    \        val queueSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val queueMax = queueSize - 1\n        val stackIndex = 0\n        val queueIndex\
    \ = 0\n        val stackIsEmpty = stackIndex == stackMax\n        val queueIsEmpty\
    \ = queueIndex == queueMax\n        while(stackIsEmpty || queueIsEmpty) {\n  \
    \          if(stackIsEmpty) {\n                stackIndex += 1\n             \
    \   stackIsEmpty = stackIndex == stackMax\n            }\n            if(queueIsEmpty)\
    \ {\n                queueIndex += 1\n                queueIsEmpty = queueIndex\
    \ == queueMax\n            }\n            val stack = lst(stackIndex)\n      \
    \      val queue = lst(queueIndex)\n            val stackSize = stack.size\n \
    \           val queueSize = queue.size\n            val stackMax = stackSize -\
    \ 1\n            val queueMax = queueSize - 1\n            val stackIndex = 0\n\
    \            val queueIndex = 0\n            val stackIsEmpty = stackIndex ==\
    \ stackMax\n            val queueIsEmpty = queueIndex == queueMax\n          \
    \  val stackIsOpen = stackIndex > 0\n            val queueIsOpen = queueIndex\
    \ > 0\n            val stackIsClosed = stackIndex < stackMax\n            val\
    \ queueIsClosed = queueIndex < queueMax\n            val stackIsOpenParen = stackIsOpen\
    \ && stackIsClosed\n            val queueIsOpenParen = queueIsOpen && queueIsClosed\n\
    \            val stackIsCloseParen = stackIsClosed && stackIsOpen\n          \
    \  val queueIsCloseParen = queueIsClosed && queueIsOpen\n            val stackIsCloseParenOrOpen\
    \ = stackIsCloseParen || stackIsOpenParen\n            val queueIsCloseParenOrOpen\
    \ = queueIsCloseParen || queueIsOpenParen\n            if(stackIsOpenParen) {\n\
    \                stackIndex += 1\n                stackIsEmpty = stackIndex ==\
    \ stackMax\n            }\n            if(queueIsOpenParen) {\n              \
    \  queueIndex += 1\n                queueIsEmpty = queueIndex == queueMax\n  \
    \          }\n            val stack = lst(stackIndex)\n            val queue =\
    \ lst(queueIndex)\n            val stackSize = stack.size\n            val queueSize\
    \ = queue.size\n            val stackMax = stackSize - 1\n            val queueMax\
    \ = queueSize - 1\n            val stackIndex = 0\n            val queueIndex\
    \ = 0\n            val stackIsEmpty = stack\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpisaamshz.scala:92:0 ----------------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpisaamshz.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpisaamshz.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpisaamshz.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpisaamshz.scala:66:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m66 |\e[0m            \e[33mval\e\
    [0m \e[36mstack\e[0m = lst(stackIndex)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstack is already defined as \e[33mvalue\e[0m \e[35mstack\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpisaamshz.scala:67:16 ---------------------------\e[0m\e[0m\n\e\
    [31m67 |\e[0m            \e[33mval\e[0m \e[36mqueue\e[0m = lst(queueIndex)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mqueue is already defined as \e[33mvalue\e[0m \e[35mqueue\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e"
  stdout: ''
  timestamp: 1659979659
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach {\n            s =>\n                val openCount = open.count(_\
    \ == s)\n                val closeCount = close.count(_ == s)\n              \
    \  if (openCount == closeCount) {\n                    result += s\n         \
    \       } else if (openCount > closeCount) {\n                    stack += s\n\
    \                } else if (openCount < closeCount) {\n                    result\
    \ += s\n                    stack += s\n                }\n        }\n       \
    \ if (stack.size == 0) {\n            return \"No\"\n        } else {\n      \
    \      return \"Yes\"\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjekwcaa9.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpjekwcaa9.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpjekwcaa9.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpjekwcaa9.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => open.push(x)\n           \
    \     case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n\
    \                case \")()\" => stack.push(x)\n                case \")\" =>\
    \ close.push(x)\n                case \")()\" => stack.push(x)\n             \
    \   case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n\
    \                case \")()\" => stack.push(x)\n                case \")()()\"\
    \ => stack.push(x)\n                case \")()()\" => stack.push(x)\n        \
    \        case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n\
    \                case \")()()\" => stack.push(x)\n                case \")()\"\
    \ => stack.push(x)\n                case \")()()\" => stack.push(x)\n        \
    \        case \")()()\" => stack.push(x)\n                case \")()\" => stack.push(x)\n\
    \                case \")()()\" => stack.push(x)\n                case \")()()\"\
    \ => stack.push(x)\n                case \")()\" => stack.push(x)\n          \
    \      case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n\
    \                case \")()\" => stack.push(x)\n                case \")()()\"\
    \ => stack.push(x)\n                case \")()()\" => stack.push(x)\n        \
    \        case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n\
    \                case \")()()\" => stack.push(x)\n                case \")()\"\
    \ => stack.push(x)\n                case \")()()\" => stack.push(x)\n        \
    \        case \")()()\" => stack.push(x)\n                case \")()\" => stack.push(x)\n\
    \                case \")()()\" => stack.push(x)\n                case \")()()\"\
    \ => stack.push(x)\n                case \")()\" => stack.push(x)\n          \
    \      case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n\
    \                case \")()\" => stack.push(x)\n                case \")()()\"\
    \ => stack.push(x)\n                case \")()()\" => stack.push(x)\n        \
    \        case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n\
    \                case \")()()\" => stack.push(x)\n                case \")()\"\
    \ => stack.push(x)\n                case \")()()\" => stack.push(x)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1f3zwzxm.scala:88:0 ----------------------------\e\
    [0m\e[0m\n\e[31m88 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m')' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1f3zwzxm.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1f3zwzxm.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1f3zwzxm.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1f3zwzxm.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1f3zwzxm.scala:22:19\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found: \
    \   Unit\n\e[31m   |\e[0m        Required: String\n\e[31m23 |\e[0m           \
    \ x \e[33mmatch\e[0m {\n\e[31m24 |\e[0m                \e[33mcase\e[0m \e[31m\"\
    )\"\e[0m => close."
  stdout: ''
  timestamp: 1659979658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.push(x)\n                }\n               \
    \ case \")(\"  => {\n                    open.push(x)\n                }\n   \
    \             case \")(\" => {\n                    stack.push(x)\n          \
    \      }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")\" => {\n                    close.push(x)\n\
    \                }\n                case \")\" => {\n                    result.add(\"\
    Yes\")\n                }\n                case \")\" => {\n                 \
    \   result.add(\"No\")\n                }\n                case \")(\" => {\n\
    \                    val temp = stack.pop()\n                    val temp2 = stack.pop()\n\
    \                    val temp3 = stack.pop()\n                    val temp4 =\
    \ stack.pop()\n                    val temp5 = stack.pop()\n                 \
    \   val temp6 = stack.pop()\n                    val temp7 = stack.pop()\n   \
    \                 val temp8 = stack.pop()\n                    val temp9 = stack.pop()\n\
    \                    val temp10 = stack.pop()\n                    val temp11\
    \ = stack.pop()\n                    val temp12 = stack.pop()\n              \
    \      val temp13 = stack.pop()\n                    val temp14 = stack.pop()\n\
    \                    val temp15 = stack.pop()\n                    val temp16\
    \ = stack.pop()\n                    val temp17 = stack.pop()\n              \
    \      val temp18 = stack.pop()\n                    val temp19 = stack.pop()\n\
    \                    val temp20 = stack.pop()\n                    val temp21\
    \ = stack.pop()\n                    val temp22 = stack.pop()\n              \
    \      val temp23 = stack.pop()\n                    val temp24 = stack.pop()\n\
    \                    val temp25 = stack.pop()\n                    val temp26\
    \ = stack.pop()\n                    val temp27 = stack.pop()\n              \
    \      val temp28 = stack.pop()\n                    val temp29 = stack.pop()\n\
    \                    val temp30 = stack.pop()\n                    val temp31\
    \ = stack.pop()\n                    val temp32 = stack.pop()\n              \
    \      val temp33 = stack.pop()\n                    val temp34 = stack.pop()\n\
    \                    val temp35 = stack.pop()\n                    val temp36\
    \ = stack.pop()\n                    val temp37 = stack.pop()\n              \
    \      val temp38 = stack.pop()\n                    val temp39 = stack.pop()\n\
    \                    val temp40 = stack.pop()\n                    val temp41\
    \ = stack.pop()\n                    val temp42 = stack.pop()\n              \
    \      val temp43 = stack.pop()\n                    val temp44 = stack.pop()\n\
    \                    val temp45 = stack.pop()\n                    val temp4\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc7i30t2h.scala:92:4 ----------------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc7i30t2h.scala:109:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m109 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpc7i30t2h.scala:18:20 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpc7i30t2h.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpc7i30t2h.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpc7i30t2h.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmpc7i30t2h.scala:93:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m93 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e"
  stdout: ''
  timestamp: 1659979655
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => stack.push(x)\n          \
    \      case \")(\"  => stack.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpqvlgfgda.scala:74:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m                \e[33mcase\e[0m \")\n\e[31m\e[31m   |\e\
    [0m                     ^\e[0m\n\e[31m   |\e[0m                     unclosed string\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmpqvlgfgda.scala:76:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqvlgfgda.scala:92:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m92 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpqvlgfgda.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpqvlgfgda.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set"
  stdout: ''
  timestamp: 1659795020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n\
    \        val queueSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val queueMax = queueSize - 1\n        val stackArray = Array.ofDim[String](stackMax)\n\
    \        val queueArray = Array.ofDim[String](queueMax)\n        val stackArraySize\
    \ = stackMax * 2\n        val queueArraySize = queueMax * 2\n        val stackArrayIndex\
    \ = 0\n        val queueArrayIndex = 0\n        val stackArrayIndex2 = 0\n   \
    \     val queueArrayIndex2 = 0\n        val stackArrayIndex3 = 0\n        val\
    \ queueArrayIndex3 = 0\n        val stackArrayIndex4 = 0\n        val queueArrayIndex4\
    \ = 0\n        val stackArrayIndex5 = 0\n        val queueArrayIndex5 = 0\n  \
    \      val stackArrayIndex6 = 0\n        val queueArrayIndex6 = 0\n        val\
    \ stackArrayIndex7 = 0\n        val queueArrayIndex7 = 0\n        val stackArrayIndex8\
    \ = 0\n        val queueArrayIndex8 = 0\n        val stackArrayIndex9 = 0\n  \
    \      val queueArrayIndex9 = 0\n        val stackArrayIndex10 = 0\n        val\
    \ queueArrayIndex10 = 0\n        val stackArrayIndex11 = 0\n        val queueArrayIndex11\
    \ = 0\n        val stackArrayIndex12 = 0\n        val queueArrayIndex12 = 0\n\
    \        val stackArrayIndex13 = 0\n        val queueArrayIndex13 = 0\n      \
    \  val stackArrayIndex14 = 0\n        val queueArrayIndex14 = 0\n        val stackArrayIndex15\
    \ = 0\n        val queueArrayIndex15 = 0\n        val stackArrayIndex16 = 0\n\
    \        val queueArrayIndex16 = 0\n        val stackArrayIndex17 = 0\n      \
    \  val queueArrayIndex17 = 0\n        val stackArrayIndex18 = 0\n        val queueArrayIndex18\
    \ = 0\n        val stackArrayIndex19 = 0\n        val queueArrayIndex19 = 0\n\
    \        val stackArrayIndex20 = 0\n        val queueArrayIndex20 = 0\n      \
    \  val stackArrayIndex21 = 0\n        val queueArrayIndex21 = 0\n        val stackArrayIndex22\
    \ = 0\n        val queueArrayIndex22 = 0\n        val stackArrayIndex23 = 0\n\
    \        val queueArrayIndex23 = 0\n        val stackArrayIndex24 = 0\n      \
    \  val queueArrayIndex24 = 0\n        val stackArrayIndex25 = 0\n        val queueArray\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx9tuq6oj.scala:79:4 ----------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx9tuq6oj.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx9tuq6oj.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx9tuq6oj.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx9tuq6oj.scala:79:5\
    \ ---------------------\e[0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659979657
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x.startsWith(\"(\"\
    ) => queue.enqueue(x)\n            case x if x.startsWith(\")\") => stack.push(x)\n\
    \            case x => bad.add(x)\n        })\n        while(!queue.isEmpty &&\
    \ !stack.isEmpty) {\n            val x = queue.dequeue()\n            val y =\
    \ stack.pop()\n            good += x + y\n            bad += y\n            x\
    \ match {\n                case x if x.startsWith(\"(\") => queue.enqueue(x)\n\
    \                case x if x.startsWith(\")\") => stack.push(x)\n            \
    \    case x => bad.add(x)\n            }\n        }\n        if (good.size ==\
    \ lst.size) {\n            return \"Yes\"\n        } else {\n            return\
    \ \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpe9ad2ggd.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpe9ad2ggd.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpe9ad2ggd.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpe9ad2ggd.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") open += x\n         \
    \   if (x == \")\") close += x\n        })\n        val openCount = open.count\n\
    \        val closeCount = close.count\n        if (openCount == closeCount) {\n\
    \            val openList = open.mkString(\"(\", \")\")\n            val closeList\
    \ = close.mkString(\"(\", \")\")\n            val newList = openList + closeList\n\
    \            val newStack = mutable.Stack[String]()\n            newStack.push(newList)\n\
    \            while (!newStack.isEmpty) {\n                val newList = newStack.pop()\n\
    \                if (newList.contains(\"(\") && newList.contains(\")\")) {\n \
    \                   result += \"Yes\"\n                } else {\n            \
    \        result += \"No\"\n                }\n            }\n        } else {\n\
    \            result += \"No\"\n        }\n        result.toString()\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppyjpraim.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppyjpraim.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppyjpraim.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmppyjpraim.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppyjpraim.scala:32:27 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36mnewStack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659979654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        for(i <- 0 until lst.length){\n\
    \            val str = lst(i)\n            if(!(str.contains(\"(\") || str.contains(\"\
    )\"))){\n                return \"No\"\n            }\n            if(!(str.contains(\"\
    (\"))){\n                stack += str\n            }\n            if(!(str.contains(\"\
    )\"))) {\n                queue += str\n            }\n        }\n        while(!stack.isEmpty\
    \ && !queue.isEmpty){\n            val str = stack.pop()\n            val str2\
    \ = queue.pop()\n            if(str2.contains(\"(\") && str2.contains(\")\")){\n\
    \                result += (str)\n            }\n        }\n        if(!stack.isEmpty\
    \ && !queue.isEmpty){\n            return \"No\"\n        }\n        if(!stack.isEmpty\
    \ && queue.isEmpty){\n            return \"Yes\"\n        }\n        if(!queue.isEmpty\
    \ && !stack.isEmpty){\n            return \"Yes\"\n        }\n        if(!queue.isEmpty\
    \ && stack.isEmpty){\n            return \"No\"\n        }\n        if(!queue.isEmpty\
    \ && !stack.isEmpty){\n            return \"Yes\"\n        }\n        return \"\
    No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph7b20094.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmph7b20094.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmph7b20094.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        lst.foreach(x => stack += x)\n    \
    \    while(stack.nonEmpty) {\n            val cur = stack.pop()\n            val\
    \ len = cur.length\n            val newStack = mutable.Stack[String]()\n     \
    \       for(i <- 0 until len) {\n                val c = cur.charAt(i)\n     \
    \           if(c == '(') {\n                    newStack += cur.substring(0, i)\n\
    \                    stack.push(\"(\" + cur.substring(i + 1))\n              \
    \  } else if(c == ')') {\n                    if(newStack.nonEmpty) {\n      \
    \                  val newStackSize = newStack.size - 1\n                    \
    \    val newStackString = newStack.mkString\n                        if(newStackSize\
    \ == 0) {\n                            result += \"(\" + newStackString + \")\"\
    \n                        } else if(newStackSize == stackSize) {\n           \
    \                 result += \"(\" + newStackString + \")\"\n                 \
    \       } else {\n                            result += \"(\" + newStackString\
    \ + \")\"\n                        }\n                    }\n                \
    \    newStack += cur.substring(i + 1)\n                    stack.pop\n       \
    \         }\n            }\n        }\n        if(result.nonEmpty) {\n       \
    \     val result = result.mkString\n            if(result.length == stackSize)\
    \ {\n                result\n            } else {\n                \"No\"\n  \
    \          }\n        } else {\n            \"No\"\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg3438fmo.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpg3438fmo.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpg3438fmo.scala:25:27 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mnewStack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpg3438fmo.scala:49:25 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m            \e[33mval\e[0m \e[36mresult\e[0m = result.mkString\n\
    \e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m        \
    \                 Recursive \e[33mvalue\e[0m \e[35mresult\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val open = mutable.Set[String]()\n\
    \        val close = mutable.Set[String]()\n        lst.foreach(x => x match {\n\
    \            case x if x == \")\" => close.add(x)\n            case x if x ==\
    \ \"(\" => open.add(x)\n            case _ => queue.enqueue(x)\n        })\n \
    \       while(!queue.isEmpty) {\n            val x = queue.poll\n            x\
    \ match {\n                case x if x == \")\" => close.add(x)\n            \
    \    case x if x == \"(\" => open.add(x)\n                case _ => stack.push(x)\n\
    \            }\n        }\n        while(!stack.isEmpty) {\n            val x\
    \ = stack.poll\n            x match {\n                case x if x == \")\" =>\
    \ close.add(x)\n                case x if x == \"(\" => open.add(x)\n        \
    \        case _ => result.enqueue(x)\n            }\n        }\n        if(close.size\
    \ == open.size && close.size == result.size) {\n            val good = close.intersect(open).intersect(result)\n\
    \            if(good.size == 0) {\n                return \"No\"\n           \
    \ } else {\n                return \"Yes\"\n            }\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_pg891ol.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp_pg891ol.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp_pg891ol.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp_pg891ol.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp_pg891ol.scala:22:20 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result += \"No\"\n\
    \            } else {\n                val stackSize = stack.size\n          \
    \      if(open < close && stackSize > 0) {\n                    result += \"Yes\"\
    \n                } else {\n                    result += \"No\"\n           \
    \     }\n                stack.push(str)\n            }\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprdrq5gbj.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmprdrq5gbj.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.add(x)\n                    stack.push(x)\n\
    \                }\n                case \"(\" => {\n                    open.add(x)\n\
    \                    stack.push(x)\n                }\n                case _\
    \ => {\n                    stack.push(x)\n                }\n            }\n\
    \        })\n        while(stack.nonEmpty) {\n            val x = stack.pop()\n\
    \            x match {\n                case \")\" => {\n                    close.add(x)\n\
    \                    stack.push(x)\n                }\n                case \"\
    (\" => {\n                    open.add(x)\n                    stack.push(x)\n\
    \                }\n                case _ => {\n                    result.add(x)\n\
    \                }\n            }\n        }\n        if(close.size == open.size\
    \ && close.size == result.size) {\n            return \"Yes\"\n        } else\
    \ {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdsz00nzr.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpdsz00nzr.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpdsz00nzr.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpdsz00nzr.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        lst.foreach(x => {\n  \
    \          x match {\n                case \")\" => stack.pop\n              \
    \  case \")(\"  => stack.pop\n                case \")()\" => stack.pop\n    \
    \            case \")()()\" => stack.pop\n                case \")()()()\" =>\
    \ stack.pop\n                case \")()()()()\" => stack.pop\n               \
    \ case \")()()()()()\" => stack.pop\n                case \")()()()()()()\" =>\
    \ stack.pop\n                case \")()()()()()()()\" => stack.pop\n         \
    \       case \")()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()\"\
    \ => stack.pop\n                case \")()()()()()()()()()()\" => stack.pop\n\
    \                case \")()()()()()()()()()()()\" => stack.pop\n             \
    \   case \")()()()()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()()()\"\
    \ => stack.pop\n                case \")()()()()()()()()()()()\" => stack.pop\n\
    \                case \")()()()()()()()()()()()()\" => stack.pop\n           \
    \     case \")()()()()()()()()()()()()\" => stack.pop\n                case \"\
    )()()()()()()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()()()()()\"\
    \ => stack.pop\n                case \")()()()()()()()()()()()()()\" => stack.pop\n\
    \                case \")()()()()()()()()()()()()()\" => stack.pop\n         \
    \       case \")()()()()()()()()()()()()()()\" => stack.pop\n                case\
    \ \")()()()()()()()()()()()()()()\" => stack.pop\n                case \")()()()()()()()()()()()()()()\"\
    \ => stack.pop\n                case \")()()()()()()()()()()()()()()()\" => stack.pop\n\
    \                case \")()()()()()()()()()()()()()()()\" => stack.pop\n     \
    \           case \")()()()()()()()()()()()()()()()\" => stack.pop\n          \
    \      case \")()()()()()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmppkz13n0z.scala:51:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m                \e[33mcase\e[0m \")()()()()()\n\e[31m\e\
    [31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                    \
    \ unclosed string literal\n\e[31m\e[31m-- Error: /tmp/tmppkz13n0z.scala:53:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m53 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                 end of statement expected but '=' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmppkz13n0z.scala:69:0 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m')' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppkz13n0z.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppkz13n0z.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppkz13n0z.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppkz13n0z.scala:53:4\
    \ -------------------------\e[0m\e[0m\n\e[31m53 |\e[0m    \e[33mdef\e[0m \e[36mmain\e\
    [0m(\e[36marg"
  stdout: ''
  timestamp: 1659979654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x contains \"(\") {\n           \
    \     open += x\n            } else {\n                close += x\n          \
    \  }\n        })\n        val openCount = open.size\n        val closeCount =\
    \ close.size\n        if (openCount == closeCount) {\n            val openStr\
    \ = open.toList\n            val closeStr = close.toList\n            val openStrCount\
    \ = openStr.size\n            val closeStrCount = closeStr.size\n            if\
    \ (openStrCount == closeStrCount) {\n                val openStrSet = openStr.toSet\n\
    \                val closeStrSet = closeStr.toSet\n                if (openStrSet.size\
    \ == closeStrSet.size && openStrSet.size == openStrCount) {\n                \
    \    val openStrSetCount = openStrSet.size\n                    val closeStrSetCount\
    \ = closeStrSet.size\n                    if (openStrSetCount == closeStrSetCount)\
    \ {\n                        val openStrSetSet = openStrSet.toSet\n          \
    \              val closeStrSetSet = closeStrSet.toSet\n                      \
    \  if (openStrSetSet.size == closeStrSetSet.size && openStrSetSet.size == openStrSetCount)\
    \ {\n                            val openStrSetSetCount = openStrSetSet.size\n\
    \                            val closeStrSetSetCount = closeStrSetSet.size\n \
    \                           if (openStrSetSetCount == closeStrSetSetCount) {\n\
    \                                val openStrSetSetSetCount = openStrSetSet.size\n\
    \                                val closeStrSetSetCount = closeStrSetSet.size\n\
    \                                if (openStrSetSetCount == closeStrSetSetCount)\
    \ {\n                                    val openStrSetSetSetCount = openStrSetSet.size\n\
    \                                    val closeStrSetSetCount = closeStrSetSet.size\n\
    \                                    if (openStrSetSetCount == closeStrSetSetCount)\
    \ {\n                                        val openStrSetSetSetCount = openStrSetSet.size\n\
    \                                        val closeStrSetSetCount = closeStrSetSet.size\n\
    \                                        if (openStrSetSetCount == closeStrSetSetCount)\
    \ {\n                                            return \"Yes\"\n            \
    \                            }\n                                    }\n      \
    \                          }\n                            }\n                \
    \        }\n                    }\n                }\n            }\n        }\n\
    \        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm8rs93ew.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpm8rs93ew.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpm8rs93ew.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpm8rs93ew.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") {\n                open\
    \ += x\n                stack.push(x)\n            } else if (x == \")\") {\n\
    \                close += x\n                val last = stack.pop()\n        \
    \        if (last == \"(\") {\n                    open += last\n            \
    \    } else if (last == \")\") {\n                    close += last\n        \
    \        } else {\n                    result += \"No\"\n                    return\n\
    \                }\n            } else {\n                result += \"No\"\n \
    \               return\n            }\n        })\n        if (open.length ==\
    \ close.length) {\n            result += \"Yes\"\n        } else {\n         \
    \   result += \"No\"\n        }\n        result.toString()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3lyzf2o0.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp3lyzf2o0.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp3lyzf2o0.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp3lyzf2o0.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp3lyzf2o0.scala:35:20 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                    \e[33mreturn\e[0m\n\e[31m\e[31m \
    \  |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0m                    Found:\
    \    Unit\n\e[31m   |\e[0m                    Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3lyzf2o0.scala:39:16 --------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                \e[33mreturn\e[0m\n\e[31m\e[31m   |"
  stdout: ''
  timestamp: 1659979657
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpoihlwpih.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpoihlwpih.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgoodStr\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mgoodStr is already\
    \ defined as \e[33mvalue\e[0m \e[35mgoodStr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpoihlwpih.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbadStr\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbadStr is already\
    \ defined as \e[33mvalue\e[0m \e[35mbadStr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpoihlwpih.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgoodStr\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mgoodStr is already\
    \ defined as \e[33mvalue\e[0m \e[35mgoodStr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpoihlwpih.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbadStr\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbadStr is already\
    \ defined as \e[33mvalue\e[0m \e[35mbadStr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpoihlwpih.scala:28:12\
    \ ---------------------------\e[0m\e[0"
  stdout: ''
  timestamp: 1659979657
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n\
    \        val queueSize = lst.size\n        val stackIsEmpty = stack.isEmpty\n\
    \        val queueIsEmpty = queue.isEmpty\n        val resultIsEmpty = result.isEmpty\n\
    \        val stackIsFull = stackSize == stackIsEmpty\n        val queueIsFull\
    \ = queueSize == queueIsEmpty\n        val resultIsFull = resultSize == resultIsEmpty\n\
    \        val stackIsFull = stackSize == stackIsEmpty\n        val queueIsFull\
    \ = queueSize == queueIsEmpty\n        val resultIsFull = resultSize == resultIsEmpty\n\
    \        val stackIsEmpty = stack.isEmpty\n        val queueIsEmpty = queue.isEmpty\n\
    \        val resultIsEmpty = result.isEmpty\n        val stackIsFull = stackSize\
    \ == stackIsEmpty\n        val queueIsFull = queueSize == queueIsEmpty\n     \
    \   val resultIsFull = resultSize == resultIsEmpty\n        val stackIsFull =\
    \ stackSize == stackIsEmpty\n        val queueIsFull = queueSize == queueIsEmpty\n\
    \        val resultIsFull = resultSize == resultIsEmpty\n        val stackIsEmpty\
    \ = stack.isEmpty\n        val queueIsEmpty = queue.isEmpty\n        val resultIsEmpty\
    \ = result.isEmpty\n        val stackIsFull = stackSize == stackIsEmpty\n    \
    \    val queueIsFull = queueSize == queueIsEmpty\n        val resultIsFull = resultSize\
    \ == resultIsEmpty\n        val stackIsFull = stackSize == stackIsEmpty\n    \
    \    val queueIsFull = queueSize == queueIsEmpty\n        val resultIsFull = resultSize\
    \ == resultIsEmpty\n        val stackIsEmpty = stack.isEmpty\n        val queueIsEmpty\
    \ = queue.isEmpty\n        val resultIsEmpty = result.isEmpty\n        val stackIsFull\
    \ = stackSize == stackIsEmpty\n        val queueIsFull = queueSize == queueIsEmpty\n\
    \        val resultIsFull = resultSize == resultIsEmpty\n        val stackIsFull\
    \ = stackSize == stackIsEmpty\n        val queueIsFull = queueSize == queueIsEmpty\n\
    \        val resultIsFull = resultSize == resultIsEmpty\n        val stackIsEmpty\
    \ = stack.isEmpty\n        val queueIsEmpty = queue.isEmpty\n        val resultIsEmpty\
    \ = result.isEmpty\n        val stackIsFull\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_f9vagxb.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_f9vagxb.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackIsFull\e[0m = stackSize == stackIsEmpty\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackIsFull\
    \ is already defined as \e[33mvalue\e[0m \e[35mstackIsFull\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_f9vagxb.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mqueueIsFull\e[0m = queueSize == queueIsEmpty\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mqueueIsFull\
    \ is already defined as \e[33mvalue\e[0m \e[35mqueueIsFull\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_f9vagxb.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mresultIsFull\e[0m = resultSize == resultIsEmpty\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mresultIsFull\
    \ is already defined as \e[33mvalue\e[0m \e[35mresultIsFull\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_f9vagxb.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackIsEmpty\e[0m = stack.isEmpty\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackIsEmpty is already defined as \e[33mvalue\e[0m \e[35mstackIsEmpty\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tm"
  stdout: ''
  timestamp: 1659979658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackSize2 = stackSize * stackSize\n\
    \        val stackSize3 = stackSize2 * stackSize\n        val stackSize4 = stackSize3\
    \ * stackSize\n        val stackSize5 = stackSize4 * stackSize\n        val stackSize6\
    \ = stackSize5 * stackSize\n        val stackSize7 = stackSize6 * stackSize\n\
    \        val stackSize8 = stackSize7 * stackSize\n        val stackSize9 = stackSize8\
    \ * stackSize\n        val stackSize10 = stackSize9 * stackSize\n        val stackSize11\
    \ = stackSize10 * stackSize\n        val stackSize12 = stackSize11 * stackSize\n\
    \        val stackSize13 = stackSize12 * stackSize\n        val stackSize14 =\
    \ stackSize13 * stackSize\n        val stackSize15 = stackSize14 * stackSize\n\
    \        val stackSize16 = stackSize15 * stackSize\n        val stackSize17 =\
    \ stackSize16 * stackSize\n        val stackSize18 = stackSize17 * stackSize\n\
    \        val stackSize19 = stackSize18 * stackSize\n        val stackSize20 =\
    \ stackSize19 * stackSize\n        val stackSize21 = stackSize20 * stackSize\n\
    \        val stackSize22 = stackSize21 * stackSize\n        val stackSize23 =\
    \ stackSize22 * stackSize\n        val stackSize24 = stackSize23 * stackSize\n\
    \        val stackSize25 = stackSize24 * stackSize\n        val stackSize26 =\
    \ stackSize25 * stackSize\n        val stackSize27 = stackSize26 * stackSize\n\
    \        val stackSize28 = stackSize27 * stackSize\n        val stackSize29 =\
    \ stackSize28 * stackSize\n        val stackSize30 = stackSize29 * stackSize\n\
    \        val stackSize31 = stackSize30 * stackSize\n        val stackSize32 =\
    \ stackSize31 * stackSize\n        val stackSize33 = stackSize32 * stackSize\n\
    \        val stackSize34 = stackSize33 * stackSize\n        val stackSize35 =\
    \ stackSize34 * stackSize\n        val stackSize36 = stackSize35 * stackSize\n\
    \        val stackSize37 = stackSize36 * stackSize\n        val stackSize38 =\
    \ stackSize37 * stackSize\n        val stackSize39 = stackSize38 * stackSize\n\
    \        val stackSize\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpch5x3hl7.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpch5x3hl7.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpch5x3hl7.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpch5x3hl7.scala:60:5\
    \ ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979657
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.add(x)\n                case \")(\"  => open.add(x)\n             \
    \   case \")(\"  => stack += x\n                case \")\" => stack += x\n   \
    \             case _ => stack += x\n            }\n        })\n        while(stack.nonEmpty)\
    \ {\n            val s = stack.pop()\n            val openCount = open.count(_\
    \ == s)\n            val closeCount = close.count(_ == s)\n            val count\
    \ = openCount + closeCount\n            if(count == openCount) {\n           \
    \     result += s\n            }\n        }\n        if(result.size == lst.size)\
    \ {\n            val str = result.mkString\n            val stackStr = stack.mkString\n\
    \            if(str.equals(stackStr)) {\n                return \"Yes\"\n    \
    \        }\n        }\n        return \"No\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwv4z2fz6.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpwv4z2fz6.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpwv4z2fz6.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpwv4z2fz6.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.foreach(c => stack += c)\n                   \
    \ result ++= stack.reverse\n                    stack.toList.foreach(x => stack.toList.remove(x))\n\
    \                    stack.toList.foreach(x => stack.toList.remove(x))\n     \
    \           case \")(\" =>\n                    open += x\n                case\
    \ _ =>\n                    stack += x\n            }\n        })\n        val\
    \ openCount = open.size\n        val closeCount = close.size\n        if (openCount\
    \ == closeCount) {\n            val openList = open.toList\n            val closeList\
    \ = close.toList\n            val openSet = openList.distinct\n            val\
    \ closeSet = closeList.distinct\n            if (openSet.size == closeSet.size)\n\
    \                if (openSet.size == openCount)\n                    result.append(\"\
    Yes\")\n                else\n                    result.append(\"No\")\n    \
    \        else\n                result.append(\"No\")\n        }\n        else\n\
    \            result.append(\"No\")\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfyjbmjhw.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpfyjbmjhw.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpfyjbmjhw.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpfyjbmjhw.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodParens = mutable.Set[String]()\n        val badParens = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    stack += x\n                }\n                case\
    \ \")(\"  => {\n                    queue += x\n                }\n          \
    \      case \")(\" => {\n                    stack += x\n                    queue\
    \ += x\n                }\n                case \")(\" => {\n                \
    \    stack += x\n                    queue += x\n                }\n         \
    \       case \")(\" => {\n                    stack += x\n                   \
    \ queue += x\n                }\n                case \")(\" => {\n          \
    \          stack += x\n                    queue += x\n                }\n   \
    \             case \")(\" => {\n                    stack += x\n             \
    \       queue += x\n                }\n                case \")(\" => {\n    \
    \                stack += x\n                    queue += x\n                }\n\
    \                case \")(\" => {\n                    stack += x\n          \
    \          queue += x\n                }\n                case \")(\" => {\n \
    \                   stack += x\n                    queue += x\n             \
    \   }\n                case \")(\" => {\n                    stack += x\n    \
    \                queue += x\n                }\n                case \")(\" =>\
    \ {\n                    stack += x\n                    queue += x\n        \
    \        }\n                case \")(\" => {\n                    stack += x\n\
    \                    queue += x\n                }\n                case \")(\"\
    \ => {\n                    stack += x\n                    queue += x\n     \
    \           }\n                case \")(\" => {\n                    stack +=\
    \ x\n                    queue += x\n                }\n                case \"\
    )(\" => {\n                    stack += x\n                    queue += x\n  \
    \              }\n                case \")(\" => {\n                    stack\
    \ += x\n                    queue += x\n                }\n                case\
    \ \")(\" => {\n                    stack += x\n                    queue += x\n\
    \                }\n                case \")(\" => {\n                    stack\
    \ += x\n                    queue += x\n                }\n                case\
    \ \")(\" => {\n                    stack += x\n                    queue += x\n\
    \                }\n                case \")(\" => {\n                    stack\
    \ += x\n                    queue += x\n                }\n                case\
    \ \")(\" => {\n                    stack += x\n                    queue += x\n\
    \                }\n                case \")(\" => {\n                    stack\
    \ += x\n                    queue += x\n                }\n                case\
    \ \")(\" => {\n                    stack += x\n                    queue += x\n\
    \                }\n                case \")(\" => {\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp81vn5svg.scala:139:0 ---------------------------\e\
    [0m\e[0m\n\e[31m139 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp81vn5svg.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp81vn5svg.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp81vn5svg.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mgood\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp81vn5svg.scala:21:18\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mbad\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m       \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp81vn5svg.scala:22:25\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mgoodParens\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e["
  stdout: ''
  timestamp: 1659979666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        val openCount = mutable.Map[String, Int]()\n        val closeCount =\
    \ mutable.Map[String, Int]()\n        lst.foreach(x => {\n            x match\
    \ {\n                case \")\" =>\n                    closeCount += x -> 1\n\
    \                case \")(\"  =>\n                    closeCount += x -> 2\n \
    \               case \")(\" =>\n                    closeCount += x -> 1\n   \
    \             case \")()\" =>\n                    closeCount += x -> 1\n    \
    \            case \")()()\" =>\n                    closeCount += x -> 3\n   \
    \             case \")(\" =>\n                    closeCount += x -> 1\n     \
    \           case \")(\" =>\n                    closeCount += x -> 1\n       \
    \         case \")(\" =>\n                    closeCount += x -> 1\n         \
    \       case \")(\" =>\n                    closeCount += x -> 1\n           \
    \     case \")(\" =>\n                    closeCount += x -> 1\n             \
    \   case \")(\" =>\n                    closeCount += x -> 1\n               \
    \ case \")(\" =>\n                    closeCount += x -> 1\n                case\
    \ \")(\" =>\n                    closeCount += x -> 1\n                case \"\
    )(\" =>\n                    closeCount += x -> 1\n                case \")(\"\
    \ =>\n                    closeCount += x -> 1\n                case \")(\" =>\n\
    \                    closeCount += x -> 1\n                case \")(\" =>\n  \
    \                  closeCount += x -> 1\n                case \")(\" =>\n    \
    \                closeCount += x -> 1\n                case \")(\" =>\n      \
    \              closeCount += x -> 1\n                case \")(\" =>\n        \
    \            closeCount += x -> 1\n                case \")(\" =>\n          \
    \          closeCount += x -> 1\n                case \")(\" =>\n            \
    \        closeCount += x -> 1\n                case \")(\" =>\n              \
    \      closeCount += x -> 1\n                case \")(\" =>\n                \
    \    closeCount += x -> 1\n                case \")(\" =>\n                  \
    \  closeCount += x -> 1\n                case \")(\" =>\n                    closeCount\
    \ += x -> 1\n                case \")(\" =>\n                    closeCount +=\
    \ x -> 1\n                case \")(\" =>\n                    closeCount += x\
    \ -> 1\n                case \")(\" =>\n                    closeCount += x ->\
    \ 1\n                case \")(\" =>\n                    closeCount += x -> 1\n\
    \                case \")(\" =>\n                    close\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgaih8dq8.scala:105:0 ---------------------------\e\
    [0m\e[0m\n\e[31m105 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m')'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgaih8dq8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgaih8dq8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgaih8dq8.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgaih8dq8.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgaih8dq8.scala:22:24\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mopenCount\e[0m = mutable.Map[\e[35mString\e[0m, \e[35mInt\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when com"
  stdout: ''
  timestamp: 1659979665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x == \")\" => close.add(x)\n\
    \            case x if x == \")\" => close.remove(x)\n            case x if x\
    \ == \"(\" => open.add(x)\n            case x if x == \"(\" => open.remove(x)\n\
    \            case x => stack += x\n        })\n        val openCount = open.size\n\
    \        val closeCount = close.size\n        if (openCount == closeCount) {\n\
    \            val stackSize = stack.size\n            if (stackSize == 0) {\n \
    \               result.append(\"Yes\")\n            } else {\n               \
    \ val stack = stack.dropRight(stackSize)\n                val stackSize = stack.size\n\
    \                if (stackSize == 0) {\n                    result.append(\"Yes\"\
    )\n                } else {\n                    val stack = stack.dropRight(stackSize)\n\
    \                    val stackSize = stack.size\n                    if (stackSize\
    \ == 0) {\n                        result.append(\"Yes\")\n                  \
    \  } else {\n                        val stack = stack.dropRight(stackSize)\n\
    \                        val stackSize = stack.size\n                        if\
    \ (stackSize == 0) {\n                            result.append(\"Yes\")\n   \
    \                     } else {\n                            val stack = stack.dropRight(stackSize)\n\
    \                            val stackSize = stack.size\n                    \
    \        if (stackSize == 0) {\n                                result.append(\"\
    Yes\")\n                            } else {\n                               \
    \ val stack = stack.dropRight(stackSize)\n                                val\
    \ stackSize = stack.size\n                                if (stackSize == 0)\
    \ {\n                                    result.append(\"Yes\")\n            \
    \                    } else {\n                                    val stack =\
    \ stack.dropRight(stackSize)\n                                    val stackSize\
    \ = stack.size\n                                    if (stackSize == 0) {\n  \
    \                                      result.append(\"Yes\")\n              \
    \                      } else {\n                                        val stack\
    \ = stack.dropRight(stackSize)\n                                        val stackSize\
    \ = stack.size\n                                        if (stackSize == 0) {\n\
    \                                            result.append(\"Yes\")\n        \
    \                                } else {\n                                  \
    \          val stack = stack.dropRight(stackSize)\n                          \
    \                  val stackSize = stack.size\n                              \
    \              if (stackSize == 0) {\n                                       \
    \         result.append(\"Yes\")\n                                           \
    \ } else {\n                                                val stack = stack.dropRight(stackSize)\n\
    \                                                val stackSize = stack.size\n\
    \                                                if (stackSize == 0) {\n     \
    \                                               result.append(\"Yes\")\n     \
    \                                           } else {\n                       \
    \                             val stack = stack.dropRight(stackSize)\n       \
    \                                             val stackSize = stack.size\n   \
    \                                                 if (stackSize == 0) {\n    \
    \                                                    result.append(\"Yes\")\n\
    \                                                    } else {\n              \
    \                                          val stack = stack.dropRight(stackSize\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5c3pzg76.scala:87:4 ----------------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5c3pzg76.scala:104:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m104 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp5c3pzg76.scala:18:20 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5c3pzg76.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5c3pzg76.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp5c3pzg76.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmp5c3pzg76.scala:36:28 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                \e[33mval\e[0m \e[36mstack\e[0m = stack.dropRight(stackSize"
  stdout: ''
  timestamp: 1659979662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.foreach(y => stack += y)\n                 \
    \   close.clear()\n                }\n                case \")(\" => {\n     \
    \               open += x\n                }\n                case \")(\" => {\n\
    \                    open += x\n                }\n                case \")(\"\
    \ => {\n                    open += x\n                }\n                case\
    \ \")(\" => {\n                    open += x\n                }\n            \
    \    case \")(\" => {\n                    open += x\n                }\n    \
    \            case \")(\" => {\n                    open += x\n               \
    \ }\n                case \")(\" => {\n                    open += x\n       \
    \         }\n                case \")(\" => {\n                    open += x\n\
    \                }\n                case \")(\" => {\n                    open\
    \ += x\n                }\n                case \")(\" => {\n                \
    \    open += x\n                }\n                case \")(\" => {\n        \
    \            open += x\n                }\n                case \")(\" => {\n\
    \                    open += x\n                }\n                case \")(\"\
    \ => {\n                    open += x\n                }\n                case\
    \ \")(\" => {\n                    open += x\n                }\n            \
    \    case \")(\" => {\n                    open += x\n                }\n    \
    \            case \")(\" => {\n                    open += x\n               \
    \ }\n                case \")(\" => {\n                    open += x\n       \
    \         }\n                case \")(\" => {\n                    open += x\n\
    \                }\n                case \")(\" => {\n                    open\
    \ += x\n                }\n                case \")(\" => {\n                \
    \    open += x\n                }\n                case \")(\" => {\n        \
    \            open += x\n                }\n                case \")(\" => {\n\
    \                    open += x\n                }\n                case \")(\"\
    \ => {\n                    open += x\n                }\n                case\
    \ \")(\" => {\n                    open += x\n                }\n            \
    \    case \")(\" => {\n                    open += x\n                }\n    \
    \            case \")(\" => {\n                    open += x\n               \
    \ }\n                case \")(\" => {\n                    open += x\n       \
    \         }\n                case \")(\" => {\n                    open += x\n\
    \                }\n                case \")(\" => {\n                    open\
    \ += x\n                }\n                case \")(\" => {\n                \
    \    open += x\n                }\n                case \")(\" => {\n        \
    \            open += x\n                }\n                case \")(\" => {\n\
    \                    open += x\n                }\n                case \")(\"\
    \ => {\n                    open += x\n                }\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_dnuk6ud.scala:145:0 ---------------------------\e\
    [0m\e[0m\n\e[31m145 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m')'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_dnuk6ud.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_dnuk6ud.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_dnuk6ud.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_dnuk6ud.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_dnuk6ud.scala:22:19\
    \ --------------------\e[0m\e[0m\n\e[31m 22 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 23 |\e[0m        \
    \    x \e[33mmatch\e[0m {\n\e[31m 24 |\e[0m                \e[33mcase\e[0m \e\
    [31m\")\"\e[0m => {\n\e[31m 25 "
  stdout: ''
  timestamp: 1659979666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    lst.foreach(x => {\n            x match {\n                case \")\" =>\
    \ {\n                    stackSize -= 1\n                    stack += x\n    \
    \            }\n                case \"(\" => {\n                    stackSize\
    \ += 1\n                    stack += x\n                }\n                case\
    \ _ => {\n                    stackSize -= 1\n                    stack += x\n\
    \                }\n            }\n        })\n        val stackSize = stack.size\n\
    \        val stackMax = stackSize - 1\n        stack.foreach(x => {\n        \
    \    x match {\n                case \")\" => {\n                    stackSize\
    \ -= 1\n                    stack += x\n                }\n                case\
    \ \"(\" => {\n                    stackSize += 1\n                    stack +=\
    \ x\n                }\n                case _ => {\n                    stackSize\
    \ -= 1\n                    stack += x\n                }\n            }\n   \
    \     })\n        val stackSize = stack.size\n        val stackMax = stackSize\
    \ - 1\n        stack.foreach(x => {\n            x match {\n                case\
    \ \")\" => {\n                    stackSize -= 1\n                    stack +=\
    \ x\n                }\n                case \"(\" => {\n                    stackSize\
    \ += 1\n                    stack += x\n                }\n                case\
    \ _ => {\n                    stackSize -= 1\n                    stack += x\n\
    \                }\n            }\n        })\n        val stackSize = stack.size\n\
    \        val stackMax = stackSize - 1\n        stack.foreach(x => {\n        \
    \    x match {\n                case \")\" => {\n                    stackSize\
    \ -= 1\n                    stack += x\n                }\n                case\
    \ \"(\" => {\n                    stackSize += 1\n                    stack +=\
    \ x\n                }\n                case _ => {\n                    stackSize\
    \ -= 1\n                    stack += x\n                }\n            }\n   \
    \     })\n        val stackSize = stack.size\n        val stackMax = stackSize\
    \ - 1\n        stack.foreach(x => {\n            x match {\n                case\
    \ \")\" => {\n                    stackSize -= 1\n                    stack +=\
    \ x\n                }\n                case \"(\" => {\n                    stackSize\
    \ += 1\n                    stack += x\n                }\n                case\
    \ _ => {\n                    stackSize -= 1\n                    stack += x\n\
    \                }\n            }\n        })\n        val stackSize = stack.size\n\
    \        val stackMax = stackSize - 1\n        stack.foreach(x => {\n        \
    \    x match {\n                case \")\" => {\n                    stackSize\
    \ -= 1\n                    stack += x\n                }\n                case\
    \ \"(\" => {\n                    stackSize += 1\n                    stack +=\
    \ x\n                }\n                case _ => {\n                    stackSize\
    \ -= 1\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvwzz326k.scala:142:0 ---------------------------\e\
    [0m\e[0m\n\e[31m142 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvwzz326k.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackSize\e[0m = stack.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackSize is already defined as \e[33mvalue\e[0m \e[35mstackSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvwzz326k.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mstackMax\e[0m = stackSize - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mstackMax is already defined as \e[33mvalue\e[0m \e[35mstackMax\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpvwzz326k.scala:56:12 ---------------------------\e[0m\e[0m\n\e[31m56\
    \ |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = stack.size\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvwzz326k.scala:57:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMax\e[0m = stackSize - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackMax is already defined\
    \ as \e[33mvalue\e[0m \e[35mstackMax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvwzz326k.scala:74:12 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = stack.size\n\
    \e[31"
  stdout: ''
  timestamp: 1659979665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => stack.pop()\n                case \")(\"  => stack.pop(); queue.enqueue(x)\n\
    \                case \")(\"  => bad.add(x)\n                case \")\"  => good.add(x)\n\
    \                case _    => queue.enqueue(x)\n            }\n        })\n  \
    \      if (stack.size == 0 && queue.size == 0) \"Yes\"\n        else if (!good.isEmpty)\
    \ \"No\"\n        else matchParens(queue.dequeue)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpac93rj53.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpac93rj53.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpac93rj53.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpac93rj53.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979661
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    stack.pop()\n                    result += (stack.mkString())\n\
    \                }\n                case \"(\" => {\n                    stack\
    \ += x\n                }\n                case _ => {\n                    stack\
    \ += x\n                }\n            }\n        })\n        if (result.size\
    \ == lst.length) {\n            val stackStr = stack.mkString\n            if\
    \ (stackStr.contains(\"()\")) {\n                return \"Yes\"\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7ipy9xes.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp7ipy9xes.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        val openCount = mutable.ListBuffer[Int]()\n        val closeCount = mutable.ListBuffer[Int]()\n\
    \        lst.foreach { s =>\n            val open = if (s.startsWith(\"(\")) \"\
    (\" else \"\"\n            val close = if (s.endsWith(\")\")) \")\" else \"\"\n\
    \            val count = if (s.startsWith(\"(\")) 1 else if (s.endsWith(\")\"\
    )) -1 else 0\n            open += open\n            close += close\n         \
    \   openCount += count\n            closeCount += count\n            stack +=\
    \ s\n        }\n        val openCount = openCount.sum\n        val closeCount\
    \ = closeCount.sum\n        val openCount = openCount.toInt\n        val closeCount\
    \ = closeCount.toInt\n        if (openCount == closeCount) {\n            val\
    \ stackSize = stack.size\n            if (stackSize == 0) {\n                result\
    \ += \"Yes\"\n            } else {\n                val stack = stack.drop(stackSize\
    \ - 1)\n                val stackSize = stack.size\n                val stack\
    \ = stack.drop(stackSize - 1)\n                val stackSize = stack.size\n  \
    \              val stack = stack.drop(stackSize - 1)\n                val stackSize\
    \ = stack.size\n                val stack = stack.drop(stackSize - 1)\n      \
    \          val stackSize = stack.size\n                val stack = stack.drop(stackSize\
    \ - 1)\n                val stackSize = stack.size\n                val stack\
    \ = stack.drop(stackSize - 1)\n                val stackSize = stack.size\n  \
    \              val stack = stack.drop(stackSize - 1)\n                val stackSize\
    \ = stack.size\n                val stack = stack.drop(stackSize - 1)\n      \
    \          val stackSize = stack.size\n                val stack = stack.drop(stackSize\
    \ - 1)\n                val stackSize = stack.size\n                val stack\
    \ = stack.drop(stackSize - 1)\n                val stackSize = stack.size\n  \
    \              val stack = stack.drop(stackSize - 1)\n                val stackSize\
    \ = stack.size\n                val stack = stack.drop(stackSize - 1)\n      \
    \          val stackSize = stack.size\n                val stack = stack.drop(stackSize\
    \ - 1)\n                val stackSize = stack.size\n                val stack\
    \ = stack.drop(stackSize - 1)\n                val stackSize = stack.size\n  \
    \              val stack = stack.drop(stackSize - 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf5j6ovks.scala:89:0 ----------------------------\e\
    [0m\e[0m\n\e[31m89 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpf5j6ovks.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopenCount\e[0m = openCount.sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopenCount is already defined as \e[33mvalue\e[0m \e[35mopenCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpf5j6ovks.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mcloseCount\e[0m = closeCount.sum\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mcloseCount is already defined as \e[33mvalue\e[0m \e[35mcloseCount\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpf5j6ovks.scala:36:12 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        \e[33mval\e[0m \e[36mopenCount\e[0m = openCount.toInt\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopenCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mopenCount\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpf5j6ovks.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcloseCount\e[0m = closeCount.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcloseCount is already defined as \e[33mvalue\e[0m \e[35mcloseCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpf5j6ovks.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = "
  stdout: ''
  timestamp: 1659979666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.ListBuffer.empty[String]\n        val close = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { s =>\n            if (s.startsWith(\"(\")) {\n        \
    \        open += s\n                stack.push(s)\n            } else if (s.endsWith(\"\
    )\")) {\n                close += s\n                stack.pop\n            }\
    \ else {\n                result += (open :+ s) + (close :+ s)\n            }\n\
    \        }\n        if (stack.size == 0) {\n            result += \"No\"\n   \
    \     } else {\n            result += \"Yes\"\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptullh49y.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmptullh49y.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmptullh49y.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmptullh49y.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val openCount = stack.length\n            val closeCount = stack.length\n\
    \            stack.push(str)\n            while(openCount > 0 && closeCount >\
    \ 0) {\n                val openStr = stack.pop()\n                val closeStr\
    \ = stack.pop()\n                if(openStr == closeStr) {\n                 \
    \   openCount -= 1\n                    closeCount -= 1\n                } else\
    \ {\n                    if(openStr == \"()\") {\n                        openCount\
    \ -= 1\n                    } else {\n                        closeCount -= 1\n\
    \                    }\n                }\n            }\n            if(openCount\
    \ == 0 && closeCount == 0) {\n                result += \"Yes\"\n            }\
    \ else {\n                result += \"No\"\n            }\n        }\n       \
    \ return result.toString()\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n   \
    \ assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzo6515y0.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpzo6515y0.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        for(i <- 0 until lst.size) {\n            if(!open.isEmpty && !close.isEmpty)\
    \ {\n                val openCount = open.count(_ == lst(i))\n               \
    \ val closeCount = close.count(_ == lst(i))\n                if(openCount == closeCount)\
    \ {\n                    result += \"Yes\"\n                } else {\n       \
    \             result += \"No\"\n                    break\n                }\n\
    \            }\n            if(!open.isEmpty && close.isEmpty) {\n           \
    \     result += \"Yes\"\n                break\n            }\n            if(!close.isEmpty\
    \ && open.isEmpty) {\n                result += \"No\"\n                break\n\
    \            }\n            if(!open.isEmpty && !close.isEmpty) {\n          \
    \      val openCount = open.count(_ == lst(i))\n                val closeCount\
    \ = close.count(_ == lst(i))\n                if(openCount > closeCount) {\n \
    \                   result += \"Yes\"\n                } else {\n            \
    \        result += \"No\"\n                    break\n                }\n    \
    \        }\n            if(!close.isEmpty && !open.isEmpty) {\n              \
    \  val openCount = open.count(_ == lst(i))\n                val closeCount = close.count(_\
    \ == lst(i))\n                if(closeCount > openCount) {\n                 \
    \   result += \"Yes\"\n                } else {\n                    result +=\
    \ \"No\"\n                    break\n                }\n            }\n      \
    \      if(!open.isEmpty && close.isEmpty) {\n                result += \"No\"\n\
    \                break\n            }\n            if(!open.isEmpty && !close.isEmpty)\
    \ {\n                val openCount = open.count(_ == lst(i))\n               \
    \ val closeCount = close.count(_ == lst(i))\n                if(openCount > closeCount)\
    \ {\n                    result += \"No\"\n                } else {\n        \
    \            result += \"Yes\"\n                    break\n                }\n\
    \            }\n            if(!open.isEmpty && !close.isEmpty) {\n          \
    \      val openCount = open.count(_ == lst(i))\n                val closeCount\
    \ = close.count(_ == lst(i))\n                if(closeCount > openCount) {\n \
    \                   result += \"No\"\n                } else {\n             \
    \       result += \"Yes\"\n                    break\n                }\n    \
    \        }\n            if(!open.isEmpty && close.isEmpty) {\n               \
    \ result += \"No\"\n                break\n            }\n            if(!open.isEmpty\
    \ && !close.isEmpty) {\n                val openCount = open.count(_ == lst(i))\n\
    \                val closeCount = close.count(_ == lst(i))\n                if(openCount\
    \ > closeCount) {\n                    result += \"No\"\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphteklys_.scala:112:0 ---------------------------\e\
    [0m\e[0m\n\e[31m112 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphteklys_.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphteklys_.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphteklys_.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphteklys_.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphteklys_.scala:30:20\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                    break\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmphtekl"
  stdout: ''
  timestamp: 1659979663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.synchronized {\n                        stack.pop()\
    \ match {\n                            case Some(open) => open.remove(open)\n\
    \                            case None => result.synchronized {\n            \
    \                    result += open\n                                result +=\
    \ close\n                                result\n                            }\n\
    \                        }\n                    }\n                case \")(\"\
    \  =>\n                    stack.synchronized {\n                        stack\
    \ += x\n                    }\n                case \")(\" =>\n              \
    \      stack.synchronized {\n                        stack += x\n            \
    \        }\n                case _ =>\n                    open.synchronized {\n\
    \                        open += x\n                    }\n            }\n   \
    \     })\n        stack.synchronized {\n            stack.reverseIterator.foreach(x\
    \ => result.synchronized {\n                result += x\n            })\n    \
    \    }\n        result.synchronized {\n            val res = result.mkString(\"\
    (\", \", \", \")\")\n            if (res.contains(\"(\") && res.contains(\")\"\
    )) {\n                res\n            } else {\n                \"No\"\n    \
    \        }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3b0w6640.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp3b0w6640.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp3b0w6640.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp3b0w6640.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => open.push(x)\n           \
    \     case \")(\"  => stack.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => stack.push(x)\n                case _ => stack.push(x)\n\
    \            }\n        })\n        val openCount = open.count\n        val closeCount\
    \ = close.count\n        if (openCount == closeCount) {\n            val openStack\
    \ = stack.toList\n            val closeStack = stack.toList.reverse\n        \
    \    val openStackSize = openStack.size\n            val closeStackSize = closeStack.size\n\
    \            val openStackElement = openStack.last\n            val closeStackElement\
    \ = closeStack.last\n            val openStackElementIndex = openStack.lastIndexOf(openStackElement)\n\
    \            val closeStackElementIndex = closeStack.lastIndexOf(closeStackElement)\n\
    \            val openStackElementSize = openStackElementIndex + 1\n          \
    \  val closeStackElementSize = closeStackElementIndex + 1\n            val openStackElementElement\
    \ = openStack.slice(openStackElementIndex, openStackElementSize)\n           \
    \ val closeStackElementElement = closeStack.slice(closeStackElementIndex, closeStackElementSize)\n\
    \            val openStackElementElementElement = openStack.slice(openStackElementIndex\
    \ + 1, openStackElementSize)\n            val closeStackElementElementElement\
    \ = closeStack.slice(closeStackElementIndex + 1, closeStackElementSize)\n    \
    \        val openStackElementElementElementElement = openStack.slice(openStackElementIndex\
    \ + 2, openStackElementSize)\n            val closeStackElementElementElement\
    \ = closeStack.slice(closeStackElementIndex + 2, closeStackElementSize)\n    \
    \        val openStackElementElementElementElement = openStack.slice(openStackElementIndex\
    \ + 3, openStackElementSize)\n            val closeStackElementElementElement\
    \ = closeStack.slice(closeStackElementIndex + 3, closeStackElementSize)\n    \
    \        val openStackElementElementElementElement = openStack.slice(openStackElementIndex\
    \ + 4, openStackElementSize)\n            val closeStackElementElementElement\
    \ = closeStack.slice(closeStackElementIndex + 4, closeStackElementSize)\n    \
    \        val openStackElementElementElementElement = openStack.slice(openStackElementIndex\
    \ + 5, openStackElement\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0lvpg396.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0lvpg396.scala:73:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m73 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp0lvpg396.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp0lvpg396.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0lvpg396.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp0lvpg396.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0lvpg396.scala:50:16 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m            \e[33mval\e[0m \e[36mcloseStackElementElementElemen"
  stdout: ''
  timestamp: 1659979666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x == \")\" => close.push(x)\n\
    \            case x if x == \"(\" => open.push(x)\n            case _ => ()\n\
    \        })\n        while(!close.isEmpty && !open.isEmpty) {\n            val\
    \ closed = close.pop()\n            val opened = open.pop()\n            val newStack\
    \ = stack :+ opened\n            val newResult = result :+ closed\n          \
    \  val newOpen = open - opened\n            val newClose = close - closed\n  \
    \          if(newOpen.isEmpty && newClose.isEmpty) {\n                val newStack2\
    \ = newStack.dropRight(1)\n                val newResult2 = newResult.dropRight(1)\n\
    \                if(newStack2.toList == newResult2.toList) {\n               \
    \     return \"Yes\"\n                }\n            }\n        }\n        return\
    \ \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt82bkj_3.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpt82bkj_3.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpt82bkj_3.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpt82bkj_3.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.push(x)\n                case \")(\"  =>\n   \
    \                 open.push(x)\n                case \")()\" =>\n            \
    \        stack.push(x)\n                case \")()()\" =>\n                  \
    \  val s = stack.pop()\n                    val c = close.pop()\n            \
    \        val o = open.pop()\n                    result.append((s + c).mkString(\"\
    \"))\n                    result.append((o + c).mkString(\"\"))\n            }\n\
    \        })\n        if (close.isEmpty) result.mkString(\"\") else\n         \
    \   if (open.isEmpty) result.mkString(\"\") else\n                if (stack.size\
    \ == 0) result.mkString(\"\") else\n                    result.mkString(\"\").reverse.mkString(\"\
    \").reverse\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz5o87oap.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpz5o87oap.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpz5o87oap.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpz5o87oap.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        lst.foreach(x => if (x == \"\
    (\") stack += x else if (!x == \"(\") queue += x else ())\n        while (stack.nonEmpty\
    \ || queue.nonEmpty) {\n            val a = stack.pop\n            val b = queue.pop\n\
    \            if (a == \"(\") stack += b else if (!b == \"(\") queue += b else\
    \ ()\n            if (stack.nonEmpty || queue.nonEmpty) {\n                val\
    \ c = stack.pop\n                val d = queue.pop\n                if (c == \"\
    (\") stack += d else if (!d == \"(\") queue += d else ()\n                if (stack.nonEmpty\
    \ || queue.nonEmpty) {\n                    val e = stack.pop\n              \
    \      val f = queue.pop\n                    if (e == \"(\") stack += f else\
    \ if (!f == \"(\") queue += f else ()\n                    if (stack.nonEmpty\
    \ || queue.nonEmpty) {\n                        val g = stack.pop\n          \
    \              val h = queue.pop\n                        if (g == \"(\") stack\
    \ += h else if (!h == \"(\") queue += h else ()\n                        if (stack.nonEmpty\
    \ || queue.nonEmpty) {\n                            val i = stack.pop\n      \
    \                      val j = queue.pop\n                            if (i ==\
    \ \"(\") stack += j else if (!j == \"(\") queue += j else ()\n               \
    \             if (stack.nonEmpty || queue.nonEmpty) {\n                      \
    \          val k = stack.pop\n                                val l = queue.pop\n\
    \                                if (k == \"(\") stack += l else if (!l == \"\
    (\") queue += l else ()\n                                if (stack.nonEmpty ||\
    \ queue.nonEmpty) {\n                                    val m = stack.pop\n \
    \                                   val n = queue.pop\n                      \
    \              if (m == \"(\") stack += n else if (!n == \"(\") queue += n else\
    \ ()\n                                    if (stack.nonEmpty || queue.nonEmpty)\
    \ {\n                                        val o = stack.pop\n             \
    \                           val p = queue.pop\n                              \
    \          if (o == \"(\") stack += p else if (!p == \"(\") queue += p else ()\n\
    \                                        if (stack.nonEmpty || queue.nonEmpty)\
    \ {\n                                            val q = stack.pop\n         \
    \                                   val r = queue.pop\n                      \
    \                      if (q == \"(\") stack += r else if (!r == \"(\") queue\
    \ += r else ()\n                                            if (stack.nonEmpty\
    \ || queue.nonEmpty) {\n                                                val s\
    \ = stack.pop\n                                                val t = queue.pop\n\
    \                                                if (s == \"(\") stack += t else\
    \ if (!t == \"(\") queue += t else ()\n                                      \
    \          if (stack.nonEmpty || queue.nonEmpty) {\n                         \
    \                           val u = stack.pop\n                              \
    \                      val v = \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpgnfc9ha9.scala:64:59 ---------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m                                                    \e\
    [33mval\e[0m \e[36mv\e[0m = \n\e[31m\e[31m   |\e[0m                          \
    \                                 ^\e[0m\n\e[31m   |\e[0m                    \
    \                   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgnfc9ha9.scala:82:0 ----------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgnfc9ha9.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgnfc9ha9.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgnfc9ha9.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mgood\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgnfc9ha9.scala:21:59\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => \e[33mif\e[0m (x == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e\
    [0m (!x == \e[31m\"(\"\e[0m) queue += x \e[33melse\e[0m ())\n\e[31m\e[31m   |\e\
    [0m                "
  stdout: ''
  timestamp: 1659979668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        lst.foreach(x => {\n  \
    \          x match {\n                case \")\" => {\n                    queue.enqueue(x)\n\
    \                    stack.pop()\n                }\n                case \"(\"\
    \ => {\n                    stack.push(x)\n                }\n               \
    \ case _ => {\n                    queue.enqueue(x)\n                }\n     \
    \       }\n        })\n        while(!stack.isEmpty && !queue.isEmpty) {\n   \
    \         val curr = queue.poll()\n            val next = stack.pop()\n      \
    \      if(!result.contains(curr)) {\n                result.enqueue(curr)\n  \
    \              result.enqueue(next)\n            }\n        }\n        if(!stack.isEmpty\
    \ && !queue.isEmpty) {\n            \"No\"\n        } else {\n            \"Yes\"\
    \n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpicxajotb.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpicxajotb.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpicxajotb.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.foreach(y => stack.pop())\n                  \
    \  result ++= stack\n                    stack.clear()\n                case x\
    \ if x != \"(\" =>\n                    open += x\n                case x if x\
    \ == \")\" =>\n                    close.foreach(y => stack.pop())\n         \
    \           result ++= stack\n                    stack.clear()\n            \
    \    case x if x == \")\" =>\n                    close.foreach(y => stack.pop())\n\
    \                    result ++= stack\n                    stack.clear()\n   \
    \             case x if x != \"(\" =>\n                    open += x\n       \
    \     }\n        })\n        result match {\n            case Nil => \"No\"\n\
    \            case x => x.mkString(\"(\", \")\")\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9m127e2n.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9m127e2n.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9m127e2n.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp9m127e2n.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxIndex = stackSize - 1\n        val stackMin = 0\n        val\
    \ stackMinIndex = stackSize - 1\n        val stackMinValue = lst(stackMin)\n \
    \       val stackMaxValue = lst(stackMax)\n        val stackMinIndex = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue =\
    \ lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue\
    \ = lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue\
    \ = lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue\
    \ = lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue\
    \ = lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue\
    \ = lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue\
    \ = lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue\
    \ = lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue\
    \ = lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue\
    \ = lst(stackMin)\n        val stackMaxValue = lst(stackMax)\n        val stackMinIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinValue\
    \ = lst(\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1k_50mv7.scala:69:32 ---------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m        \e[33mval\e[0m \e[36mstackMinValue\e[0m = lst(\n\
    \e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m \
    \                               expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1k_50mv7.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMinIndex\e[0m = stackSize - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackMinIndex is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackMinIndex\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1k_50mv7.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMaxIndex\e[0m = stackSize - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackMaxIndex is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackMaxIndex\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1k_50mv7.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMinValue\e[0m = lst(stackMin)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMinValue is already defined as \e[33mvalue\e[0m \e[35mstackMinValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1k_50mv7.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mstackMaxValue\e[0m = lst(stackMax)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mstackMaxValue is already defined as \e[33mvalue\e[0m \e[35mstackMa"
  stdout: ''
  timestamp: 1659979668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") open.append(x)\n    \
    \        if (x == \")\") close.append(x)\n            if (open.isEmpty && close.isEmpty)\
    \ stack.append(x)\n            if (open.isEmpty && close.isNotEmpty) result.append(x)\n\
    \            if (open.isNotEmpty && close.isEmpty) result.append(x)\n        \
    \    if (open.isNotEmpty && close.isNotEmpty) stack.append(x)\n        })\n  \
    \      if (stack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp38uqm62v.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp38uqm62v.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp38uqm62v.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp38uqm62v.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val len = lst.size\n  \
    \      for(i <- 0 until len){\n            val str = lst(i)\n            if(str\
    \ == \"(\"){\n                stack.push(str)\n            }else if(str == \"\
    )\"){\n                val top = stack.pop()\n                if(top == \"(\"\
    ){\n                    queue.enqueue(str)\n                }else{\n         \
    \           result.enqueue(str)\n                }\n            }else{\n     \
    \           result.enqueue(str)\n            }\n        }\n        if(stack.size\
    \ == 0){\n            result.dequeue()\n        }else{\n            val top =\
    \ stack.pop()\n            if(top == \"(\"){\n                queue.enqueue(top)\n\
    \            }else{\n                result.enqueue(top)\n            }\n    \
    \    }\n        if(queue.size == 0){\n            result.dequeue()\n        }else{\n\
    \            val top = queue.dequeue()\n            if(top == \"(\"){\n      \
    \          stack.enqueue(top)\n            }else{\n                result.enqueue(top)\n\
    \            }\n        }\n        if(stack.size == 0){\n            result.dequeue()\n\
    \        }else{\n            val top = stack.pop()\n            if(top == \"(\"\
    ){\n                queue.enqueue(top)\n            }else{\n                result.enqueue(top)\n\
    \            }\n        }\n        if(queue.size == 0){\n            result.dequeue()\n\
    \        }else{\n            val top = queue.dequeue()\n            if(top ==\
    \ \"(\"){\n                stack.enqueue(top)\n            }else{\n          \
    \      result.enqueue(top)\n            }\n        }\n        if(stack.size ==\
    \ 0){\n            result.dequeue()\n        }else{\n            val top = stack.pop()\n\
    \            if(top == \"(\"){\n                queue.enqueue(top)\n         \
    \   }else{\n                result.enqueue(top)\n            }\n        }\n  \
    \      if(queue.size == 0){\n            result.dequeue()\n        }else{\n  \
    \          val top = queue.dequeue()\n            if(top == \"(\"){\n        \
    \        stack.enqueue(top)\n            }else{\n                result.enqueue(top)\n\
    \            }\n        }\n        if(stack.size == 0){\n            result.dequeue()\n\
    \        }else{\n            val top = stack.pop()\n            if(top == \"(\"\
    ){\n                queue.enqueue(top)\n            }else{\n                result.enqueue(top)\n\
    \            }\n        }\n        if(queue.size == 0){\n            result.dequeue()\n\
    \        }else{\n            val top = queue.dequeue()\n            if(top ==\
    \ \"(\"){\n                stack.enqueue(top)\n            }else{\n          \
    \      result.enqueue\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpibbwwod8.scala:132:0 ---------------------------\e\
    [0m\e[0m\n\e[31m132 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpibbwwod8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpibbwwod8.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpibbwwod8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpibbwwod8.scala:131:1\
    \ --------------------\e[0m\e[0m\n\e[31m131 |\e[0m}\n\e[31m\e[31m    |\e[0m ^\e\
    [0m\n\e[31m    |\e[0m Found:    Unit\n\e[31m    |\e[0m Required: String\n\e[31m\
    \    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpibbwwod8.scala:116:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m116 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m    |\e[0m    ^\e[0m\n\
    \e[33m    |\e[0m    Line is indented too far to the left, or a `}` is missing\n\
    1 warning found\n5 errors found\n"
  stdout: ''
  timestamp: 1659979669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => stack.push(x)\n          \
    \      case \")(\"  => stack.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpqvlgfgda.scala:74:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m                \e[33mcase\e[0m \")\n\e[31m\e[31m   |\e\
    [0m                     ^\e[0m\n\e[31m   |\e[0m                     unclosed string\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmpqvlgfgda.scala:76:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqvlgfgda.scala:92:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m92 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpqvlgfgda.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpqvlgfgda.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set"
  stdout: ''
  timestamp: 1659795020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n\
    \        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n \
    \       val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize\
    \ - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n\
    \        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize\
    \ - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n\
    \        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize\
    \ - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n\
    \        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize\
    \ - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n\
    \        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize\
    \ - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n\
    \        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize\
    \ - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n\
    \        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize\
    \ - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n\
    \        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize\
    \ - 1\n        val stackSize = lst.size\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMax = stackMaxSize - 1\n        val stackSize = lst.size\n\
    \        val stackMaxSize = stackSize - 1\n        val stackMax = stackMaxSize\
    \ - 1\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmprt_pi9r7.scala:74:11 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmprt_pi9r7.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprt_pi9r7.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMaxSize\e[0m = stackSize - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackMaxSize is already\
    \ defined as \e[33mvalue\e[0m \e[35mstackMaxSize\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprt_pi9r7.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMax\e[0m = stackMaxSize - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackMax is already\
    \ defined as \e[33mvalue\e[0m \e[35mstackMax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprt_pi9r7.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackSize is already defined as \e[33mvalue\e[0m \e[35mstackSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp"
  stdout: ''
  timestamp: 1659979670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxIndex = stackSize - 1\n        val stackIndex = stackSize - 1\n\
    \        val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue\
    \ = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n   \
    \     val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue\
    \ = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n   \
    \     val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue\
    \ = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n   \
    \     val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue\
    \ = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n   \
    \     val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue\
    \ = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n   \
    \     val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue\
    \ = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n   \
    \     val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue\
    \ = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n   \
    \     val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue\
    \ = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n   \
    \     val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue\
    \ = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n   \
    \     val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue\
    \ = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n   \
    \     val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue\
    \ = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n   \
    \     val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue\
    \ = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n   \
    \     val stackMaxValue = lst(stackMaxIndex).charAt(0)\n        val stackValue\
    \ = lst(stackIndex).charAt(0)\n        val stackMaxIndex = stackSize - 1\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdkotrr5r.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mstackMaxIndex\e[0m = stackSize\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMaxIndex is already defined as \e[33mvalue\e[0m \e[35mstackMaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpdkotrr5r.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mstackMaxValue\e[0m = lst(stackMaxIndex).charAt(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMaxValue is already defined as \e[33mvalue\e[0m \e[35mstackMaxValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpdkotrr5r.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mstackValue\e[0m = lst(stackIndex).charAt(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackValue is already defined as \e[33mvalue\e[0m \e[35mstackValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpdkotrr5r.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mstackMaxIndex\e[0m = stackSize - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mstackMaxIndex is already defined as \e[33mvalue\e[0m \e[35mstackMaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpdkotrr5r.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mstackMaxValue\e[0m = lst(stackMaxIndex).charAt(\e\
    [31m0\e[0m)\n\e[31m\e[31m"
  stdout: ''
  timestamp: 1659979670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach { s =>\n            s match {\n                case \")\"\
    \ =>\n                    close.foreach(c => stack += c)\n                   \
    \ result ++= stack\n                    stack.toList.reverse.foreach(c => stack\
    \ += c)\n                    stack.clear()\n                case \")(\" =>\n \
    \                   open += s\n                case \")(\" =>\n              \
    \      open += s\n                case \")\" =>\n                    open += s\n\
    \                case \")\" =>\n                    open += s\n              \
    \  case \")(\" =>\n                    open += s\n                case \")(\"\
    \ =>\n                    open += s\n                case \")(\" =>\n        \
    \            open += s\n                case \")(\" =>\n                    open\
    \ += s\n                case \")(\" =>\n                    open += s\n      \
    \          case \")(\" =>\n                    open += s\n                case\
    \ \")(\" =>\n                    open += s\n                case \")(\" =>\n \
    \                   open += s\n                case \")(\" =>\n              \
    \      open += s\n                case \")(\" =>\n                    open +=\
    \ s\n                case \")(\" =>\n                    open += s\n         \
    \       case \")(\" =>\n                    open += s\n                case \"\
    )(\" =>\n                    open += s\n                case \")(\" =>\n     \
    \               open += s\n                case \")(\" =>\n                  \
    \  open += s\n                case \")(\" =>\n                    open += s\n\
    \                case \")(\" =>\n                    open += s\n             \
    \   case \")(\" =>\n                    open += s\n                case \")(\"\
    \ =>\n                    open += s\n                case \")(\" =>\n        \
    \            open += s\n                case \")(\" =>\n                    open\
    \ += s\n                case \")(\" =>\n                    open += s\n      \
    \          case \")(\" =>\n                    open += s\n                case\
    \ \")(\" =>\n                    open += s\n                case \")(\" =>\n \
    \                   open += s\n                case \")(\" =>\n              \
    \      open += s\n                case \")(\" =>\n                    open +=\
    \ s\n                case \")(\" =>\n                    open += s\n         \
    \       case \")(\" =>\n                    open += s\n                case \"\
    )(\" =>\n                    open += s\n                case \")(\" =>\n     \
    \               open += s\n                case \")(\" =>\n                  \
    \  open += s\n                case \")(\" =>\n                    open += s\n\
    \                case \")(\" =>\n\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsa0dearv.scala:122:0 ---------------------------\e\
    [0m\e[0m\n\e[31m122 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsa0dearv.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsa0dearv.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsa0dearv.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsa0dearv.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsa0dearv.scala:22:20\
    \ --------------------\e[0m\e[0m\n\e[31m 22 |\e[0m        lst.foreach { \e[36ms\e\
    [0m =>\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found: \
    \   Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 23 |\e[0m         \
    \   s \e[33mmatch\e[0m {\n\e[31m 24 |\e[0m                \e[33mcase\e[0m \e[31m\"\
    )\"\e[0m =>\n\e[31m 25 |\e"
  stdout: ''
  timestamp: 1659979673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") open += x\n         \
    \   else if (x == \")\") close += x\n            else stack += x\n        })\n\
    \        val openCount = open.size\n        val closeCount = close.size\n    \
    \    if (openCount == closeCount) {\n            val openStack = stack.take(openCount)\n\
    \            val closeStack = stack.drop(openCount)\n            val openStackSize\
    \ = openStack.size\n            val closeStackSize = closeStack.size\n       \
    \     if (openStackSize == closeStackSize) {\n                val openStackElement\
    \ = openStack.last\n                val closeStackElement = closeStack.last\n\
    \                if (openStackElement == closeStackElement) {\n              \
    \      result += \"Yes\"\n                } else {\n                    result\
    \ += \"No\"\n                }\n            } else {\n                result +=\
    \ \"No\"\n            }\n        } else {\n            result += \"No\"\n    \
    \    }\n        result.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2fpkce1k.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2fpkce1k.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2fpkce1k.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp2fpkce1k.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach { s =>\n            s match {\n                case \")\"\
    \ =>\n                    close.clear()\n                    stack.clear()\n \
    \               case \")(\"  =>\n                    close.clear()\n         \
    \           stack.clear()\n                case \")(\"  =>\n                 \
    \   close.clear()\n                    stack.clear()\n                case \"\
    )(\" =>\n                    close.clear()\n                    stack.clear()\n\
    \                case \")(\" =>\n                    close.clear()\n         \
    \           stack.clear()\n                case \")(\" =>\n                  \
    \  close.clear()\n                    stack.clear()\n                case \")(\"\
    \ =>\n                    close.clear()\n                    stack.clear()\n \
    \               case \")(\" =>\n                    close.clear()\n          \
    \          stack.clear()\n                case \")(\" =>\n                   \
    \ close.clear()\n                    stack.clear()\n                case \")(\"\
    \ =>\n                    close.clear()\n                    stack.clear()\n \
    \               case \")(\" =>\n                    close.clear()\n          \
    \          stack.clear()\n                case \")(\" =>\n                   \
    \ close.clear()\n                    stack.clear()\n                case \")(\"\
    \ =>\n                    close.clear()\n                    stack.clear()\n \
    \               case \")(\" =>\n                    close.clear()\n          \
    \          stack.clear()\n                case \")(\" =>\n                   \
    \ close.clear()\n                    stack.clear()\n                case \")(\"\
    \ =>\n                    close.clear()\n                    stack.clear()\n \
    \               case \")(\" =>\n                    close.clear()\n          \
    \          stack.clear()\n                case \")(\" =>\n                   \
    \ close.clear()\n                    stack.clear()\n                case \")(\"\
    \ =>\n                    close.clear()\n                    stack.clear()\n \
    \               case \")(\" =>\n                    close.clear()\n          \
    \          stack.clear()\n                case \")(\" =>\n                   \
    \ close.clear()\n                    stack.clear()\n                case \")(\"\
    \ =>\n                    close.clear()\n                    stack.clear()\n \
    \               case \")(\" =>\n                    close.clear()\n          \
    \          stack.clear()\n                case \")(\" =>\n                   \
    \ close.clear()\n                    stack.clear()\n                case \")(\"\
    \ =>\n                    close.clear()\n                    stack.clear()\n \
    \               case \")(\" =>\n                    close.clear()\n          \
    \          stack.clear()\n                case \")(\" =>\n                   \
    \ close.clear()\n                    stack.clear()\n                case \")(\"\
    \ =>\n                    close.clear()\n                    stack.clear()\n \
    \               case \")(\" =>\n                    close.clear()\n          \
    \          stack.clear()\n                case \")(\" =>\n                   \
    \ close.clear()\n                    stack.clear()\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu3loa0jc.scala:132:0 ---------------------------\e\
    [0m\e[0m\n\e[31m132 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu3loa0jc.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu3loa0jc.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu3loa0jc.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu3loa0jc.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu3loa0jc.scala:22:20\
    \ --------------------\e[0m\e[0m\n\e[31m 22 |\e[0m        lst.foreach { \e[36ms\e\
    [0m =>\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found: \
    \   Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 23 |\e[0m         \
    \   s \e[33mmatch\e[0m {\n\e[31m 24 |\e[0m                \e[33mcase\e[0m \e[31m\"\
    )\"\e[0m "
  stdout: ''
  timestamp: 1659979674
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val open = mutable.Set[String]()\n\
    \        val close = mutable.Set[String]()\n        lst.foreach { s =>\n     \
    \       if (s.startsWith(\"(\")) {\n                open += s\n            } else\
    \ {\n                close += s\n            }\n        }\n        open foreach\
    \ { s =>\n            stack push s\n        }\n        close foreach { s =>\n\
    \            queue push s\n        }\n        while(!queue.isEmpty && !stack.isEmpty)\
    \ {\n            val s = queue.poll\n            val c = stack.pop()\n       \
    \     if (s.startsWith(\"(\")) {\n                open += c\n            } else\
    \ {\n                close += c\n            }\n            result push s\n  \
    \      }\n        if (open.isEmpty && close.isEmpty) {\n            return \"\
    No\"\n        }\n        if (open.isEmpty || close.isEmpty) {\n            return\
    \ \"Yes\"\n        }\n        if (result.size == 1) {\n            result.toList\n\
    \        } else {\n            \"No\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj1l22bd1.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpj1l22bd1.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpj1l22bd1.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpj1l22bd1.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpj1l22bd1.scala:22:20 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val open = mutable.HashSet[String]()\n        val close = mutable.HashSet[String]()\n\
    \        val good = mutable.HashSet[String]()\n        lst.foreach(x => x match\
    \ {\n            case x if x == \"\" => ()\n            case x if open.isEmpty\
    \ => ()\n            case x if close.isEmpty => ()\n            case x if open.isEmpty\
    \ && close.isEmpty => ()\n            case x if open.isEmpty => ()\n         \
    \   case x if close.isEmpty => ()\n            case x if x == \")\" => close.push(x)\n\
    \            case x if x == \")(\" => open.push(x)\n            case x if open.isEmpty\
    \ && close.isEmpty => ()\n            case x if open.isEmpty => ()\n         \
    \   case x if close.isEmpty => ()\n            case x if x == \")(\" => open.push(x)\n\
    \            case x if open.isEmpty && close.isEmpty => ()\n            case x\
    \ if open.isEmpty => ()\n            case x if close.isEmpty => ()\n         \
    \   case x if x == \")\" => close.push(x)\n            case x if x == \")(\" =>\
    \ open.push(x)\n            case x if open.isEmpty && close.isEmpty => ()\n  \
    \          case x if open.isEmpty => ()\n            case x if close.isEmpty =>\
    \ ()\n            case x if x == \")(\" => open.push(x)\n            case x if\
    \ open.isEmpty && close.isEmpty => ()\n            case x if open.isEmpty => ()\n\
    \            case x if close.isEmpty => ()\n            case x if x == \")\" =>\
    \ close.push(x)\n            case x if x == \")(\" => open.push(x)\n         \
    \   case x if open.isEmpty && close.isEmpty => ()\n            case x if open.isEmpty\
    \ => ()\n            case x if close.isEmpty => ()\n            case x if x ==\
    \ \")(\" => open.push(x)\n            case x if open.isEmpty && close.isEmpty\
    \ => ()\n            case x if open.isEmpty => ()\n            case x if close.isEmpty\
    \ => ()\n            case x if x == \")\" => close.push(x)\n            case x\
    \ if x == \")(\" => open.push(x)\n            case x if open.isEmpty && close.isEmpty\
    \ => ()\n            case x if open.isEmpty => ()\n            case x if close.isEmpty\
    \ => ()\n            case x if x == \")(\" => open.push(x)\n            case x\
    \ if open.isEmpty && close.isEmpty => ()\n            case x if open.isEmpty =>\
    \ ()\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzyl_j_8u.scala:67:4 ----------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    ')' expected, but 'def' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpzyl_j_8u.scala:83:0 ----------------------------\e[0m\e[0m\n\e[31m83\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzyl_j_8u.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpzyl_j_8u.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpzyl_j_8u.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.HashSet[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpzyl_j_8u.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.HashSet[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpzyl_j_8u.scala:22:19 ------------------------\e\
    [0m\e[0m\n\e[3"
  stdout: ''
  timestamp: 1659979670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => stack.pop() match {\n                    case \")\" => result += \"Yes\"\n\
    \                    case \")()\" => result += \"No\"\n                    case\
    \ \")()()\" => result += \"No\"\n                    case \")()()()\" => result\
    \ += \"No\"\n                    case \")()()()()\" => result += \"No\"\n    \
    \                case \")()()()()()\" => result += \"No\"\n                  \
    \  case \")()()()()()()\" => result += \"No\"\n                    case \")()()()()()()()\"\
    \ => result += \"No\"\n                    case \")()()()()()()()()\" => result\
    \ += \"No\"\n                    case \")()()()()()()()()()\" => result += \"\
    No\"\n                    case \")()()()()()()()()()()\" => result += \"No\"\n\
    \                    case \")()()()()()()()()()()()\" => result += \"No\"\n  \
    \                  case \")()()()()()()()()()()()\" => result += \"No\"\n    \
    \                case \")()()()()()()()()()()()\" => result += \"No\"\n      \
    \              case \")()()()()()()()()()()()()\" => result += \"No\"\n      \
    \              case \")()()()()()()()()()()()()()\" => result += \"No\"\n    \
    \                case \")()()()()()()()()()()()()()()\" => result += \"No\"\n\
    \                    case \")()()()()()()()()()()()()()()\" => result += \"No\"\
    \n                    case \")()()()()()()()()()()()()()()\" => result += \"No\"\
    \n                    case \")()()()()()()()()()()()()()()()\" => result += \"\
    No\"\n                    case \")()()()()()()()()()()()()()()()\" => result +=\
    \ \"No\"\n                    case \")()()()()()()()()()()()()()()()\" => result\
    \ += \"No\"\n                    case \")()()()()()()()()()()()()()()()()\" =>\
    \ result += \"No\"\n                    case \")()()()()()()()()()()()()()()()()\"\
    \ => result += \"No\"\n                    case \")()()()()()()()()()()()()()()()()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpquc2ncha.scala:47:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m                    \e[33mcase\e[0m \")()()()()()()()()()()()()()()()()\n\
    \e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m        \
    \                 unclosed string literal\n\e[31m\e[31m-- Error: /tmp/tmpquc2ncha.scala:49:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m49 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                 end of statement expected but '=' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpquc2ncha.scala:65:0 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpquc2ncha.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpquc2ncha.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpquc2ncha.scala:49:4\
    \ -------------------------\e[0m\e[0m\n\e[31m49 |\e[0m    \e[33mdef\e[0m \e[36mmain\e\
    [0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m  \
    \ |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    Not found: )()()()()()()()()()()()()()()()()def\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n6 errors found\n"
  stdout: ''
  timestamp: 1659979670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val left = str.substring(0, open)\n \
    \               val right = str.substring(close + 1)\n                val newStack\
    \ = stack.toList\n                newStack.push(left)\n                newStack.push(right)\n\
    \                while(!newStack.isEmpty) {\n                    val str = newStack.pop()\n\
    \                    if(str.length == 0) {\n                        result.append(\"\
    Yes\")\n                        break\n                    } else {\n        \
    \                val open = str.indexOf(\"(\")\n                        val close\
    \ = str.indexOf(\")\")\n                        if(open < 0 || close < 0) {\n\
    \                            result.append(\"No\")\n                         \
    \   break\n                        } else {\n                            val left\
    \ = str.substring(0, open)\n                            val right = str.substring(close\
    \ + 1)\n                            val newStack = stack.toList\n            \
    \                newStack.push(left)\n                            newStack.push(right)\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n        return result.toString()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8tlou_ez.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8tlou_ez.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8tlou_ez.scala:36:24 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8tlou_ez.scala:42:28\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m                        \
    \    break\n\e[31m\e[31m   |\e[0m                            ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                            Not found: break\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979671
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxIndex = stackSize - 1\n        val stackMaxValue = lst(stackMaxIndex)\n\
    \        val stackValue = lst(0)\n        val stackIndex = 0\n        val stackMaxValueIndex\
    \ = stackSize - 1\n        val stackMaxValueValue = lst(stackMaxValueIndex)\n\
    \        val stackValueIndex = stackSize - 1\n        val stackValueValue = lst(0)\n\
    \        val stackMaxValueIndexValue = stackSize - 1\n        val stackMaxValueValueValue\
    \ = lst(stackMaxValueIndexValue)\n        val stackValueIndexValue = stackSize\
    \ - 1\n        val stackValueValueValue = lst(0)\n        val stackMaxValueIndexValueValue\
    \ = stackSize - 1\n        val stackMaxValueValueValueValue = lst(stackMaxValueIndexValueValue)\n\
    \        val stackValueIndexValueValue = stackSize - 1\n        val stackValueValueValueValue\
    \ = lst(0)\n        val stackMaxValueIndexValueValueValue = stackSize - 1\n  \
    \      val stackMaxValueValueValueValueValue = lst(stackMaxValueIndexValueValueValue)\n\
    \        val stackValueIndexValueValue = stackSize - 1\n        val stackValueValueValueValueValue\
    \ = lst(0)\n        val stackMaxValueIndexValueValueValueValue = stackSize - 1\n\
    \        val stackMaxValueValueValueValueValueValue = lst(stackMaxValueIndexValueValueValueValue)\n\
    \        val stackValueIndexValueValue = stackSize - 1\n        val stackValueValueValueValueValueValue\
    \ = lst(0)\n        val stackMaxValueIndexValueValueValueValueValue = stackSize\
    \ - 1\n        val stackMaxValueValueValueValueValueValueValue = lst(stackMaxValueIndexValueValueValueValueValue)\n\
    \        val stackValueIndexValueValue = stackSize - 1\n        val stackValueValueValueValueValueValueValue\
    \ = lst(0)\n        val stackMaxValueIndexValueValueValueValueValueValue = stackSize\
    \ - 1\n        val stackMaxValueValueValueValueValueValueValueValue = lst(stackMaxValueIndexValueValueValueValueValueValue)\n\
    \        val stackValueIndexValueValue = stackSize - 1\n        val stackValueValueValueValueValueValueValueValue\
    \ = lst(0)\n        val stackMaxValueIndexValueValueValueValueValueValueValue\
    \ = stackSize - 1\n        val stackMaxValueValueValueValueValueValueValueValueValue\
    \ = lst(stackMaxValueIndexValueValueValueValueValueValueValueValue)\n        val\
    \ stackValueIndexValueValue = stackSize - 1\n        val stackValueValueValueValue\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8nz_rx4l.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8nz_rx4l.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackValueIndexValueValue\e[0m = stackSize - \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mstackValueIndexValueValue is already defined as \e[33mvalue\e[0m \e[35mstackValueIndexValueValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8nz_rx4l.scala:44:12 ---------------------------\e[0m\e[0m\n\e\
    [31m44 |\e[0m        \e[33mval\e[0m \e[36mstackValueIndexValueValue\e[0m = stackSize\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackValueIndexValueValue is already defined as \e[33mvalue\e\
    [0m \e[35mstackValueIndexValueValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8nz_rx4l.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mstackValueIndexValueValue\e\
    [0m = stackSize - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackValueIndexValueValue is already defined as \e[33mvalue\e\
    [0m \e[35mstackValueIndexValueValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8nz_rx4l.scala:52:12 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mstackValueIndexValueValue\e\
    [0m = stackSize - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackValueIndexValueValue is already defined as \e[33mvalue\e\
    [0m \e[35mstackValueInd"
  stdout: ''
  timestamp: 1659979673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        lst.foreach(x => if (x\
    \ == \"(\") queue.enqueue(x) else stack.push(x))\n        while(stack.nonEmpty)\
    \ {\n            val x = stack.pop()\n            if (x == \"(\") {\n        \
    \        queue.enqueue(x)\n            } else {\n                val y = queue.pop()\n\
    \                if (y == \"(\") queue.enqueue(y) else stack.push(y)\n       \
    \     }\n        }\n        if (queue.nonEmpty) result.enqueue(\"Yes\") else result.enqueue(\"\
    No\")\n        result.dequeue()\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplxx1q_lb.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmplxx1q_lb.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmplxx1q_lb.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979671
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxIndex = stackSize - 1\n        val stackMin = 0\n        val\
    \ stackMinIndex = 0\n        val stackMaxStack = mutable.Stack[String]()\n   \
    \     val stackMinStack = mutable.Stack[String]()\n        val stackMaxStackSize\
    \ = stackMaxStack.size()\n        val stackMinStackSize = stackMinStack.size()\n\
    \        val stackMaxStackMaxIndex = stackMaxStackSize - 1\n        val stackMinStackMinIndex\
    \ = 0\n        val stackMaxStackMinIndex = 0\n        val stackMaxStackMinStackIndex\
    \ = stackMaxStackSize - 1\n        val stackMaxStackMinStackMinIndex = 0\n   \
    \     val stackMaxStackMinStackMinStackIndex = stackMaxStackSize - 1\n       \
    \ val stackMaxStackMinStackMinStackMinIndex = 0\n        val stackMaxStackMinStackMinStackMinStackIndex\
    \ = stackMaxStackSize - 1\n        val stackMaxStackMinStackMinStackMinStackMinIndex\
    \ = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackIndex = stackMaxStackSize\
    \ - 1\n        val stackMaxStackMinStackMinStackMinStackMinStackMinIndex = 0\n\
    \        val stackMaxStackMinStackMinStackMinStackMinStackMinStackIndex = stackMaxStackSize\
    \ - 1\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex\
    \ = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackIndex\
    \ = stackMaxStackSize - 1\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex\
    \ = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex\
    \ = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex\
    \ = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex\
    \ = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex\
    \ = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex\
    \ = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex\
    \ = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex\
    \ = 0\n        val stackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex\
    \ = 0\n        val stackMaxStackMinStackMin\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjh0n391z.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjh0n391z.scala:42:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMaxStackMinStackMinStackMinStackMinStackMinStackIndex\e[0m = stackMaxStackSize\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMaxStackMinStackMinStackMinStackMinStackMinStackIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mstackMaxStackMinStackMinStackMinStackMinStackMinStackIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjh0n391z.scala:43:12 ---------------------------\e[0m\e[0m\n\e\
    [31m43 |\e[0m        \e[33mval\e[0m \e[36mstackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mstackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjh0n391z.scala:44:12 ---------------------------\e[0m\e[0m\n\e\
    [31m44 |\e[0m        \e[33mval\e[0m \e[36mstackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mstackMaxStackMinStackMinStackMinStackMinStackMinStackMinIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group"
  stdout: ''
  timestamp: 1659979675
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => stack.push(x)\n          \
    \      case \")(\"  => stack.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpqvlgfgda.scala:74:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m                \e[33mcase\e[0m \")\n\e[31m\e[31m   |\e\
    [0m                     ^\e[0m\n\e[31m   |\e[0m                     unclosed string\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmpqvlgfgda.scala:76:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqvlgfgda.scala:92:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m92 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpqvlgfgda.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpqvlgfgda.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set"
  stdout: ''
  timestamp: 1659795020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxIndex = stackSize - 1\n        val stackMin = 0\n        val\
    \ stackMinIndex = 0\n        val stackMinSize = stackSize - 1\n        val stackMaxSize\
    \ = stackSize - 1\n        val stackMinMax = stackSize - 1\n        val stackMinMaxIndex\
    \ = stackSize - 1\n        val stackMinMaxSize = stackSize - 1\n        val stackMinMaxMin\
    \ = stackSize - 1\n        val stackMinMaxMinIndex = stackSize - 1\n        val\
    \ stackMinMaxMinSize = stackSize - 1\n        val stackMinMaxMinMax = stackSize\
    \ - 1\n        val stackMinMaxMinMaxIndex = stackSize - 1\n        val stackMinMaxMinMaxSize\
    \ = stackSize - 1\n        val stackMinMaxMinMaxMin = stackSize - 1\n        val\
    \ stackMinMaxMinMaxMinIndex = stackSize - 1\n        val stackMinMaxMinMaxMinSize\
    \ = stackSize - 1\n        val stackMinMaxMinMaxMinMax = stackSize - 1\n     \
    \   val stackMinMaxMinMaxMinMaxIndex = stackSize - 1\n        val stackMinMaxMinMaxMinMaxSize\
    \ = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMin = stackSize - 1\n  \
    \      val stackMinMaxMinMaxMinMaxMinIndex = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinSize\
    \ = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinMax = stackSize - 1\n\
    \        val stackMinMaxMinMaxMinMaxMinMaxIndex = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinMaxSize\
    \ = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinMaxMax = stackSize -\
    \ 1\n        val stackMinMaxMinMaxMinMaxMinMaxMaxIndex = stackSize - 1\n     \
    \   val stackMinMaxMinMaxMinMaxMinMaxMaxSize = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinMaxMax\
    \ = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinMaxMaxIndex = stackSize\
    \ - 1\n        val stackMinMaxMinMaxMinMaxMinMaxMaxSize = stackSize - 1\n    \
    \    val stackMinMaxMinMaxMinMaxMinMaxMax = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinMaxMaxIndex\
    \ = stackSize - 1\n        val stackMinMaxMinMaxMinMaxMinMaxMaxSize = stackSize\
    \ - 1\n        val stackMinMax\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpanjr6nzy.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpanjr6nzy.scala:51:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMinMaxMinMaxMinMaxMinMaxMax\e[0m = stackSize - \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mstackMinMaxMinMaxMinMaxMinMaxMax is already defined as \e[33mvalue\e\
    [0m \e[35mstackMinMaxMinMaxMinMaxMinMaxMax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpanjr6nzy.scala:52:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMinMaxMinMaxMinMaxMinMaxMaxIndex\e[0m = stackSize - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMinMaxMinMaxMinMaxMinMaxMaxIndex is already defined as\
    \ \e[33mvalue\e[0m \e[35mstackMinMaxMinMaxMinMaxMinMaxMaxIndex\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpanjr6nzy.scala:53:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMinMaxMinMaxMinMaxMinMaxMaxSize\e[0m = stackSize - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMinMaxMinMaxMinMaxMinMaxMaxSize is already defined as\
    \ \e[33mvalue\e[0m \e[35mstackMinMaxMinMaxMinMaxMinMaxMaxSize\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpanjr6nzy.scala:54:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMinMaxMinMaxMinMaxMinMaxMax\e[0m = stackSize - \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        val openCount = mutable.Map[String, Int]()\n        val closeCount =\
    \ mutable.Map[String, Int]()\n        lst.foreach(x => {\n            x match\
    \ {\n                case \")\" => closeCount += ((x, 1))\n                case\
    \ \")(\"  => openCount += ((x, 1))\n                case \")(\"  => closeCount\
    \ += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n         \
    \       case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount\
    \ += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n         \
    \       case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount\
    \ += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n        \
    \        case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount\
    \ += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n         \
    \       case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount\
    \ += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n        \
    \        case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount\
    \ += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n         \
    \       case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount\
    \ += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n        \
    \        case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount\
    \ += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n         \
    \       case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount\
    \ += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n        \
    \        case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount\
    \ += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n         \
    \       case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount\
    \ += ((x, 1))\n                case \")\" => closeCount += ((x, 1))\n        \
    \        case \")\" => openCount += ((x, 1))\n                case \")\" => closeCount\
    \ += ((x, 1))\n                case \")\" => openCount += ((x, 1))\n         \
    \       case \")\" => closeCount += ((x, 1))\n                case \")\" => openCount\
    \ += ((\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpwcw0d1_i.scala:64:43 ---------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m                \e[33mcase\e[0m \e[31m\")\"\e[0m => openCount\
    \ += ((\n\e[31m\e[31m   |\e[0m                                           ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwcw0d1_i.scala:82:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m82 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpwcw0d1_i.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpwcw0d1_i.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpwcw0d1_i.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpwcw0d1_i.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explan"
  stdout: ''
  timestamp: 1659979673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val len = lst.size\n  \
    \      for(i <- 0 until len){\n            val str = lst(i)\n            val len\
    \ = str.length\n            val isOpen = str.charAt(0) == '('\n            val\
    \ isClose = str.charAt(len-1) == ')'\n            if(!isOpen && !isClose){\n \
    \               queue.enqueue(str)\n            }\n            else if(isOpen\
    \ && !isClose){\n                stack.push(str)\n            }\n            else\
    \ if(isClose && !isOpen){\n                val str = stack.pop()\n           \
    \     if(!queue.contains(str)){\n                    result.enqueue(str)\n   \
    \             }\n            }\n        }\n        if(result.size == len){\n \
    \           return \"Yes\"\n        }\n        else{\n            return \"No\"\
    \n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7cm3xqtd.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp7cm3xqtd.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp7cm3xqtd.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        val openCount = mutable.ListBuffer[Int]()\n        val closeCount = mutable.ListBuffer[Int]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") {\n                open\
    \ += x\n                openCount += 1\n            } else if (x == \")\") {\n\
    \                close += x\n                closeCount += 1\n            } else\
    \ {\n                stack += x\n            }\n        })\n        val openCount\
    \ = openCount.toList\n        val closeCount = closeCount.toList\n        if (openCount.size\
    \ == closeCount.size) {\n            val open = open.toList\n            val close\
    \ = close.toList\n            val stack = stack.toList\n            val len =\
    \ openCount.size\n            val stackLen = stack.length\n            var i =\
    \ 0\n            var j = 0\n            var k = 0\n            var l = 0\n   \
    \         var m = 0\n            var n = 0\n            var o = 0\n          \
    \  var p = 0\n            var q = 0\n            var r = 0\n            var s\
    \ = 0\n            var t = 0\n            var u = 0\n            var v = 0\n \
    \           var w = 0\n            var x = 0\n            var y = 0\n        \
    \    var z = 0\n            var a = 0\n            var b = 0\n            var\
    \ c = 0\n            var d = 0\n            var e = 0\n            var f = 0\n\
    \            var g = 0\n            var h = 0\n            var i = 0\n       \
    \     var j = 0\n            var k = 0\n            var l = 0\n            var\
    \ m = 0\n            var n = 0\n            var o = 0\n            var p = 0\n\
    \            var q = 0\n            var r = 0\n            var s = 0\n       \
    \     var t = 0\n            var u = 0\n            var v = 0\n            var\
    \ w = 0\n            var x = 0\n            var y = 0\n            var z = 0\n\
    \            var a = 0\n            var b = 0\n            var c = 0\n       \
    \     var d = 0\n            var e = 0\n            var f = 0\n            var\
    \ g = 0\n            var h = 0\n            var i = 0\n            var j = 0\n\
    \            var k = 0\n            var l = 0\n            var m = 0\n       \
    \     var n = 0\n            var o = 0\n            var p = 0\n            var\
    \ q = 0\n            var r = 0\n            var s = 0\n            var t = 0\n\
    \            var u = 0\n            var v = 0\n            var w = 0\n       \
    \     var x = 0\n            var y = 0\n            var z = 0\n            var\
    \ a = 0\n            var b = 0\n            var c = 0\n            var d = 0\n\
    \            var e = 0\n            var f = 0\n            var g = 0\n       \
    \     var h = 0\n            var i = 0\n            var j = 0\n            var\
    \ k = 0\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0gee6whc.scala:142:0 ---------------------------\e\
    [0m\e[0m\n\e[31m142 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0gee6whc.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopenCount\e[0m = openCount.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopenCount is already defined as \e[33mvalue\e[0m \e[35mopenCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0gee6whc.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mcloseCount\e[0m = closeCount.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mcloseCount is already defined as \e[33mvalue\e[0m \e[35mcloseCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp0gee6whc.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp0gee6whc.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0gee6whc.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |"
  stdout: ''
  timestamp: 1659979678
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") open += x\n         \
    \   if (x == \")\") close += x\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"Yes\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n  \
    \          if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if\
    \ (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"\
    No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n     \
    \       if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n  \
    \          if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if\
    \ (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n  \
    \          if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if\
    \ (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n  \
    \          if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if\
    \ (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && close\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0_jcllro.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0_jcllro.scala:58:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m58 |\e[0m    \e[33mdef\e[0m \e\
    [36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e\
    [31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    ')' expected, but 'def' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmp0_jcllro.scala:74:0 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0_jcllro.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0_jcllro.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0_jcllro.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0_jcllro.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e["
  stdout: ''
  timestamp: 1659979673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => if (x == \"(\") stack += x else if (!stack.isEmpty &&\
    \ x == \")\") result += stack.pop())\n        if (result.size == lst.length) result.mkString(\"\
    Yes\") else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr7vg0zev.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpr7vg0zev.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x == \")\" => close.push(x)\n\
    \            case x if x == \"(\" => open.push(x)\n            case _ => stack\
    \ += x\n        })\n        val openCount = open.size\n        val closeCount\
    \ = close.size\n        if (openCount == closeCount) {\n            val openStr\
    \ = open.toList\n            val closeStr = close.toList\n            val openStrLen\
    \ = openStr.size\n            val closeStrLen = closeStr.size\n            val\
    \ openStrSet = openStr.distinct\n            val closeStrSet = closeStr.distinct\n\
    \            val openStrSetLen = openStrSet.size\n            val closeStrSetLen\
    \ = closeStrSet.size\n            val openStrSetSet = openStrSet.intersect(closeStrSet)\n\
    \            val closeStrSetSet = closeStrSet.intersect(openStrSet)\n        \
    \    val openStrSetSetLen = openStrSetSet.size\n            val closeStrSetSetLen\
    \ = closeStrSetSet.size\n            val openStrSetSetSet = openStrSetSet.intersect(closeStrSetSet)\n\
    \            val closeStrSetSetSet = closeStrSetSet.intersect(openStrSetSet)\n\
    \            val openStrSetSetSetLen = openStrSetSetSet.size\n            val\
    \ closeStrSetSetSetLen = closeStrSetSet.size\n            val openStrSetSetSetSet\
    \ = openStrSetSet.intersect(closeStrSetSetSet)\n            val closeStrSetSetSet\
    \ = closeStrSetSet.intersect(openStrSetSetSet)\n            val openStrSetSetSetSetLen\
    \ = openStrSetSetSet.size\n            val closeStrSetSetSetLen = closeStrSetSet.size\n\
    \            val openStrSetSetSetSet = openStrSetSet.intersect(closeStrSetSetSet)\n\
    \            val closeStrSetSetSet = closeStrSetSet.intersect(openStrSetSetSet)\n\
    \            val openStrSetSetSetSetLen = openStrSetSetSetSet.size\n         \
    \   val closeStrSetSetSetLen = closeStrSetSet.size\n            val openStrSetSetSetSet\
    \ = openStrSetSetSet.intersect(closeStrSetSetSet)\n            \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc4rdd_an.scala:73:0 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc4rdd_an.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc4rdd_an.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc4rdd_an.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc4rdd_an.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc4rdd_an.scala:47:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m            \e[33mval\e\
    [0m \e[36mcloseStrSetSetSet\e[0m = closeStrSetSet.intersect(openStrSetSetSet)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcloseStrSetSetSet is already defined as \e[33mvalue\e[0m"
  stdout: ''
  timestamp: 1659979678
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxIndex = stackSize - 1\n        val stackIndex = 0\n        val\
    \ stackMaxValue = lst(stackMaxIndex)\n        val stackMaxValueIndex = stackMaxIndex\n\
    \        val stackMaxValueValue = lst(stackMaxValueIndex)\n        val stackMaxValueValueIndex\
    \ = stackMaxValueIndex\n        val stackMaxValueValueValue = lst(stackMaxValueValueIndex)\n\
    \        val stackMaxValueValueValueIndex = stackMaxValueValueIndex\n        val\
    \ stackMaxValueValueValueValue = lst(stackMaxValueValueValueIndex)\n        val\
    \ stackMaxValueValueValueValueIndex = stackMaxValueValueValueIndex\n        val\
    \ stackMaxValueValueValueValueValue = lst(stackMaxValueValueValueValueIndex)\n\
    \        val stackMaxValueValueValueValueValueIndex = stackMaxValueValueValueValueIndex\n\
    \        val stackMaxValueValueValueValueValueValue = lst(stackMaxValueValueValueValueValueIndex)\n\
    \        val stackMaxValueValueValueValueValueIndex = stackMaxValueValueValueValueValueIndex\n\
    \        val stackMaxValueValueValueValueValueValue = lst(stackMaxValueValueValueValueValueIndex)\n\
    \        val stackMaxValueValueValueValueValueIndex = stackMaxValueValueValueValueValueValueIndex\n\
    \        val stackMaxValueValueValueValueValueValueValue = lst(stackMaxValueValueValueValueValueValueIndex)\n\
    \        val stackMaxValueValueValueValueValueValueIndex = stackMaxValueValueValueValueValueValueValueIndex\n\
    \        val stackMaxValueValueValueValueValueValueValue = lst(stackMaxValueValueValueValueValueValueValueIndex)\n\
    \        val stackMaxValueValueValueValueValueValueIndex = stackMaxValueValueValueValueValueValueValueIndex\n\
    \        val stackMaxValueValueValueValueValueValueValue = lst(stackMaxValueValueValueValueValueValueValueIndex)\n\
    \        val stackMaxValueValueValueValueValueValueIndex = stackMaxValueValueValueValueValueValueValueValueIndex\n\
    \        val stackMaxValueValueValueValueValueValueValueIndex = stackMaxValueValueValueValueValueValueValueValueValueIndex\n\
    \        val stackMaxValueValueValueValueValueValueValueValue = lst(stackMaxValueValueValueValueValueValueValueValueIndex)\n\
    \        val stackMaxValueValueValueValueValueValueValueIndex = stackMaxValueValueValueValueValueValueValueValueValueIndex\n\
    \        val stackMaxValueValueValueValueValueValueValueValue = lst(stackMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpoup9ntn8.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpoup9ntn8.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMaxValueValueValueValueValueIndex\e[0m = stackMaxValueValueValueValueValueIndex\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMaxValueValueValueValueValueIndex is already defined\
    \ as \e[33mvalue\e[0m \e[35mstackMaxValueValueValueValueValueIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpoup9ntn8.scala:36:12 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        \e[33mval\e[0m \e[36mstackMaxValueValueValueValueValueValue\e\
    [0m = lst(stackMaxValueValueValueValueValueIndex)\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMaxValueValueValueValueValueValue is already defined\
    \ as \e[33mvalue\e[0m \e[35mstackMaxValueValueValueValueValueValue\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpoup9ntn8.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36mstackMaxValueValueValueValueValueIndex\e\
    [0m = stackMaxValueValueValueValueValueValueIndex\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMaxValueValueValueValueValueIndex is already defined\
    \ as \e[33mvalue\e[0m \e[35mstackMaxValueValueValueValueValueIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpoup9ntn8.scala:40:12 -"
  stdout: ''
  timestamp: 1659979677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxSize = stackMax * 2\n        val stackMaxMax = stackMaxSize -\
    \ 1\n        val stackMaxMaxSize = stackMaxMax * 2\n        val stackMaxMaxMax\
    \ = stackMaxMaxSize - 1\n        val stackMaxMaxMaxSize = stackMaxMaxMax * 2\n\
    \        val stackMaxMaxMaxMax = stackMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxSize\
    \ = stackMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMax = stackMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMax * 2\n     \
    \   val stackMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxMaxMaxSize\
    \ = stackMaxMaxMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMax\
    \ * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp55rx3h15.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp55rx3h15.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmp55rx3h15.scala:34:45 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mstackMaxMaxMaxMaxMaxMaxMaxSize\e\
    [0m = stackMaxMaxMaxMaxMaxMaxMax * \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m       \
    \                                      ^\e[0m\n\e[31m   |\e[0m               \
    \    Recursive \e[33mvalue\e[0m \e[35mstackMaxMaxMaxMaxMaxMaxMax\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp55rx3h15.scala:40:54\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e\
    [36mstackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\e[0m = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ * \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                    Not found: stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp55rx3h15.scala:41:53\
    \ ------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e\
    [36mstackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\e[0m = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                     "
  stdout: ''
  timestamp: 1659979679
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stackIsEmpty = stack.isEmpty\n        val resultIsEmpty = result.isEmpty\n\
    \        val stackIsFull = stackSize == stackIsEmpty\n        val resultIsFull\
    \ = resultSize == resultIsEmpty\n        val stackIsEmptyOrFull = stackIsEmpty\
    \ || stackIsFull\n        val resultIsEmptyOrFull = resultIsEmpty || resultIsFull\n\
    \        val stackIsFullOrEmpty = stackIsFull || stackIsEmpty\n        val resultIsFullOrEmpty\
    \ = resultIsFull || resultIsEmpty\n        val stackIsEmptyOrFullOrEmpty = stackIsEmptyOrFull\
    \ || stackIsFullOrEmpty\n        val resultIsEmptyOrFullOrEmpty = resultIsEmptyOrFull\
    \ || resultIsFullOrEmpty\n        val stackIsFullOrFullOrEmpty = stackIsFullOrEmpty\
    \ || stackIsFullOrEmpty\n        val resultIsFullOrFullOrEmpty = resultIsFullOrEmpty\
    \ || resultIsFullOrEmpty\n        val stackIsFullOrFullOrEmpty = stackIsFullOrEmpty\
    \ || stackIsFullOrEmpty\n        val resultIsFullOrFullOrEmpty = resultIsFullOrEmpty\
    \ || resultIsFullOrEmpty\n        val stackIsFullOrFullOrEmpty = stackIsFullOrEmpty\
    \ || stackIsFullOrEmpty\n        val resultIsFullOrFullOrEmpty = resultIsFullOrEmpty\
    \ || resultIsFullOrEmpty\n        val stackIsFullOrFullOrEmpty = stackIsFullOrEmpty\
    \ || stackIsFullOrEmpty\n        val resultIsFullOrFullOrEmpty = resultIsFullOrEmpty\
    \ || resultIsFullOrEmpty\n        val stackIsFullOrFullOrEmpty = stackIsFullOrEmpty\
    \ || stackIsFullOrEmpty\n        val resultIsFullOrFullOrEmpty = resultIsFullOrEmpty\
    \ || resultIsFullOrEmpty\n        val stackIsFullOrFullOrEmpty = stackIsFullOrEmpty\
    \ || stackIsFullOrEmpty\n        val resultIsFullOrFullOrEmpty = resultIsFullOrEmpty\
    \ || resultIsFullOrEmpty\n        val stackIsFullOrFullOrEmpty = stackIsFullOrEmpty\
    \ || stackIsFullOrEmpty\n        val resultIsFullOrFullOrEmpty = resultIsFullOrEmpty\
    \ || resultIsFullOrEmpty\n        val stackIsFullOrFullOrEmpty = stackIs\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9y77l_wu.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mstackIsFullOrFullOrEmpty\e\
    [0m = stackIsFullOrEmpty || stackIsFullOrEmpty\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackIsFullOrFullOrEmpty is already defined as \e[33mvalue\e\
    [0m \e[35mstackIsFullOrFullOrEmpty\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9y77l_wu.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mresultIsFullOrFullOrEmpty\e\
    [0m = resultIsFullOrEmpty || resultIsFullOrEmpty\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresultIsFullOrFullOrEmpty is already defined as \e[33mvalue\e\
    [0m \e[35mresultIsFullOrFullOrEmpty\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9y77l_wu.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mstackIsFullOrFullOrEmpty\e\
    [0m = stackIsFullOrEmpty || stackIsFullOrEmpty\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackIsFullOrFullOrEmpty is already defined as \e[33mvalue\e\
    [0m \e[35mstackIsFullOrFullOrEmpty\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9y77l_wu.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mresultIsFullOrFullOrEmpty\e\
    [0m = resultIsFullOrEmpty || resultIsFullOrEmpty\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresultIsFullOrFullOrEmpty is already defined as \e[33mvalue\e\
    [0m \e[35mresultIsFullOrFullOrEmpt"
  stdout: ''
  timestamp: 1659979679
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x == \")\" => close.push(x)\n\
    \            case x if x == \")\" => stack.push(x)\n            case x if x ==\
    \ \"(\" => open.push(x)\n            case x if x == \")\" => stack.pop() match\
    \ {\n                case x if x == \")\" => close.push(x)\n                case\
    \ x if x == \")\" => result.add(\"Yes\")\n                case x if x == \"(\"\
    \ => open.push(x)\n                case x => result.add(\"No\")\n            }\n\
    \            case x => result.add(\"No\")\n        })\n        result.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj9_dshtn.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpj9_dshtn.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpj9_dshtn.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpj9_dshtn.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => stack.push(x)\n          \
    \      case \")(\"  => stack.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" \n    }\n    def main(args: Array[String]) = {\n \
    \   assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n \
    \   assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptiiwc0ku.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=>' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptiiwc0ku.scala:92:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m92 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmptiiwc0ku.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmptiiwc0ku.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmptiiwc0ku.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmptiiwc0ku.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmptiiwc0ku.scala:76:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m76 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m])"
  stdout: ''
  timestamp: 1659979678
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.ListBuffer[String]()\n        val bad = mutable.ListBuffer[String]()\n\
    \        val goodParens = mutable.ListBuffer[String]()\n        val badParens\
    \ = mutable.ListBuffer[String]()\n        val goodParensCount = mutable.ListBuffer[Int]()\n\
    \        val badParensCount = mutable.ListBuffer[Int]()\n        val goodParensCount2\
    \ = mutable.ListBuffer[Int]()\n        val badParensCount2 = mutable.ListBuffer[Int]()\n\
    \        val goodParensCount3 = mutable.ListBuffer[Int]()\n        val badParensCount3\
    \ = mutable.ListBuffer[Int]()\n        val goodParensCount4 = mutable.ListBuffer[Int]()\n\
    \        val badParensCount4 = mutable.ListBuffer[Int]()\n        val goodParensCount5\
    \ = mutable.ListBuffer[Int]()\n        val badParensCount5 = mutable.ListBuffer[Int]()\n\
    \        val goodParensCount6 = mutable.ListBuffer[Int]()\n        val badParensCount6\
    \ = mutable.ListBuffer[Int]()\n        val goodParensCount7 = mutable.ListBuffer[Int]()\n\
    \        val badParensCount7 = mutable.ListBuffer[Int]()\n        val goodParensCount8\
    \ = mutable.ListBuffer[Int]()\n        val badParensCount8 = mutable.ListBuffer[Int]()\n\
    \        val goodParensCount9 = mutable.ListBuffer[Int]()\n        val badParensCount9\
    \ = mutable.ListBuffer[Int]()\n        val goodParensCount10 = mutable.ListBuffer[Int]()\n\
    \        val badParensCount10 = mutable.ListBuffer[Int]()\n        val goodParensCount11\
    \ = mutable.ListBuffer[Int]()\n        val badParensCount11 = mutable.ListBuffer[Int]()\n\
    \        val goodParensCount12 = mutable.ListBuffer[Int]()\n        val badParensCount12\
    \ = mutable.ListBuffer[Int]()\n        val goodParensCount13 = mutable.ListBuffer[Int]()\n\
    \        val badParensCount13 = mutable.ListBuffer[Int]()\n        val goodParensCount14\
    \ = mutable.ListBuffer[Int]()\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmprc5i4xhy.scala:51:11 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmprc5i4xhy.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmprc5i4xhy.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmprc5i4xhy.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmprc5i4xhy.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmprc5i4xhy.scala:22:25 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mgoodParens\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |"
  stdout: ''
  timestamp: 1659979681
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    if (!stack.isEmpty) {\n                        stack.pop()\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    if (!queue.isEmpty) {\n                        queue.pop()\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    if (!queue.isEmpty) {\n                        queue.pop()\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    if (!queue.isEmpty) {\n                        queue.pop()\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    if (!queue.isEmpty) {\n                        queue.pop()\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    if (!queue.isEmpty) {\n                        queue.pop()\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    if (!queue.isEmpty) {\n                        queue.pop()\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    if (!queue.isEmpty) {\n                        queue.pop()\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    if (!queue.isEmpty) {\n                        queue.pop()\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    if (!queue.isEmpty) {\n                        queue.pop()\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    if (!queue.isEmpty) {\n                        queue.pop()\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    if (!queue.isEmpty) {\n                        queue.pop()\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    if (!queue.isEmpty) {\n                        queue.pop()\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    if (!queue.isEmpty) {\n                        queue.pop()\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    if (!queue.isEmpty) {\n                        queue.pop()\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    if (!queue.isEmpty) {\n                        queue.pop()\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    if (!queue.isEmpty) {\n                        queue.pop()\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    if (!queue.isEmpty) {\n                        queue.pop()\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    if (!queue.isEmpty) {\n                        queue.pop()\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    if (!queue.isEmpty) {\n                        queue.pop()\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    if (!queue.is\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf7x6qfkk.scala:128:4 ---------------------------\e\
    [0m\e[0m\n\e[31m128 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf7x6qfkk.scala:145:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m145 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpf7x6qfkk.scala:18:20 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpf7x6qfkk.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpf7x6qfkk.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpf7x6qfkk.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpf7x6qfkk.scala:22:22 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mgoodStr\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m "
  stdout: ''
  timestamp: 1659979679
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") stack += x\n        \
    \    if (x == \")\") stack -= x\n            if (stack.size == 0 && queue.size\
    \ == 0) good += x\n            if (stack.size == 0 && queue.size != 0) bad +=\
    \ x\n            if (stack.size != 0 && queue.size == 0) bad += x\n          \
    \  if (stack.size != 0 && queue.size != 0) queue += x\n        })\n        if\
    \ (good.size == lst.size) good.toList.mkString(\"(\", \")\")\n        else if\
    \ (bad.size == lst.size) \"No\"\n        else matchParens(lst.tail)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl6314lqu.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpl6314lqu.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpl6314lqu.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpl6314lqu.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979678
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.ListBuffer[String]()\n        lst.foreach(x => if\
    \ (x == \"(\") stack += x else if (!x == \"(\") queue += x else ())\n        while\
    \ (stack.nonEmpty || queue.nonEmpty) {\n            if (stack.nonEmpty && queue.nonEmpty)\
    \ {\n                if (stack.head == \"(\" && queue.head == \"(\") stack.pop()\
    \ else if (!stack.head == \"(\" && queue.head == \"(\") queue.pop() else ()\n\
    \            } else if (stack.nonEmpty) {\n                result += \"(\"\n \
    \               stack.pop()\n            } else if (queue.nonEmpty) {\n      \
    \          result += \")\"\n                queue.pop()\n            }\n     \
    \   }\n        if (result.nonEmpty) result.mkString\n        else \"No\"\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptv5fqwiq.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmptv5fqwiq.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmptv5fqwiq.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmptv5fqwiq.scala:21:59 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        lst.foreach(\e[36mx\e[0m => \e[33mif\e[0m (x\
    \ == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"\
    (\"\e[0m) queue += x \e[33melse\e[0m ())\n\e[31m\e[31m   |\e[0m              \
    \                                             ^^\e[0m\n\e[31m   |\e[0m       \
    \                          value unary_! is not a member of String\n4 errors found\n"
  stdout: ''
  timestamp: 1659979681
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val len = lst.size\n  \
    \      for(i <- 0 until len) {\n            val str = lst(i)\n            val\
    \ open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\")\n    \
    \        if(open < 0 || close < 0) {\n                result.enqueue(str)\n  \
    \          } else {\n                val stackStr = str.substring(0, open)\n \
    \               val queueStr = str.substring(open + 1, close)\n              \
    \  stack.push(stackStr)\n                queue.enqueue(queueStr)\n           \
    \ }\n        }\n        while(stack.nonEmpty) {\n            val str = stack.pop()\n\
    \            val queueStr = queue.pop()\n            if(!queueStr.equals(str))\
    \ {\n                result.enqueue(str)\n            }\n        }\n        if(result.isEmpty)\
    \ {\n            \"No\"\n        } else {\n            \"Yes\"\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq1bdtfxe.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpq1bdtfxe.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpq1bdtfxe.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979679
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackSize2 = stackSize * stackSize\n\
    \        val stackSize3 = stackSize2 * stackSize\n        val stackSize4 = stackSize3\
    \ * stackSize\n        val stackSize5 = stackSize4 * stackSize\n        val stackSize6\
    \ = stackSize5 * stackSize\n        val stackSize7 = stackSize6 * stackSize\n\
    \        val stackSize8 = stackSize7 * stackSize\n        val stackSize9 = stackSize8\
    \ * stackSize\n        val stackSize10 = stackSize9 * stackSize\n        val stackSize11\
    \ = stackSize10 * stackSize\n        val stackSize12 = stackSize11 * stackSize\n\
    \        val stackSize13 = stackSize12 * stackSize\n        val stackSize14 =\
    \ stackSize13 * stackSize\n        val stackSize15 = stackSize14 * stackSize\n\
    \        val stackSize16 = stackSize15 * stackSize\n        val stackSize17 =\
    \ stackSize16 * stackSize\n        val stackSize18 = stackSize17 * stackSize\n\
    \        val stackSize19 = stackSize18 * stackSize\n        val stackSize20 =\
    \ stackSize19 * stackSize\n        val stackSize21 = stackSize20 * stackSize\n\
    \        val stackSize22 = stackSize21 * stackSize\n        val stackSize23 =\
    \ stackSize22 * stackSize\n        val stackSize24 = stackSize23 * stackSize\n\
    \        val stackSize25 = stackSize24 * stackSize\n        val stackSize26 =\
    \ stackSize25 * stackSize\n        val stackSize27 = stackSize26 * stackSize\n\
    \        val stackSize28 = stackSize27 * stackSize\n        val stackSize29 =\
    \ stackSize28 * stackSize\n        val stackSize30 = stackSize29 * stackSize\n\
    \        val stackSize31 = stackSize30 * stackSize\n        val stackSize32 =\
    \ stackSize31 * stackSize\n        val stackSize33 = stackSize32 * stackSize\n\
    \        val stackSize34 = stackSize33 * stackSize\n        val stackSize35 =\
    \ stackSize34 * stackSize\n        val stackSize36 = stackSize35 * stackSize\n\
    \        val stackSize37 = stackSize36 * stackSize\n        val stackSize38 =\
    \ stackSize37 * stackSize\n        val stackSize39 = stackSize38 * stackSize\n\
    \        val stackSize\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpch5x3hl7.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpch5x3hl7.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpch5x3hl7.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpch5x3hl7.scala:60:5\
    \ ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979657
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stackMax = stackSize - 1\n        val resultMax = resultSize - 1\n     \
    \   val stackIndex = 0\n        val resultIndex = 0\n        val stackIsEmpty\
    \ = stack.isEmpty\n        val resultIsEmpty = result.isEmpty\n        val stackIsFull\
    \ = stackMax == stackIndex\n        val resultIsFull = resultMax == resultIndex\n\
    \        while(stackIsEmpty || resultIsEmpty) {\n            val stackSize = lst.size\n\
    \            val resultSize = lst.size\n            val stackMax = stackSize -\
    \ 1\n            val resultMax = resultSize - 1\n            val stackIndex =\
    \ 0\n            val resultIndex = 0\n            val stackIsEmpty = stack.isEmpty\n\
    \            val resultIsEmpty = result.isEmpty\n            val stackIsFull =\
    \ stackMax == stackIndex\n            val resultIsFull = resultMax == resultIndex\n\
    \            while(stackIsEmpty || resultIsEmpty) {\n                val stackSize\
    \ = lst.size\n                val resultSize = lst.size\n                val stackMax\
    \ = stackSize - 1\n                val resultMax = resultSize - 1\n          \
    \      val stackIndex = 0\n                val resultIndex = 0\n             \
    \   val stackIsEmpty = stack.isEmpty\n                val resultIsEmpty = result.isEmpty\n\
    \                val stackIsFull = stackMax == stackIndex\n                val\
    \ resultIsFull = resultMax == resultIndex\n                while(stackIsEmpty\
    \ || resultIsEmpty) {\n                    val stackSize = lst.size\n        \
    \            val resultSize = lst.size\n                    val stackMax = stackSize\
    \ - 1\n                    val resultMax = resultSize - 1\n                  \
    \  val stackIndex = 0\n                    val resultIndex = 0\n             \
    \       val stackIsEmpty = stack.isEmpty\n                    val resultIsEmpty\
    \ = result.isEmpty\n                    val stackIsFull = stackMax == stackIndex\n\
    \                    val resultIsFull = resultMax == resultIndex\n           \
    \         while(stackIsEmpty || resultIsEmpty) {\n                        val\
    \ stackSize = lst.size\n                        val resultSize = lst.size\n  \
    \                      val stackMax = stackSize - 1\n                        val\
    \ resultMax = resultSize - 1\n                        val stackIndex = 0\n   \
    \                     val resultIndex = 0\n                        val stackIsEmpty\
    \ = stack.isEmpty\n                        val resultIsEmpty = result.isEmpty\n\
    \                        val stackIsFull = stackMax == stackIndex\n          \
    \              val resultIsFull = resultMax == resultIndex\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpot37uayc.scala:92:0 ----------------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpot37uayc.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpot37uayc.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpot37uayc.scala:30:8\
    \ ---------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mwhile\e[0m(stackIsEmpty\
    \ || resultIsEmpty) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m  \
    \      Found:    Unit\n\e[31m   |\e[0m        Required: String\n\e[31m31 |\e[0m\
    \            \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m32 |\e[0m \
    \           \e[33mval\e[0m \e[36mresultSize\e[0m = lst.size\n\e[31m33 |\e[0m \
    \           \e[33mval\e[0m \e[36mstackMax\e[0m = stackSize - \e[31m1\e[0m\n\e\
    [31m34 |\e[0m            \e[33mval\e[0m \e[36mresultMax\e[0m = resultSize - \e\
    [31m1\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36mstackIndex\e[0m =\
    \ \e[31m0\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36mresultIndex\e\
    [0m = \e[31m0\e[0m\n\e[31m37 |\e[0m            \e[33mval\e[0m \e[36mstackIsEmpty\e\
    [0m = stack.isEmpty\n\e[31m38 |\e[0m            \e[33mval\e[0m \e[36mresultIsEmpty\e\
    [0m = result.isEmpty\n\e[31m39 |\e[0m            \e[33mval\e[0m \e[36mstackIsFull\e\
    [0m = stackMax == stackIndex\n\e[31m40 |\e[0m            \e[33mval\e[0m \e[36mresultIsFull\e\
    [0m = resultMax == resultIndex\n\e[31m41 |\e[0m            \e[33mwhile\e[0m(stackIsEmpty\
    \ || resultIsEmpty) {\n\e[31m"
  stdout: ''
  timestamp: 1659979683
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        val openCount = mutable.Map[String, Int]()\n        val closeCount =\
    \ mutable.Map[String, Int]()\n        lst.foreach(x => x match {\n           \
    \ case x if x == \")\" => closeCount += ((x, 1))\n            case x if x == \"\
    (\" => open += x\n            case x => stack += x\n        })\n        val openCount\
    \ = openCount.toSeq\n        val closeCount = closeCount.toSeq\n        val openCount\
    \ = openCount.sortBy(_._2).reverse\n        val closeCount = closeCount.sortBy(_._2).reverse\n\
    \        val openCount = openCount.take(openCount.size - 1).sortBy(_._1).reverse\n\
    \        val closeCount = closeCount.take(closeCount.size - 1).sortBy(_._1).reverse\n\
    \        val openCount = openCount.take(openCount.size - 1).sortBy(_._1).reverse\n\
    \        val closeCount = closeCount.take(closeCount.size - 1).sortBy(_._1).reverse\n\
    \        val openCount = openCount.take(openCount.size - 1).sortBy(_._1).reverse\n\
    \        val closeCount = closeCount.take(closeCount.size - 1).sortBy(_._1).reverse\n\
    \        val openCount = openCount.take(openCount.size - 1).sortBy(_._1).reverse\n\
    \        val closeCount = closeCount.take(closeCount.size - 1).sortBy(_._1).reverse\n\
    \        val openCount = openCount.take(openCount.size - 1).sortBy(_._1).reverse\n\
    \        val closeCount = closeCount.take(closeCount.size - 1).sortBy(_._1).reverse\n\
    \        val openCount = openCount.take(openCount.size - 1).sortBy(_._1).reverse\n\
    \        val closeCount = closeCount.take(closeCount.size - 1).sortBy(_._1).reverse\n\
    \        val openCount = openCount.take(openCount.size - 1).sortBy(_._1).reverse\n\
    \        val closeCount = closeCount.take(closeCount.size - 1).sortBy(_._1).reverse\n\
    \        val openCount = openCount.take(openCount.size - 1).sortBy(_._1).reverse\n\
    \        val closeCount = closeCount.take(closeCount.size - 1).sortBy(_._1).reverse\n\
    \        val openCount = openCount.take(openCoun\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwk_mukb8.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwk_mukb8.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopenCount\e[0m = openCount.toSeq\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopenCount is already defined as \e[33mvalue\e[0m \e[35mopenCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpwk_mukb8.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mcloseCount\e[0m = closeCount.toSeq\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mcloseCount is already defined as \e[33mvalue\e[0m \e[35mcloseCount\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpwk_mukb8.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36mopenCount\e[0m = openCount.sortBy(_._2).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopenCount is already defined as \e[33mvalue\e[0m \e[35mopenCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpwk_mukb8.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mcloseCount\e[0m = closeCount.sortBy(_._2).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcloseCount is already defined as \e[33mvalue\e[0m \e[35mcloseCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpwk_mukb8.scala:33:12 ------"
  stdout: ''
  timestamp: 1659979682
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x.startsWith(\"(\"\
    ) => queue.enqueue(x)\n            case x if x.startsWith(\")\") => stack.push(x)\n\
    \            case x => bad.add(x)\n        })\n        while(!queue.isEmpty &&\
    \ !stack.isEmpty) {\n            val x = queue.poll\n            val y = stack.pop()\n\
    \            good += x + y\n            bad += y\n            x match {\n    \
    \            case x if x.startsWith(\"(\") => queue.enqueue(x)\n             \
    \   case x if x.startsWith(\")\") => stack.push(x)\n                case x =>\
    \ bad.add(x)\n            }\n        }\n        if(good.size == lst.size) {\n\
    \            return \"Yes\"\n        } else {\n            return \"No\"\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbphp494s.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpbphp494s.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpbphp494s.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpbphp494s.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979682
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.foreach(x => stack.pop())\n                  \
    \  result ++= stack\n                    stack = mutable.Stack[String]()\n   \
    \             case \")(\"  =>\n                    open += x\n               \
    \ case \")(\"  =>\n                    open += x\n                case \")\" =>\n\
    \                    open += x\n                case \")\" =>\n              \
    \      open += x\n                case \")\" =>\n                    open += x\n\
    \                case \")\" =>\n                    open += x\n              \
    \  case \")\" =>\n                    open += x\n                case \")\" =>\n\
    \                    open += x\n                case \")\" =>\n              \
    \      open += x\n                case \")\" =>\n                    open += x\n\
    \                case \")\" =>\n                    open += x\n              \
    \  case \")\" =>\n                    open += x\n                case \")\" =>\n\
    \                    open += x\n                case \")\" =>\n              \
    \      open += x\n                case \")\" =>\n                    open += x\n\
    \                case \")\" =>\n                    open += x\n              \
    \  case \")\" =>\n                    open += x\n                case \")\" =>\n\
    \                    open += x\n                case \")\" =>\n              \
    \      open += x\n                case \")\" =>\n                    open += x\n\
    \                case \")\" =>\n                    open += x\n              \
    \  case \")\" =>\n                    open += x\n                case \")\" =>\n\
    \                    open += x\n                case \")\" =>\n              \
    \      open += x\n                case \")\" =>\n                    open += x\n\
    \                case \")\" =>\n                    open += x\n              \
    \  case \")\" =>\n                    open += x\n                case \")\" =>\n\
    \                    open += x\n                case \")\" =>\n              \
    \      open += x\n                case \")\" =>\n                    open += x\n\
    \                case \")\" =>\n                    open += x\n              \
    \  case \")\" =>\n                    open += x\n                case \")\" =>\n\
    \                    open += x\n                case \")\" =>\n              \
    \      open += x\n                case \")\" =>\n                    open += x\n\
    \                case \")\" =>\n                    open += x\n              \
    \  case \")\" =>\n                    open += x\n                case \")\" =>\n\
    \                    open += x\n                case \")\" =>\n              \
    \      open += x\n                case \")\" =>\n                    open += x\n\
    \                case \")\" =>\n                    open += x\n              \
    \  case \")\" =>\n                    open \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1lsnqkyb.scala:129:0 ---------------------------\e\
    [0m\e[0m\n\e[31m129 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m')'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1lsnqkyb.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1lsnqkyb.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1lsnqkyb.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1lsnqkyb.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1lsnqkyb.scala:27:28\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                    stack\
    \ = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-expl"
  stdout: ''
  timestamp: 1659979682
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => if (x == \"(\") stack += x else if (!x == \"(\") queue\
    \ += x else if (!x == \")\") bad += x else if (!x == \")\") good += x)\n     \
    \   val goodStr = good.toList\n        val badStr = bad.toList\n        if (goodStr.size\
    \ == 0 && badStr.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp65e4c363.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp65e4c363.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp65e4c363.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp65e4c363.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp65e4c363.scala:22:59 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        lst.foreach(\e[36mx\e[0m => \e[33mif\e[0m (x\
    \ == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"\
    (\"\e[0m) queue += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\")\"\e[0m) bad\
    \ += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\")\"\e[0m) good += x)\n\e[31m\e\
    [31m   |\e[0m                                                           ^^\e[0m\n\
    \e[31m   |\e[0m                                 value unary_! is not a member\
    \ of String\n\e[31m\e[31m-- [E008] Not Found Error: /"
  stdout: ''
  timestamp: 1659979685
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.foreach(y => stack += y)\n                 \
    \   stack.toList.reverse.foreach(y => result += y)\n                    stack.toList.reverse.clear()\n\
    \                }\n                case \"(\" => {\n                    open.foreach(y\
    \ => stack += y)\n                    stack.toList.reverse.foreach(y => result\
    \ += y)\n                    stack.toList.reverse.clear()\n                }\n\
    \                case _ => stack += x\n            }\n        })\n        if (stack.size\
    \ == 0)\n            \"No\"\n        else\n            \"Yes\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj1g7th4x.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpj1g7th4x.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpj1g7th4x.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpj1g7th4x.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979681
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n\
    \        val close = mutable.Set[String]()\n        lst.foreach(x => if (open(x)\
    \ ) open(x) += x else close(x) += x)\n        open.foreach(x => if (close(x) )\
    \ close(x) -= x else stack += x)\n        close.foreach(x => if (open(x) ) open(x)\
    \ -= x else stack += x)\n        stack.foreach(x => if (close(x) ) close(x) -=\
    \ x else queue += x)\n        queue.foreach(x => if (open(x) ) open(x) -= x else\
    \ queue += x)\n        if (stack.size == 0 && queue.size == 0) \"Yes\" else \"\
    No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm8yi88sy.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpm8yi88sy.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpm8yi88sy.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpm8yi88sy.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpm8yi88sy.scala:22:20 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979681
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo1od9pxi.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo1od9pxi.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgoodSize\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mgoodSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mgoodSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo1od9pxi.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbadSize\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbadSize is already\
    \ defined as \e[33mvalue\e[0m \e[35mbadSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo1od9pxi.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgoodSize\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mgoodSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mgoodSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo1od9pxi.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbadSize\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbadSize is already\
    \ defined as \e[33mvalue\e[0m \e[35mbadSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo1od9pxi.scala:28:12\
    \ ------------------"
  stdout: ''
  timestamp: 1659979685
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val open = mutable.HashSet[String]()\n        val close = mutable.HashSet[String]()\n\
    \        lst.foreach { x =>\n            x match {\n                case \")\"\
    \ =>\n                    close.push(x)\n                case \")(\" =>\n    \
    \                stack.push(x)\n                case \")(\" =>\n             \
    \       stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n\
    \                case \")(\" =>\n                    stack.push(x)\n         \
    \       case \")(\" =>\n                    stack.push(x)\n                case\
    \ \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n\
    \                    stack.push(x)\n                case \")(\" =>\n         \
    \           stack.push(x)\n                case \")(\" =>\n                  \
    \  stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n\
    \                case \")(\" =>\n                    stack.push(x)\n         \
    \       case \")(\" =>\n                    stack.push(x)\n                case\
    \ \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n\
    \                    stack.push(x)\n                case \")(\" =>\n         \
    \           stack.push(x)\n                case \")(\" =>\n                  \
    \  stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n\
    \                case \")(\" =>\n                    stack.push(x)\n         \
    \       case \")(\" =>\n                    stack.push(x)\n                case\
    \ \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n\
    \                    stack.push(x)\n                case \")(\" =>\n         \
    \           stack.push(x)\n                case \")(\" =>\n                  \
    \  stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n\
    \                case \")(\" =>\n                    stack.push(x)\n         \
    \       case \")(\" =>\n                    stack.push(x)\n                case\
    \ \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n\
    \                    stack.push(x)\n                case \")(\" =>\n         \
    \           stack.push(x)\n                case \")(\" =>\n                  \
    \  stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n\
    \                case \")(\" =>\n                    stack.push(x)\n         \
    \       case \")(\" =>\n                    stack.push(x)\n                case\
    \ \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n\
    \                    stack.push(x)\n                case \")(\" =>\n         \
    \           stack.push(x)\n                case \")(\" =>\n                  \
    \  stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n\
    \                case \")(\" =>\n                    stack.push(x)\n         \
    \       case \")(\" =>\n                    stack.push(x)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqxacvx1s.scala:123:0 ---------------------------\e\
    [0m\e[0m\n\e[31m123 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqxacvx1s.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqxacvx1s.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqxacvx1s.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.HashSet[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqxacvx1s.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.HashSet[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqxacvx1s.scala:22:20\
    \ --------------------\e[0m\e[0m\n\e[31m 22 |\e[0m        lst.foreach { \e[36mx\e\
    [0m =>\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found: \
    \   Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 23 |\e[0m         \
    \   x \e[33mmatch\e[0m {\n\e[31m 24 |\e[0m                \e[33mcase\e[0m \e[31m\"\
    )\"\e[0m =>\n\e[31m 25"
  stdout: ''
  timestamp: 1659979687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mut\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfam8mfx_.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstack is already defined as \e[33mvalue\e[0m \e[35mstack\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfam8mfx_.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpfam8mfx_.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is already\
    \ defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfam8mfx_.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mresultSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresultSize is already defined as \e[33mvalue\e[0m \e[35mresultSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfam8mfx_.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mstack is already defined as \e[33mvalue\e[0m \e[35mstack\e[0m\n\
    \e[31m   |\e[0m\n"
  stdout: ''
  timestamp: 1659979687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        lst.foreach(x => if (x\
    \ == \"(\") stack += x else if (!x == \"(\") queue += x else ())\n        val\
    \ stackSize = stack.size\n        val queueSize = queue.size\n        if (stackSize\
    \ == queueSize) {\n            val stackElements = stack.take(stackSize)\n   \
    \         val queueElements = queue.take(queueSize)\n            val stackElementsLen\
    \ = stackElements.size\n            val queueElementsLen = queueElements.size\n\
    \            if (stackElementsLen == queueElementsLen) {\n                val\
    \ stackElementsLen2 = stackElements.take(stackElementsLen)\n                val\
    \ queueElementsLen2 = queueElements.take(queueElementsLen)\n                val\
    \ stackElementsLen3 = stackElements.take(stackElementsLen)\n                val\
    \ queueElementsLen3 = queueElements.take(queueElementsLen)\n                val\
    \ stackElementsLen4 = stackElements.take(stackElementsLen)\n                val\
    \ queueElementsLen4 = queueElements.take(queueElementsLen)\n                val\
    \ stackElementsLen5 = stackElements.take(stackElementsLen)\n                val\
    \ queueElementsLen5 = queueElements.take(queueElementsLen)\n                val\
    \ stackElementsLen6 = stackElements.take(stackElementsLen)\n                val\
    \ queueElementsLen6 = queueElements.take(queueElementsLen)\n                val\
    \ stackElementsLen7 = stackElements.take(stackElementsLen)\n                val\
    \ queueElementsLen7 = queueElements.take(queueElementsLen)\n                val\
    \ stackElementsLen8 = stackElements.take(stackElementsLen)\n                val\
    \ queueElementsLen8 = queueElements.take(queueElementsLen)\n                val\
    \ stackElementsLen9 = stackElements.take(stackElementsLen)\n                val\
    \ queueElementsLen9 = queueElements.take(queueElementsLen)\n                val\
    \ stackElementsLen10 = stackElements.take(stackElementsLen)\n                val\
    \ queueElementsLen10 = queueElements.take(queueElementsLen)\n                val\
    \ stackElementsLen11 = stackElements.take(stackElementsLen)\n                val\
    \ queueElementsLen11 = queueElements.take(queueElementsLen)\n                val\
    \ stackElementsLen12 = stackElements.take(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp05kfsn7r.scala:50:60 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m                \e[33mval\e[0m \e[36mstackElementsLen12\e\
    [0m = stackElements.take(\n\e[31m\e[31m   |\e[0m                             \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                 expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmp05kfsn7r.scala:68:0 ----------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp05kfsn7r.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp05kfsn7r.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp05kfsn7r.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp05kfsn7r.scala:21:59\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => \e[33mif\e[0m (x == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e\
    [0m (!x == \e[31m\"(\"\e[0m) queue += x \e[33melse\e[0m ())\n\e[31m\e[31m   |\e\
    [0m       "
  stdout: ''
  timestamp: 1659979687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x == \")\" => close.push(x)\n\
    \            case x if x == \"(\" => open.push(x)\n            case _ => stack\
    \ += x\n        })\n        val openCount = open.size\n        val closeCount\
    \ = close.size\n        if (openCount == closeCount) {\n            val openStack\
    \ = stack.take(openCount)\n            val closeStack = stack.drop(closeCount)\n\
    \            val openStackSize = openStack.size\n            val closeStackSize\
    \ = closeStack.size\n            if (openStackSize == closeStackSize) {\n    \
    \            val openStack = openStack.mkString\n                val closeStack\
    \ = closeStack.mkString\n                val openStackSize = openStack.size\n\
    \                val closeStackSize = closeStack.size\n                if (openStackSize\
    \ == closeStackSize) {\n                    val openStack = openStack.mkString\n\
    \                    val closeStack = closeStack.mkString\n                  \
    \  val openStackSize = openStack.size\n                    val closeStackSize\
    \ = closeStack.size\n                    if (openStackSize == closeStackSize)\
    \ {\n                        val openStack = openStack.mkString\n            \
    \            val closeStack = closeStack.mkString\n                        val\
    \ openStackSize = openStack.size\n                        val closeStackSize =\
    \ closeStack.size\n                        if (openStackSize == closeStackSize)\
    \ {\n                            val openStack = openStack.mkString\n        \
    \                    val closeStack = closeStack.mkString\n                  \
    \          val openStackSize = openStack.size\n                            val\
    \ closeStackSize = closeStack.size\n                            if (openStackSize\
    \ == closeStackSize) {\n                                val openStack = openStack.mkString\n\
    \                                val closeStack = closeStack.mkString\n      \
    \                          val openStackSize = openStack.size\n              \
    \                  val closeStackSize = closeStack.size\n                    \
    \            if (openStackSize == closeStackSize) {\n                        \
    \            val openStack = openStack.mkString\n                            \
    \        val closeStack = closeStack.mkString\n                              \
    \      val openStackSize = openStack.size\n                                  \
    \  val closeStackSize = closeStack.size\n                                    if\
    \ (openStackSize == closeStackSize) {\n                                      \
    \  val openStack = openStack.mkString\n                                      \
    \  val closeStack = closeStack.mkString\n                                    \
    \    val openStackSize = openStack.size\n                                    \
    \    val closeStackSize = closeStack.size\n                                  \
    \      if (openStack\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdjej9syl.scala:70:4 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdjej9syl.scala:87:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m87 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpdjej9syl.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpdjej9syl.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpdjej9syl.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpdjej9syl.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpdjej9syl.scala:35:32 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                \e[33mval\e[0m \e[36mopenStack\e[0m =\
    \ openStack.mkString\n\e[31m"
  stdout: ''
  timestamp: 1659979686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.ListBuffer[String]()\n        val bad = mutable.ListBuffer[String]()\n\
    \        val goodParens = mutable.ListBuffer[String]()\n        val badParens\
    \ = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n            x match\
    \ {\n                case \")\" =>\n                    stack.pop() match {\n\
    \                        case Some(\"(\") => goodParens += x\n               \
    \         case _ => badParens += x\n                    }\n                case\
    \ \")(\"  =>\n                    stack.pop() match {\n                      \
    \  case Some(\"(\") => goodParens += x\n                        case _ => badParens\
    \ += x\n                    }\n                case \")()\" =>\n             \
    \       stack.pop() match {\n                        case Some(\"(\") => goodParens\
    \ += x\n                        case _ => badParens += x\n                   \
    \ }\n                case \")()()\" =>\n                    stack.pop() match\
    \ {\n                        case Some(\"(\") => goodParens += x\n           \
    \             case _ => badParens += x\n                    }\n              \
    \  case \")()\" =>\n                    stack.pop() match {\n                \
    \        case Some(\"(\") => goodParens += x\n                        case _ =>\
    \ badParens += x\n                    }\n                case \")\" =>\n     \
    \               stack.pop() match {\n                        case Some(\"(\")\
    \ => goodParens += x\n                        case _ => badParens += x\n     \
    \               }\n                case \")()\" =>\n                    stack.pop()\
    \ match {\n                        case Some(\"(\") => goodParens += x\n     \
    \                   case _ => badParens += x\n                    }\n        \
    \        case \")()()\" =>\n                    stack.pop() match {\n        \
    \                case Some(\"(\") => goodParens += x\n                       \
    \ case _ => badParens += x\n                    }\n                case \")()()\"\
    \ =>\n                    stack.pop() match {\n                        case Some(\"\
    (\") => goodParens += x\n                        case _ => badParens += x\n  \
    \                  }\n                case \")()()\" =>\n                    stack.pop()\
    \ match {\n                        case Some(\"(\") => goodParens += x\n     \
    \                   case _ => badParens += x\n                    }\n        \
    \        case \")()()\" =>\n                    stack.pop() match {\n        \
    \                case Some(\"(\") => goodParens += x\n                       \
    \ case _ => badParens += x\n                    }\n                case \")()()\"\
    \ =>\n                    stack.pop() match {\n                        case Some(\"\
    (\") => goodParens += x\n                        case _ => badParens += x\n  \
    \                  }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplx5t67_h.scala:103:0 ---------------------------\e\
    [0m\e[0m\n\e[31m103 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m')'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplx5t67_h.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplx5t67_h.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplx5t67_h.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mgood\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplx5t67_h.scala:21:18\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mbad\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplx5t67_h.scala:22:25\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mgoodParens\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m  \
    \ |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compili"
  stdout: ''
  timestamp: 1659979688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxSize = stackMax * 2\n        val stackMaxMax = stackMaxSize -\
    \ 1\n        val stackMaxMaxSize = stackMaxMax * 2\n        val stackMaxMaxMax\
    \ = stackMaxMaxSize - 1\n        val stackMaxMaxMaxSize = stackMaxMaxMax * 2\n\
    \        val stackMaxMaxMaxMax = stackMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxSize\
    \ = stackMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMax = stackMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMax * 2\n     \
    \   val stackMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxMaxMaxSize\
    \ = stackMaxMaxMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMax\
    \ * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbsmjiiza.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpbsmjiiza.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpbsmjiiza.scala:34:45 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mstackMaxMaxMaxMaxMaxMaxMaxSize\e\
    [0m = stackMaxMaxMaxMaxMaxMaxMax * \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m       \
    \                                      ^\e[0m\n\e[31m   |\e[0m               \
    \    Recursive \e[33mvalue\e[0m \e[35mstackMaxMaxMaxMaxMaxMaxMax\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbsmjiiza.scala:37:47\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e\
    [36mstackMaxMaxMaxMaxMaxMaxMaxMaxMax\e[0m = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                Not found: stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbsmjiiza.scala:41:53 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mstackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\e\
    [0m = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize - \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                                 "
  stdout: ''
  timestamp: 1659979688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n\
    \            if (x == \"(\") {\n                stack += x\n            } else\
    \ if (x == \")\") {\n                val s = stack.pop()\n                if (queue.contains(s))\
    \ {\n                    result += \"No\"\n                } else {\n        \
    \            result += \"Yes\"\n                }\n                queue += s\n\
    \            }\n        })\n        result mkString \"\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6a891rv3.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6a891rv3.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6a891rv3.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        lst.foreach(x => {\n      \
    \      if (x == \"(\") stack.push(x)\n            if (x == \")\") queue.push(x)\n\
    \            if (stack.size == 0 && queue.size == 0) {\n                good.add(x)\n\
    \            }\n        })\n        if (good.size == 0) \"No\" else \"Yes\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5g_dgi4u.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5g_dgi4u.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5g_dgi4u.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val open = mutable.HashSet[String]()\n        val close = mutable.HashSet[String]()\n\
    \        lst.foreach(x => {\n            if (open.isEmpty) {\n               \
    \ open += x\n            } else if (close.isEmpty) {\n                close +=\
    \ x\n            } else if (open.isEmpty && close.isEmpty) {\n               \
    \ result += x\n            } else if (open.isEmpty && close.contains(x)) {\n \
    \               result += x\n            } else if (open.contains(x) && close.isEmpty)\
    \ {\n                result += x\n            } else if (open.contains(x) && close.contains(x))\
    \ {\n                result += \"(\" + x + \")\"\n                stack += x\n\
    \            } else if (open.contains(x) && close.contains(x)) {\n           \
    \     result += \"(\" + x + \")\"\n                stack += x\n            } else\
    \ if (open.contains(x) && close.contains(x)) {\n                result += \"(\"\
    \ + x + \")\"\n                stack += x\n            } else if (open.contains(x)\
    \ && close.contains(x)) {\n                result += \"(\" + x + \")\"\n     \
    \           stack += x\n            } else if (open.contains(x) && close.contains(x))\
    \ {\n                result += \"(\" + x + \")\"\n                stack += x\n\
    \            } else if (open.contains(x) && close.contains(x)) {\n           \
    \     result += \"(\" + x + \")\"\n                stack += x\n            } else\
    \ if (open.contains(x) && close.contains(x)) {\n                result += \"(\"\
    \ + x + \")\"\n                stack += x\n            } else if (open.contains(x)\
    \ && close.contains(x)) {\n                result += \"(\" + x + \")\"\n     \
    \           stack += x\n            } else if (open.contains(x) && close.contains(x))\
    \ {\n                result += \"(\" + x + \")\"\n                stack += x\n\
    \            } else if (open.contains(x) && close.contains(x)) {\n           \
    \     result += \"(\" + x + \")\"\n                stack += x\n            } else\
    \ if (open.contains(x) && close.contains(x)) {\n                result += \"(\"\
    \ + x + \")\"\n                stack += x\n            } else if (open.contains(x)\
    \ && close.contains(x)) {\n                result += \"(\" + x + \")\"\n     \
    \           stack += x\n            } else if (open.contains(x) && close.contains(x))\
    \ {\n                result += \"(\" + x + \")\"\n                stack += x\n\
    \            } else if (open.contains(x) && close.contains(x)) {\n           \
    \     result += \"(\" + x + \")\"\n                stack += x\n            } else\
    \ if (open.contains(x) && close.contains(x)) {\n                result += \"(\"\
    \ + x + \")\"\n                stack += x\n            } else if (open.contains(x)\
    \ && close.contains(x)) {\n                result \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1a02usrf.scala:97:0 ----------------------------\e\
    [0m\e[0m\n\e[31m97 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m')' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1a02usrf.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1a02usrf.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1a02usrf.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.HashSet[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1a02usrf.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.HashSet[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1a02usrf.scala:22:19\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found: \
    \   Unit\n\e[31m   |\e[0m        Required: String\n\e[31m23 |\e[0m           \
    \ \e[33mif\e[0m (open.isEmpty) {\n\e[31m24 |\e[0m                open += x\n\e\
    [31m25 |\e[0m            } "
  stdout: ''
  timestamp: 1659979689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.add(x)\n                case \")(\"  => open.add(x)\n             \
    \   case \")(\"  => stack += x\n                case \")\" => stack += x\n   \
    \             case _ => stack += x\n            }\n        })\n        val openCount\
    \ = open.size\n        val closeCount = close.size\n        if (openCount == closeCount)\
    \ {\n            val openStack = stack.take(openCount)\n            val closeStack\
    \ = stack.drop(closeCount)\n            val openStackSize = openStack.size\n \
    \           val closeStackSize = closeStack.size\n            if (openStackSize\
    \ == closeStackSize) {\n                val stackSize = stack.size\n         \
    \       if (stackSize == 1) {\n                    val stackElement = stack.pop()\n\
    \                    val stackElementSize = stackElement.size\n              \
    \      if (stackElementSize == 1) {\n                        val stackElementElement\
    \ = stackElement.pop()\n                        if (stackElementElement == closeStack.head)\
    \ {\n                            result += \"Yes\"\n                        }\
    \ else {\n                            result += \"No\"\n                     \
    \   }\n                    } else {\n                        result += \"No\"\n\
    \                    }\n                } else {\n                    result +=\
    \ \"No\"\n                }\n            } else {\n                result += \"\
    No\"\n            }\n        } else {\n            result += \"No\"\n        }\n\
    \        result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqmd4vym1.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqmd4vym1.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqmd4vym1.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpqmd4vym1.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mut\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfam8mfx_.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstack is already defined as \e[33mvalue\e[0m \e[35mstack\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfam8mfx_.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpfam8mfx_.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is already\
    \ defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfam8mfx_.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mresultSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresultSize is already defined as \e[33mvalue\e[0m \e[35mresultSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfam8mfx_.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mstack is already defined as \e[33mvalue\e[0m \e[35mstack\e[0m\n\
    \e[31m   |\e[0m\n"
  stdout: ''
  timestamp: 1659979687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => open.push(x)\n           \
    \     case \")(\"  => stack.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpymzfq6v3.scala:74:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m                \e[33mcase\e[0m \")\n\e[31m\e[31m   |\e\
    [0m                     ^\e[0m\n\e[31m   |\e[0m                     unclosed string\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmpymzfq6v3.scala:76:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpymzfq6v3.scala:92:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m92 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpymzfq6v3.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpymzfq6v3.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpymzfq6v3.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpymzfq6v3.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set"
  stdout: ''
  timestamp: 1659795439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.foreach(y => stack += y)\n                   \
    \ result ++= stack\n                    stack = mutable.Stack[String]()\n    \
    \            case x if !open.contains(x) =>\n                    stack += x\n\
    \                case x if open.contains(x) =>\n                    stack.lastOption\
    \ match {\n                        case Some(last) => stack += x\n           \
    \             case None => stack += x\n                    }\n            }\n\
    \        })\n        stack.lastOption match {\n            case Some(last) =>\
    \ result ++= stack\n            case None => result ++= stack.reverse\n      \
    \  }\n        result.lastOption match {\n            case Some(last) => last\n\
    \            case None => \"No\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6k93z94_.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6k93z94_.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6k93z94_.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp6k93z94_.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6k93z94_.scala:27:28 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    stack = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp6k93z94_.scala:42:31 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            \e[33mcase\e[0m Some(last) => last\n\e[31m\e\
    [31m   |\e[0m "
  stdout: ''
  timestamp: 1659979687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val open = mutable.HashSet[String]()\n        val close = mutable.HashSet[String]()\n\
    \        val good = mutable.HashSet[String]()\n        lst.foreach(x => {\n  \
    \          x match {\n                case \")\" => close.add(x)\n           \
    \     case \")(\"  => open.add(x)\n                case \")(\"  => open.add(x)\n\
    \                case \")(\"  => open.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" => close.add(x)\n\
    \                case \")\" => close.add(x)\n                case \")\" \n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqp3wa7iq.scala:80:4 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=>' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqp3wa7iq.scala:97:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m97 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpqp3wa7iq.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpqp3wa7iq.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqp3wa7iq.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.HashSet[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpqp3wa7iq.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.HashSet[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqp3wa7iq.scala:22:19 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.HashSet[\e\
    [35mString\e[0m]("
  stdout: ''
  timestamp: 1659979688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stackMax = stackSize - 1\n        val resultMax = resultSize - 1\n     \
    \   val stackIndex = 0\n        val resultIndex = 0\n        val stackIsEmpty\
    \ = stack.isEmpty\n        val resultIsEmpty = result.isEmpty\n        while(stackIsEmpty\
    \ || resultIsEmpty) {\n            val stackSize = lst.size\n            val resultSize\
    \ = lst.size\n            val stackMax = stackSize - 1\n            val resultMax\
    \ = resultSize - 1\n            val stackIndex = 0\n            val resultIndex\
    \ = 0\n            val stackIsEmpty = stack.isEmpty\n            val resultIsEmpty\
    \ = result.isEmpty\n            val stackIsFull = stackSize == stackMax\n    \
    \        val resultIsFull = resultSize == resultMax\n            while(stackIsEmpty\
    \ || resultIsEmpty) {\n                val stackSize = lst.size\n            \
    \    val resultSize = lst.size\n                val stackMax = stackSize - 1\n\
    \                val resultMax = resultSize - 1\n                val stackIndex\
    \ = 0\n                val resultIndex = 0\n                val stackIsEmpty =\
    \ stack.isEmpty\n                val resultIsEmpty = result.isEmpty\n        \
    \        val stackIsFull = stackSize == stackMax\n                val resultIsFull\
    \ = resultSize == resultMax\n                if(stackIsEmpty && resultIsEmpty)\
    \ {\n                    val stackSize = lst.size\n                    val resultSize\
    \ = lst.size\n                    val stackMax = stackSize - 1\n             \
    \       val resultMax = resultSize - 1\n                    val stackIndex = 0\n\
    \                    val resultIndex = 0\n                    val stackIsEmpty\
    \ = stack.isEmpty\n                    val resultIsEmpty = result.isEmpty\n  \
    \                  val stackIsFull = stackSize == stackMax\n                 \
    \   val resultIsFull = resultSize == resultMax\n                    if(stackIsEmpty\
    \ && resultIsEmpty) {\n                        val stackSize = lst.size\n    \
    \                    val resultSize = lst.size\n                        val stackMax\
    \ = stackSize - 1\n                        val resultMax = resultSize - 1\n  \
    \                      val stackIndex = 0\n                        val resultIndex\
    \ = 0\n                        val stackIsEmpty = stack.isEmpty\n            \
    \            val resultIsEmpty = result.isEmpty\n                        val stackIsFull\
    \ = stackSize == stackMax\n                        val resultIsFull = resultSize\
    \ == resultMax\n                        if(stackIsEmpty && resultIsEmpty) {\n\
    \                            val stackSize = lst.size\n                      \
    \      val resultSize = lst.\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n \
    \   assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxg2e46uc.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpxg2e46uc.scala:92:0 ----------------------------\e[0m\e[0m\n\e[31m92\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxg2e46uc.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpxg2e46uc.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmpxg2e46uc.scala:76:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m76 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659979689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    stack.pop()\n                }\n                case\
    \ \")()\" => {\n                    stack.pop()\n                    stack.pop()\n\
    \                    stack.pop()\n                    result += \"Yes\"\n    \
    \            }\n                case \")(\" => {\n                    stack.pop()\n\
    \                    stack.pop()\n                    result += \"No\"\n     \
    \           }\n                case _ => {\n                    stack += x\n \
    \               }\n            }\n        })\n        result.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0opo0_ik.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0opo0_ik.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.foreach(c => stack += c)\n                 \
    \   result ++= stack\n                    stack = mutable.Stack[String]()\n  \
    \              }\n                case \"(\" => {\n                    open.foreach(c\
    \ => stack += c)\n                    result ++= stack\n                    stack\
    \ = mutable.Stack[String]()\n                }\n                case _ => {\n\
    \                    stack += x\n                }\n            }\n        })\n\
    \        if (stack.nonEmpty) {\n            result ++= stack\n        }\n    \
    \    if (result.size == lst.size) {\n            val stack2 = mutable.Stack[String]()\n\
    \            val stack3 = mutable.Stack[String]()\n            val stack4 = mutable.Stack[String]()\n\
    \            val stack5 = mutable.Stack[String]()\n            val stack6 = mutable.Stack[String]()\n\
    \            val stack7 = mutable.Stack[String]()\n            val stack8 = mutable.Stack[String]()\n\
    \            val stack9 = mutable.Stack[String]()\n            val stack10 = mutable.Stack[String]()\n\
    \            val stack11 = mutable.Stack[String]()\n            val stack12 =\
    \ mutable.Stack[String]()\n            val stack13 = mutable.Stack[String]()\n\
    \            val stack14 = mutable.Stack[String]()\n            val stack15 =\
    \ mutable.Stack[String]()\n            val stack16 = mutable.Stack[String]()\n\
    \            val stack17 = mutable.Stack[String]()\n            val stack18 =\
    \ mutable.Stack[String]()\n            val stack19 = mutable.Stack[String]()\n\
    \            val stack20 = mutable.Stack[String]()\n            val stack21 =\
    \ mutable.Stack[String]()\n            val stack22 = mutable.Stack[String]()\n\
    \            val stack23 = mutable.Stack[String]()\n            val stack24 =\
    \ mutable.Stack[String]()\n            val stack25 = mutable.Stack[String]()\n\
    \            val stack26 = mutable.Stack[String]()\n            val stack27 =\
    \ mutable.Stack[String]()\n            val stack28 = mutable.Stack[String]()\n\
    \            val stack29 = mut\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp38krmln2.scala:88:0 ----------------------------\e\
    [0m\e[0m\n\e[31m88 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp38krmln2.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp38krmln2.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp38krmln2.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp38krmln2.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp38krmln2.scala:27:28\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                    stack\
    \ = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain"
  stdout: ''
  timestamp: 1659979692
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxIndex = stackSize - 1\n        val stackMin = 0\n        val\
    \ stackMinIndex = 0\n        val stackMaxMin = stackSize - 1\n        val stackMaxMinIndex\
    \ = stackSize - 1\n        val stackMaxMinIndex2 = stackSize - 1\n        val\
    \ stackMaxMinIndex3 = stackSize - 1\n        val stackMaxMinIndex4 = stackSize\
    \ - 1\n        val stackMaxMinIndex5 = stackSize - 1\n        val stackMaxMinIndex6\
    \ = stackSize - 1\n        val stackMaxMinIndex7 = stackSize - 1\n        val\
    \ stackMaxMinIndex8 = stackSize - 1\n        val stackMaxMinIndex9 = stackSize\
    \ - 1\n        val stackMaxMinIndex10 = stackSize - 1\n        val stackMaxMinIndex11\
    \ = stackSize - 1\n        val stackMaxMinIndex12 = stackSize - 1\n        val\
    \ stackMaxMinIndex13 = stackSize - 1\n        val stackMaxMinIndex14 = stackSize\
    \ - 1\n        val stackMaxMinIndex15 = stackSize - 1\n        val stackMaxMinIndex16\
    \ = stackSize - 1\n        val stackMaxMinIndex17 = stackSize - 1\n        val\
    \ stackMaxMinIndex18 = stackSize - 1\n        val stackMaxMinIndex19 = stackSize\
    \ - 1\n        val stackMaxMinIndex20 = stackSize - 1\n        val stackMaxMinIndex21\
    \ = stackSize - 1\n        val stackMaxMinIndex22 = stackSize - 1\n        val\
    \ stackMaxMinIndex23 = stackSize - 1\n        val stackMaxMinIndex24 = stackSize\
    \ - 1\n        val stackMaxMinIndex25 = stackSize - 1\n        val stackMaxMinIndex26\
    \ = stackSize - 1\n        val stackMaxMinIndex27 = stackSize - 1\n        val\
    \ stackMaxMinIndex28 = stackSize - 1\n        val stackMaxMinIndex29 = stackSize\
    \ - 1\n        val stackMaxMinIndex30 = stackSize - 1\n        val stackMaxMinIndex31\
    \ = stackSize - 1\n        val stackMaxMinIndex32 = stackSize - 1\n        val\
    \ stackMaxMinIndex33 = stackSize - 1\n        val stackMaxMinIndex34 = stackSize\
    \ - 1\n        val stackMaxMinIndex35 = stackSize - 1\n        val stackMaxMinIndex36\
    \ = stackSize - 1\n        val stackMaxMinIndex37 = stackSize - 1\n        val\
    \ stackMaxMinIndex38 = \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpgv1445je.scala:63:32 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mstackMaxMinIndex38\e[0m\
    \ = \n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e\
    [0m                                expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgv1445je.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgv1445je.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgv1445je.scala:64:5\
    \ ---------------------\e[0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979691
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach {\n            s =>\n                val openCount = open.count(_\
    \ == s)\n                val closeCount = close.count(_ == s)\n              \
    \  if (openCount > closeCount) {\n                    result += \"No\"\n     \
    \               return\n                }\n                if (openCount == closeCount)\
    \ {\n                    result += \"Yes\"\n                    return\n     \
    \           }\n                result += \"No\"\n                return\n    \
    \    }\n        result += \"No\"\n        return\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpit_jsh7i.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpit_jsh7i.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpit_jsh7i.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpit_jsh7i.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpit_jsh7i.scala:28:20 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    \e[33mreturn\e[0m\n\e[31m\e[31m \
    \  |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0m                    Found:\
    \    Unit\n\e[31m   |\e[0m                    Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpit_jsh7i.scala:32:20 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    \e[33mreturn\e[0m\n\e[31m\e[31m \
    \  |\e[0m      "
  stdout: ''
  timestamp: 1659979693
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        val openCount = mutable.ListBuffer[Int]()\n        val closeCount = mutable.ListBuffer[Int]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    closeCount += closeCount.length\n                \
    \    closeCount -= 1\n                    close.toList.reverse.foreach(x => stack\
    \ += x)\n                    stack.toList.reverse.foreach(x => result += x)\n\
    \                }\n                case \"(\" => {\n                    openCount\
    \ += openCount.length\n                    openCount -= 1\n                  \
    \  open += x\n                    stack += x\n                }\n            \
    \    case _ => stack += x\n            }\n        })\n        val openCount =\
    \ openCount.sum\n        val closeCount = closeCount.sum\n        val open = open.toList.reverse\n\
    \        val close = close.toList.reverse\n        val openCount = openCount.toInt\n\
    \        val closeCount = closeCount.toInt\n        if (openCount == closeCount\
    \ && openCount == open.length)\n            result += \"Yes\"\n        else\n\
    \            result += \"No\"\n        result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4_9p_2vz.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mopenCount\e[0m = openCount.sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mopenCount is already defined as \e[33mvalue\e[0m \e[35mopenCount\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp4_9p_2vz.scala:42:12 ---------------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m        \e[33mval\e[0m \e[36mcloseCount\e[0m = closeCount.sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcloseCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mcloseCount\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4_9p_2vz.scala:43:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopen\e[0m = open.toList.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopen is already defined as \e[33mvalue\e[0m \e[35mopen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp4_9p_2vz.scala:44:12 ---------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = close.toList.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mclose\
    \ is already defined as \e[33mvalue\e[0m \e[35mclose\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4_9p_2vz.scala:45:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopenCount\e[0m = openCount.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopenCount is already defined as \e[33mvalue\e[0m \e[35mopenCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that over"
  stdout: ''
  timestamp: 1659979690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val stackStr = str.substring(open + 1,\
    \ close)\n                val stackStr = stackStr.trim\n                val stackStr\
    \ = stackStr.substring(0,stackStr.length-1)\n                if(!stack.isEmpty\
    \ && stackStr == stack.last) {\n                    result.append(\"Yes\")\n \
    \               } else {\n                    stack += stackStr\n            \
    \    }\n            }\n        }\n        result.mkString(\",\")\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpesqnlw2t.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpesqnlw2t.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpesqnlw2t.scala:28:20 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mval\e[0m \e[36mstackStr\e[0m =\
    \ stackStr.trim\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackStr is already defined as \e[33mvalue\e[0m \e[35mstackStr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpesqnlw2t.scala:29:20 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m                \e[33mval\e[0m \e[36mstackStr\e[0m = stackStr.substring(\e\
    [31m0\e[0m,stackStr.length-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m              \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackStr\
    \ is already defined as \e[33mvalue\e[0m \e[35mstackStr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n4 errors found\n"
  stdout: ''
  timestamp: 1659979691
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") open += x\n         \
    \   if (x == \")\") close += x\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"Yes\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (close.isEmpty && !open.isEmpty) result += \"No\"\n \
    \           if (open.isEmpty && close.isEmpty) result += \"No\"\n            if\
    \ (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"\
    No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n     \
    \       if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n  \
    \          if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if\
    \ (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n  \
    \          if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if\
    \ (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n  \
    \          if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if\
    \ (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && close\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7f0c3t7m.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7f0c3t7m.scala:58:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m58 |\e[0m    \e[33mdef\e[0m \e\
    [36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e\
    [31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    ')' expected, but 'def' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmp7f0c3t7m.scala:74:0 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7f0c3t7m.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7f0c3t7m.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7f0c3t7m.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7f0c3t7m.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e["
  stdout: ''
  timestamp: 1659979690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        lst.foreach(x => {\n  \
    \          x match {\n                case \")\" => {\n                    queue.enqueue(x)\n\
    \                    stack.push(x)\n                }\n                case \"\
    (\" => {\n                    stack.push(x)\n                }\n             \
    \   case \")\" => {\n                    val top = stack.pop()\n             \
    \       val next = queue.dequeue()\n                    result.enqueue(top + next)\n\
    \                }\n                case \"(\" => {\n                    val top\
    \ = stack.pop()\n                    val next = queue.dequeue()\n            \
    \        result.enqueue(top + next)\n                }\n            }\n      \
    \  })\n        if (stack.size == 0)\n            result.enqueue(\"Yes\")\n   \
    \     else\n            result.enqueue(\"No\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd70a3gcz.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpd70a3gcz.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpd70a3gcz.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979691
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxIndex = stackSize - 1\n        val stackMin = 0\n        val\
    \ stackMinIndex = stackSize - 1\n        val stackMaxStack = mutable.Stack[String]()\n\
    \        val stackMinStack = mutable.Stack[String]()\n        val stackMaxStackSize\
    \ = stackMaxStack.size()\n        val stackMinStackSize = stackMinStack.size()\n\
    \        val stackMaxStackMax = stackMaxStack.last\n        val stackMinStackMin\
    \ = stackMinStack.last\n        val stackMaxStackMin = stackMaxStack.last\n  \
    \      val stackMinStackMax = stackMinStack.last\n        val stackMaxStackMinIndex\
    \ = stackMaxStackSize - 1\n        val stackMinStackMinIndex = stackMinStackSize\
    \ - 1\n        val stackMaxStackMaxIndex = stackMaxStackSize - 1\n        val\
    \ stackMinStackMinIndex = stackMinStackSize - 1\n        val stackMaxStackMinIndex\
    \ = stackMaxStackSize - 1\n        val stackMinStackMaxIndex = stackMinStackSize\
    \ - 1\n        val stackMaxStackMinIndex = stackMaxStackSize - 1\n        val\
    \ stackMinStackMinIndex = stackMinStackSize - 1\n        val stackMaxStackMaxIndex\
    \ = stackMaxStackSize - 1\n        val stackMinStackMinIndex = stackMinStackSize\
    \ - 1\n        val stackMaxStackMinIndex = stackMaxStackSize - 1\n        val\
    \ stackMinStackMaxIndex = stackMinStackSize - 1\n        val stackMaxStackMinIndex\
    \ = stackMaxStackSize - 1\n        val stackMinStackMinIndex = stackMinStackSize\
    \ - 1\n        val stackMaxStackMaxIndex = stackMaxStackSize - 1\n        val\
    \ stackMinStackMinIndex = stackMinStackSize - 1\n        val stackMaxStackMinIndex\
    \ = stackMaxStackSize - 1\n        val stackMinStackMaxIndex = stackMinStackSize\
    \ - 1\n        val stackMaxStackMinIndex = stackMaxStackSize - 1\n        val\
    \ stackMinStackMinIndex = stackMinStackSize - 1\n        val stackMaxStackMaxIndex\
    \ = stackMaxStackSize - 1\n        val stackMinStackMinIndex = stackMinStackSize\
    \ - 1\n        val stackMaxStackMinIndex = stackMaxStackSize - 1\n        val\
    \ stackMinStackMaxIndex = stackMinStackSize - 1\n        val stackMaxStackMinIndex\
    \ = stackMaxStackSize - 1\n        val stackMinStackMinIndex = stackMinStackSize\
    \ - 1\n        val stackMaxStack\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppn_hzqye.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppn_hzqye.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMinStackMinIndex\e[0m = stackMinStackSize - \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mstackMinStackMinIndex is already defined as \e[33mvalue\e[0m \e[35mstackMinStackMinIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppn_hzqye.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mstackMaxStackMinIndex\e[0m = stackMaxStackSize\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMaxStackMinIndex is already defined as \e[33mvalue\e\
    [0m \e[35mstackMaxStackMinIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppn_hzqye.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mstackMaxStackMinIndex\e\
    [0m = stackMaxStackSize - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMaxStackMinIndex is already defined as \e[33mvalue\e\
    [0m \e[35mstackMaxStackMinIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppn_hzqye.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mstackMinStackMinIndex\e\
    [0m = stackMinStackSize - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMinStackMinIndex is already defined as \e[33mvalue\e\
    [0m \e[35mstackMinS"
  stdout: ''
  timestamp: 1659979695
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") open += x\n         \
    \   if (x == \")\") close += x\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"Yes\"\n            if (open.isEmpty && close.isNotEmpty) result\
    \ += \"No\"\n            if (open.isNotEmpty && close.isEmpty) result += \"No\"\
    \n            if (open.isNotEmpty && close.isNotEmpty) result += \"Yes\"\n   \
    \         if (open.isEmpty && close.isNotEmpty) result += \"No\"\n           \
    \ if (open.isNotEmpty && close.isNotEmpty) result += \"Yes\"\n            if (open.isEmpty\
    \ && close.isEmpty) result += \"Yes\"\n            if (open.isNotEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isNotEmpty && close.isNotEmpty) result\
    \ += \"Yes\"\n            if (open.isEmpty && close.isNotEmpty) result += \"No\"\
    \n            if (open.isNotEmpty && close.isNotEmpty) result += \"Yes\"\n   \
    \     })\n        result mkString \"\\n\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplt8amjhc.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmplt8amjhc.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmplt8amjhc.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmplt8amjhc.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach {\n            s =>\n                val l = s.toList\n \
    \               val len = l.length\n                for (i <- 0 until len) {\n\
    \                    val c = l(i)\n                    if (c == '(') {\n     \
    \                   stack.push(c)\n                    } else if (c == ')') {\n\
    \                        val top = stack.pop()\n                        if (top\
    \ == '(') {\n                            queue.enqueue(c)\n                  \
    \      } else {\n                            bad.add (s\"$top$c\")\n         \
    \               }\n                    }\n                }\n        }\n     \
    \   if (queue.size == 0) {\n            good.add(\"Yes\")\n        } else {\n\
    \            bad.add(\"No\")\n        }\n        if (good.size == 0) {\n     \
    \       bad.add(\"No\")\n        } else {\n            good.add(\"Yes\")\n   \
    \     }\n        good.toString.replace(\"[\", \"\").replace(\"]\", \"\")\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp00r20d_s.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp00r20d_s.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp00r20d_s.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp00r20d_s.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.HashSet[String]()\n        val close = mutable.HashSet[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.foreach(y => stack += y)\n                   \
    \ result ++= stack\n                    stack = mutable.Stack[String]()\n    \
    \            case \")(\"  =>\n                    open += x\n                case\
    \ \")(\"  =>\n                    open += x\n                case \")(\" =>\n\
    \                    open += x\n                case \")\" =>\n              \
    \      open += x\n                case \")\" =>\n                    open += x\n\
    \                case \")\" =>\n                    open += x\n              \
    \  case \")\" =>\n                    open += x\n                case \")\" =>\n\
    \                    open += x\n                case \")\" =>\n              \
    \      open += x\n                case \")\" =>\n                    open += x\n\
    \                case \")\" =>\n                    open += x\n              \
    \  case \")\" =>\n                    open += x\n                case \")\" =>\n\
    \                    open += x\n                case \")\" =>\n              \
    \      open += x\n                case \")\" =>\n                    open += x\n\
    \                case \")\" =>\n                    open += x\n              \
    \  case \")\" =>\n                    open += x\n                case \")\" =>\n\
    \                    open += x\n                case \")\" =>\n              \
    \      open += x\n                case \")\" =>\n                    open += x\n\
    \                case \")\" =>\n                    open += x\n              \
    \  case \")\" =>\n                    open += x\n                case \")\" =>\n\
    \                    open += x\n                case \")\" =>\n              \
    \      open += x\n                case \")\" =>\n                    open += x\n\
    \                case \")\" =>\n                    open += x\n              \
    \  case \")\" =>\n                    open += x\n                case \")\" =>\n\
    \                    open += x\n                case \")\" =>\n              \
    \      open += x\n                case \")\" =>\n                    open += x\n\
    \                case \")\" =>\n                    open += x\n              \
    \  case \")\" =>\n                    open += x\n                case \")\" =>\n\
    \                    open += x\n                case \")\" =>\n              \
    \      open += x\n                case \")\" =>\n                    open += x\n\
    \                case \")\" =>\n                    open += x\n              \
    \  case \")\" =>\n                    open += x\n                case \")\" =>\n\
    \                    open += x\n                case \")\" =>\n              \
    \      open += x\n                case \")\" =>\n                    open += x\n\
    \                case \")\" =>\n                    open += x\n              \
    \  case \")\" =>\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuw9jey_k.scala:128:0 ---------------------------\e\
    [0m\e[0m\n\e[31m128 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m')'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuw9jey_k.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuw9jey_k.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuw9jey_k.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.HashSet[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuw9jey_k.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.HashSet[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuw9jey_k.scala:27:28\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                    stack\
    \ = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling wit"
  stdout: ''
  timestamp: 1659979694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach {\n            s =>\n                s match {\n        \
    \            case \"(\" =>\n                        stack.push(s)\n          \
    \              queue.enqueue(s)\n                    case \")\" =>\n         \
    \               val top = stack.pop()\n                        val next = queue.poll()\n\
    \                        val goodParens = s\"${top}${next}\"\n               \
    \         val badParens = s\"${top}${next}\"\n                        good +=\
    \ goodParens\n                        bad += badParens\n                }\n  \
    \      }\n        if (good.size == lst.size) {\n            return \"Yes\"\n \
    \       } else {\n            return \"No\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9y9i1kku.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9y9i1kku.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9y9i1kku.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp9y9i1kku.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x == \")\" => close.push(x)\n\
    \            case x if x == \")()\" => close.push(x)\n            case x if x\
    \ == \"(\" => open.push(x)\n            case x if x == \")(\" => open.push(x)\n\
    \            case x if x == \")()()\" => close.push(x)\n            case x if\
    \ x == \")()(\" => close.push(x)\n            case x if x == \")()()()\" => close.push(x)\n\
    \            case x if x == \")()()()()\" => close.push(x)\n            case x\
    \ if x == \")()()()()()\" => close.push(x)\n            case x if x == \")()()()()()()\"\
    \ => close.push(x)\n            case x if x == \")()()()()()()()\" => close.push(x)\n\
    \            case x if x == \")()()()()()()()()\" => close.push(x)\n         \
    \   case x if x == \")()()()()()()()()()\" => close.push(x)\n            case\
    \ x if x == \")()()()()()()()()()()\" => close.push(x)\n            case x if\
    \ x == \")()()()()()()()()()()()\" => close.push(x)\n            case x if x ==\
    \ \")()()()()()()()()()()()()\" => close.push(x)\n            case x if x == \"\
    )()()()()()()()()()()()()()\" => close.push(x)\n            case x if x == \"\
    )()()()()()()()()()()()()()\" => close.push(x)\n            case x if x == \"\
    )()()()()()()()()()()()()()()\" => close.push(x)\n            case x if x == \"\
    )()()()()()()()()()()()()()()()\" => close.push(x)\n            case x if x ==\
    \ \")()()()()()()()()()()()()()()()()\" => close.push(x)\n            case x if\
    \ x == \")()()()()()()()()()()()()()()()()\" => close.push(x)\n            case\
    \ x if x == \")()()()()()()()()()()()()()()()()\" \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2cgyconl.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=>' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2cgyconl.scala:47:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m47 |\e[0m    \e[33mdef\e[0m \e\
    [36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e\
    [31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    ')' expected, but 'def' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmp2cgyconl.scala:63:0 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2cgyconl.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2cgyconl.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2cgyconl.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2cgyconl.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not fo"
  stdout: ''
  timestamp: 1659979694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n\
    \        val stackMax = lst.last\n        val stackMaxIndex = stackSize - 1\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stackMaxIndex = lst.last\n        val stackMaxIndex = lst.last\n\
    \        val stack\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw1cor0zm.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw1cor0zm.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMaxIndex\e[0m = lst.last\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMaxIndex is already defined as \e[33mvalue\e[0m \e[35mstackMaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpw1cor0zm.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mstackMaxIndex\e[0m = lst.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackMaxIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mstackMaxIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw1cor0zm.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMaxIndex\e[0m = lst.last\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMaxIndex is already defined as \e[33mvalue\e[0m \e[35mstackMaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpw1cor0zm.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mstackMaxIndex\e[0m = lst.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackMaxIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mstackMaxIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw1cor0zm.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m "
  stdout: ''
  timestamp: 1659979696
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") {\n                stack\
    \ += x\n            } else if (x == \")\") {\n                val last = stack.pop()\n\
    \                if (last == x) {\n                    good += x\n           \
    \     } else {\n                    bad += x\n                }\n            }\n\
    \        })\n        if (good.size == lst.size) {\n            return \"Yes\"\n\
    \        } else {\n            return \"No\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfoy3lm8k.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpfoy3lm8k.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpfoy3lm8k.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpfoy3lm8k.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => if (x == \"(\") stack += x else stack.pop())\n     \
    \   if (stack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9lky_sr7.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9lky_sr7.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.HashSet[String]()\n        val close = mutable.HashSet[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x.startsWith(\"(\"\
    ) => open.push(x)\n            case x if x.startsWith(\")\") => close.push(x)\n\
    \            case x => stack.push(x)\n        })\n        val openCount = open.size\n\
    \        val closeCount = close.size\n        val openStack = stack.take(openCount)\n\
    \        val closeStack = stack.drop(closeCount)\n        val openStackSize =\
    \ openStack.size\n        val closeStackSize = closeStack.size\n        val openStackIsEmpty\
    \ = openStack.isEmpty\n        val closeStackIsEmpty = closeStack.isEmpty\n  \
    \      val openStackIsFull = openStackSize == openCount\n        val closeStackIsFull\
    \ = closeStackSize == closeCount\n        val openStackIsEmptyOrFull = openStackIsEmpty\
    \ || openStackIsFull\n        val closeStackIsEmptyOrFull = closeStackIsEmpty\
    \ || closeStackIsFull\n        val openStackIsFullOrEmpty = openStackIsFull ||\
    \ openStackIsEmpty\n        val closeStackIsFullOrEmpty = closeStackIsFull ||\
    \ closeStackIsEmpty\n        val openStackIsEmptyOrFullOrEmpty = openStackIsEmptyOrFull\
    \ || closeStackIsEmptyOrFull\n        val closeStackIsEmptyOrFullOrEmpty = closeStackIsEmptyOrFull\
    \ || closeStackIsEmptyOrEmpty\n        val openStackIsFullOrEmptyOrEmpty = openStackIsFullOrEmpty\
    \ || closeStackIsFullOrEmpty\n        val closeStackIsFullOrEmptyOrEmpty = closeStackIsFullOrEmpty\
    \ || closeStackIsFullOrEmpty\n        val openStackIsEmptyOrFullOrEmptyOrEmpty\
    \ = openStackIsEmptyOrFullOrEmpty || closeStackIsEmptyOrFullOrEmpty\n        val\
    \ closeStackIsEmptyOrFullOrEmptyOrEmpty = closeStackIsEmptyOrFullOrEmpty || closeStackIsFullOrEmptyOrEmpty\n\
    \        val openStackIsFullOrEmptyOrEmptyOrEmpty = openStackIsFullOrEmptyOrEmpty\
    \ || closeStackIsFullOrEmptyOrEmpty\n        val closeStackIsFullOrEmptyOrEmptyOrEmpty\
    \ = closeStackIsFullOrEmptyOrEmpty || closeStackIsFullOrEmptyOrEmpty\n       \
    \ val openStackIsEmptyOr\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqa9gi82s.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqa9gi82s.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqa9gi82s.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqa9gi82s.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.HashSet[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqa9gi82s.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.HashSet[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqa9gi82s.scala:50:5\
    \ ---------------------\e[0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n6 errors found\n"
  stdout: ''
  timestamp: 1659979696
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result += \"No\"\n\
    \            } else {\n                result += \"Yes\"\n                stack\
    \ += str\n                while(open > -1) {\n                    val openParen\
    \ = str.indexOf(\"(\", open)\n                    val closeParen = str.indexOf(\"\
    )\", open)\n                    if(openParen < 0 || closeParen < 0) {\n      \
    \                  result += \"No\"\n                        break\n         \
    \           }\n                    val newStr = str.substring(0, open) + str.substring(open+1,\
    \ close) + str.substring(close+1)\n                    stack += newStr\n     \
    \               if(stack.size == 1) {\n                        result += \"Yes\"\
    \n                        break\n                    }\n                    val\
    \ newOpen = str.indexOf(\"(\", openParen)\n                    val newClose =\
    \ str.indexOf(\")\", closeParen)\n                    if(newOpen < 0 || newClose\
    \ < 0) {\n                        result += \"No\"\n                        break\n\
    \                    }\n                    val newStr2 = str.substring(0, newOpen)\
    \ + str.substring(newOpen+1, newClose) + str.substring(newClose+1)\n         \
    \           stack += newStr2\n                    if(stack.size == 1) {\n    \
    \                    result += \"Yes\"\n                        break\n      \
    \              }\n                    open = newOpen\n                    close\
    \ = newClose\n                }\n            }\n        }\n        result match\
    \ {\n            case List(\"Yes\") => \"Yes\"\n            case List(\"No\")\
    \ => \"No\"\n            case _ => \"No\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqh6gun9d.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqh6gun9d.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqh6gun9d.scala:34:24 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqh6gun9d.scala:40:24\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                        break\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpqh6gun9d.scala:46:24 ------------------------\e[0m\e\
    [0m\n\e[31m46 |\e[0m                        break\n\e[31m\e[31m   |\e[0m     \
    \                   ^^^^^\e[0m\n\e[31m   |\e[0m                        Not found:\
    \ break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqh6gun9d.scala:52:24\
    \ ------------------------\e[0m\e[0m\n\e[31m52 |\e[0m                        break\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ exp"
  stdout: ''
  timestamp: 1659979695
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach { s =>\n            val openCount = if (open.contains(s))\
    \ open.count(_ == s) else 0\n            val closeCount = if (close.contains(s))\
    \ close.count(_ == s) else 0\n            if (openCount == 0 && closeCount ==\
    \ 0) {\n                result += s\n            } else {\n                if\
    \ (openCount > closeCount) {\n                    stack += s\n               \
    \ } else {\n                    result += s\n                }\n            }\n\
    \        }\n        if (stack.size == 0) {\n            \"No\"\n        } else\
    \ {\n            \"Yes\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxu1q_xmg.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpxu1q_xmg.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpxu1q_xmg.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpxu1q_xmg.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979695
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.ListBuffer[String]()\n        val bad = mutable.ListBuffer[String]()\n\
    \        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String,\
    \ Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount\
    \ = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n\
    \        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String,\
    \ Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount\
    \ = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n\
    \        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String,\
    \ Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount\
    \ = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n\
    \        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String,\
    \ Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount\
    \ = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n\
    \        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String,\
    \ Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount\
    \ = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n\
    \        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String,\
    \ Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount\
    \ = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n\
    \        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String,\
    \ Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount\
    \ = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n\
    \        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String,\
    \ Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount\
    \ = mutable.Map[\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpislgb2c_.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpislgb2c_.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mgoodCount\e[0m = mutable.Map[\e[35mString\e\
    [0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgoodCount is already defined as \e[33mvalue\e[0m \e[35mgoodCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpislgb2c_.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mbadCount\e[0m = mutable.Map[\e[35mString\e\
    [0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbadCount is already defined as \e[33mvalue\e[0m \e[35mbadCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpislgb2c_.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mgoodCount\e[0m = mutable.Map[\e[35mString\e\
    [0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgoodCount is already defined as \e[33mvalue\e[0m \e[35mgoodCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpislgb2c_.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mbadCount\e[0m = mutable.Map[\e[35mString\e\
    [0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbadCount is already defined as \e[33mvalue\e[0m \e[35mbadCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of "
  stdout: ''
  timestamp: 1659979696
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        lst.foreach(x => {\n            if\
    \ (x == \"(\") {\n                stack.push(x)\n            } else if (x == \"\
    )\") {\n                if (stack.isEmpty) {\n                    result.append(\"\
    No\")\n                } else {\n                    val top = stack.pop()\n \
    \                   val newTop = top + x\n                    stack += newTop\n\
    \                    result.append(\"Yes\")\n                }\n            }\n\
    \        })\n        result.toString()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr7lqwqmw.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpr7lqwqmw.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979695
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        val good = mutable.ListBuffer[String]()\n        val bad = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => open.push(x)\n           \
    \     case \")(\"  => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case \")\" => stack.push(x)\n\
    \                case \")\" => stack.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpncw96zaf.scala:79:4 ----------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpncw96zaf.scala:96:0 ----------------------------\e[0m\e[0m\n\e[31m96\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpncw96zaf.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpncw96zaf.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpncw96zaf.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpncw96zaf.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpncw96zaf.scala:22:19 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.ListB"
  stdout: ''
  timestamp: 1659979696
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.ListBuffer[String]()\n        val bad = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    stack.pop() match {\n                        case\
    \ \")\" => good+=(queue.toList.reverse)\n                        case \")()\"\
    \ => bad+=(queue.toList.reverse)\n                        case _ => bad+=(queue.toList.reverse)\n\
    \                    }\n                    queue+=x\n                }\n    \
    \            case \"(\" => {\n                    stack+=x\n                 \
    \   queue+=x\n                }\n                case _ => queue+=x\n        \
    \    }\n        })\n        val stackSize = stack.size\n        val queueSize\
    \ = queue.size\n        if(stackSize == queueSize) {\n            good.toList.mkString(\"\
    \") match {\n                case \"\" => \"No\"\n                case x => \"\
    Yes\"\n            }\n        } else {\n            bad.toList.mkString(\"\")\
    \ match {\n                case \"\" => \"No\"\n                case x => \"Yes\"\
    \n            }\n        }\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n   \
    \ assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6ogivew8.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6ogivew8.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6ogivew8.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp6ogivew8.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979695
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        lst.foreach(x => stack += x)\n    \
    \    while(stack.size > 0) {\n            val curr = stack.pop()\n           \
    \ val newStack = stack.filter(_ != curr)\n            val newStackSize = newStack.size\n\
    \            val newResult = result.filter(_ != curr)\n            if(newStackSize\
    \ == stackSize && newStack.size == 1 && newResult.size == 1) {\n             \
    \   result += newResult\n            }\n        }\n        if(result.size == 1)\
    \ {\n            result match {\n                case Nil => \"Yes\"\n       \
    \         case _ => \"No\"\n            }\n        } else {\n            \"No\"\
    \n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppvr5ng7z.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppvr5ng7z.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979696
