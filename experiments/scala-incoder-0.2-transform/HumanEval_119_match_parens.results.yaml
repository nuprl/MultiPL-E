language: scala
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n\
    \        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n\
    \        val stackSize = lst.size\n        val queueSize = lst.size\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n\
    \        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n\
    \        val stackSize = lst.size\n        val queueSize = lst.size\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n\
    \        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n\
    \        val stackSize = lst.size\n        val queueSize = lst.size\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n\
    \        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n\
    \        val stackSize = lst.size\n        val queueSize = lst.size\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n\
    \        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n\
    \        val stackSize = lst.size\n        val queueSize = lst.size\n        val\
    \ stack = mutable.Stack[String]()\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjge_9aeb.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstack is already defined as \e[33mvalue\e[0m \e[35mstack\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjge_9aeb.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mqueue is already defined as \e[33mvalue\e[0m \e[35mqueue\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpjge_9aeb.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Queue[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpjge_9aeb.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is already\
    \ defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjge_9aeb.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mqueueSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mqueueSize is already defined as \e[33mvalue\e[0m \e[35mqueueSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31"
  stdout: ''
  timestamp: 1659795018
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodString = mutable.Set[String]()\n        val badString = mutable.Set[String]()\n\
    \        val goodParens = mutable.Set[String]()\n        val badParens = mutable.Set[String]()\n\
    \        val goodParensString = mutable.Set[String]()\n        val badParensString\
    \ = mutable.Set[String]()\n        val goodParensParens = mutable.Set[String]()\n\
    \        val badParensParens = mutable.Set[String]()\n        val goodParensParensString\
    \ = mutable.Set[String]()\n        val badParensParensString = mutable.Set[String]()\n\
    \        val goodParensParensParens = mutable.Set[String]()\n        val badParensParensParens\
    \ = mutable.Set[String]()\n        val goodParensParensParensString = mutable.Set[String]()\n\
    \        val badParensParensParensString = mutable.Set[String]()\n        val\
    \ goodParensParensParensParens = mutable.Set[String]()\n        val badParensParensParensParens\
    \ = mutable.Set[String]()\n        val goodParensParensParensParensString = mutable.Set[String]()\n\
    \        val badParensParensParensParensString = mutable.Set[String]()\n     \
    \   val goodParensParensParensParensParens = mutable.Set[String]()\n        val\
    \ badParensParensParensParensParens = mutable.Set[String]()\n        val goodParensParensParensParensParensString\
    \ = mutable.Set[String]()\n        val badParensParensParensParensParensString\
    \ = mutable.Set[String]()\n        val goodParensParensParensParensParensParens\
    \ = mutable.Set[String]()\n        val badParensParensParensParensParensParens\
    \ = mutable.Set[String]()\n        val goodParensParensParensParensParensParensString\
    \ = mutable.Set[String]()\n        val badParensParensParensParensParensParensString\
    \ = mutable.Set[String\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphba7x9mv.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphba7x9mv.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphba7x9mv.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphba7x9mv.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mgood\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphba7x9mv.scala:21:18\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mbad\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m       \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphba7x9mv.scala:22:25\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mgoodString\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-e"
  stdout: ''
  timestamp: 1659795441
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val newStack = if (open < 0 || close < 0) stack.toList else stack.drop(open).drop(close).reverse\n\
    \            val newStr = if (open < 0 || close < 0) str else str.substring(open\
    \ + 1, close)\n            val newResult = if (newStack.isEmpty) result else result.dropRight(newStack.size)\n\
    \            val newResult2 = if (newStr.isEmpty) newResult else newResult :+\
    \ newStr\n            stack.push(newStr)\n            result += newResult2\n \
    \       }\n        if (result.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps1sgnib2.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmps1sgnib2.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    if(str == \"(\") {\n                stack.push(str)\n            } else if(str\
    \ == \")\") {\n                val popped = stack.pop()\n                if(popped\
    \ == \"(\") {\n                    result.append(\"Yes\")\n                } else\
    \ {\n                    result.append(\"No\")\n                }\n          \
    \  } else {\n                result.append(\"No\")\n            }\n        }\n\
    \        return result.toString()\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1078uj_o.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp1078uj_o.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val openCount = stack.length\n      \
    \          val closeCount = stack.length\n                while(openCount > 0\
    \ && closeCount > 0) {\n                    if(openCount > closeCount) {\n   \
    \                     stack.pop()\n                        openCount -= 1\n  \
    \                  } else {\n                        stack.pop()\n           \
    \             closeCount -= 1\n                    }\n                }\n    \
    \            val openParens = stack.length\n                val closeParens =\
    \ stack.length\n                while(openParens > 0 && closeParens > 0) {\n \
    \                   if(openParens > closeParens) {\n                        stack.pop()\n\
    \                        openParens -= 1\n                    } else {\n     \
    \                   stack.pop()\n                        closeParens -= 1\n  \
    \                  }\n                }\n                val newStack = stack.mkString(\"\
    (\", \")\")\n                if(newStack == str) {\n                    result.append(\"\
    Yes\")\n                } else {\n                    result.append(\"No\")\n\
    \                }\n            }\n        }\n        return result.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn37_2azo.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpn37_2azo.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795440
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val openCount = stack.length\n            val closeCount = stack.length\n\
    \            if(openCount > closeCount) {\n                stack += str\n    \
    \            result += \"Yes\"\n            } else if(openCount < closeCount)\
    \ {\n                stack += str\n                result += \"No\"\n        \
    \    } else {\n                result += \"No\"\n            }\n        }\n  \
    \      result.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp57at94qw.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp57at94qw.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxIndex = stackSize - 1\n        val stackMaxValue = lst(stackMaxIndex)\n\
    \        val stackMin = stackSize + 1\n        val stackMinIndex = stackSize +\
    \ 1\n        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue\
    \ = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n     \
    \   val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinValue = lst(stackMinIndex)\n\
    \        val stackMin\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwpvc8sfy.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwpvc8sfy.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMinValue\e[0m = lst(stackMinIndex)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackMinValue is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackMinValue\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwpvc8sfy.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMinValue\e[0m = lst(stackMinIndex)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackMinValue is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackMinValue\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwpvc8sfy.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMinValue\e[0m = lst(stackMinIndex)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackMinValue is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackMinValue\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwpvc8sfy.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMinValue\e[0m = lst(stackMinIndex)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackMinValue is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackMinValue\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwpvc8sfy.sc"
  stdout: ''
  timestamp: 1659795441
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open != -1 && close != -1) {\n                val openCount\
    \ = stack.length\n                val closeCount = stack.length\n            \
    \    val openParen = str.indexOf(\"(\")\n                val closeParen = str.indexOf(\"\
    )\")\n                val openParenCount = stack.length\n                val closeParenCount\
    \ = stack.length\n                stack.push(str)\n                while(openParenCount\
    \ > closeParenCount && openParenCount > openCount && closeParenCount > closeCount)\
    \ {\n                    if(stack.size == openParenCount) {\n                \
    \        val temp = stack.pop()\n                        if(temp.equals(str))\
    \ {\n                            result.append(\"Yes\")\n                    \
    \        result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpofq68dqu.scala:110:0 ---------------------------\e\
    [0m\e[0m\n\e[31m110 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpofq68dqu.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpofq68dqu.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpofq68dqu.scala:20:8\
    \ ---------------------\e[0m\e[0m\n\e[31m 20 |\e[0m        \e[33mfor\e[0m(i <-\
    \ \e[31m0\e[0m until lst.size) {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m\
    \    |\e[0m        Found:    Unit\n\e[31m    |\e[0m        Required: String\n\e\
    [31m 21 |\e[0m            \e[33mval\e[0m \e[36mstr\e[0m = lst(i)\n\e[31m 22 |\e\
    [0m            \e[33mval\e[0m \e[36mopen\e[0m = str.indexOf(\e[31m\"(\"\e[0m)\n\
    \e[31m 23 |\e[0m            \e[33mval\e[0m \e[36mclose\e[0m = str.indexOf(\e[31m\"\
    )\"\e[0m)\n\e[31m 24 |\e[0m            \e[33mif\e[0m(open != -\e[31m1\e[0m &&\
    \ close != -\e[31m1\e[0m) {\n\e[31m 25 |\e[0m                \e[33mval\e[0m \e\
    [36mopenCount\e[0m = stack.length\n\e[31m 26 |\e[0m                \e[33mval\e\
    [0m \e[36mcloseCount\e[0m = stack.length\n\e[31m 27 |\e[0m                \e[33mval\e\
    [0m \e[36mopenParen\e[0m = str.indexOf(\e[31m\"(\"\e[0m)\n\e[31m 28 |\e[0m   \
    \             \e[33mval\e[0m \e[36mcloseParen\e[0m = str.indexOf(\e[31m\")\"\e\
    [0m)\n\e[31m 29 |\e[0m                \e[33mval\e[0m \e[36mopenParenCount\e[0m\
    \ = stack.length\n\e[31m 30 |\e[0m                \e[33mval\e[0m \e[36mcloseParenCount\e\
    [0m = stack.length\n\e[31m 31 |\e[0m            "
  stdout: ''
  timestamp: 1659795441
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x.startsWith(\"(\"\
    ) => queue.enqueue(x)\n            case x if x.startsWith(\")\") => stack.push(x)\n\
    \            case x => badStr += x\n        })\n        while(!queue.isEmpty)\
    \ {\n            val curr = queue.dequeue()\n            if(!good.contains(curr))\
    \ {\n                good += curr\n                goodStr += curr\n         \
    \   }\n            if(!bad.contains(curr)) {\n                bad += curr\n  \
    \              badStr += curr\n            }\n            if(!stack.isEmpty) {\n\
    \                val top = stack.dequeue()\n                if(!good.contains(top))\
    \ {\n                    good += top\n                    goodStr += top\n   \
    \             }\n                if(!bad.contains(top)) {\n                  \
    \  bad += top\n                    badStr += top\n                }\n        \
    \    }\n        }\n        if(good.size == lst.size) {\n            return \"\
    Yes\"\n        }\n        if(bad.size == lst.size) {\n            return \"No\"\
    \n        }\n        if(goodStr.size == lst.size) {\n            return \"Yes\"\
    \n        }\n        if(badStr.size == lst.size) {\n            return \"No\"\n\
    \        }\n        return \"No\"\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsy3g06rf.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpsy3g06rf.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpsy3g06rf.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpsy3g06rf.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpsy3g06rf.scala:22:22 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mgoodStr\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpsy3g06rf.scala:23:21 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mbadStr\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m"
  stdout: ''
  timestamp: 1659795439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.push(x)\n                }\n               \
    \ case \")(\"  => {\n                    open.push(x)\n                }\n   \
    \             case \")(\" => {\n                    stack.push(x)\n          \
    \      }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8jgqcjag.scala:128:4 ---------------------------\e\
    [0m\e[0m\n\e[31m128 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp8jgqcjag.scala:145:0 ---------------------------\e[0m\e[0m\n\e[31m145\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8jgqcjag.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8jgqcjag.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8jgqcjag.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp8jgqcjag.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmp8jgqcjag.scala:129:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m129 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0"
  stdout: ''
  timestamp: 1659795059
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        lst.foreach(x => if (x == \"\
    (\") stack.push(x) else if (x == \")\") queue.push(x) else if (stack.size == 0\
    \ && queue.size == 0) good.add(x))\n        if (good.size == 0) \"No\" else \"\
    Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv0rfzun9.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpv0rfzun9.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpv0rfzun9.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprdr94pzo.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprdr94pzo.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackSize is already defined as \e[33mvalue\e[0m \e[35mstackSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprdr94pzo.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprdr94pzo.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackSize is already defined as \e[33mvalue\e[0m \e[35mstackSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprdr94pzo.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same gro"
  stdout: ''
  timestamp: 1659795049
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String,\
    \ Int]()\n        lst.foreach(x => {\n            x match {\n                case\
    \ \")\" => {\n                    queue.enqueue(x)\n                }\n      \
    \          case \")()\" => {\n                    queue.enqueue(x)\n         \
    \           stack.push(x)\n                }\n                case \")(\" => {\n\
    \                    queue.enqueue(x)\n                    stack.push(x)\n   \
    \             }\n                case \")()()\" => {\n                    queue.enqueue(x)\n\
    \                    stack.push(x)\n                    queue.enqueue(x)\n   \
    \                 stack.push(x)\n                }\n                case \")(()\"\
    \ => {\n                    queue.enqueue(x)\n                    stack.push(x)\n\
    \                    queue.enqueue(x)\n                    stack.push(x)\n   \
    \                 queue.enqueue(x)\n                    stack.push(x)\n      \
    \          }\n                case \")()(\" => {\n                    queue.enqueue(x)\n\
    \                    stack.push(x)\n                    queue.enqueue(x)\n   \
    \                 stack.push(x)\n                    queue.enqueue(x)\n      \
    \              stack.push(x)\n                    queue.enqueue(x)\n         \
    \           stack.push(x)\n                }\n                case \")()(()\"\
    \ => {\n                    queue.enqueue(x)\n                    stack.push(x)\n\
    \                    queue.enqueue(x)\n                    stack.push(x)\n   \
    \                 queue.enqueue(x)\n                    stack.push(x)\n      \
    \              queue.enqueue(x)\n                    stack.push(x)\n         \
    \           queue.enqueue(x)\n                    stack.push(x)\n            \
    \    }\n                case \")()(()()\" => {\n                    queue.enqueue(x)\n\
    \                    stack.push(x)\n                    queue.enqueue(x)\n   \
    \                 stack.push(x)\n                    queue.enqueue(x)\n      \
    \              stack.push(x)\n                    queue.enqueue(x)\n         \
    \           stack.push(x)\n                    queue.enqueue(x)\n            \
    \        stack.push(x)\n                    queue.enqueue(x)\n               \
    \     stack.push(x)\n                    queue.enqueue(x)\n                  \
    \  stack.push(x)\n                    queue.enqueue(x)\n                    stack.push(x)\n\
    \                    queue.enqueue(x)\n                    stack.push(x)\n   \
    \                 queue.enqueue(x)\n                    stack.push(x)\n      \
    \              queue.enqueue(x)\n                    stack.push(x)\n         \
    \           queue.enqueue(x)\n                    stack.push(x)\n            \
    \        queue.enqueue(x)\n                    stack.push(x)\n               \
    \     queue.enqueue(x)\n                    stack.push(x)\n                  \
    \  queue.en\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo399t2jt.scala:122:0 ---------------------------\e\
    [0m\e[0m\n\e[31m122 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo399t2jt.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo399t2jt.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo399t2jt.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mgood\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo399t2jt.scala:21:18\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mbad\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m       \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo399t2jt.scala:22:22\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mgoodStr\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-"
  stdout: ''
  timestamp: 1659795441
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => open.push(x)\n           \
    \     case \")(\"  => stack.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpymzfq6v3.scala:74:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m                \e[33mcase\e[0m \")\n\e[31m\e[31m   |\e\
    [0m                     ^\e[0m\n\e[31m   |\e[0m                     unclosed string\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmpymzfq6v3.scala:76:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpymzfq6v3.scala:92:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m92 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpymzfq6v3.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpymzfq6v3.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpymzfq6v3.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpymzfq6v3.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set"
  stdout: ''
  timestamp: 1659795439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        lst.foreach(x => if (x.contains(\"(\")) stack.push(x) else if (x.contains(\"\
    )\")) queue.push(x) else if (stack.size == 0 && queue.size == 0) good.add(x) else\
    \ if (stack.size > 0 && queue.size == 0) bad.add(x) else if (stack.size > 0 &&\
    \ queue.size > 0) goodStr.add(x) else if (stack.size == 0 && queue.size > 0) badStr.add(x))\n\
    \        if (good.size == 0 && bad.size == 0) \"No\" else \"Yes\"\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9wm2zs9x.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9wm2zs9x.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9wm2zs9x.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp9wm2zs9x.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp9wm2zs9x.scala:22:22 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mgoodStr\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9wm2zs9x.scala:23:21 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mbadStr\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m"
  stdout: ''
  timestamp: 1659795439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => stack.push(x)\n          \
    \      case \")(\"  => stack.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpqvlgfgda.scala:74:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m                \e[33mcase\e[0m \")\n\e[31m\e[31m   |\e\
    [0m                     ^\e[0m\n\e[31m   |\e[0m                     unclosed string\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmpqvlgfgda.scala:76:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqvlgfgda.scala:92:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m92 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpqvlgfgda.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpqvlgfgda.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set"
  stdout: ''
  timestamp: 1659795020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach { s =>\n            if (s.startsWith(\"(\")) {\n        \
    \        open += s\n            } else if (s.startsWith(\")\")) {\n          \
    \      close += s\n            } else {\n                stack += s\n        \
    \    }\n        }\n        val openCount = open.count\n        val closeCount\
    \ = close.count\n        if (openCount == closeCount) {\n            val openParens\
    \ = open.mkString(\"(\", \", \", \")\")\n            val closeParens = close.mkString(\"\
    (\", \", \", \")\")\n            val newStack = stack.filterNot(s => openParens.contains(s))\n\
    \            val newStack2 = stack.filterNot(s => closeParens.contains(s))\n \
    \           if (newStack.isEmpty && newStack2.isEmpty) {\n                result\
    \ += \"Yes\"\n            } else {\n                result += \"No\"\n       \
    \     }\n        } else {\n            result += \"No\"\n        }\n        result.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgxlcs4yv.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpgxlcs4yv.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpgxlcs4yv.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpgxlcs4yv.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => if (x == \"(\") stack += x else stack.pop())\n     \
    \   stack.foreach(x => if (x == \"(\") result += \"Yes\" else result += \"No\"\
    )\n        result.mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo2udhslv.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpo2udhslv.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795439
