name: HumanEval_69_search
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a non-empty list of positive integers. Return the greatest\
  \ integer that is greater than \n    // zero, and has a frequency greater than or\
  \ equal to the value of the integer itself. \n    // The frequency of an integer\
  \ is the number of times it appears in the list.\n    // If no such a value exist,\
  \ return -1.\n    // Examples:\n    // >>> search((List[Long](4l.toLong, 1l.toLong,\
  \ 2l.toLong, 2l.toLong, 3l.toLong, 1l.toLong)))\n    // (2l)\n    // >>> search((List[Long](1l.toLong,\
  \ 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)))\n\
  \    // (3l)\n    // >>> search((List[Long](5l.toLong, 5l.toLong, 4l.toLong, 4l.toLong,\
  \ 4l.toLong)))\n    // (-1l)\n    def search(lst : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(search((List[Long](5l.toLong,\
  \ 5l.toLong, 5l.toLong, 5l.toLong, 1l.toLong))) == (1l));\n    assert(search((List[Long](4l.toLong,\
  \ 1l.toLong, 4l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](3l.toLong,\
  \ 3l.toLong))) == (-1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 8l.toLong,\
  \ 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong))) == (8l));\n    assert(search((List[Long](2l.toLong,\
  \ 3l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](2l.toLong,\
  \ 7l.toLong, 8l.toLong, 8l.toLong, 4l.toLong, 8l.toLong, 7l.toLong, 3l.toLong, 9l.toLong,\
  \ 6l.toLong, 5l.toLong, 10l.toLong, 4l.toLong, 3l.toLong, 6l.toLong, 7l.toLong,\
  \ 1l.toLong, 7l.toLong, 4l.toLong, 10l.toLong, 8l.toLong, 1l.toLong))) == (1l));\n\
  \    assert(search((List[Long](3l.toLong, 2l.toLong, 8l.toLong, 2l.toLong))) ==\
  \ (2l));\n    assert(search((List[Long](6l.toLong, 7l.toLong, 1l.toLong, 8l.toLong,\
  \ 8l.toLong, 10l.toLong, 5l.toLong, 8l.toLong, 5l.toLong, 3l.toLong, 10l.toLong)))\
  \ == (1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 3l.toLong, 6l.toLong,\
  \ 5l.toLong, 6l.toLong, 4l.toLong))) == (-1l));\n    assert(search((List[Long](6l.toLong,\
  \ 9l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 4l.toLong, 7l.toLong, 1l.toLong, 8l.toLong,\
  \ 8l.toLong, 9l.toLong, 8l.toLong, 10l.toLong, 10l.toLong, 8l.toLong, 4l.toLong,\
  \ 10l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong,\
  \ 7l.toLong, 9l.toLong))) == (1l));\n    assert(search((List[Long](1l.toLong, 9l.toLong,\
  \ 10l.toLong, 1l.toLong, 3l.toLong))) == (1l));\n    assert(search((List[Long](6l.toLong,\
  \ 9l.toLong, 7l.toLong, 5l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 3l.toLong, 7l.toLong,\
  \ 5l.toLong, 10l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 10l.toLong, 2l.toLong,\
  \ 8l.toLong, 6l.toLong, 5l.toLong, 4l.toLong, 9l.toLong, 5l.toLong, 3l.toLong, 10l.toLong)))\
  \ == (5l));\n    assert(search((List[Long](1l.toLong))) == (1l));\n    assert(search((List[Long](8l.toLong,\
  \ 8l.toLong, 10l.toLong, 6l.toLong, 4l.toLong, 3l.toLong, 5l.toLong, 8l.toLong,\
  \ 2l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 6l.toLong, 10l.toLong,\
  \ 4l.toLong, 2l.toLong, 1l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
  \ 5l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong, 10l.toLong, 4l.toLong,\
  \ 8l.toLong, 2l.toLong, 10l.toLong, 5l.toLong, 1l.toLong, 2l.toLong, 9l.toLong,\
  \ 5l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 8l.toLong, 6l.toLong, 4l.toLong, 10l.toLong)))\
  \ == (2l));\n    assert(search((List[Long](1l.toLong, 6l.toLong, 10l.toLong, 1l.toLong,\
  \ 6l.toLong, 9l.toLong, 10l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 7l.toLong,\
  \ 3l.toLong))) == (1l));\n    assert(search((List[Long](9l.toLong, 2l.toLong, 4l.toLong,\
  \ 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 2l.toLong, 5l.toLong, 7l.toLong, 7l.toLong,\
  \ 7l.toLong, 3l.toLong, 10l.toLong, 1l.toLong, 5l.toLong, 4l.toLong, 2l.toLong,\
  \ 8l.toLong, 4l.toLong, 1l.toLong, 9l.toLong, 10l.toLong, 7l.toLong, 10l.toLong,\
  \ 2l.toLong, 8l.toLong, 10l.toLong, 9l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong,\
  \ 6l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 4l.toLong,\
  \ 10l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 7l.toLong, 8l.toLong, 8l.toLong,\
  \ 3l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 2l.toLong, 10l.toLong, 7l.toLong)))\
  \ == (4l));\n    assert(search((List[Long](9l.toLong, 8l.toLong, 6l.toLong, 10l.toLong,\
  \ 2l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 7l.toLong, 8l.toLong, 10l.toLong,\
  \ 3l.toLong, 8l.toLong, 2l.toLong, 6l.toLong, 2l.toLong, 3l.toLong, 1l.toLong)))\
  \ == (2l));\n    assert(search((List[Long](5l.toLong, 5l.toLong, 3l.toLong, 9l.toLong,\
  \ 5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 5l.toLong, 6l.toLong, 10l.toLong,\
  \ 10l.toLong, 6l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 7l.toLong, 7l.toLong,\
  \ 10l.toLong, 8l.toLong))) == (-1l));\n    assert(search((List[Long](10l.toLong)))\
  \ == (-1l));\n    assert(search((List[Long](9l.toLong, 7l.toLong, 7l.toLong, 2l.toLong,\
  \ 4l.toLong, 7l.toLong, 2l.toLong, 10l.toLong, 9l.toLong, 7l.toLong, 5l.toLong,\
  \ 7l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](5l.toLong, 4l.toLong,\
  \ 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 3l.toLong, 6l.toLong,\
  \ 1l.toLong, 8l.toLong))) == (1l));\n    assert(search((List[Long](7l.toLong, 9l.toLong,\
  \ 9l.toLong, 9l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 1l.toLong,\
  \ 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 7l.toLong, 5l.toLong, 6l.toLong,\
  \ 7l.toLong, 6l.toLong, 7l.toLong, 7l.toLong, 6l.toLong))) == (1l));\n    assert(search((List[Long](3l.toLong,\
  \ 10l.toLong, 10l.toLong, 9l.toLong, 2l.toLong))) == (-1l));\n    }\n\n}\n"
completions: ["        val freq = mutable.Map[Long, Int]()\n        for (i <- lst)\
    \ {\n            freq += i -> freq.getOrElse(i, 0) + 1\n        }\n        val\
    \ max = freq.maxBy(_._2)\n        if (max != 0) {\n            freq.filter(_._2\
    \ > 0).maxBy(_._1)._1\n        } else {\n            -1\n        }", "       \
    \ val freq = mutable.Map[Long, Int]()\n        for (i <- lst) {\n            freq\
    \ += i -> freq.getOrElse(i, 0) + 1\n        }\n        val max = freq.maxBy(_._2)._1\n\
    \        if (max > 0) max else -1", "        val freq = mutable.HashMap.empty[Long,\
    \ Int]\n        val maxFreq = mutable.HashMap.empty[Long, Int]\n        val maxFreqKey\
    \ = mutable.HashMap.empty[Long, Long]\n        val maxFreqVal = mutable.HashMap.empty[Long,\
    \ Long]\n        val maxFreqKey = mutable.HashMap.empty[Long, Long]\n        val\
    \ maxFreqVal = mutable.HashMap.empty[Long, Long]\n        for(i <- 0 until lst.size)\
    \ {\n            freq += lst(i) -> 1\n            maxFreq += lst(i) -> 1\n   \
    \         maxFreqKey += lst(i) -> i\n            maxFreqVal += lst(i) -> i\n \
    \       }\n        val maxFreqKeyVal = maxFreqKey.toSeq.sortWith(_._1 < _._1).last\n\
    \        val maxFreqValVal = maxFreqVal.toSeq.sortWith(_._1 < _._1).last\n   \
    \     if(maxFreqKeyVal._2 > maxFreqValVal._2) {\n            -1\n        } else\
    \ {\n            freq(maxFreqKeyVal._2)\n        }", "        var max = 0\n  \
    \      var freq = 0\n        var maxIndex = 0\n        lst.foreach{ x =>\n   \
    \         if (x > max) {\n                max = x\n                freq = 1\n\
    \                maxIndex = 0\n            } else if (freq > x) {\n          \
    \      freq = x\n                maxIndex = 0\n            } else if (freq ==\
    \ x) {\n                maxIndex += 1\n            }\n        }\n        if (maxIndex\
    \ == 0) {\n            return -1\n        }\n        return max", "        val\
    \ freq = mutable.HashMap.empty[Long, Int]\n        val maxFreq = mutable.HashMap.empty[Long,\
    \ Int]\n        lst.foreach(x => freq += x -> freq.getOrElse(x, 0) + 1L)\n   \
    \     lst.foreach(x => maxFreq += x -> freq.getOrElse(x, 0) + 1L)\n        lst.foreach(x\
    \ => freq -= x)\n        lst.foreach(x => maxFreq -= x)\n        lst.foreach(x\
    \ => if (maxFreq.getOrElse(x, 0) > freq.getOrElse(x, 0)) x else -1)", "      \
    \  val freq = mutable.HashMap[Long, Int]()\n        lst.foreach(x => freq += (x\
    \ -> freq.getOrElse(x, 0) + 1l))\n        val max = freq.maxBy(_._2)._1\n    \
    \    if (max >= 0l) {\n            freq.filter(_._2 >= max).maxBy(_._1)._1\n \
    \       } else {\n            -1l\n        }", "        val freq = mutable.Map[Long,\
    \ Int]()\n        lst.foreach(x => freq += (x -> freq.getOrElse(x, 0) + 1l))\n\
    \        val max = freq.maxBy(_._2)._1\n        if (max > 0) max else -1", " \
    \       val freq = mutable.HashMap.empty[Long, Int]\n        lst.foreach(x =>\
    \ freq += x -> freq.getOrElse(x, 0l))\n        val max = freq.maxBy(_._2)._1\n\
    \        val maxFreq = freq.maxBy(_._2)._2\n        if(maxFreq >= max) max else\
    \ -1", "        val freq = mutable.HashMap[Long, Int]()\n        lst.foreach(x\
    \ => freq += x -> freq.getOrElse(x, 0) + 1l)\n        val max = freq.maxBy(_._2)\n\
    \        if (max._2 >= freq.filter(_._2 == max._2).head._2) {\n            max._1\n\
    \        } else {\n            -1\n        }", "        var max = 0\n        var\
    \ maxCount = 0\n        var maxFreq = 0\n        var i = 0\n        while(i <\
    \ lst.size) {\n            val freq = lst(i).toLong\n            if(freq > maxFreq)\
    \ {\n                max = lst(i)\n                maxCount = freq\n         \
    \       maxFreq = freq\n            }\n            i += 1\n        }\n       \
    \ if(maxCount == 0) {\n            return -1\n        }\n        return max",
  "        val freq = mutable.Map[Long, Int]()\n        lst.foreach(x => freq += x\
    \ -> freq.getOrElse(x, 0) + 1l)\n        val max = freq.maxBy(_._2)._1\n     \
    \   if (max > 0) max else -1", "        val freq = mutable.HashMap.empty[Long,\
    \ Int]\n        lst.foreach(x => freq += x -> freq.getOrElse(x, 0) + 1)\n    \
    \    val max = freq.maxBy(_._2)._1\n        val maxFreq = freq.maxBy(_._2)._2\n\
    \        if (maxFreq >= max) max else -1", "        val freq = mutable.Map[Long,\
    \ Int]()\n        for (i <- 0 until lst.size) {\n            freq += (lst(i) ->\
    \ freq(lst(i))+1)\n        }\n        val max = freq.maxBy(_._2)\n        if (max\
    \ > 0) max\n        else -1", "        var max = 0\n        var freq = 0\n   \
    \     for (i <- 0 until lst.size) {\n            freq = lst(i).toLong\n      \
    \      if (freq > 0) {\n                max = Math.max(freq, max)\n          \
    \  }\n        }\n        if (max > 0) {\n            return max\n        }\n \
    \       return -1", "        val freq = mutable.Map[Long, Int]()\n        val\
    \ max = -1\n        lst.foreach{ x =>\n            freq += x -> freq.getOrElse(x,\
    \ 0) + 1\n            if (freq.getOrElse(x, 0) >= max) max = freq.getOrElse(x,\
    \ 0)\n        }\n        if (max > 0) max else -1", "        val freq = mutable.Map[Long,\
    \ Int]()\n        val max = -1\n        lst.foreach(x => freq += x -> freq.getOrElse(x,\
    \ 0) + 1L)\n        lst.foreach(x => if (freq.getOrElse(x, 0) > max) max = freq.getOrElse(x,\
    \ 0))\n        max", "        var max = 0\n        var freq = 0\n        var i\
    \ = 0\n        while(i < lst.length) {\n            val num = lst(i)\n       \
    \     freq = freq + 1\n            if(num > 0) {\n                max = Math.max(max,\
    \ num)\n            }\n            i = i + 1\n        }\n        if(freq >= lst.length)\
    \ {\n            return -1\n        }\n        else {\n            return max\n\
    \        }", "        val freq = mutable.HashMap.empty[Long, Int]\n        lst.foreach(x\
    \ => freq += x -> freq.getOrElse(x, 0l))\n        val max = freq.maxBy(_._2)._1\n\
    \        if (max > 0) max else -1", "        val freq = mutable.Map[Long, Int]()\n\
    \        lst.foreach(x => freq += (x -> freq.getOrElse(x, 0) + 1l))\n        val\
    \ max = freq.maxBy(_._2)._1\n        if (max > 0) max else -1", "        val freq\
    \ = mutable.Map[Long, Int]()\n        val max = -1\n        lst.foreach(x => freq\
    \ += x -> freq.getOrElse(x, 0) + 1l)\n        lst.foreach(x => if (freq.getOrElse(x,\
    \ 0) > max) max = freq.getOrElse(x, 0))\n        max"]
stop_tokens:
- "\n    }\n"
