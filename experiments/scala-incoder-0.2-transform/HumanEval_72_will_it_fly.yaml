name: HumanEval_72_will_it_fly
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that returns True if the object q will fly, and False otherwise.\n\
  \    // The object q will fly if it's balanced (it is a palindromic list) and the\
  \ sum of its elements is less than or equal the maximum possible weight w.\n   \
  \ // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\n\
  \    // (false)\n    // # 1+2 is less than the maximum possible weight, but it's\
  \ unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
  \ (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more than the maximum\
  \ possible weight.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
  \ (9l))\n    // (true)\n    // # 3+2+3 is less than the maximum possible weight,\
  \ and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)), (5l))\n    //\
  \ (true)\n    // # 3 is less than the maximum possible weight, and it's balanced.\n\
  \    def willItFly(q : List[Long], w : Long) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
  \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
  \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
  \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
  \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
  \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
  \    }\n\n}\n"
completions: ["        val maxWeight = w\n        val maxSum = q.foldLeft(0l){ (sum,\
    \ e) => sum + e }\n        val balanced = maxSum < maxWeight\n        val palindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val sumLessOrEqual = maxSum - maxWeight\n\
    \        balanced && palindromic && sumLessOrEqual < 0", "        val maxWeight\
    \ = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isBalanced = maxSum == maxWeight\n        val isLessThanMax\
    \ = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced = maxSum < maxWeight\
    \ && !isBalanced\n        val isLessThanMaxButBalanced = maxSum < maxWeight &&\
    \ isBalanced\n        val isLessThanMaxButNotBalancedButPalindromic = maxSum <\
    \ maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedButPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedButPalindromicButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isPalindromic\n  \
    \      val isLessThanMaxButBalancedButPalindromicButNotPalindromic = maxSum <\
    \ maxWeight && isBalanced && isPalindromic && !isPalindromic\n        val isLessThanMaxButNotBalancedButPalindromicButNotPalindromicButNotBalanced\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isPalindromic && !isBalanced\n\
    \        val isLessThanMaxButBalancedButPalindromicButNotPalindromicButNotBalancedButPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && !isPalindromic && !isBalanced\
    \ && !isPalindromic\n        val isLessThanMaxButNotBalancedButPalindromicButNotPalindromicButNotBalancedButPalindromicButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isPalindromic && !isBalanced\
    \ && !isPalindromic && !isPalindromic\n        val isLessThanMaxButBalancedButPalindromicButNotPalindromicButNotBalancedButPalindromicButNotPalindromicButNotBalanced\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && !isPalindro", "     \
    \   val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced =\
    \ maxSum < maxWeight\n        val isFlipped = q.forall(_ < maxWeight)\n      \
    \  isPalindromic && isBalanced && isFlipped", "        val maxWeight = w\n   \
    \     val palindromic = q.reverse.forall(x => x == x.toLong)\n        val sumOfElements\
    \ = q.sum\n        val isBalanced = sumOfElements <= maxWeight\n        val isFlippable\
    \ = palindromic && isBalanced\n        val isFlippableAndBalanced = isFlippable\
    \ && isBalanced\n        isFlippableAndBalanced", "        val maxWeight = w\n\
    \        val maxSum = q.foldLeft(0l)(_ + _)\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isBalanced = maxSum < maxWeight\n        val isFlippable\
    \ = isPalindromic && isBalanced\n        isFlippable", "        val maxWeight\
    \ = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q.head)\n        val isBalanced = maxSum < maxWeight\n        val isFlippable\
    \ = q.tail.forall(_ < q.head)\n        isPalindromic && isBalanced && isFlippable",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem) =>\
    \ sum + elem }\n        val balanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(elem => elem == q(0))\n        val isLessOrEqual = maxSum\
    \ < maxWeight\n        (balanced && isPalindromic && isLessOrEqual)", "      \
    \  val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem) => sum\
    \ + elem }\n        val isPalindromic = q.reverse.forall(_ == q.head)\n      \
    \  val isBalanced = maxSum - maxWeight <= 0\n        isPalindromic && isBalanced",
  "        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isLessThanMax = maxSum < maxWeight\n        isBalanced\
    \ && isPalindromic && isLessThanMax", "        val maxWeight = w\n        val\
    \ maxSum = q.foldLeft(0l) { (sum, e) => sum + e }\n        val isBalanced = maxSum\
    \ == maxWeight\n        val isPalindromic = q.reverse.forall(e => e == q(0))\n\
    \        val isLessOrEqual = maxSum < maxWeight\n        isBalanced && isPalindromic\
    \ && isLessOrEqual", "        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = maxSum < maxWeight\n        isPalindromic && isBalanced", "   \
    \     val maxWeight = w\n        val maxSum = q.foldLeft(0l){ (sum, e) => sum\
    \ + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessThanMax = maxSum < maxWeight\n\
    \        isBalanced && isPalindromic && isLessThanMax", "        val maxWeight\
    \ = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum + e }\n        val\
    \ isPalindromic = q.reverse.forall(e => e == q(0))\n        val isBalanced = maxSum\
    \ - maxWeight < 0\n        (isPalindromic && isBalanced)", "        val maxWeight\
    \ = w\n        val palindromic = q.reverse.forall(x => x == x.toLong)\n      \
    \  val sumOfElements = q.sum\n        val isBalanced = sumOfElements <= maxWeight\n\
    \        val isFlippable = palindromic && isBalanced\n        isFlippable", " \
    \       val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n \
    \       val maxWeightSum = w.toLong * q.length\n        val maxWeightSumOfElements\
    \ = w.toLong * q.sum\n        val maxWeightSumOfElementsOfElements = w.toLong\
    \ * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElements =\
    \ w.toLong * q.sum * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.length\n    \
    \    val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum *\
    \ q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum *\
    \ q.sum * q.sum * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum *\
    \ q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum *\
    \ q.sum * q.", "        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.forall(x => x <= maxWeight && x >= maxSum - maxWeight)\n\
    \        isPalindromic && isBalanced", "        val maxWeight = w\n        val\
    \ maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isBalanced = maxSum < maxWeight\n        val isFlippable\
    \ = isPalindromic && isBalanced\n        isFlippable", "        val maxWeight\
    \ = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum < maxWeight\n\
    \        val isFly = isPalindromic && isBalanced\n        val result = isFly\n\
    \        println(s\"$result $q w $w maxSum $maxSum maxWeight $maxWeight isPalindromic\
    \ $isPalindromic isBalanced $isBalanced isFly $isFly\")\n        result", "  \
    \      val maxWeight = w\n        val maxSum = q.sum\n        val maxList = q.max\n\
    \        val maxListSize = maxList.size\n        val maxListElements = maxList.iterator\n\
    \        val maxListElementsSize = maxListElements.size\n        val maxListElementsSum\
    \ = maxListElements.sum\n        val maxListElementsSumLessOrEqualToMaxWeight\
    \ = maxListElementsSum < maxWeight\n        val maxListElementsSumGreaterOrEqualToMaxWeight\
    \ = maxListElementsSum > maxWeight\n        val maxListElementsSumLessOrEqualToMaxWeightAndBalanced\
    \ = maxListElementsSumLessOrEqualToMaxWeight && maxListElementsSize == maxListElementsSumLessOrEqualToMaxWeight\n\
    \        val maxListElementsSumGreaterOrEqualToMaxWeightAndBalanced = maxListElementsSumGreaterOrEqualToMaxWeight\
    \ && maxListElementsSize == maxListElementsSumGreaterOrEqualToMaxWeight\n    \
    \    val maxListElementsSumLessOrEqualToMaxWeightAndBalancedAndIsPalindromic =\
    \ maxListElementsSumLessOrEqualToMaxWeightAndBalanced && maxListElementsIsPalindromic(maxList)\n\
    \        val maxListElementsSumGreaterOrEqualToMaxWeightAndBalancedAndIsPalindromic\
    \ = maxListElementsSumGreaterOrEqualToMaxWeightAndBalanced && maxListElementsIsPalindromic(maxList)\n\
    \        val maxListElementsSumLessOrEqualToMaxWeightAndBalancedAndIsPalindromicAndIsEven\
    \ = maxListElementsSumLessOrEqualToMaxWeightAndBalancedAndIsPalindromic && maxListElementsIsEven(maxList)\n\
    \        val maxListElementsSumGreaterOrEqualToMaxWeightAndBalancedAndIsPalindromicAndIsEven\
    \ = maxListElementsSumGreaterOrEqualToMaxWeightAndBalancedAndIsPalindromic &&\
    \ maxListElementsIsEven(maxList)\n        val maxListElementsSumLessOrEqualToMaxWeightAndBalancedAndIsPalindromicAndIsOdd\
    \ = maxListElementsSumLessOrEqualToMaxWeightAndBalancedAndIsPalindromic && maxListElementsIsOdd(maxList)\n\
    \        val maxListElementsSumGreaterOrEqualToMaxWeightAndBalancedAndIsPalin",
  "        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum < maxWeight\n\
    \        val isFly = isPalindromic && isBalanced\n        val result = isFly\n\
    \        println(\"willItFly: isFly = \" + isFly + \", isPalindromic = \" + isPalindromic\
    \ + \", isBalanced = \" + isBalanced + \", maxSum = \" + maxSum + \", maxWeight\
    \ = \" + maxWeight + \", result = \" + result)\n        result", "        val\
    \ maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isBalanced = q.foldLeft(0l)(_\
    \ + _) <= maxWeight\n        val isLessThanMax = maxSum < maxWeight\n        val\
    \ isLessThanMaxAndBalanced = isLessThanMax && isBalanced\n        isPalindromic\
    \ && isLessThanMaxAndBalanced", "        val maxWeight = w\n        val maxSum\
    \ = q.foldLeft(0)(_ + _)\n        val isPalindromic = q.reverse.forall(_ == q.head)\n\
    \        val isBalanced = maxSum == maxWeight\n        isPalindromic && isBalanced",
  "        val maxSum = w.toLong * q.length\n        val sums = q.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ x.toLong)\n        sums.last <= maxSum", "        val maxWeight\
    \ = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == _)\n        val isBalanced = maxSum < maxWeight\n        val isFlippable\
    \ = q.forall(_ < maxWeight)\n        isPalindromic && isBalanced && isFlippable",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem) =>\
    \ sum + elem }\n        val isPalindromic = q.reverse.forall(elem => elem == q.head)\n\
    \        val isBalanced = maxSum == maxWeight\n        val isFlippable = maxWeight\
    \ - maxSum < 0\n        val isFlippableAndBalanced = isFlippable && isBalanced\n\
    \        val isFlippableAndPalindromic = isFlippable && isPalindromic\n      \
    \  val isFlippableAndBalancedAndPalindromic = isFlippableAndBalanced && isPalindromic\n\
    \        val isFlippableAndBalancedAndPalindromicAndFlippable = isFlippableAndBalanced\
    \ && isPalindromic && isFlippable\n        val isFlippableAndBalancedAndPalindromicAndFlippableAndFlippable\
    \ = isFlippableAndBalanced && isPalindromic && isFlippable && isFlippable\n  \
    \      val isFlippableAndBalancedAndPalindromicAndFlippableAndFlippableAndFlippable\
    \ = isFlippableAndBalanced && isPalindromic && isFlippable && isFlippable && isFlippable\n\
    \        val isFlippableAndBalancedAndPalindromicAndFlippableAndFlippableAndFlippableAndFlippable\
    \ = isFlippableAndBalanced && isPalindromic && isFlippable && isFlippable && isFlippable\
    \ && isFlippable && isFlippable\n        val isFlippableAndBalancedAndPalindromicAndFlippableAndFlippableAndFlippableAndFlippableAndFlippable\
    \ = isFlippableAndBalanced && isPalindromic && isFlippable && isFlippable && isFlippable\
    \ && isFlippable && isFlippable && isFlippable && isFlippable\n        val isFlippableAndBalancedAndPalindromicAndFlippableAndFlippable",
  "        val maxWeight = w.toLong\n        val sumOfElements = q.sum\n        val\
    \ isPalindromic = q.isEmpty\n        val isBalanced = sumOfElements <= maxWeight\n\
    \        val isFlipped = isPalindromic && isBalanced\n        val isLessThanMaxWeight\
    \ = sumOfElements < maxWeight\n        val isLessThanMaxWeightAndBalanced = isLessThanMaxWeight\
    \ && isBalanced\n        val isLessThanMaxWeightAndFlipped = isLessThanMaxWeight\
    \ && isFlipped\n        val isLessThanMaxWeightAndNotFlipped = isLessThanMaxWeight\
    \ && !isFlipped\n        isLessThanMaxWeightAndNotFlipped", "        val maxSum\
    \ = w.toLong * w.toLong\n        val sumOfElements = q.foldLeft(0l) { (sum, element)\
    \ => sum + element }\n        sumOfElements <= maxSum", "        val maxWeight\
    \ = w\n        val maxSum = q.foldLeft(0l) { (sum, elem) => sum + elem }\n   \
    \     val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isWon = isPalindromic && isBalanced\n    \
    \    val isLost = !isPalindromic && !isBalanced\n        isWon || isLost", " \
    \       val maxWeight = w\n        val sumOfWeights = q.sum\n        val isPalindromic\
    \ = q.isEmpty\n        val isBalanced = sumOfWeights <= maxWeight\n        val\
    \ isFlippable = q.tail.isEmpty && q.head == q.head.reverse\n        val isFlippableAndBalanced\
    \ = isFlippable && isBalanced\n        val isFlippableAndPalindromic = isFlippable\
    \ && isPalindromic\n        val isFlippableAndBalancedAndPalindromic = isFlippableAndBalanced\
    \ && isPalindromic\n        val isFlippableAndBalancedAndPalindromicAndNotFlippable\
    \ = isFlippableAndBalanced && isPalindromic && isFlippable\n        val isFlippableAndBalancedAndPalindromicAndNotFlippableAndNotBalanced\
    \ = isFlippableAndBalanced && isPalindromic && isFlippable && !isBalanced\n  \
    \      val isFlippableAndBalancedAndPalindromicAndNotFlippableAndNotBalancedAndNotPalindromic\
    \ = isFlippableAndBalanced && isPalindromic && isFlippable && !isBalanced && !isPalindromic\n\
    \        val isFlippableAndBalancedAndPalindromicAndNotFlippableAndNotBalancedAndNotPalindromicAndNotFlippable\
    \ = isFlippableAndBalanced && isPalindromic && isFlippable && !isBalanced && !isPalindromic\
    \ && !isFlippable\n        val isFlippableAndBalancedAndPalindromicAndNotFlippableAndNotBalancedAndNotPalindromicAndNotFlippableAndNotBalanced\
    \ = isFlippableAndBalanced && isPalindromic && isFlippable && !isBalanced && !isPalindromic\
    \ && !isFlippable && !isBalanced\n        val isFlippableAndBalancedAndPalindromicAndNotFlippableAndNotBalancedAndNotPalindromicAndNotFlippableAndNotBalancedAndNotPalindromic\
    \ = isFlippableAndBalanced && isPalindrom", "        val maxWeight = w.toLong\n\
    \        val maxSum = q.foldLeft(0l)(_ + _)\n        val isBalanced = maxSum <\
    \ maxWeight\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n  \
    \      val isLessOrEqual = maxSum < maxWeight\n        val isLessOrEqualPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqualPalindromic2 =\
    \ q.reverse.forall(x => x == q(0))\n        val isLessOrEqualPalindromic3 = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessOrEqualPalindromic4 = q.reverse.forall(x =>\
    \ x == q(0))\n        val isLessOrEqualPalindromic5 = q.reverse.forall(x => x\
    \ == q(0))\n        val isLessOrEqualPalindromic6 = q.reverse.forall(x => x ==\
    \ q(0))\n        val isLessOrEqualPalindromic7 = q.reverse.forall(x => x == q(0))\n\
    \        val isLessOrEqualPalindromic8 = q.reverse.forall(x => x == q(0))\n  \
    \      val isLessOrEqualPalindromic9 = q.reverse.forall(x => x == q(0))\n    \
    \    val isLessOrEqualPalindromic10 = q.reverse.forall(x => x == q(0))\n     \
    \   val isLessOrEqualPalindromic11 = q.reverse.forall(x => x == q(0))\n      \
    \  val isLessOrEqualPalindromic12 = q.reverse.forall(x => x == q(0))\n       \
    \ val isLessOrEqualPalindromic13 = q.reverse.forall(x => x == q(0))\n        val\
    \ isLessOrEqualPalindromic14 = q.reverse.forall(x => x == q(0))\n        val isLessOrEqualPalindromic15\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqualPalindromic16 =\
    \ q.reverse.forall(x => x == q(0))\n        val isLessOrEqualPalindromic17 = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessOrEqualPalindromic18 = q.reverse.forall(x =>\
    \ x == q(0))\n        val isLessOrEqualPalindromic19 = q.reverse.forall(x => x\
    \ == q(0))\n        val isLessOrEqualPalindromic20 = q.reverse.forall(", "   \
    \     val maxSum = w.toLong * w.toLong\n        val maxWeight = w.toLong\n   \
    \     val maxWeightSum = w.toLong * w.toLong\n        val maxWeightSumOfWeights\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfWeightsOfWeights = w.toLong\
    \ * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeights = w.toLong *\
    \ w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeights = w.toLong\
    \ * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeightsOfWeights\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeights\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeights\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeights\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeights\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeights\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeights\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeights\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeights\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeightsOfWeight",
  "        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x ==\
    \ x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFly = palindromic && isBalanced\n        isFly",
  "        val maxSum = w.toLong * w.toLong\n        val maxWeight = w.toLong\n  \
    \      val maxList = q.reverse\n        val maxListSum = maxList.reduceLeft(_\
    \ + _)\n        val isBalanced = maxListSum == maxSum\n        val isPalindromic\
    \ = maxList.reduceLeft(_ + _) == maxList.reduceRight(_ + _)\n        isBalanced\
    \ && isPalindromic", "        val maxWeight = w\n        val sumOfElements = q.sum\n\
    \        val isPalindromic = q.isEmpty\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFlipped = q.reverse.forall(x => x != q.head)\n \
    \       (isPalindromic && isBalanced && isFlipped)", "        val maxWeight =\
    \ w\n        val palindromic = q.reverse.forall(x => x == x.toLong)\n        val\
    \ sumOfElements = q.sum\n        val isBalanced = sumOfElements <= maxWeight\n\
    \        val isFlippable = palindromic && isBalanced\n        isFlippable", " \
    \       val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n \
    \       val maxWeightSum = w.toLong * q.length\n        val maxWeightSumOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElements = w.toLong\
    \ * q.length\n        val maxWeightSumOfElementsOfElementsOfElements = w.toLong\
    \ * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.to", "        val maxWeight = w\n        val palindromic = q.reverse.forall(x\
    \ => x == x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced\
    \ = sumOfElements <= maxWeight\n        val isFly = palindromic && isBalanced\n\
    \        isFly", "        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n\
    \        val isBalanced = maxSum < maxWeight\n        val isFlippable = isPalindromic\
    \ && isBalanced\n        isFlippable", "        val maxWeight = w\n        val\
    \ maxSum = q.foldLeft(0l)(_ + _)\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isBalanced = q.foldLeft(0l)(_ + _) <= maxWeight\n\
    \        val isFlippable = q.foldLeft(0l)(_ + _) <= maxSum && isPalindromic\n\
    \        val isFlippable2 = q.foldLeft(0l)(_ + _) <= maxSum && isPalindromic &&\
    \ isBalanced\n        val isFlippable3 = q.foldLeft(0l)(_ + _) <= maxSum && isPalindromic\
    \ && isBalanced && isFlippable2\n        isFlippable3", "        val maxWeight\
    \ = w\n        val palindromic = q.reverse.forall(x => x == x.toLong)\n      \
    \  val sumOfElements = q.sum\n        val isBalanced = sumOfElements <= maxWeight\n\
    \        val isFly = palindromic && isBalanced\n        val isNotFly = !palindromic\
    \ && !isBalanced\n        val isNotBalanced = !palindromic && isBalanced\n   \
    \     val isNotFly_2 = !palindromic && !isBalanced && sumOfElements > maxWeight\n\
    \        val isNotBalanced_2 = !palindromic && !isBalanced && sumOfElements <\
    \ maxWeight\n        val isNotFly_3 = !palindromic && !isBalanced && sumOfElements\
    \ == maxWeight\n        val isNotBalanced_3 = !palindromic && !isBalanced && sumOfElements\
    \ != maxWeight\n        val isNotFly_4 = !palindromic && !isBalanced && sumOfElements\
    \ < maxWeight && sumOfElements == maxWeight\n        val isNotBalanced_4 = !palindromic\
    \ && !isBalanced && sumOfElements > maxWeight && sumOfElements == maxWeight\n\
    \        val isNotFly_5 = !palindromic && !isBalanced && sumOfElements < maxWeight\
    \ && sumOfElements != maxWeight\n        val isNotBalanced_5 = !palindromic &&\
    \ !isBalanced && sumOfElements > maxWeight && sumOfElements != maxWeight\n   \
    \     val isNotFly_6 = !palindromic && !isBalanced && sumOfElements == maxWeight\
    \ && sumOfElements != maxWeight\n        val isNotBalanced_6 = !palindromic &&\
    \ !isBalanced && sumOfElements != maxWeight && sumOfElements == maxWeight\n  \
    \      val isNotFly_7 = !palindromic && !isBalanced && sumOfElements < maxWeight\
    \ && sumOfElements != maxWeight && sumOfElements == maxWeight\n        val isNotBalanced_7\
    \ = !palindromic && !isBalanced && sumOfElements > maxWeight && sumOfElements\
    \ != maxWeight && sumOfElements == maxWeight\n        val isNotFly_8 = !palindromic\
    \ && !isBalanced && sumOfElements < maxWeight && sumOfElements != maxWeight &&\
    \ sumOfElements != maxWeight\n        val isNotBalance", "        val maxWeight\
    \ = w\n        val palindromic = q.reverse.forall(x => x == x.toLong)\n      \
    \  val sumOfElements = q.foldLeft(0l) { (sum, elem) => sum + elem }\n        val\
    \ isBalanced = sumOfElements <= maxWeight\n        val isFly = palindromic &&\
    \ isBalanced\n        isFly", "        val maxWeight = w\n        val maxSum =\
    \ q.foldLeft(0l) { (sum, elem) => sum + elem }\n        val isBalanced = maxSum\
    \ == maxWeight\n        val isPalindromic = q.reverse.forall(elem => elem == q(0))\n\
    \        isBalanced && isPalindromic", "        val maxWeight = w\n        val\
    \ palindrome = q.reverse.forall(x => x == x.toLong)\n        val sumOfElements\
    \ = q.sum\n        val isBalanced = sumOfElements <= maxWeight\n        val isFly\
    \ = palindrome && isBalanced\n        isFly", "        val maxWeight = w\n   \
    \     val maxSum = q.foldLeft(0l){ (sum, elem) => sum + elem }\n        val isPalindromic\
    \ = q.reverse.forall(_ == q.head)\n        val isBalanced = maxSum < maxWeight\n\
    \        val isFlippable = q.forall(_ < maxWeight)\n        isPalindromic && isBalanced\
    \ && isFlippable", "        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0l)\
    \ { (sum, e) => sum + e }\n        val isBalanced = maxSum < maxWeight\n     \
    \   val isPalindromic = q.reverse.forall(e => e == q(0))\n        isBalanced &&\
    \ isPalindromic", "        val maxSum = w.toLong * w.toLong\n        val maxWeight\
    \ = w.toLong\n        val maxWeightSum = w.toLong * w.toLong\n        val maxWeightSumOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElements = w.toLong\
    \ * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElements = w.toLong\
    \ * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.to", "        val maxWeight = w\n        val sumOfElements = q.sum\n   \
    \     val isPalindromic = q.isPalindromic\n        val isBalanced = q.isBalanced\n\
    \        val isFlipped = q.isFlipped\n        val isLessOrEqualToMaxWeight = sumOfElements\
    \ <= maxWeight\n        val isLessOrEqualToMaxWeightAndBalanced = sumOfElements\
    \ <= maxWeight && isBalanced\n        val isLessOrEqualToMaxWeightAndFlipped =\
    \ sumOfElements <= maxWeight && isFlipped\n        val isLessOrEqualToMaxWeightAndPalindromic\
    \ = sumOfElements <= maxWeight && isPalindromic\n        val isLessOrEqualToMaxWeightAndBalancedAndFlipped\
    \ = sumOfElements <= maxWeight && isBalanced && isFlipped\n        val isLessOrEqualToMaxWeightAndPalindromicAndFlipped\
    \ = sumOfElements <= maxWeight && isPalindromic && isFlipped\n        val isLessOrEqualToMaxWeightAndBalancedAndFlippedAndPalindromic\
    \ = sumOfElements <= maxWeight && isBalanced && isFlipped && isPalindromic\n \
    \       val isLessOrEqualToMaxWeightAndBalancedAndFlippedAndPalindromicAndFlipped\
    \ = sumOfElements <= maxWeight && isBalanced && isFlipped && isPalindromic &&\
    \ isFlipped\n        val isLessOrEqualToMaxWeightAndBalancedAndFlippedAndPalindromicAndFlippedAndPalindromic\
    \ = sumOfElements <= maxWeight && isBalanced && isFlipped && isPalindromic &&\
    \ isFlipped && isPalindromic\n        val isLessOrEqualToMaxWeightAndBalancedAndFlippedAndPalindromicAndFlippedAndPalindromicAndFlipped\
    \ = sumOfElements <= maxWeight && isBalanced && isFlipped && isPalindromic &&\
    \ isFlipped && isPalindromic && isFlipped\n        val isLessOrEqualToMaxWeightAndBalancedAndFlippedAndPalindromicAndFlipped",
  "        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val\
    \ isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        val isFlippableAndLessThanMaxWeight = isFlippable && maxWeight < q.reduceLeft(_\
    \ + _)\n        isFlippableAndLessThanMaxWeight", "        val maxWeight = w\n\
    \        val maxSum = q.reduce(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == _)\n        val isBalanced = maxSum == maxWeight\n        val isLessThanMaxWeight\
    \ = maxSum < maxWeight\n        val isLessThanMaxSum = maxSum < q.reduce(_ + _)\n\
    \        isPalindromic && isBalanced && isLessThanMaxWeight && isLessThanMaxSum",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum\
    \ + e }\n        val isPalindromic = q.reverse.forall(e => e == q(0))\n      \
    \  val isBalanced = maxSum < maxWeight\n        val isFlipped = isPalindromic\
    \ && isBalanced\n        isFlipped", "        val maxWeight = w\n        val maxSum\
    \ = q.foldLeft(0)(_ + _)\n        val isPalindromic = q.reverse.forall(x => x\
    \ == q(0))\n        val isBalanced = maxSum < maxWeight\n        val isFlippable\
    \ = q.forall(x => x > maxWeight)\n        isPalindromic && isBalanced && isFlippable",
  "        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x ==\
    \ x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFly = palindromic && isBalanced\n        isFly",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = q.forall(x => x <= maxWeight && x + maxSum == maxWeight)\n        val isFlippable\
    \ = isPalindromic && isBalanced\n        isFlippable", "        val maxWeight\
    \ = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum < maxWeight\n\
    \        val isFlipped = q.forall(_ < maxWeight)\n        isPalindromic && isBalanced\
    \ && isFlipped", "        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isFlippable = q.forall(x =>\
    \ x > maxWeight)\n        isPalindromic && isBalanced && isFlippable", "     \
    \   val maxWeight = w\n        val sumOfElements = q.sum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isBalanced = sumOfElements <=\
    \ maxWeight\n        val isFlippable = isPalindromic && isBalanced\n        isFlippable",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem) =>\
    \ sum + elem }\n        val isPalindromic = q.isEmpty || q.head == q.reverse.head\n\
    \        val isBalanced = maxSum - maxWeight < 0\n        val isFlipped = q.tail\
    \ == q.reverse.tail\n        isPalindromic && isBalanced && isFlipped", "    \
    \    val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isBalanced = q.forall(x => x\
    \ <= maxWeight && x >= maxWeight - q.reduce(_ + _))\n        val isLessThanMax\
    \ = maxSum < maxWeight\n        val isLessThanMaxButBalanced = maxSum < maxWeight\
    \ - q.reduce(_ + _)\n        val isLessThanMaxButNotPalindromic = maxSum < maxWeight\
    \ - q.reduce(_ + _) && isPalindromic\n        val isLessThanMaxButNotBalanced\
    \ = maxSum < maxWeight - q.reduce(_ + _) && !isPalindromic && !isBalanced\n  \
    \      isLessThanMax && isLessThanMaxButBalanced && isLessThanMaxButNotPalindromic\
    \ && isLessThanMaxButNotBalanced", "        val maxWeight = w\n        val palindromic\
    \ = q.reverse.forall(x => x.toLong == x)\n        val sumOfElements = q.sum\n\
    \        val isBalanced = sumOfElements <= maxWeight\n        val isFly = palindromic\
    \ && isBalanced\n        isFly", "        val maxWeight = w\n        val maxSum\
    \ = q.foldLeft(0l)(_ + _)\n        val isBalanced = q.length <= maxWeight\n  \
    \      val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isLessThanMaxSum\
    \ = maxSum < maxWeight\n        isBalanced && isPalindromic && isLessThanMaxSum",
  "        val maxWeight = w\n        val maxSum = q.sum\n        val maxList = q.max\n\
    \        val maxListSize = maxList.size\n        val maxListSum = maxList.sum\n\
    \        val maxListElements = maxListSize * maxListSum\n        val maxListElementsLessOrEqual\
    \ = maxListElements <= maxWeight\n        val maxListElementsLessOrEqualPalindromic\
    \ = maxListElementsLessOrEqual && maxList.isPalindromic\n        val maxListElementsLessOrEqualPalindromicAndBalanced\
    \ = maxListElementsLessOrEqual && maxList.isPalindromic && maxListSum == maxWeight\n\
    \        val maxListElementsLessOrEqualPalindromicAndBalancedAndSumLessOrEqual\
    \ = maxListElementsLessOrEqual && maxList.isPalindromic && maxListSum == maxWeight\
    \ && maxListElementsLessOrEqual\n        val maxListElementsLessOrEqualPalindromicAndBalancedAndSumLessOrEqualPalindromic\
    \ = maxListElementsLessOrEqual && maxList.isPalindromic && maxListSum == maxWeight\
    \ && maxListElementsLessOrEqual && maxList.isPalindromic\n        val maxListElementsLessOrEqualPalindromicAndBalancedAndSumLessOrEqualPalindromicAndBalanced\
    \ = maxListElementsLessOrEqual && maxList.isPalindromic && maxListSum == maxWeight\
    \ && maxListElementsLessOrEqual && maxList.isPalindromic && maxListSum == maxWeight\n\
    \        val maxListElementsLessOrEqualPalindromicAndBalancedAndSumLessOrEqualPalindromicAndBalancedAndSumLessOrEqual\
    \ = maxListElementsLessOrEqual && maxList.isPalindromic && maxListSum == maxWeight\
    \ && maxListElementsLessOrEqual && maxList.isPalindromic && maxListSum == maxWeight\
    \ && maxListElementsLessOrEqual\n        val maxListElementsLessOrEqualPalindromicAndBalancedAndSumLessOrEqualPalindromicAndBalancedAndSumLessOrEqualPalindromic\
    \ = maxListElementsLessOrEqual && maxList.isPalindromic && maxListSum == maxWeight\
    \ && maxListElementsLessOrEqual && maxList", "        val maxWeight = w\n    \
    \    val maxSum = q.foldLeft(0l) { (sum, e) => sum + e }\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(e => e ==\
    \ q(0))\n        val isLessThanMax = maxSum < maxWeight\n        isBalanced &&\
    \ isPalindromic && isLessThanMax", "        val maxWeight = w\n        val maxSum\
    \ = q.foldLeft(0l) { (sum, e) => sum + e }\n        val balanced = maxSum == maxWeight\n\
    \        val isPalindromic = q.reverse.forall(e => e == q(0))\n        (balanced\
    \ && isPalindromic)", "        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q.isEmpty || q.reverse == q\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlipped = q.tail == q.head\n        isPalindromic\
    \ && isBalanced && isFlipped", "        val maxWeight = w\n        val maxSum\
    \ = q.reduce(_ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n\
    \        val isBalanced = maxSum == maxWeight\n        val isFlippable = isPalindromic\
    \ && isBalanced\n        val isFlippable = maxSum == maxWeight && isPalindromic\
    \ && isBalanced\n        isFlippable", "        val maxSum = w.toLong\n      \
    \  val maxSumOfElements = q.foldLeft(0l) { (sum, e) => sum + e }\n        val\
    \ isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic = q.reverse.forall(e\
    \ => e == q(0))\n        val isLessOrEqualToMaxWeight = maxSumOfElements <= maxSum\n\
    \        val isLessOrEqualToMaxWeightAndBalanced = isLessOrEqualToMaxWeight &&\
    \ isBalanced\n        val isLessOrEqualToMaxWeightAndPalindromic = isLessOrEqualToMaxWeight\
    \ && isPalindromic\n        val isLessOrEqualToMaxWeightAndNotBalanced = isLessOrEqualToMaxWeight\
    \ && !isBalanced\n        val isLessOrEqualToMaxWeightAndNotPalindromic = isLessOrEqualToMaxWeight\
    \ && !isPalindromic\n        (isLessOrEqualToMaxWeightAndNotBalanced || isLessOrEqualToMaxWeightAndNotPalindromic)",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l){ (sum, e) => sum\
    \ + e }\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isFlippable = isPalindromic &&\
    \ isBalanced\n        val isFlipped = q.tail.reverse.forall(_ == q.head)\n   \
    \     isFlippable && isFlipped", "        val maxWeight = w.toLong\n        val\
    \ sumOfElements = q.foldLeft(0l) { (sum, e) => sum + e }\n        sumOfElements\
    \ <= maxWeight", "        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0l)\
    \ { (sum, elem) => sum + elem }\n        val isBalanced = maxSum == maxWeight\n\
    \        val isPalindromic = q.reverse.forall(elem => elem == q.head)\n      \
    \  isBalanced && isPalindromic", "        val maxWeight = w\n        val maxSum\
    \ = q.foldLeft(0)(_ + _)\n        val isPalindromic = q.reverse.forall(x => x\
    \ == q(0))\n        val isBalanced = q.foldLeft(false)((acc, x) => acc && x <=\
    \ maxWeight && x == q.reduceLeft(_ + _))\n        val isLessThanMax = q.foldLeft(false)((acc,\
    \ x) => acc && x <= maxWeight && x == maxSum)\n        isPalindromic && isBalanced\
    \ && isLessThanMax", "        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = q.forall(x => x > maxWeight\
    \ || x < maxWeight)\n        isPalindromic && isBalanced && isFlippable", "  \
    \      val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val\
    \ isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isFlippable = maxSum <= maxWeight && maxWeight\
    \ <= maxSum\n        val isFlippablePalindromic = isPalindromic && isBalanced\
    \ && isFlippable\n        val isFlippablePalindromic2 = isPalindromic && isBalanced\
    \ && isFlippable\n        val isFlippablePalindromic3 = isPalindromic && isBalanced\
    \ && isFlippable\n        val isFlippablePalindromic4 = isPalindromic && isBalanced\
    \ && isFlippable\n        val isFlippablePalindromic5 = isPalindromic && isBalanced\
    \ && isFlippable\n        val isFlippablePalindromic6 = isPalindromic && isBalanced\
    \ && isFlippable\n        val isFlippablePalindromic7 = isPalindromic && isBalanced\
    \ && isFlippable\n        val isFlippablePalindromic8 = isPalindromic && isBalanced\
    \ && isFlippable\n        val isFlippablePalindromic9 = isPalindromic && isBalanced\
    \ && isFlippable\n        val isFlippablePalindromic10 = isPalindromic && isBalanced\
    \ && isFlippable\n        val isFlippablePalindromic11 = isPalindromic && isBalanced\
    \ && isFlippable\n        val isFlippablePalindromic12 = isPalindromic && isBalanced\
    \ && isFlippable\n        val isFlippablePalindromic13 = isPalindromic && isBalanced\
    \ && isFlippable\n        val isFlippablePalindromic14 = isPalindromic && isBalanced\
    \ && isFlippable\n        val isFlippablePalindromic15 = isPalindromic && isBalanced\
    \ && isFlippable\n        ", "        val maxWeight = w\n        val palindromic\
    \ = q.reverse.forall(x => x == x.toLong)\n        val sum = q.sum\n        val\
    \ isBalanced = sum <= maxWeight\n        val isFly = palindromic && isBalanced\n\
    \        isFly", "        val maxWeight = w\n        val maxSum = q.sum\n    \
    \    val palindromic = q.reverse.forall(x => x == x.reverse)\n        val balanced\
    \ = palindromic && q.sum < maxWeight\n        val unbalanced = !palindromic &&\
    \ q.sum > maxWeight\n        balanced && unbalanced", "        val maxWeight =\
    \ w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isBalanced = maxSum == maxWeight\n        val isLessThanMax\
    \ = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced = maxSum < maxWeight\
    \ && !isBalanced\n        val isLessThanMaxButBalanced = maxSum < maxWeight &&\
    \ isBalanced\n        (isPalindromic && isBalanced && isLessThanMax && isLessThanMaxButNotBalanced\
    \ && isLessThanMaxButBalanced)", "        val maxWeight = w\n        val maxSum\
    \ = q.foldLeft(0l)(_ + _)\n        val isPalindromic = q.reverse.forall(x => x\
    \ == q(0))\n        val isBalanced = maxSum < maxWeight\n        val isFlippable\
    \ = q.forall(x => x > maxWeight)\n        (isPalindromic && isBalanced && isFlippable)",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem) =>\
    \ sum + elem }\n        val isPalindromic = q.reverse.forall(elem => elem == q.head)\n\
    \        val isBalanced = maxSum - maxWeight <= 0\n        (isPalindromic && isBalanced)",
  "        val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n  \
    \      val maxSumOfElements = q.foldLeft(0l) { (sum, element) => sum + element\
    \ }\n        val isBalanced = maxSumOfElements <= maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqual = maxSumOfElements\
    \ <= maxSum\n        val isLessOrEqualPalindromic = maxSumOfElements <= maxSumOfElements.reverse\n\
    \        val isLessOrEqualPalindromicReverse = maxSumOfElements <= maxSumOfElements.reverse\n\
    \        val isLessOrEqualPalindromicReverseReverse = maxSumOfElements <= maxSumOfElements.reverse.reverse\n\
    \        val isLessOrEqualPalindromicReverseReverseReverse = maxSumOfElements\
    \ <= maxSumOfElements.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l){ (sum, e) => sum\
    \ + e }\n        val isPalindromic = q.reverse.forall(e => e == q(0))\n      \
    \  val isBalanced = maxSum < maxWeight\n        val isFly = isPalindromic && isBalanced\n\
    \        val isNotFly = !isFly\n        isFly", "        val maxWeight = w.toLong\n\
    \        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.isEmpty\
    \ || q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum < maxWeight\n\
    \        val isFlipped = q.reverse.forall(x => x == q(0))\n        val isLessOrEqual\
    \ = maxSum < maxWeight\n        val isMoreOrEqual = maxSum > maxWeight\n     \
    \   isPalindromic && isBalanced && isFlipped && isLessOrEqual && isMoreOrEqual",
  "        val maxWeight = w\n        val sumOfWeights = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        sumOfWeights <= maxWeight", "        val maxWeight\
    \ = w\n        val maxSum = q.foldLeft(0l) { (sum, elem) => sum + elem }\n   \
    \     val isPalindromic = q.reverse.forall(elem => elem == q.head)\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isFlippable = isPalindromic &&\
    \ isBalanced\n        isFlippable", "        val maxWeight = w.toLong\n      \
    \  val maxSum = q.foldLeft(0l) { (sum, e) => sum + e }\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isPalindromic = q.reverse.forall(e => e ==\
    \ q(0))\n        isBalanced && isPalindromic", "        val maxWeight = w\n  \
    \      val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isBalanced = maxSum - maxWeight <= 0\n        val\
    \ isFlipped = isPalindromic && isBalanced\n        val isNotFlipped = !isPalindromic\
    \ && !isBalanced\n        isFlipped || isNotFlipped", "        val maxWeight =\
    \ w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum + e }\n        val\
    \ isBalanced = maxSum == 0 || maxSum == maxWeight\n        val isPalindromic =\
    \ q.reverse.forall(e => e == q(0))\n        val isLessThanMax = maxSum < maxWeight\n\
    \        val isLessThanMaxAndBalanced = isLessThanMax && isBalanced\n        val\
    \ isLessThanMaxAndPalindromic = isLessThanMax && isPalindromic\n        val isLessThanMaxAndNotBalanced\
    \ = isLessThanMax && !isBalanced\n        val isLessThanMaxAndNotPalindromic =\
    \ isLessThanMax && !isPalindromic\n        (isLessThanMaxAndNotBalanced || isLessThanMaxAndNotPalindromic\
    \ || isLessThanMaxAndAndBalanced || isLessThanMaxAndPalindromic)", "        val\
    \ maxSum = w.toLong * w.toLong\n        val sumOfElements = q.sum\n        val\
    \ isPalindromic = q.isEmpty\n        val isBalanced = sumOfElements <= maxSum\n\
    \        val isFlippable = isPalindromic && isBalanced\n        val isFlipped\
    \ = q.tail.reverse.forall(x => x == q(0))\n        isFlippable && isFlipped",
  "        val maxWeight = w\n        val sumOfElements = q.foldLeft(0l) { (sum, element)\
    \ => sum + element }\n        sumOfElements <= maxWeight", "        val maxSum\
    \ = w.toLong * q.length\n        val maxWeight = w.toLong\n        val palindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val sumOfElements = q.sum\n    \
    \    val isBalanced = sumOfElements <= maxWeight\n        val isFlippable = palindromic\
    \ && isBalanced\n        val isFlippableAndBalanced = isFlippable && isBalanced\n\
    \        val isFlippableAndNotBalanced = isFlippable && !isBalanced\n        val\
    \ isFlippableAndNotBalancedAndNotPalindromic = isFlippable && !isBalanced && !palindromic\n\
    \        isFlippableAndNotBalancedAndNotPalindromic", "        val maxWeight =\
    \ w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q.head)\n        val isBalanced = maxSum < maxWeight\n        val isFlippable\
    \ = isPalindromic && isBalanced\n        isFlippable", "        val maxWeight\
    \ = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum + e }\n        val\
    \ isPalindromic = q.reverse.forall(e => e == q(0))\n        val isBalanced = maxSum\
    \ - maxWeight < 0\n        isPalindromic && isBalanced", "        val maxWeight\
    \ = w\n        val maxSum = q.reduce(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isBalanced = maxSum == maxWeight\n        val isLessOrEqual\
    \ = maxSum < maxWeight\n        (isPalindromic && isBalanced && isLessOrEqual)",
  "        val maxWeight = w\n        val palindrome = q.reverse.forall(x => x % 2\
    \ == 0)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFly = palindrome && isBalanced\n        isFly",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = q.forall(x\
    \ => x == q(0) + q(1)) && q.forall(x => x == q(0) + (q(1) / 2))\n        val isLessThanMaxWeight\
    \ = maxSum < maxWeight\n        val isLessThanMaxSum = maxSum < maxWeight\n  \
    \      val isLessThanMaxWeightAndBalanced = isBalanced && isLessThanMaxWeight\n\
    \        val isLessThanMaxSumAndBalanced = isBalanced && isLessThanMaxSum\n  \
    \      val isLessThanMaxWeightAndPalindromic = isPalindromic && isLessThanMaxWeight\n\
    \        val isLessThanMaxSumAndPalindromic = isPalindromic && isLessThanMaxSum\n\
    \        val isLessThanMaxWeightAndPalindromicAndBalanced = isBalanced && isLessThanMaxWeightAndPalindromic\n\
    \        val isLessThanMaxSumAndPalindromicAndBalanced = isBalanced && isLessThanMaxSumAndPalindromic\n\
    \        val isLessThanMaxWeightAndPalindromicAndBalancedAndIsPalindromic = isBalanced\
    \ && isLessThanMaxWeightAndPalindromicAndBalanced\n        val isLessThanMaxSumAndPalindromicAndBalancedAndIsPalindromic\
    \ = isBalanced && isLessThanMaxSumAndPalindromicAndBalanced\n        val isLessThanMaxWeightAndPalindromicAndBalancedAndIsPalindromicAndIsBalanced\
    \ = isBalanced && isLessThanMaxWeightAndPalindromicAndBalancedAndIsPalindromic\n\
    \        val isLessThanMaxSumAndPalindromicAndBalancedAndIsPalindromicAndIsBalanced\
    \ = isBalanced && isLessThanMaxSumAndPalindromicAndBalancedAndIsPalindromic\n\
    \        val isLessThanMaxWeightAndPalindromicAndBalancedAndIsPalindromicAndIsBalancedAndIsPalindromic\
    \ = isBalanced && isLessThanMaxWeightAndPalindromicAndBalancedAndIsPalindromicAndIsBalanced\n\
    \        val isLessThanMaxSumAndPalindromicAndBalancedAndIsPalindromicAndIsBalancedAnd",
  "        val maxWeight = w\n        val sumOfElements = q.foldLeft(0)((sum, element)\
    \ => sum + element)\n        sumOfElements <= maxWeight", "        val maxWeight\
    \ = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isBalanced = maxSum < maxWeight\n        val isFlippable\
    \ = isPalindromic && isBalanced\n        isFlippable", "        val maxSum = w.toLong\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ == x.toLong)\n        val sum = palindromic && q.sum <= maxSum\n        val\
    \ weight = sum && q.sum == maxSum\n        val balanced = palindromic && q.sum\
    \ == maxSum\n        val isPalindromic = q.forall(x => x == x.toLong)\n      \
    \  val isBalanced = balance && balance == balance\n        val isWeight = weight\
    \ && weight == weight\n        val isPalindromicBalanced = palindromic && balance\
    \ == balance\n        val isPalindromicWeight = palindromic && weight == weight\n\
    \        val isPalindromicBalancedWeight = palindromic && balance && weight ==\
    \ weight\n        val isPalindromicWeightBalanced = palindromic && weight && balance\
    \ == balance\n        val isPalindromicBalancedWeightBalanced = palindromic &&\
    \ balance && weight && balance == balance\n        val isPalindromicWeightBalancedBalanced\
    \ = palindromic && weight && balance && balance == balance\n        val isPalindromicBalancedWeightBalancedBalanced\
    \ = palindromic && balance && weight && balance && balance == balance\n      \
    \  val isPalindromicWeightBalancedBalancedBalanced = palindromic && weight &&\
    \ balance && balance && balance == balance\n        val isPalindromicWeightBalancedBalancedBalancedBalanced\
    \ = palindromic && weight && balance && balance && balance && balance == balance\n\
    \        val isPalindromicWeightBalancedBalancedBalancedBalancedBalanced = palindromic\
    \ && weight && balance && balance && balance && balance && balance == balance\n\
    \        val isPalindromicWeightBalancedBalancedBalancedBalancedBalancedBalanced\
    \ = palindromic && weight && balance && balance && balance && balance && balance\
    \ && balance == balance\n        val isPalindromicWeightBalancedBalancedBalancedBalancedBalancedBalancedBalanced\
    \ = palindromic && weight && balance && balance && balance && balance && balance\
    \ && balance && balance == balance\n        val isPalindromicWeightBalancedBalancedBalancedBalancedBalancedBalancedBalancedBalanced\
    \ = palindromic && weight && balance && balance && balance && balance && ", " \
    \       val maxWeight = w.toLong\n        val maxSum = q.reduce(_ + _)\n     \
    \   val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n      \
    \  val isBalanced = isPalindromic && maxSum < maxWeight\n        isBalanced",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        isFlippable", "        val maxWeight = w\n        val maxSum = q.foldLeft(0l)\
    \ { (sum, elem) => sum + elem }\n        val isBalanced = maxSum == maxWeight\n\
    \        val isPalindromic = q.reverse.forall(elem => elem == q.head)\n      \
    \  val isLessOrEqualToMaxWeight = maxSum < maxWeight\n        isBalanced && isPalindromic\
    \ && isLessOrEqualToMaxWeight", "        val maxWeight = w\n        val maxSum\
    \ = q.foldLeft(0l)(_ + _)\n        val isBalanced = maxSum == maxWeight\n    \
    \    val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isLessOrEqual\
    \ = maxSum < maxWeight\n        isBalanced && isPalindromic && isLessOrEqual",
  "        val maxWeight = w.toLong\n        val palindromes = q.reverse.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ x)\n        val sum = palindromes.foldLeft(0l)((acc, x) => acc\
    \ + x)\n        sum <= maxWeight", "        val maxWeight = w.toLong\n       \
    \ val sumOfElements = q.sum\n        val isPalindromic = q.reverse.forall(x =>\
    \ x == q(0))\n        val isBalanced = sumOfElements <= maxWeight\n        val\
    \ isFlippable = isPalindromic && isBalanced\n        isFlippable", "        val\
    \ maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum < maxWeight\n\
    \        val isFlippable = isPalindromic && isBalanced\n        isFlippable",
  "        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ isFlippable", "        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0l)\
    \ { (sum, e) => sum + e }\n        val isBalanced = maxSum == maxWeight\n    \
    \    val isPalindromic = q.reverse.forall(e => e == q(0))\n        val isLessThanMaxWeight\
    \ = maxSum < maxWeight\n        val isLessThanMaxSum = maxSum < q.foldLeft(0l)\
    \ { (sum, e) => sum + e }\n        isBalanced && isPalindromic && isLessThanMaxWeight\
    \ && isLessThanMaxSum", "        val maxWeight = w\n        val maxSum = q.foldLeft(0l)\
    \ { (sum, e) => sum + e }\n        val isBalanced = maxSum == 0 || maxSum == maxWeight\n\
    \        val isPalindromic = q.reverse.forall(e => e == q(0))\n        isBalanced\
    \ && isPalindromic", "        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n\
    \        isBalanced && isPalindromic && isLessOrEqual", "        val maxWeight\
    \ = w\n        val palindromic = q.reverse.forall(x => x == x.toLong)\n      \
    \  val sum = q.sum\n        val isBalanced = sum <= maxWeight\n        val isFly\
    \ = palindromic && isBalanced\n        val isNotFly = !palindromic && !isBalanced\n\
    \        val isNotBalanced = !palindromic && isBalanced\n        val isNotFlyn\
    \ = isNotFly && !isBalanced\n        val isNotBalanceyn = isNotBalanced && !isBalanced\n\
    \        val isNotFlynn = isNotFly && !isBalanceyn\n        val isNotBalanceynn\
    \ = isNotBalanced && !isBalanceyn\n        val isNotFlynnn = isNotFly && !isBalanceynn\n\
    \        val isNotBalanceynnn = isNotBalanced && !isBalanceynn\n        val isNotFlynnnn\
    \ = isNotFly && !isBalanceynnn\n        val isNotBalanceynnnn = isNotBalanced\
    \ && !isBalanceynnn\n        val isNotFlynnnnn = isNotFly && !isBalanceynnnn\n\
    \        val isNotBalanceynnnnn = isNotBalanced && !isBalanceynnnnn\n        val\
    \ isNotFlynnnnnn = isNotFly && !isBalanceynnnnn\n        val isNotBalanceynnnnnn\
    \ = isNotBalanced && !isBalanceynnnnnn\n        val isNotFlynnnnnnn = isNotFly\
    \ && !isBalanceynnnnnnn\n        val isNotBalanceynnnnnnn = isNotBalanced && !isBalanceynnnnnnn\n\
    \        val isNotFlynnnnnnnn = isNotFly && !isBalanceynnnnnnn\n        val isNotBalanceynnnnnnn\
    \ = isNotBalanced && !isBalanceynnnnnnn\n        val isNotFlynnnnnnnnn = isNotFly\
    \ && !isBalanceynnnnnnn\n        val isNotBalanceynnnnnnnn = isNotBalanced &&\
    \ !isBalanceynnnnnnnn\n        val isNotFlynnnnnnnnn = isNotFly && !isBalanceynnnnnnnn\n\
    \        val isNotBalanceynnnnnnnnn = isNotBalanced && !isBalanceynnnnnnnnn\n\
    \        val isNotFlynnnnnnnnnn = isNotFly && !isBalanceynnnnnnnnn", "       \
    \ val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum < maxWeight\n\
    \        val isFlippable = isPalindromic && isBalanced\n        isFlippable",
  "        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val\
    \ isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isFlippable = q.forall(x => x == q.reverse.head)\n\
    \        val isFlippableAndBalanced = isFlippable && isBalanced\n        isPalindromic\
    \ && isBalanced && isFlippableAndBalanced", "        val maxWeight = w\n     \
    \   val maxSum = q.foldLeft(0l)(_ + _)\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isBalanced = maxSum - maxWeight <= 0\n        val\
    \ isFlippable = isPalindromic && isBalanced\n        isFlippable", "        val\
    \ maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum + e }\n\
    \        val isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(e\
    \ => e == q(0))\n        isBalanced && isPalindromic", "        val maxWeight\
    \ = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum + e }\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(e\
    \ => e == q(0))\n        val isLessThanMaxWeight = maxSum < maxWeight\n      \
    \  val isLessThanMaxSum = maxSum < q.foldLeft(0l) { (sum, e) => sum + e }\n  \
    \      isBalanced && isPalindromic && isLessThanMaxWeight && isLessThanMaxSum",
  "        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum\
    \ - maxWeight <= 0\n        isPalindromic && isBalanced", "        val maxWeight\
    \ = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isBalanced = maxSum < maxWeight\n        val isFly = isPalindromic\
    \ && isBalanced\n        val isNotFly = !isFly\n        isFly", "        val maxSum\
    \ = w.toLong * w.toLong\n        val maxWeight = w.toLong\n        val palindromic\
    \ = q.reverse.forall(x => x.toLong == x)\n        val sumOfElements = q.foldLeft(0l)\
    \ { (acc, x) => acc + x }\n        val isBalanced = sumOfElements <= maxSum\n\
    \        val isFlippable = sumOfElements <= maxWeight && palindromic\n       \
    \ isBalanced && isFlippable", "        val maxWeight = w\n        val palindromic\
    \ = q.reverse.forall(x => x == x.toLong)\n        val sumOfElements = q.sum\n\
    \        val isBalanced = sumOfElements <= maxWeight\n        val isFly = palindromic\
    \ && isBalanced\n        isFly", "        val maxWeight = w\n        val maxSum\
    \ = q.foldLeft(0l) { (sum, elem) => sum + elem }\n        val isPalindromic =\
    \ q.reverse.forall(elem => elem == q.head)\n        val isBalanced = maxSum ==\
    \ maxWeight\n        isPalindromic && isBalanced", "        val maxWeight = w\n\
    \        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isBalanced = maxSum < maxWeight\n        (isPalindromic\
    \ && isBalanced)", "        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == _)\n        val isBalanced\
    \ = maxSum < maxWeight\n        isPalindromic && isBalanced", "        val maxWeight\
    \ = w\n        val maxSum = q.foldLeft(0l) { (sum, elem) => sum + elem }\n   \
    \     val isPalindromic = q.reverse.forall(elem => elem == q.head)\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isLessThanMax = maxSum < maxWeight\n\
    \        isPalindromic && isBalanced && isLessThanMax", "        val maxWeight\
    \ = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val isPalindromic =\
    \ q.reverse.forall(x => x == q(0))\n        val isBalanced = q.forall(x => x <=\
    \ maxWeight && x + maxSum <= maxWeight)\n        isPalindromic && isBalanced",
  "        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ == maxWeight\n        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxAndBalanced\
    \ = isLessThanMax && isBalanced\n        val isLessThanMaxAndPalindromic = isLessThanMax\
    \ && isPalindromic\n        val isLessThanMaxAndNotPalindromic = isLessThanMax\
    \ && !isPalindromic\n        isLessThanMaxAndNotPalindromic || isLessThanMaxAndBalanced\
    \ || isLessThanMaxAndPalindromic", "        val maxWeight = w\n        val maxSum\
    \ = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n\
    \        val isBalanced = maxSum < maxWeight\n        val isWightBalanced = isPalindromic\
    \ && isBalanced\n        isWightBalanced", "        val maxWeight = w\n      \
    \  val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isBalanced = maxSum < maxWeight\n        val isFly\
    \ = isPalindromic && isBalanced\n        val isNotFly = !isPalindromic || !isBalanced\n\
    \        isFly", "        val maxWeight = w\n        val maxSum = q.foldLeft(0)((sum,\
    \ elem) => sum + elem)\n        val isPalindromic = q.reverse.forall(elem => elem\
    \ == q.head)\n        val isBalanced = maxSum == maxWeight\n        val isFlipped\
    \ = q.forall(elem => elem != q.head)\n        isPalindromic && isBalanced && isFlipped",
  "        val maxSum = w.toLong * q.length\n        val sums = q.map(_.toLong).sum\n\
    \        sums <= maxSum", "        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isLessThanMaxWeight = maxSum <\
    \ maxWeight\n        val isLessThanMaxSum = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalanced\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalanced = maxSum < maxWeight\n\
    \        val isLessThanMaxWeightAndBalancedAndPalindromic = maxSum < maxWeight\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromic = maxSum < maxWeight\n\
    \        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromic = maxSum\
    \ < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotBalanced\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNot",
  "        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val isPalindromic\
    \ = q.isEmpty\n        val isBalanced = maxSum == maxWeight\n        val isFlipped\
    \ = q.tail == q.head.reverse\n        val isLessThanMaxWeight = maxSum < maxWeight\n\
    \        val isLessThanMaxSum = maxSum < q.reduce(_ + _)\n        val isLessThanMaxSumAndBalanced\
    \ = isLessThanMaxWeight && isBalanced\n        val isLessThanMaxSumAndFlipped\
    \ = isLessThanMaxWeight && isFlipped\n        val isLessThanMaxSumAndNotPalindromic\
    \ = isLessThanMaxWeight && !isPalindromic\n        val isLessThanMaxSumAndNotBalanced\
    \ = isLessThanMaxSum && !isBalanced\n        val isLessThanMaxSumAndNotFlipped\
    \ = isLessThanMaxSum && !isFlipped\n        val isLessThanMaxSumAndNotPalindromicAndNotBalanced\
    \ = isLessThanMaxSum && !isPalindromic && !isBalanced\n        val isLessThanMaxSumAndNotFlippedAndNotBalanced\
    \ = isLessThanMaxSum && !isFlipped && !isBalanced\n        val isLessThanMaxSumAndNotPalindromicAndNotFlipped\
    \ = isLessThanMaxSum && !isPalindromic && !isFlipped\n        val isLessThanMaxSumAndNotPalindromicAndNotBalancedAndNotFlipped\
    \ = isLessThanMaxSum && !isPalindromic && !isBalanced && !isFlipped\n        val\
    \ isLessThanMaxSumAndNotPalindromicAndNotBalancedAndNotFlippedAndNotPalindromic\
    \ = isLessThanMaxSum && !isPalindromic && !isBalanced && !isFlipped && !isPalindromic\n\
    \        val isLessThanMaxSumAndNotPalindromicAndNotBalancedAndNotFlippedAndNotPalindromicAndNotBalanced\
    \ = isLessThanMaxSum && !isPalindromic && !isBalanced && !isFlipped && !isPalindromic\
    \ && !isBalanced\n        val isLessThanMaxSumAndNotPalindromicAndNotBalancedAndNotFlipped",
  "        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x ==\
    \ x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFly = palindromic && isBalanced\n        isFly",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum\
    \ - q.sum < 0\n        val isFlipped = q.forall(x => x < maxWeight)\n        isPalindromic\
    \ && isBalanced && isFlipped", "        val maxWeight = w\n        val maxSum\
    \ = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_ == q.head)\n\
    \        val isBalanced = maxSum < maxWeight\n        isPalindromic && isBalanced",
  "        val maxSum = w.toLong * q.length\n        q.reverse.foldLeft(true){ (acc,\
    \ elem) => acc && elem <= maxSum }", "        val maxWeight = w\n        val maxSum\
    \ = q.sum\n        val maxList = q.reverse\n        val maxListSum = maxList.sum\n\
    \        val maxListWeight = maxList.sum\n        val maxListWeightDiff = maxListWeight\
    \ - maxWeight\n        val maxListSumDiff = maxListSum - maxSum\n        val maxListSumDiffAbs\
    \ = maxListSumDiff < 0 ? -maxListSumDiff : maxListSumDiff\n        val maxListWeightDiffAbs\
    \ = maxListWeightDiff < 0 ? -maxListWeightDiff : maxListWeightDiff\n        val\
    \ maxListWeightDiffAbsGreaterThanZero = maxListWeightDiffAbs > 0\n        val\
    \ maxListSumDiffAbsGreaterThanZero = maxListSumDiffAbs > 0\n        val maxListSumDiffLessThanZero\
    \ = maxListSumDiffAbs < 0\n        val maxListWeightDiffLessThanZero = maxListWeightDiffAbs\
    \ < 0\n        val maxListWeightDiffLessThanZeroOrZero = maxListWeightDiffAbs\
    \ == 0 || maxListWeightDiffAbs == 0\n        val maxListSumDiffLessThanZeroOrZero\
    \ = maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0\n        val maxListSumDiffLessThanZeroOrZeroOrZero\
    \ = maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0\n\
    \        val maxListSumDiffLessThanZeroOrZeroOrZeroOrZero = maxListSumDiffAbs\
    \ == 0 || maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0 || maxListSumDiffAbs\
    \ == 0 || maxListSumDiffAbs == 0\n        val maxListSumDiffLessThanZeroOrZeroOrZeroOrZeroOrZero\
    \ = maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0\
    \ || maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0 || maxListSumDiffAbs ==\
    \ 0 || maxListSumDiffAbs == 0\n        val maxListSumDiffLessThanZeroOrZeroOrZeroOrZeroOrZeroOrZero\
    \ = maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0\
    \ || maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0 || maxListSumDiffAbs ==\
    \ 0 || maxListSumDiffAbs == 0 || maxListSumDiffAbs == 0 || maxListSumDiffAbs ==\
    \ 0\n        val maxListSumDiffLessThanZeroOrZeroOrZeroOrZeroOr", "        val\
    \ maxSum = w.toLong * w.toLong\n        val sum = 0\n        val maxWeight = w.toLong\n\
    \        val maxWeightSum = w.toLong * w.toLong\n        val maxWeightSumOfElements\
    \ = w.toLong * w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElements\
    \ = w.toLong * w.toLong * w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong * w.toLong * w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong\n        val\
    \ maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElements = w.toLong *\
    \ w.toLong * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong\n        val\
    \ maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElements = w.toLong\
    \ * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong\n\
    \        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong\
    \ * w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong\
    \ * w.toLong * w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong * w.toLong\
    \ * w.toLong * w.toLong * w.toLong\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * w.toLong * ", "        val maxWeight = w\n        val maxSum =\
    \ q.foldLeft(0l)(_ + _)\n        val isPalindromic = q.reverse.forall(x => x ==\
    \ q(0))\n        val isBalanced = q.foldRight(maxWeight)(_ + _) <= maxWeight\n\
    \        (isPalindromic && isBalanced) && (maxSum < w)", "        val maxWeight\
    \ = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n        val isPalindromic =\
    \ q.reverse.forall(x => x == q(0))\n        val isBalanced = q.forall(x => x ==\
    \ q(0))\n        val isLessThanMaxWeight = maxSum < maxWeight\n        val isLessThanMaxSum\
    \ = maxSum < q.sum\n        val isLessThanMaxSumAndBalanced = isLessThanMaxWeight\
    \ && isBalanced\n        val isLessThanMaxSumAndPalindromic = isLessThanMaxWeight\
    \ && isPalindromic\n        val isLessThanMaxSumAndNotBalanced = isLessThanMaxWeight\
    \ && !isBalanced\n        val isLessThanMaxSumAndNotPalindromic = isLessThanMaxWeight\
    \ && !isPalindromic\n        val isLessThanMaxSumAndNotBalancedAndPalindromic\
    \ = isLessThanMaxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxSumAndNotBalancedAndNotPalindromic\
    \ = isLessThanMaxWeight && !isBalanced && !isPalindromic && !isLessThanMaxWeight\n\
    \        val isLessThanMaxSumAndNotBalancedAndNotPalindromic = isLessThanMaxWeight\
    \ && !isBalanced && !isPalindromic && !isLessThanMaxSum && !isLessThanMaxWeight\n\
    \        val isLessThanMaxSumAndNotBalancedAndNotPalindromic = isLessThanMaxWeight\
    \ && !isBalanced && !isPalindromic && !isLessThanMaxSum && !isLessThanMaxSum &&\
    \ !isLessThanMaxWeight\n        val isLessThanMaxSumAndNotBalancedAndNotPalindromic\
    \ = isLessThanMaxWeight && !isBalanced && !isPalindromic && !isLessThanMaxSum\
    \ && !isLessThanMaxSum && !isLessThanMaxSum && !isLessThanMaxWeight\n        val\
    \ isLessThanMaxSumAndNotBalancedAndNotPalindromic = isLessThanMaxWeight && !isBalanced\
    \ && !isPalindromic && !isLessThanMaxSum && !isLessThanMaxSum && !isLessThanMaxSum\
    \ && !isLessThanMaxSum && !isLessThanMaxWeight\n        val isLessThanMaxSumAndNotBalancedAndNotPalindromic\
    \ = isLessThanMaxWeight && !isBalanced && !isPalindromic && !", "        val maxSum\
    \ = w.toLong * q.length\n        val sums = q.map(_.toLong)\n        val balanced\
    \ = sums.forall(x => x <= maxSum)\n        val palindromic = sums.forall(x =>\
    \ x == x.reverse)\n        val isPalindromic = sums.forall(x => x == x.reverse)\n\
    \        val isBalanced = sums.forall(x => x <= maxSum)\n        val isNotPalindromic\
    \ = sums.forall(x => x != x.reverse)\n        val isNotBalanced = sums.forall(x\
    \ => x <= maxSum)\n        val isNotPalindromicAndBalanced = sums.forall(x =>\
    \ x != x.reverse && x <= maxSum)\n        val isNotBalancedAndPalindromic = sums.forall(x\
    \ => x != x.reverse && x <= maxSum)\n        val isNotBalancedAndNotPalindromic\
    \ = sums.forall(x => x != x.reverse && x <= maxSum)\n        val isNotBalancedAndNotPalindromicAndBalanced\
    \ = sums.forall(x => x != x.reverse && x <= maxSum)\n        val isNotBalancedAndNotPalindromicAndNotBalanced\
    \ = sums.forall(x => x != x.reverse && x <= maxSum)\n        val isNotBalancedAndNotPalindromicAndNotBalancedAndPalindromic\
    \ = sums.forall(x => x != x.reverse && x <= maxSum)\n        val isNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = sums.forall(x => x != x.reverse && x <= maxSum)\n        val isNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndBalanced\
    \ = sums.forall(x => x != x.reverse && x <= maxSum)\n        val isNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalanced\
    \ = sums.forall(x => x != x.reverse && x <= maxSum)\n        val isNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndPalindromic\
    \ = sums.forall(x => x != x.reverse && x <= maxSum)\n        val isNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNot",
  "        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum == maxWeight\n\
    \        val isFlippable = q.forall(_ < maxWeight)\n        isPalindromic && isBalanced\
    \ && isFlippable", "        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isFlippable = isPalindromic\
    \ && isBalanced\n        isFlippable", "        val maxSum = w.toLong * q.length\n\
    \        val sumOfElements = q.foldLeft(0l) { (sum, elem) => sum + elem }\n  \
    \      sumOfElements <= maxSum", "        val maxSum = w.toLong * q.length\n \
    \       val sums = q.map(x => x.toLong).sum\n        sums <= maxSum && sums ==\
    \ maxSum.toLong", "        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isWightBalanced = isPalindromic && isBalanced\n\
    \        isWightBalanced", "        val maxSum = w.toLong * q.length\n       \
    \ val maxWeight = w.toLong\n        val maxSumOfElements = q.foldLeft(0l) { (sum,\
    \ e) => sum + e }\n        val isBalanced = maxSumOfElements <= maxWeight\n  \
    \      val isPalindromic = q.reverse.forall(e => e == q(0))\n        val isFlippable\
    \ = maxSumOfElements - maxWeight <= 0\n        isBalanced && isPalindromic &&\
    \ isFlippable", "        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessThanMaxWeight = maxSum\
    \ - w < 0\n        val isLessThanMaxSum = maxSum - q.sum < 0\n        isBalanced\
    \ && isPalindromic && isLessThanMaxWeight && isLessThanMaxSum", "        val maxWeight\
    \ = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum + e }\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(e\
    \ => e == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n        (isBalanced\
    \ && isPalindromic && isLessOrEqual)", "        val maxWeight = w\n        val\
    \ maxSum = q.reduceLeft(_ + _)\n        val isBalanced = maxSum == maxWeight\n\
    \        val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isLessThanMax\
    \ = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced = isLessThanMax\
    \ && !isBalanced\n        val isLessThanMaxButBalanced = isLessThanMax && isBalanced\n\
    \        val isLessThanMaxButNotPalindromic = isLessThanMax && !isPalindromic\n\
    \        val isLessThanMaxButPalindromic = isLessThanMax && isPalindromic\n  \
    \      (isLessThanMaxButNotBalanced || isLessThanMaxButBalanced || isLessThanMaxButNotPalindromic\
    \ || isLessThanMaxButPalindromic)", "        val maxWeight = w\n        val maxSum\
    \ = q.foldLeft(0l) { (sum, elem) => sum + elem }\n        val isBalanced = maxSum\
    \ == maxWeight\n        val isPalindromic = q.reverse.forall(elem => elem == q(0))\n\
    \        val isLessThanMaxWeight = maxSum < maxWeight\n        isBalanced && isPalindromic\
    \ && isLessThanMaxWeight", "        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.foldRight(true)((acc, x) => acc && x == q(0))\n        (isPalindromic\
    \ && isBalanced) && (maxSum < maxWeight)", "        val maxWeight = w.toLong\n\
    \        val palindromic = q.reverse.forall(x => x.toLong == x)\n        val sumOfElements\
    \ = q.sum\n        val isBalanced = sumOfElements <= maxWeight\n        val isFlippable\
    \ = palindromic && isBalanced\n        isFlippable", "        val maxWeight =\
    \ w\n        val palindromic = q.reverse.forall(x => x == x.toLong)\n        val\
    \ sum = q.sum\n        val isBalanced = sum <= maxWeight\n        val isFly =\
    \ palindromic && isBalanced\n        val isNotFly = !palindromic || !isBalanced\n\
    \        isFly", "        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        val isFlippableAndLessThanMaxWeight = isFlippable && maxSum < maxWeight\n\
    \        isFlippableAndLessThanMaxWeight", "        val maxWeight = w\n      \
    \  val maxSum = q.foldLeft(0l) { (sum, elem) => sum + elem }\n        val isPalindromic\
    \ = q.reverse.forall(elem => elem == q.head)\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ val isFlippable = q.reverse.forall(elem => elem == q.head)\n        val isFlippable\
    \ = q.reverse.forall(elem => elem == q.head)\n        val isFlippable = q.reverse.forall(elem\
    \ => elem == q.head)\n        val isFlippable = q.reverse.forall(elem => elem\
    \ == q.head)\n        val isFlippable = q.reverse.forall(elem => elem == q.head)\n\
    \        val isFlippable = q.reverse.forall(elem => elem == q.head)\n        val\
    \ isFlippable = q.reverse.forall(elem => elem == q.head)\n        val isFlippable\
    \ = q.reverse.forall(elem => elem == q.head)\n        val isFlippable = q.reverse.forall(elem\
    \ => elem == q.head)\n        val isFlippable = q.reverse.forall(elem => elem\
    \ == q.head)\n        val isFlippable = q.reverse.forall(elem => elem == q.head)\n\
    \        val isFlippable = q.reverse.forall(elem => elem == q.head)\n        val\
    \ isFlippable = q.reverse.forall(elem => elem == q.head)\n        val isFlippable\
    \ = q.reverse.forall(elem => elem == q.head)\n        val isFlippable = q.reverse.forall(elem\
    \ => elem == q.head)\n        val isFlippable = q.reverse.forall(elem => elem\
    \ == q.head)\n        val isFlippable = q.reverse.forall(elem => elem == q.head)\n\
    \        val isFlippable = q.reverse.forall(elem => elem == q.head)\n        val\
    \ isFlippable = q.reverse.forall(elem => elem == q.head)\n        val isFlippable\
    \ = q.reverse.forall(elem => elem == q.head)\n        val isFlippable = q.reverse.forall(elem\
    \ => elem == q.head)\n        val isFlippable = q.reverse.forall(elem => elem\
    \ == q.head)\n        val isFlippable = q.reverse.forall(elem => elem == ", " \
    \       val maxWeight = w.toLong\n        val sumOfElements = q.sum\n        val\
    \ isBalanced = sumOfElements <= maxWeight\n        val isPalindromic = q.reverse.forall(_\
    \ == q.head)\n        val isLessOrEqualToMaxWeight = sumOfElements <= maxWeight\n\
    \        isBalanced && isPalindromic && isLessOrEqualToMaxWeight", "        val\
    \ maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum == maxWeight\n\
    \        isPalindromic && isBalanced", "        val maxWeight = w\n        val\
    \ sumOfElements = q.foldLeft(0l) { (sum, element) => sum + element }\n       \
    \ sumOfElements <= maxWeight", "        val maxWeight = w\n        val maxSum\
    \ = q.sum\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n    \
    \    val isBalanced = q.forall(x => x == q(0) + q(1))\n        val isLessThanMax\
    \ = maxSum - maxWeight < 0\n        val isLessThanMaxAndBalanced = maxSum - maxWeight\
    \ < 0 && isBalanced\n        val isLessThanMaxAndPalindromic = maxSum - maxWeight\
    \ < 0 && isPalindromic\n        val isLessThanMaxAndBalancedAndPalindromic = maxSum\
    \ - maxWeight < 0 && isBalanced && isPalindromic\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZero\
    \ = maxSum - maxWeight < 0 && isBalanced && isPalindromic && q(0) > 0\n      \
    \  val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZero = maxSum - maxWeight\
    \ < 0 && isBalanced && isPalindromic && q(0) > 0 && q(0) > 0\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZero\
    \ = maxSum - maxWeight < 0 && isBalanced && isPalindromic && q(0) > 0 && q(0)\
    \ > 0 && q(0) > 0\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZeroAndNotZero\
    \ = maxSum - maxWeight < 0 && isBalanced && isPalindromic && q(0) > 0 && q(0)\
    \ > 0 && q(0) > 0 && q(0) > 0\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZero\
    \ = maxSum - maxWeight < 0 && isBalanced && isPalindromic && q(0) > 0 && q(0)\
    \ > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZero\
    \ = maxSum - maxWeight < 0 && isBalanced && isPalindromic && q(0) > 0 && q(0)\
    \ > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0\n\
    \        val isLessThanMaxAndBalanced", "        val maxWeight = w\n        val\
    \ maxSum = q.foldLeft(0l) { (sum, elem) => sum + elem }\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x => x ==\
    \ q(0))\n        isBalanced && isPalindromic", "        val maxWeight = w\n  \
    \      val maxSum = q.foldLeft(0l) { (sum, elem) => sum + elem }\n        val\
    \ isPalindromic = q.reverse.forall(elem => elem == q.head)\n        val isBalanced\
    \ = maxSum - maxWeight < 0\n        val isFlippable = isPalindromic && isBalanced\n\
    \        isFlippable", "        val maxWeight = w.toLong\n        val sumOfElements\
    \ = q.reduceLeft(_ + _)\n        sumOfElements <= maxWeight && q.isBalanced",
  "        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val\
    \ isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        val isFlippableAndLessThanMaxWeight = isFlippable && maxWeight < q.reduceLeft(_\
    \ + _)\n        isFlippableAndLessThanMaxWeight", "        val maxWeight = w\n\
    \        val maxSum = q.sum\n        val palindromic = q.reverse.forall(x => x\
    \ == x.reverse)\n        val balanced = palindromic && maxSum < maxWeight\n  \
    \      val unbalanced = !palindromic && maxSum > maxWeight\n        balanced &&\
    \ unbalanced", "        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isWon = isPalindromic && isBalanced\n\
    \        val isWonOrNot = isWon || maxSum > maxWeight\n        isWonOrNot", " \
    \       val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum\
    \ + e }\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isFlippable = isPalindromic &&\
    \ isBalanced\n        val isFlippableWithWeight = isFlippable && maxWeight <=\
    \ maxSum\n        val isFlippableWithWeightAndMaxSum = isFlippableWithWeight &&\
    \ maxSum == maxWeight\n        val isFlippableWithWeightAndMaxSumAndMaxWeight\
    \ = isFlippableWithWeightAndMaxSum && maxWeight <= maxSum\n        val isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSum\
    \ = isFlippableWithWeightAndMaxSumAndMaxWeight && maxSum == maxWeight\n      \
    \  val isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeight = isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSum\
    \ && maxWeight <= maxSum\n        val isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSum\
    \ = isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeight && maxSum\
    \ == maxWeight\n        val isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeight\
    \ = isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeight\
    \ && maxWeight <= maxSum\n        val isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSum\
    \ = isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSum\
    \ && maxWeight <= maxSum\n        val isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeight\
    \ = isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSum\n\
    \        val isFlippableWithWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSumAndMaxWeightAndMaxSum",
  "        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0)(_ + _)\n \
    \       val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = q.forall(x => x == q(0)) && q.forall(x => x == q(q.length - 1))\n        val\
    \ isLessThanMaxWeight = maxSum - maxWeight <= 0\n        val isLessThanMaxSum\
    \ = maxSum - maxWeight < 0\n        val isLessThanMaxSumAndBalanced = maxSum -\
    \ maxWeight < 0 && maxSum - maxWeight <= maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = maxSum - maxWeight < 0 && maxSum - maxWeight <= maxWeight && isPalindromic\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndNotAllZero = maxSum -\
    \ maxWeight < 0 && maxSum - maxWeight <= maxWeight && isPalindromic && q.forall(x\
    \ => x == 0)\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotAllZeroAndNotAllZero\
    \ = maxSum - maxWeight < 0 && maxSum - maxWeight <= maxWeight && isPalindromic\
    \ && q.forall(x => x == 0) && (q.forall(x => x == 0))\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotAllZeroAndNotAllZeroAndNotAllZero\
    \ = maxSum - maxWeight < 0 && maxSum - maxWeight <= maxWeight && isPalindromic\
    \ && q.forall(x => x == 0) && (q.forall(x => x == 0) && (q.forall(x => x == 0)))\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndNotAllZeroAndNotAllZeroAndNotAllZeroAndNotAllZero\
    \ = maxSum - maxWeight < 0 && maxSum - maxWeight <= maxWeight && isPalindromic\
    \ && q.forall(x => x == 0) && (q.forall(x => x == 0) && (q.forall(x => x == 0)\
    \ && (q.forall(x => x == 0)))\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotAllZeroAndNotAllZeroAndNotAllZeroAndNotAllZeroAndNotAllZero\
    \ = maxSum - maxWeight < 0 && maxSum - maxWeight <= maxWeight && isPalindromic\
    \ && q.forall(x => x == 0) && (q.for", "        val maxWeight = w.toLong\n   \
    \     val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isBalanced = isPalindromic && maxSum < maxWeight\n   \
    \     isBalanced", "        val maxSum = w.toLong * w.toLong\n        val sumOfElements\
    \ = q.foldLeft(0l) { (sum, element) => sum + element }\n        sumOfElements\
    \ <= maxSum", "        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isFlippable = isPalindromic &&\
    \ isBalanced\n        val isFlipped = q.tail.forall(_ == q.head)\n        isFlippable\
    \ && isFlipped", "        val maxWeight = w\n        val sumOfElements = q.foldLeft(0l)\
    \ { (sum, e) => sum + e }\n        sumOfElements <= maxWeight", "        val maxWeight\
    \ = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.isEmpty\
    \ || q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum < maxWeight\n\
    \        val isFlipped = q.reverse.forall(x => x == q(0))\n        isPalindromic\
    \ && isBalanced && isFlipped", "        val maxWeight = w\n        val maxSum\
    \ = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n\
    \        val isBalanced = maxSum < maxWeight\n        val isFlippable = isPalindromic\
    \ && isBalanced\n        isFlippable", "        val maxWeight = w.toLong\n   \
    \     val sumOfWeights = q.foldLeft(0L){ (sum, elem) => sum + elem }\n       \
    \ sumOfWeights <= maxWeight", "        val maxSum = w.toLong * q.length\n    \
    \    val sums = q.map(x => x.toLong)\n        val isPalindromic = sums.reverse.forall(_\
    \ == sums.head)\n        val isBalanced = sums.forall(_ <= maxSum)\n        isPalindromic\
    \ && isBalanced", "        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        val isFlippable = if (isFlippable) true else false\n        isFlippable",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l){ (sum, e) => sum\
    \ + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        isBalanced && isPalindromic", " \
    \       val maxSum = w.toLong * w.toLong\n        val maxWeight = w.toLong\n \
    \       val maxList = q.maxBy(_.toLong)\n        val maxListSum = maxList.toLong\n\
    \        val maxListWeight = maxList.toLong\n        val isPalindromic = maxListSum\
    \ == maxSum\n        val isBalanced = maxListWeight <= maxWeight\n        val\
    \ isFlipping = isPalindromic && isBalanced\n        isFlipping", "        val\
    \ maxWeight = w.toLong\n        val palindrome = q.reverse.forall(x => x == x.toLong)\n\
    \        val sumOfElements = q.foldLeft(0l) { (acc, x) => acc + x }\n        val\
    \ isBalanced = sumOfElements <= maxWeight\n        val isFlippable = palindrome\
    \ && isBalanced\n        isFlippable", "        val maxWeight = w.toLong\n   \
    \     val maxSum = q.foldLeft(0l) { (sum, e) => sum + e }\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isPalindromic = q.reverse.forall(e => e ==\
    \ q(0))\n        val isLessThanMaxWeight = maxSum - maxWeight < 0\n        val\
    \ isLessThanMaxSum = maxSum - q.sum < 0\n        isBalanced && isPalindromic &&\
    \ isLessThanMaxWeight && isLessThanMaxSum", "        val maxWeight = w\n     \
    \   val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == _)\n        val isBalanced = maxSum < maxWeight\n        val isFlippable\
    \ = q.forall(_ < maxWeight)\n        val isFlippableAndBalanced = isFlippable\
    \ && isBalanced\n        val isFlippableAndBalancedAndPalindromic = isFlippableAndBalanced\
    \ && isPalindromic\n        isFlippableAndBalancedAndPalindromic", "        val\
    \ maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum + e }\n\
    \        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isLessThanMaxWeight = maxSum < maxWeight\n\
    \        val isLessThanMaxSum = maxSum < maxWeight\n        val isLessThanMaxSumAndBalanced\
    \ = isLessThanMaxWeight && isBalanced\n        val isLessThanMaxWeightAndBalanced\
    \ = isLessThanMaxSum && isBalanced\n        val isLessThanMaxSumAndPalindromic\
    \ = isLessThanMaxWeight && isPalindromic\n        val isLessThanMaxWeightAndPalindromic\
    \ = isLessThanMaxSum && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = isLessThanMaxWeightAndBalanced && isPalindromic\n        val isLessThanMaxWeightAndBalancedAndPalindromic\
    \ = isLessThanMaxSumAndBalanced && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotZero\
    \ = isLessThanMaxWeightAndBalancedAndPalindromic && maxWeight > 0\n        val\
    \ isLessThanMaxWeightAndBalancedAndPalindromicAndNotZero = isLessThanMaxSumAndBalancedAndPalindromic\
    \ && maxWeight > 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotZero\
    \ = isLessThanMaxWeightAndBalancedAndPalindromic && maxWeight > 0\n        val\
    \ isLessThanMaxSumAndBalancedAndPalindromicAndNotZero = isLessThanMaxSumAndBalancedAndPalindromic\
    \ && maxWeight > 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotZero\
    \ = isLessThanMaxSumAndBalancedAndPalindromic && maxWeight > 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotZero\
    \ = isLessThanMaxSumAndBalancedAndPalindromic && maxWeight > 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotZero\
    \ = isLessThanMaxSumAndBalancedAndPalindromic && maxWeight > 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNot",
  "        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n  \
    \      val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n   \
    \     val isBalanced = maxSum < maxWeight\n        val isFlipped = q.forall(x\
    \ => x == q.last)\n        isPalindromic && isBalanced && isFlipped", "      \
    \  val maxWeight = w\n        val sumOfElements = q.sum\n        val isPalindromic\
    \ = q.isPalindromic\n        val isBalanced = isPalindromic && sumOfElements <=\
    \ maxWeight\n        val isFlipped = !isPalindromic && sumOfElements > maxWeight\n\
    \        isBalanced && isFlipped", "        val maxWeight = w.toLong\n       \
    \ val sumOfElements = q.foldLeft(0l) { (sum, element) => sum + element }\n   \
    \     sumOfElements <= maxWeight", "        val maxWeight = w\n        val palindromic\
    \ = q.reverse.forall(x => x == x.toLong)\n        val sumOfElements = q.sum\n\
    \        val isBalanced = sumOfElements <= maxWeight\n        val isFlippable\
    \ = palindromic && isBalanced\n        isFlippable", "        val maxWeight =\
    \ w\n        val maxSum = q.foldLeft(0l)(_ + _)\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isBalanced = q.forall(x => x <= maxWeight && x >=\
    \ maxSum - maxWeight)\n        val isFlippable = isPalindromic && isBalanced\n\
    \        isFlippable", "        val maxWeight = w\n        val maxSum = q.foldLeft(0l){\
    \ (sum, e) => sum + e }\n        val isPalindromic = q.reverse.forall(_ == q.head)\n\
    \        val isBalanced = maxSum - maxWeight <= 0\n        val isFlippable = isPalindromic\
    \ && isBalanced\n        isFlippable", "        val maxWeight = w\n        val\
    \ maxSum = q.sum\n        val isPalindromic = q.reverse.forall(_ == q.head)\n\
    \        val isBalanced = maxSum - q.sum < 0\n        val isWeightLessThanMax\
    \ = maxWeight - q.sum < 0\n        val isWeightLessThanMaxAndBalanced = maxWeight\
    \ - q.sum < 0 && maxSum - q.sum < 0\n        val isWeightLessThanMaxAndBalancedAndPalindromic\
    \ = maxWeight - q.sum < 0 && maxSum - q.sum < 0 && isPalindromic\n        val\
    \ isWeightLessThanMaxAndBalancedAndPalindromicAndNotPalindromic = maxWeight -\
    \ q.sum < 0 && maxSum - q.sum < 0 && isPalindromic && !isPalindromic\n       \
    \ val isWeightLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = maxWeight - q.sum < 0 && maxSum - q.sum < 0 && isPalindromic && !isPalindromic\
    \ && !isBalanced\n        val isWeightLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxWeight - q.sum < 0 && maxSum - q.sum < 0 && isPalindromic && !isPalindromic\
    \ && !isBalanced && !isPalindromic\n        val isWeightLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalanced\
    \ = maxWeight - q.sum < 0 && maxSum - q.sum < 0 && isPalindromic && !isPalindromic\
    \ && !isBalanced && !isPalindromic && !isBalanced\n        val isWeightLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxWeight - q.sum < 0 && maxSum - q.sum < 0 && isPalindromic && !isPalindromic\
    \ && !isBalanced && !isPalindromic && !isBalanced && !isPalindromic\n        val\
    \ isWeightLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalance",
  "        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isWightBalanced = isPalindromic && isBalanced\n   \
    \     isWightBalanced", "        val maxSum = w.toLong * q.length\n        val\
    \ sums = q.foldLeft(List[Long]())((acc, x) => acc :+ x.toLong)\n        sums.last\
    \ <= maxSum", "        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n\
    \        val isBalanced = maxSum == maxWeight\n        val isFlipped = q.forall(x\
    \ => x < maxWeight)\n        isPalindromic && isBalanced && isFlipped", "    \
    \    val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum\
    \ + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        isBalanced && isPalindromic", " \
    \       val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ isFlippable", "        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum == maxWeight\n        isPalindromic && isBalanced",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum\
    \ + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n\
    \        isBalanced && isPalindromic && isLessOrEqual", "        val maxWeight\
    \ = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val isPalindromic =\
    \ q.reverse.forall(x => x == q(0))\n        val isBalanced = q.foldLeft(0)(_ +\
    \ _) <= maxWeight\n        val isLessThanMax = maxSum < maxWeight\n        val\
    \ isLessThanMaxAndBalanced = isLessThanMax && isBalanced\n        isPalindromic\
    \ && isLessThanMaxAndBalanced", "        val maxWeight = w\n        val maxSum\
    \ = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n\
    \        val isBalanced = maxSum < maxWeight\n        val isFlippable = q.forall(x\
    \ => x == q.last)\n        isPalindromic && isBalanced && isFlippable", "    \
    \    val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum\
    \ == maxWeight\n        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxAndBalanced\
    \ = isLessThanMax && isBalanced\n        val isLessThanMaxAndPalindromic = isLessThanMax\
    \ && isPalindromic\n        val isLessThanMaxAndNotBalanced = isLessThanMax &&\
    \ !isBalanced\n        val isLessThanMaxAndNotPalindromic = isLessThanMax && !isPalindromic\n\
    \        val isLessThanMaxAndNotBalancedAndPalindromic = isLessThanMax && !isBalanced\
    \ && !isPalindromic\n        val isLessThanMaxAndNotBalancedAndNotPalindromic\
    \ = isLessThanMax && !isBalanced && !isPalindromic && !isLessThanMaxAndNotBalanced\n\
    \        val isLessThanMaxAndNotBalancedAndNotPalindromicAndNotLessThanMax = isLessThanMax\
    \ && !isBalanced && !isPalindromic && !isLessThanMaxAndNotBalanced && !isLessThanMaxAndNotPalindromic\n\
    \        val isLessThanMaxAndNotBalancedAndNotPalindromicAndNotLessThanMaxAndNotBalanced\
    \ = isLessThanMax && !isBalanced && !isPalindromic && !isLessThanMaxAndNotBalanced\
    \ && !isLessThanMaxAndNotPalindromic && !isLessThanMaxAndNotBalancedAndPalindromic\n\
    \        val isLessThanMaxAndNotBalancedAndNotPalindromicAndNotLessThanMaxAndNotBalancedAndPalindromic\
    \ = isLessThanMax && !isBalanced && !isPalindromic && !isLessThanMaxAndNotBalanced\
    \ && !isLessThanMaxAndNotPalindromic && !isLessThanMaxAndNotBalancedAndPalindromic\
    \ && !isLessThanMaxAndNotBalancedAndNotPalindromicAndNotLessThanMax\n        val\
    \ isLessThanMaxAndNotBalancedAndNotPalindromicAndNotLessThanMaxAndNotBalancedAndPalindromicAndNotLessThanMax\
    \ = isLessThanMax && !isBalanced && !isPalindromic && !isLessThanMaxAndNotBalance",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum\
    \ + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessThanMaxWeight = maxSum\
    \ - maxWeight < 0\n        val isLessThanMaxSum = maxSum - sum < 0\n        isBalanced\
    \ && isPalindromic && isLessThanMaxWeight && isLessThanMaxSum", "        val maxWeight\
    \ = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isBalanced = maxSum < maxWeight\n        val isFlippable\
    \ = isPalindromic && isBalanced\n        isFlippable", "        val maxSum = w.toLong\
    \ * q.length\n        val sumOfElements = q.foldLeft(0l) { (sum, element) => sum\
    \ + element }\n        sumOfElements <= maxSum"]
stop_tokens:
- "\n    }\n"
