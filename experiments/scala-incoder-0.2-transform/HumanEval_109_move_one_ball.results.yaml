language: scala
name: HumanEval_109_move_one_ball
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val max = (len - 1).toLong\n        val min = 0l\n        val result\
    \ = new mutable.ListBuffer[Long]()\n        val arr = arr.toList\n        val\
    \ len = arr.length\n        val max = (len - 1).toLong\n        val min = 0l\n\
    \        val result = new mutable.ListBuffer[Long]()\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val max = (len - 1).toLong\n        val\
    \ min = 0l\n        val result = new mutable.ListBuffer[Long]()\n        val arr\
    \ = arr.toList\n        val len = arr.length\n        val max = (len - 1).toLong\n\
    \        val min = 0l\n        val result = new mutable.ListBuffer[Long]()\n \
    \       val arr = arr.toList\n        val len = arr.length\n        val max =\
    \ (len - 1).toLong\n        val min = 0l\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val max =\
    \ (len - 1).toLong\n        val min = 0l\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val max =\
    \ (len - 1).toLong\n        val min = 0l\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val max =\
    \ (len - 1).toLong\n        val min = 0l\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val max =\
    \ (len - 1).toLong\n        val min = 0l\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val max =\
    \ (len - 1).toLong\n        val min = 0l\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val max =\
    \ (len - 1).toLong\n        val min = 0l\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val max =\
    \ (len - 1).toLong\n        val min = 0l\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val max =\
    \ (len - 1).to\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd55wc_oa.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd55wc_oa.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd55wc_oa.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = (len - \e[31m1\e\
    [0m).toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmax is already defined as \e[33mvalue\e[0m \e[35mmax\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpd55wc_oa.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = \e[31m0l\e[0m\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmin is already defined as \e\
    [33mvalue\e[0m \e[35mmin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpd55wc_oa.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel d"
  stdout: ''
  timestamp: 1659798343
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val m = arr.head\n      \
    \  val arr = arr.tail\n        val arr = arr.toList\n        val arr1 = arr.toArray\n\
    \        val arr2 = arr.toBuffer\n        val arr3 = arr.toSeq\n        val arr4\
    \ = arr.toSet\n        val arr5 = arr.toMap\n        val arr6 = arr.toIterator\n\
    \        val arr7 = arr.toStream\n        val arr8 = arr.toIterable\n        val\
    \ arr9 = arr.toArray\n        val arr10 = arr.toList\n        val arr11 = arr.toArray\n\
    \        val arr12 = arr.toBuffer\n        val arr13 = arr.toSeq\n        val\
    \ arr14 = arr.toSet\n        val arr15 = arr.toMap\n        val arr16 = arr.toIterator\n\
    \        val arr17 = arr.toStream\n        val arr18 = arr.toIterable\n      \
    \  val arr19 = arr.toArray\n        val arr20 = arr.toList\n        val arr21\
    \ = arr.toArray\n        val arr22 = arr.toBuffer\n        val arr23 = arr.toSeq\n\
    \        val arr24 = arr.toSet\n        val arr25 = arr.toMap\n        val arr26\
    \ = arr.toIterator\n        val arr27 = arr.toStream\n        val arr28 = arr.toIterable\n\
    \        val arr29 = arr.toArray\n        val arr30 = arr.toList\n        val\
    \ arr31 = arr.toArray\n        val arr32 = arr.toBuffer\n        val arr33 = arr.toSeq\n\
    \        val arr34 = arr.toSet\n        val arr35 = arr.toMap\n        val arr36\
    \ = arr.toIterator\n        val arr37 = arr.toStream\n        val arr38 = arr.toIterable\n\
    \        val arr39 = arr.toArray\n        val arr40 = arr.toList\n        val\
    \ arr41 = arr.toArray\n        val arr42 = arr.toBuffer\n        val arr43 = arr.toSeq\n\
    \        val arr44 = arr.toSet\n        val arr45 = arr.toMap\n        val arr46\
    \ = arr.toIterator\n        val arr47 = arr.toStream\n        val arr48 = arr.toIterable\n\
    \        val arr49 = arr.toArray\n        val arr50 = arr.toList\n        val\
    \ arr51 = arr.toArray\n        val arr52 = arr.toBuffer\n        val arr53 = arr.toSeq\n\
    \        val arr54 = arr.toSet\n        val arr55 = arr.toMap\n        val arr5\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0vp1d5hd.scala:86:4 ----------------------------\e\
    [0m\e[0m\n\e[31m86 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0vp1d5hd.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp0vp1d5hd.scala:28:18 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m\
    \                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp0vp1d5hd.scala:86:5 ---------------------\e[0m\e[0m\n\e[31m86\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659798344
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) true\n      \
    \  else {\n            val sortedArr = arr.sortBy(_)\n            val sortedArr_1\
    \ = sortedArr.tail\n            val sortedArr_2 = sortedArr.head\n           \
    \ val sortedArr_3 = sortedArr.drop(1)\n            val sortedArr_4 = sortedArr.drop(2)\n\
    \            val sortedArr_5 = sortedArr.drop(3)\n            val sortedArr_6\
    \ = sortedArr.drop(4)\n            val sortedArr_7 = sortedArr.drop(5)\n     \
    \       val sortedArr_8 = sortedArr.drop(6)\n            val sortedArr_9 = sortedArr.drop(7)\n\
    \            val sortedArr_10 = sortedArr.drop(8)\n            val sortedArr_11\
    \ = sortedArr.drop(9)\n            val sortedArr_12 = sortedArr.drop(10)\n   \
    \         val sortedArr_13 = sortedArr.drop(11)\n            val sortedArr_14\
    \ = sortedArr.drop(12)\n            val sortedArr_15 = sortedArr.drop(13)\n  \
    \          val sortedArr_16 = sortedArr.drop(14)\n            val sortedArr_17\
    \ = sortedArr.drop(15)\n            val sortedArr_18 = sortedArr.drop(16)\n  \
    \          val sortedArr_19 = sortedArr.drop(17)\n            val sortedArr_20\
    \ = sortedArr.drop(18)\n            val sortedArr_21 = sortedArr.drop(19)\n  \
    \          val sortedArr_22 = sortedArr.drop(20)\n            val sortedArr_23\
    \ = sortedArr.drop(21)\n            val sortedArr_24 = sortedArr.drop(22)\n  \
    \          val sortedArr_25 = sortedArr.drop(23)\n            val sortedArr_26\
    \ = sortedArr.drop(24)\n            val sortedArr_27 = sortedArr.drop(25)\n  \
    \          val sortedArr_28 = sortedArr.drop(26)\n            val sortedArr_29\
    \ = sortedArr.drop(27)\n            val sortedArr_30 = sortedArr.drop(28)\n  \
    \          val sortedArr_31 = sortedArr.drop(29)\n            val sortedArr_32\
    \ = sortedArr.drop(30)\n            val sortedArr_33 = sortedArr.drop(31)\n  \
    \          val sortedArr_34 = sortedArr.drop(32)\n            val sortedArr_35\
    \ = sortedArr.drop(33)\n            val sortedArr_36 = sortedArr.drop(\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpp_2rt3_6.scala:65:46 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m            \e[33mval\e[0m \e[36msortedArr_36\e[0m =\
    \ sortedArr.drop(\n\e[31m\e[31m   |\e[0m                                     \
    \         ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpp_2rt3_6.scala:76:0 ----------------------------\e[0m\e[0m\n\e[31m76\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- Error: /tmp/tmpp_2rt3_6.scala:29:41 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36msortedArr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m \
    \  |\e[0mNo implicit Ordering defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\e\
    [31m   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[Any]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[Any].\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpp_2rt3_6.scala:75:1 ---------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpp_2rt3_6.scala:67:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m67 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659798344
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n        else\
    \ {\n            val maxIndex = n - 1\n            val maxValue = arr(maxIndex)\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = max\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe3mwgtob.scala:95:0 ----------------------------\e\
    [0m\e[0m\n\e[31m95 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe3mwgtob.scala:32:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mmaxValueIndex\e[0m = maxIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValueIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxValueIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe3mwgtob.scala:33:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e\
    [0m \e[36mmaxValueIndex\e[0m = maxIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValueIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxValueIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe3mwgtob.scala:34:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e\
    [0m \e[36mmaxValueIndex\e[0m = maxIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValueIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxValueIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe3mwgtob.scala:35:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e\
    [0m \e[36mmaxValueIndex\e[0m = maxIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValueIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxValueIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe3mw"
  stdout: ''
  timestamp: 1659798344
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val arr1 = arr.toArray\n        val arr2 = arr.toBuffer\n        val arr3\
    \ = arr.toSeq\n        val arr4 = arr.toSet\n        val arr5 = arr.toMap\n  \
    \      val arr6 = arr.toIterator\n        val arr7 = arr.toStream\n        val\
    \ arr8 = arr.toSeq\n        val arr9 = arr.toSet\n        val arr10 = arr.toMap\n\
    \        val arr11 = arr.toIterator\n        val arr12 = arr.toStream\n      \
    \  val arr13 = arr.toSeq\n        val arr14 = arr.toSet\n        val arr15 = arr.toMap\n\
    \        val arr16 = arr.toIterator\n        val arr17 = arr.toStream\n      \
    \  val arr18 = arr.toSeq\n        val arr19 = arr.toSet\n        val arr20 = arr.toMap\n\
    \        val arr21 = arr.toIterator\n        val arr22 = arr.toStream\n      \
    \  val arr23 = arr.toSeq\n        val arr24 = arr.toSet\n        val arr25 = arr.toMap\n\
    \        val arr26 = arr.toIterator\n        val arr27 = arr.toStream\n      \
    \  val arr28 = arr.toSeq\n        val arr29 = arr.toSet\n        val arr30 = arr.toMap\n\
    \        val arr31 = arr.toIterator\n        val arr32 = arr.toStream\n      \
    \  val arr33 = arr.toSeq\n        val arr34 = arr.toSet\n        val arr35 = arr.toMap\n\
    \        val arr36 = arr.toIterator\n        val arr37 = arr.toStream\n      \
    \  val arr38 = arr.toSeq\n        val arr39 = arr.toSet\n        val arr40 = arr.toMap\n\
    \        val arr41 = arr.toIterator\n        val arr42 = arr.toStream\n      \
    \  val arr43 = arr.toSeq\n        val arr44 = arr.toSet\n        val arr45 = arr.toMap\n\
    \        val arr46 = arr.toIterator\n        val arr47 = arr.toStream\n      \
    \  val arr48 = arr.toSeq\n        val arr49 = arr.toSet\n        val arr50 = arr.toMap\n\
    \        val arr51 = arr.toIterator\n        val arr52 = arr.toStream\n      \
    \  val arr53 = arr.toSeq\n        val arr54 = arr.toSet\n        val arr55 = arr.toMap\n\
    \        val arr56 = arr.toIterator\n        val arr57 = arr.to\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpf_tbuuys.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpf_tbuuys.scala:85:5 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798343
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val n = arr.size\n    \
    \    val arr1 = arr.toArray\n        val arr2 = arr1.clone()\n        val arr3\
    \ = arr2.clone()\n        val arr4 = arr3.clone()\n        val arr5 = arr4.clone()\n\
    \        val arr6 = arr5.clone()\n        val arr7 = arr6.clone()\n        val\
    \ arr8 = arr7.clone()\n        val arr9 = arr8.clone()\n        val arr10 = arr9.clone()\n\
    \        val arr11 = arr10.clone()\n        val arr12 = arr11.clone()\n      \
    \  val arr13 = arr12.clone()\n        val arr14 = arr13.clone()\n        val arr15\
    \ = arr14.clone()\n        val arr16 = arr15.clone()\n        val arr17 = arr16.clone()\n\
    \        val arr18 = arr17.clone()\n        val arr19 = arr18.clone()\n      \
    \  val arr20 = arr19.clone()\n        val arr21 = arr20.clone()\n        val arr22\
    \ = arr21.clone()\n        val arr23 = arr22.clone()\n        val arr24 = arr23.clone()\n\
    \        val arr25 = arr24.clone()\n        val arr26 = arr25.clone()\n      \
    \  val arr27 = arr26.clone()\n        val arr28 = arr27.clone()\n        val arr29\
    \ = arr28.clone()\n        val arr30 = arr29.clone()\n        val arr31 = arr30.clone()\n\
    \        val arr32 = arr31.clone()\n        val arr33 = arr32.clone()\n      \
    \  val arr34 = arr33.clone()\n        val arr35 = arr34.clone()\n        val arr36\
    \ = arr35.clone()\n        val arr37 = arr36.clone()\n        val arr38 = arr37.clone()\n\
    \        val arr39 = arr38.clone()\n        val arr40 = arr39.clone()\n      \
    \  val arr41 = arr40.clone()\n        val arr42 = arr41.clone()\n        val arr43\
    \ = arr42.clone()\n        val arr44 = arr43.clone()\n        val arr45 = arr44.clone()\n\
    \        val arr46 = arr45.clone()\n        val arr47 = arr46.clone()\n      \
    \  val arr48 = arr47.clone()\n        val arr49 = arr48.clone()\n        val arr50\
    \ = arr49.clone()\n        val arr51 = arr50.clone()\n        val arr52 = arr51.clone()\n\
    \        val arr53 = arr52.clone()\n        val arr54 = arr53.clone()\n      \
    \  val arr55 = arr54.clone()\n        val arr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5x6pc4m0.scala:84:4 ----------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5x6pc4m0.scala:26:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5x6pc4m0.scala:84:5\
    \ ---------------------\e[0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798344
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val sortedArr = arr.sortWith(_ < _)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.take(n)\n\
    \        val sortedArr = sortedArr.toArray\n        val sortedArr = sortedArr.sortWith(_\
    \ < _)\n        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.take(n)\n        val sortedArr = sortedArr.toArray\n\
    \        val sortedArr = sortedArr.sortWith(_ < _)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.take(n)\n\
    \        val sortedArr = sortedArr.toArray\n        val sortedArr = sortedArr.sortWith(_\
    \ < _)\n        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.take(n)\n        val sortedArr = sortedArr.toArray\n\
    \        val sortedArr = sortedArr.sortWith(_ < _)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.take(n)\n\
    \        val sortedArr = sortedArr.toArray\n        val sortedArr = sortedArr.sortWith(_\
    \ < _)\n        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.take(n)\n        val sortedArr = sortedArr.toArray\n\
    \        val sortedArr = sortedArr.sortWith(_ < _)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.take(n)\n\
    \        val sortedArr = sortedArr.toArray\n        val sortedArr = sortedArr.sortWith(_\
    \ < _)\n        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.take(n)\n        val sortedArr = sortedArr.toArray\n\
    \        val sortedArr = sortedArr.sortWith(_ < _)\n        val sortedArr = sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgdm8kgv3.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpgdm8kgv3.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgdm8kgv3.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.take(n)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpgdm8kgv3.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.toArray\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgdm8kgv3.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36msortedArr\e[0m = sortedArr.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already defined as \e["
  stdout: ''
  timestamp: 1659798343
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val len = arr.length\n        val max = (len - 1) * arr.last\n        val\
    \ min = (len - 1) * arr.head\n        val maxIndex = arr.lastIndex\n        val\
    \ minIndex = arr.headIndex\n        val maxVal = arr(maxIndex)\n        val minVal\
    \ = arr(minIndex)\n        val maxValIndex = maxIndex\n        val minValIndex\
    \ = minIndex\n        val maxValIndex = maxIndex\n        val minValIndex = minIndex\n\
    \        val maxValIndex = maxIndex\n        val minValIndex = minIndex\n    \
    \    val maxValIndex = maxIndex\n        val minValIndex = minIndex\n        val\
    \ maxValIndex = maxIndex\n        val minValIndex = minIndex\n        val maxValIndex\
    \ = maxIndex\n        val minValIndex = minIndex\n        val maxValIndex = maxIndex\n\
    \        val minValIndex = minIndex\n        val maxValIndex = maxIndex\n    \
    \    val minValIndex = minIndex\n        val maxValIndex = maxIndex\n        val\
    \ minValIndex = minIndex\n        val maxValIndex = maxIndex\n        val minValIndex\
    \ = minIndex\n        val maxValIndex = maxIndex\n        val minValIndex = minIndex\n\
    \        val maxValIndex = maxIndex\n        val minValIndex = minIndex\n    \
    \    val maxValIndex = maxIndex\n        val minValIndex = minIndex\n        val\
    \ maxValIndex = maxIndex\n        val minValIndex = minIndex\n        val maxValIndex\
    \ = maxIndex\n        val minValIndex = minIndex\n        val maxValIndex = maxIndex\n\
    \        val minValIndex = minIndex\n        val maxValIndex = maxIndex\n    \
    \    val minValIndex = minIndex\n        val maxValIndex = maxIndex\n        val\
    \ minValIndex = minIndex\n        val maxValIndex = maxIndex\n        val minValIndex\
    \ = minIndex\n        val maxValIndex = maxIndex\n        val minValIndex = minIndex\n\
    \        val maxValIndex = maxIndex\n        val minValIndex = minIndex\n    \
    \    val maxValIndex = maxIndex\n        val minValIndex = minIndex\n        val\
    \ maxValIndex = maxIndex\n        val minValIndex = minIndex\n        val maxValIndex\
    \ = maxIndex\n        val minValIndex = minIndex\n        val maxValIndex = maxIndex\n\
    \        val minValIndex = minIndex\n        val maxValIndex = maxIndex\n    \
    \    val minValIndex = minIndex\n        val maxValIndex = maxIndex\n        val\
    \ minValIndex = minIndex\n        val maxValIndex = maxIndex\n        \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9cqw351v.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mmaxValIndex\e[0m = maxIndex\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxValIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9cqw351v.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mminValIndex\e[0m = minIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminValIndex is already defined as \e[33mvalue\e[0m \e[35mminValIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9cqw351v.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mmaxValIndex\e[0m = maxIndex\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxValIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9cqw351v.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mminValIndex\e[0m = minIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminValIndex is already defined as \e[33mvalue\e[0m \e[35mminValIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9cqw351v.scala:41:12 ---------------------------\e[0m\e[0m\n\e\
    [31m41 |\e[0m        \e[33mval\e[0m \e[36mmaxValIndex\e[0m = maxIndex\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxValIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded met"
  stdout: ''
  timestamp: 1659798344
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val arr2 = arr.toArray\n        val arr3 = arr.toBuffer\n        val arr4\
    \ = arr.toSeq\n        val arr5 = arr.toSet\n        val arr6 = arr.toMap\n  \
    \      val arr7 = arr.toIterator\n        val arr8 = arr.toIterable\n        val\
    \ arr9 = arr.toStream\n        val arr10 = arr.toTraversable\n        val arr11\
    \ = arr.toIndexedSeq\n        val arr12 = arr.toIndexedSeq\n        val arr13\
    \ = arr.toIndexedSeq\n        val arr14 = arr.toIndexedSeq\n        val arr15\
    \ = arr.toIndexedSeq\n        val arr16 = arr.toIndexedSeq\n        val arr17\
    \ = arr.toIndexedSeq\n        val arr18 = arr.toIndexedSeq\n        val arr19\
    \ = arr.toIndexedSeq\n        val arr20 = arr.toIndexedSeq\n        val arr21\
    \ = arr.toIndexedSeq\n        val arr22 = arr.toIndexedSeq\n        val arr23\
    \ = arr.toIndexedSeq\n        val arr24 = arr.toIndexedSeq\n        val arr25\
    \ = arr.toIndexedSeq\n        val arr26 = arr.toIndexedSeq\n        val arr27\
    \ = arr.toIndexedSeq\n        val arr28 = arr.toIndexedSeq\n        val arr29\
    \ = arr.toIndexedSeq\n        val arr30 = arr.toIndexedSeq\n        val arr31\
    \ = arr.toIndexedSeq\n        val arr32 = arr.toIndexedSeq\n        val arr33\
    \ = arr.toIndexedSeq\n        val arr34 = arr.toIndexedSeq\n        val arr35\
    \ = arr.toIndexedSeq\n        val arr36 = arr.toIndexedSeq\n        val arr37\
    \ = arr.toIndexedSeq\n        val arr38 = arr.toIndexedSeq\n        val arr39\
    \ = arr.toIndexedSeq\n        val arr40 = arr.toIndexedSeq\n        val arr41\
    \ = arr.toIndexedSeq\n        val arr42 = arr.toIndexedSeq\n        val arr43\
    \ = arr.toIndexedSeq\n        val arr44 = arr.toIndexedSeq\n        val arr45\
    \ = arr.toIndexedSeq\n        val arr46 = arr.toIndexedSeq\n        val arr47\
    \ = arr.toIndexedSeq\n        val arr48 = arr.toIndexedSeq\n        val arr49\
    \ = arr.toIndexedSeq\n        val arr50 = arr.toIndexedSeq\n        val arr51\
    \ = arr.toIndexedSeq\n        val arr52 = arr.toIndexedSeq\n        val arr53\
    \ = arr.to\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmph5udsgh_.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmph5udsgh_.scala:80:5 ---------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798343
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) true\n      \
    \  else {\n            val arr = arr.sortBy(x => x)\n            val l = arr.head\n\
    \            val r = arr.last\n            val m = arr.length\n            val\
    \ r = r - l + 1\n            val arr = arr.drop(1).take(n - 1)\n            val\
    \ arr = arr ++ arr.take(n - 1)\n            val arr = arr ++ arr.take(n - 1)\n\
    \            val arr = arr ++ arr.take(n - 1)\n            val arr = arr ++ arr.take(n\
    \ - 1)\n            val arr = arr ++ arr.take(n - 1)\n            val arr = arr\
    \ ++ arr.take(n - 1)\n            val arr = arr ++ arr.take(n - 1)\n         \
    \   val arr = arr ++ arr.take(n - 1)\n            val arr = arr ++ arr.take(n\
    \ - 1)\n            val arr = arr ++ arr.take(n - 1)\n            val arr = arr\
    \ ++ arr.take(n - 1)\n            val arr = arr ++ arr.take(n - 1)\n         \
    \   val arr = arr ++ arr.take(n - 1)\n            val arr = arr ++ arr.take(n\
    \ - 1)\n            val arr = arr ++ arr.take(n - 1)\n            val arr = arr\
    \ ++ arr.take(n - 1)\n            val arr = arr ++ arr.take(n - 1)\n         \
    \   val arr = arr ++ arr.take(n - 1)\n            val arr = arr ++ arr.take(n\
    \ - 1)\n            val arr = arr ++ arr.take(n - 1)\n            val arr = arr\
    \ ++ arr.take(n - 1)\n            val arr = arr ++ arr.take(n - 1)\n         \
    \   val arr = arr ++ arr.take(n - 1)\n            val arr = arr ++ arr.take(n\
    \ - 1)\n            val arr = arr ++ arr.take(n - 1)\n            val arr = arr\
    \ ++ arr.take(n - 1)\n            val arr = arr ++ arr.take(n - 1)\n         \
    \   val arr = arr ++ arr.take(n - 1)\n            val arr = arr ++ arr.take(n\
    \ - 1)\n            val arr = arr ++ arr.take(n - 1)\n            val arr = arr\
    \ ++ arr.take(n - 1)\n            val arr = arr ++ arr.take(n - 1)\n         \
    \   val arr = arr ++ arr.take(n - 1)\n            val arr = arr ++ arr.take(n\
    \ - 1)\n            val arr = arr ++ arr.take(n - 1)\n            val arr = arr\
    \ ++ arr.take(n - 1)\n            val arr = arr ++ arr.take(n - 1)\n         \
    \   val arr = arr ++ arr.\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0m0xui05.scala:73:4 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp0m0xui05.scala:83:0 ----------------------------\e[0m\e[0m\n\e[31m83\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0m0xui05.scala:33:16 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = r - l + \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0m0xui05.scala:34:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e\
    [0m \e[36marr\e[0m = arr.drop(\e[31m1\e[0m).take(n - \e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0m0xui05.scala:35:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e\
    [0m \e[36marr\e[0m = arr ++ arr.take(n - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0m0xui05.scala:36:16 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36marr\e[0m = arr ++ arr.take(n\
    \ - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all b"
  stdout: ''
  timestamp: 1659798344
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toArray\n \
    \       val len = arr.length\n        val arr1 = arr.toList\n        val arr2\
    \ = arr1.sortBy(x => x)\n        val arr3 = arr2.reverse\n        val arr4 = arr3.toArray\n\
    \        val arr5 = arr4.toList\n        val arr6 = arr5.sortBy(x => x)\n    \
    \    val arr7 = arr6.reverse\n        val arr8 = arr7.toArray\n        val arr9\
    \ = arr8.toList\n        val arr10 = arr9.toArray\n        val arr11 = arr10.toList\n\
    \        val arr12 = arr11.toArray\n        val arr13 = arr12.toList\n       \
    \ val arr14 = arr13.toArray\n        val arr15 = arr14.toList\n        val arr16\
    \ = arr15.toArray\n        val arr17 = arr16.toList\n        val arr18 = arr17.toArray\n\
    \        val arr19 = arr18.toList\n        val arr20 = arr19.toArray\n       \
    \ val arr21 = arr20.toList\n        val arr22 = arr21.toArray\n        val arr23\
    \ = arr22.toList\n        val arr24 = arr23.toArray\n        val arr25 = arr24.toList\n\
    \        val arr26 = arr25.toArray\n        val arr27 = arr26.toList\n       \
    \ val arr28 = arr27.toArray\n        val arr29 = arr28.toList\n        val arr30\
    \ = arr29.toArray\n        val arr31 = arr30.toList\n        val arr32 = arr31.toArray\n\
    \        val arr33 = arr32.toList\n        val arr34 = arr33.toArray\n       \
    \ val arr35 = arr34.toList\n        val arr36 = arr35.toArray\n        val arr37\
    \ = arr36.toList\n        val arr38 = arr37.toArray\n        val arr39 = arr38.toList\n\
    \        val arr40 = arr39.toArray\n        val arr41 = arr40.toList\n       \
    \ val arr42 = arr41.toArray\n        val arr43 = arr42.toList\n        val arr44\
    \ = arr43.toArray\n        val arr45 = arr44.toList\n        val arr46 = arr45.toArray\n\
    \        val arr47 = arr46.toList\n        val arr48 = arr47.toArray\n       \
    \ val arr49 = arr48.toList\n        val arr50 = arr49.toArray\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplbwlq_n9.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplbwlq_n9.scala:79:5 ---------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798343
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val m = arr.head\n      \
    \  val arr = arr.tail\n        val arr = arr.toList\n        val arr = arr.sortBy(_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(_)\n        val arr = arr.toList\n        val arr = arr.sortBy(_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(_)\n        val arr = arr.toList\n        val arr = arr.sortBy(_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(_)\n        val arr = arr.toList\n        val arr = arr.sortBy(_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(_)\n        val arr = arr.toList\n        val arr = arr.sortBy(_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(_)\n        val arr = arr.toList\n        val arr = arr.sortBy(_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(_)\n        val arr = arr.toList\n        val arr = arr.sortBy(_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj6nl5vpf.scala:91:4 ----------------------------\e\
    [0m\e[0m\n\e[31m91 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj6nl5vpf.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpj6nl5vpf.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined\
    \ as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj6nl5vpf.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj6nl5vpf.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj6nl5vpf.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e"
  stdout: ''
  timestamp: 1659798344
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) true\n      \
    \  else {\n            val arr = arr.sortBy(x => x)\n            val first = arr(0)\n\
    \            val last = arr(n)\n            val mid = first + last\n         \
    \   val left = arr.filter(_ < mid)\n            val right = arr.filter(_ >= mid)\n\
    \            if (moveOneBall(left) && moveOneBall(right)) {\n                val\
    \ newArr = arr.filter(_ >= mid)\n                val newArr = newArr.sortBy(x\
    \ => x)\n                val newFirst = newArr.head\n                val newLast\
    \ = newArr.last\n                if (newFirst < mid && newLast > mid) {\n    \
    \                true\n                } else {\n                    false\n \
    \               }\n            } else {\n                false\n            }\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvm4a37hi.scala:29:22 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m  \
    \ |\e[0m                      Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvm4a37hi.scala:37:20\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m                \e[33mval\e\
    [0m \e[36mnewArr\e[0m = newArr.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnewArr\
    \ is already defined as \e[33mvalue\e[0m \e[35mnewArr\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n2 errors found\n"
  stdout: ''
  timestamp: 1659798340
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val arr1 = arr.slice(1, n-1)\n        val arr2 = arr.slice(1, n-1)\n   \
    \     val arr3 = arr.slice(1, n-1)\n        val arr4 = arr.slice(1, n-1)\n   \
    \     val arr5 = arr.slice(1, n-1)\n        val arr6 = arr.slice(1, n-1)\n   \
    \     val arr7 = arr.slice(1, n-1)\n        val arr8 = arr.slice(1, n-1)\n   \
    \     val arr9 = arr.slice(1, n-1)\n        val arr10 = arr.slice(1, n-1)\n  \
    \      val arr11 = arr.slice(1, n-1)\n        val arr12 = arr.slice(1, n-1)\n\
    \        val arr13 = arr.slice(1, n-1)\n        val arr14 = arr.slice(1, n-1)\n\
    \        val arr15 = arr.slice(1, n-1)\n        val arr16 = arr.slice(1, n-1)\n\
    \        val arr17 = arr.slice(1, n-1)\n        val arr18 = arr.slice(1, n-1)\n\
    \        val arr19 = arr.slice(1, n-1)\n        val arr20 = arr.slice(1, n-1)\n\
    \        val arr21 = arr.slice(1, n-1)\n        val arr22 = arr.slice(1, n-1)\n\
    \        val arr23 = arr.slice(1, n-1)\n        val arr24 = arr.slice(1, n-1)\n\
    \        val arr25 = arr.slice(1, n-1)\n        val arr26 = arr.slice(1, n-1)\n\
    \        val arr27 = arr.slice(1, n-1)\n        val arr28 = arr.slice(1, n-1)\n\
    \        val arr29 = arr.slice(1, n-1)\n        val arr30 = arr.slice(1, n-1)\n\
    \        val arr31 = arr.slice(1, n-1)\n        val arr32 = arr.slice(1, n-1)\n\
    \        val arr33 = arr.slice(1, n-1)\n        val arr34 = arr.slice(1, n-1)\n\
    \        val arr35 = arr.slice(1, n-1)\n        val arr36 = arr.slice(1, n-1)\n\
    \        val arr37 = arr.slice(1, n-1)\n        val arr38 = arr.slice(1, n-1)\n\
    \        val arr39 = arr.slice(1, n-1)\n        val arr40 = arr.slice(1, n-1)\n\
    \        val arr41 = arr.slice(1, n-1)\n        val arr42 = arr.slice(1, n-1)\n\
    \        val arr43 = arr.slice(1, n-1)\n        val arr44 = arr.slice(1, n-1)\n\
    \        val arr45 = arr.slice(1, n-1)\n        val arr46 = arr.slice(1, n-1)\n\
    \        val arr47 = \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpu185xuy4.scala:74:19 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m        \e[33mval\e[0m \e[36marr47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                   expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpu185xuy4.scala:27:18 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpu185xuy4.scala:75:5 ---------------------\e[0m\e[0m\n\e[31m75\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798344
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val arr1 = arr.toArray\n        val arr2 = arr.toBuffer\n        val arr3\
    \ = arr.toSeq\n        val arr4 = arr.toSet\n        val arr5 = arr.toMap\n  \
    \      val arr6 = arr.toIterator\n        val arr7 = arr.toStream\n        val\
    \ arr8 = arr.toSeq\n        val arr9 = arr.toSet\n        val arr10 = arr.toMap\n\
    \        val arr11 = arr.toIterator\n        val arr12 = arr.toStream\n      \
    \  val arr13 = arr.toSeq\n        val arr14 = arr.toSet\n        val arr15 = arr.toMap\n\
    \        val arr16 = arr.toIterator\n        val arr17 = arr.toStream\n      \
    \  val arr18 = arr.toSeq\n        val arr19 = arr.toSet\n        val arr20 = arr.toMap\n\
    \        val arr21 = arr.toIterator\n        val arr22 = arr.toStream\n      \
    \  val arr23 = arr.toSeq\n        val arr24 = arr.toSet\n        val arr25 = arr.toMap\n\
    \        val arr26 = arr.toIterator\n        val arr27 = arr.toStream\n      \
    \  val arr28 = arr.toSeq\n        val arr29 = arr.toSet\n        val arr30 = arr.toMap\n\
    \        val arr31 = arr.toIterator\n        val arr32 = arr.toStream\n      \
    \  val arr33 = arr.toSeq\n        val arr34 = arr.toSet\n        val arr35 = arr.toMap\n\
    \        val arr36 = arr.toIterator\n        val arr37 = arr.toStream\n      \
    \  val arr38 = arr.toSeq\n        val arr39 = arr.toSet\n        val arr40 = arr.toMap\n\
    \        val arr41 = arr.toIterator\n        val arr42 = arr.toStream\n      \
    \  val arr43 = arr.toSeq\n        val arr44 = arr.toSet\n        val arr45 = arr.toMap\n\
    \        val arr46 = arr.toIterator\n        val arr47 = arr.toStream\n      \
    \  val arr48 = arr.toSeq\n        val arr49 = arr.toSet\n        val arr50 = arr.toMap\n\
    \        val arr51 = arr.toIterator\n        val arr52 = arr.toStream\n      \
    \  val arr53 = arr.toSeq\n        val arr54 = arr.toSet\n        val arr55 = arr.toMap\n\
    \        val arr56 = arr.toIterator\n        val arr57 = arr.to\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpf_tbuuys.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpf_tbuuys.scala:85:5 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798343
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val m = arr.head\n      \
    \  val arr = arr.tail\n        val arr2 = arr.toList\n        val arr3 = arr2.reverse\n\
    \        val arr4 = arr3.toList\n        val arr5 = arr4.reverse\n        val\
    \ arr6 = arr5.reverse\n        val arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n\
    \        val arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n        val\
    \ arr11 = arr10.reverse\n        val arr12 = arr11.reverse\n        val arr13\
    \ = arr12.reverse\n        val arr14 = arr13.reverse\n        val arr15 = arr14.reverse\n\
    \        val arr16 = arr15.reverse\n        val arr17 = arr16.reverse\n      \
    \  val arr18 = arr17.reverse\n        val arr19 = arr18.reverse\n        val arr20\
    \ = arr19.reverse\n        val arr21 = arr20.reverse\n        val arr22 = arr21.reverse\n\
    \        val arr23 = arr22.reverse\n        val arr24 = arr23.reverse\n      \
    \  val arr25 = arr24.reverse\n        val arr26 = arr25.reverse\n        val arr27\
    \ = arr26.reverse\n        val arr28 = arr27.reverse\n        val arr29 = arr28.reverse\n\
    \        val arr30 = arr29.reverse\n        val arr31 = arr30.reverse\n      \
    \  val arr32 = arr31.reverse\n        val arr33 = arr32.reverse\n        val arr34\
    \ = arr33.reverse\n        val arr35 = arr34.reverse\n        val arr36 = arr35.reverse\n\
    \        val arr37 = arr36.reverse\n        val arr38 = arr37.reverse\n      \
    \  val arr39 = arr38.reverse\n        val arr40 = arr39.reverse\n        val arr41\
    \ = arr40.reverse\n        val arr42 = arr41.reverse\n        val arr43 = arr42.reverse\n\
    \        val arr44 = arr43.reverse\n        val arr45 = arr44.reverse\n      \
    \  val arr46 = arr45.reverse\n        val arr47 = arr46.reverse\n        val arr48\
    \ = arr47.reverse\n        val arr49 = arr48.reverse\n        val arr50 = arr49.reverse\n\
    \        val arr51 = arr50.reverse\n        val arr52 = arr51.reverse\n      \
    \  val arr53 = arr52.reverse\n        val arr54 = arr53.reverse\n        val arr55\
    \ = arr54.reverse\n        val arr56 = arr55.reverse\n        val \n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpu31c7u77.scala:84:11 ---------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpu31c7u77.scala:28:18 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpu31c7u77.scala:85:5 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798343
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val m = arr.head\n        val r = arr.last\n        val s = arr.init\n\
    \        val d = arr.tail\n        val x = arr.last\n        val y = arr.init\n\
    \        val z = arr.tail\n        val a = arr.last\n        val b = arr.init\n\
    \        val c = arr.tail\n        val d = arr.last\n        val e = arr.init\n\
    \        val f = arr.tail\n        val g = arr.last\n        val h = arr.init\n\
    \        val i = arr.tail\n        val j = arr.last\n        val k = arr.init\n\
    \        val l = arr.tail\n        val m = arr.last\n        val n = arr.init\n\
    \        val o = arr.tail\n        val p = arr.last\n        val q = arr.init\n\
    \        val r = arr.tail\n        val s = arr.last\n        val t = arr.init\n\
    \        val u = arr.tail\n        val v = arr.last\n        val w = arr.init\n\
    \        val x = arr.last\n        val y = arr.init\n        val z = arr.tail\n\
    \        val a = arr.last\n        val b = arr.init\n        val c = arr.tail\n\
    \        val d = arr.last\n        val e = arr.init\n        val f = arr.tail\n\
    \        val g = arr.last\n        val h = arr.init\n        val i = arr.tail\n\
    \        val j = arr.last\n        val k = arr.init\n        val l = arr.tail\n\
    \        val m = arr.last\n        val n = arr.init\n        val o = arr.tail\n\
    \        val p = arr.last\n        val q = arr.init\n        val r = arr.tail\n\
    \        val s = arr.last\n        val t = arr.init\n        val u = arr.tail\n\
    \        val v = arr.last\n        val w = arr.init\n        val x = arr.last\n\
    \        val y = arr.init\n        val z = arr.tail\n        val a = arr.last\n\
    \        val b = arr.init\n        val c = arr.tail\n        val d = arr.last\n\
    \        val e = arr.init\n        val f = arr.tail\n        val g = arr.last\n\
    \        val h = arr.init\n        val i = arr.tail\n        val j = arr.last\n\
    \        val k = arr.init\n        val l = arr.tail\n        val m = arr.last\n\
    \        val n = arr.init\n        val o = arr.tail\n        val p = arr.last\n\
    \        val q = arr.init\n        val r = arr.tail\n        val s = arr.last\n\
    \        val t = arr.init\n        val u = arr.tail\n        val v = arr.last\n\
    \        val w = arr.init\n        val x = arr.last\n        \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2ikv1kx7.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already defined\
    \ as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2ikv1kx7.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2ikv1kx7.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2ikv1kx7.scala:52:12 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2ikv1kx7.scala:53:12 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined\
    \ as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2ikv1kx7.scala:58:12 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m "
  stdout: ''
  timestamp: 1659798344
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(_)\n        val arr = arr.drop(arr.length-1)\n    \
    \    val arr = arr.take(n)\n        arr.toList.forall(x => x < arr(0))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpba45dsq3.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpba45dsq3.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.drop(arr.length-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined\
    \ as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpba45dsq3.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.take(n)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpba45dsq3.scala:27:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659798340
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(_)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n    \
    \    val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val\
    \ arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.dropRight(1)\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpv80lajjf.scala:90:11 ---------------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpv80lajjf.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv80lajjf.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv80lajjf.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv80lajjf.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv80lajjf.scala:32:12 ---------------------------\e[0m\e[0m\n\e["
  stdout: ''
  timestamp: 1659798343
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val n = arr.length\n  \
    \      val arr = arr.sortBy(_)\n        val arr1 = arr.dropRight(1)\n        val\
    \ arr2 = arr.takeRight(1)\n        val arr3 = arr1.zip(arr2).map{case (a,b) =>\
    \ b - a}\n        val arr4 = arr3.toList\n        val arr5 = arr4.sortBy(_)\n\
    \        val arr6 = arr5.dropRight(1)\n        val arr7 = arr6.takeRight(1)\n\
    \        val arr8 = arr7.zip(arr6).map{case (a,b) => b - a}\n        val arr9\
    \ = arr8.toList\n        val arr10 = arr9.sortBy(_)\n        val arr11 = arr10.dropRight(1)\n\
    \        val arr12 = arr11.takeRight(1)\n        val arr13 = arr12.zip(arr11).map{case\
    \ (a,b) => b - a}\n        val arr14 = arr13.toList\n        val arr15 = arr14.sortBy(_)\n\
    \        val arr16 = arr15.dropRight(1)\n        val arr17 = arr16.takeRight(1)\n\
    \        val arr18 = arr17.zip(arr16).map{case (a,b) => b - a}\n        val arr19\
    \ = arr18.toList\n        val arr20 = arr19.sortBy(_)\n        val arr21 = arr20.dropRight(1)\n\
    \        val arr22 = arr21.takeRight(1)\n        val arr23 = arr22.zip(arr21).map{case\
    \ (a,b) => b - a}\n        val arr24 = arr23.toList\n        val arr25 = arr24.sortBy(_)\n\
    \        val arr26 = arr25.dropRight(1)\n        val arr27 = arr26.takeRight(1)\n\
    \        val arr28 = arr27.zip(arr26).map{case (a,b) => b - a}\n        val arr29\
    \ = arr28.toList\n        val arr30 = arr29.sortBy(_)\n        val arr31 = arr30.dropRight(1)\n\
    \        val arr32 = arr31.takeRight(1)\n        val arr33 = arr32.zip(arr31).map{case\
    \ (a,b) => b - a}\n        val arr34 = arr33.toList\n        val arr35 = arr34.sortBy(_)\n\
    \        val arr36 = arr35.dropRight(1)\n        val arr37 = arr36.takeRight(1)\n\
    \        val arr38 = arr37.zip(arr36).map{case (a,b) => b - a}\n        val arr39\
    \ = arr38\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1o1088o_.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1o1088o_.scala:26:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmp1o1088o_.scala:33:31\
    \ -----------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e\
    [0m \e[36marr5\e[0m = arr4.sortBy(_)\n\e[31m\e[31m   |\e[0m                  \
    \             ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m   I could not infer the type of the parameter _$2 of expanded\
    \ function:\n\e[31m   |\e[0m   _$2 => arr4.sortBy(_$2).\n\e[31m\e[31m-- [E081]\
    \ Type Error: /tmp/tmp1o1088o_.scala:38:32 -----------------------------\e[0m\e\
    [0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36marr10\e[0m = arr9.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m \
    \  Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer\
    \ the type of the parameter _$3 of expanded function:\n\e[31m   |\e[0m   _$3 =>\
    \ arr9.sortBy(_$3).\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmp1o1088o_.scala:43:33\
    \ -----------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e\
    [0m \e[36marr15\e[0m = arr14.sortBy(_)\n\e[31m\e[31m   |\e[0m                \
    \                 ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$4 of expanded\
    \ function:\n\e[31m   |\e[0m   _$4 => arr14.sortBy(_$4).\n\e[31m\e[31m-- [E081]\
    \ Type Error: /tmp/tmp1o1088o_.scala:48:33 -------------"
  stdout: ''
  timestamp: 1659798344
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if(arr.isEmpty) true\n        else {\n            val\
    \ n = arr.size\n            val m = arr.head\n            val r = arr.tail\n \
    \           val x = r.head\n            val y = r.tail\n            val z = r.last\n\
    \            val a = r.dropRight(1)\n            val b = r.dropRight(2)\n    \
    \        val c = r.dropRight(3)\n            val d = r.dropRight(4)\n        \
    \    val e = r.dropRight(5)\n            val f = r.dropRight(6)\n            val\
    \ g = r.dropRight(7)\n            val h = r.dropRight(8)\n            val i =\
    \ r.dropRight(9)\n            val j = r.dropRight(10)\n            val k = r.dropRight(11)\n\
    \            val l = r.dropRight(12)\n            val m = r.dropRight(13)\n  \
    \          val n = r.dropRight(14)\n            val o = r.dropRight(15)\n    \
    \        val p = r.dropRight(16)\n            val q = r.dropRight(17)\n      \
    \      val r = r.dropRight(18)\n            val s = r.dropRight(19)\n        \
    \    val t = r.dropRight(20)\n            val u = r.dropRight(21)\n          \
    \  val v = r.dropRight(22)\n            val w = r.dropRight(23)\n            val\
    \ x = r.dropRight(24)\n            val y = r.dropRight(25)\n            val z\
    \ = r.dropRight(26)\n            val a = r.dropRight(27)\n            val b =\
    \ r.dropRight(28)\n            val c = r.dropRight(29)\n            val d = r.dropRight(30)\n\
    \            val e = r.dropRight(31)\n            val f = r.dropRight(32)\n  \
    \          val g = r.dropRight(33)\n            val h = r.dropRight(34)\n    \
    \        val i = r.dropRight(35)\n            val j = r.dropRight(36)\n      \
    \      val k = r.dropRight(37)\n            val l = r.dropRight(38)\n        \
    \    val m = r.dropRight(39)\n            val n = r.dropRight(40)\n          \
    \  val o = r.dropRight(41)\n            val p = r.dropRight(42)\n            val\
    \ q = r.dropRight(43)\n            val r = r.dropRight(44)\n            val s\
    \ = r.dropRight(45)\n            val t = r.dropRight(46)\n            val u =\
    \ r.dropRight(47)\n            val v = r.dropRight(48)\n            val w = r.dropRight(49)\n\
    \            val x = r.dropRight(50)\n            val y = r.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpl2oc_7zn.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpl2oc_7zn.scala:95:0 ----------------------------\e[0m\e[0m\n\e[31m95\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl2oc_7zn.scala:46:16 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m            \e[33mval\e[0m \e[36mm\e[0m = r.dropRight(\e\
    [31m13\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl2oc_7zn.scala:47:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m            \e[33mval\e\
    [0m \e[36mn\e[0m = r.dropRight(\e[31m14\e[0m)\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined as \e[33mvalue\e\
    [0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpl2oc_7zn.scala:51:16 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = r.dropRight(\e\
    [31m18\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl2oc_7zn.scala:57:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m57 |\e[0m            \e[33mval\e\
    [0m \e[36mx\e[0m = r.dropRight(\e[31m24\e[0m)\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mx is already defined as \e[33mvalue\e\
    [0m \e[35mx\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m-- "
  stdout: ''
  timestamp: 1660009388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val arr1 = arr.toArray\n        val arr2 = arr1.clone\n        val arr3\
    \ = arr2.clone\n        val arr4 = arr3.clone\n        val arr5 = arr4.clone\n\
    \        val arr6 = arr5.clone\n        val arr7 = arr6.clone\n        val arr8\
    \ = arr7.clone\n        val arr9 = arr8.clone\n        val arr10 = arr9.clone\n\
    \        val arr11 = arr10.clone\n        val arr12 = arr11.clone\n        val\
    \ arr13 = arr12.clone\n        val arr14 = arr13.clone\n        val arr15 = arr14.clone\n\
    \        val arr16 = arr15.clone\n        val arr17 = arr16.clone\n        val\
    \ arr18 = arr17.clone\n        val arr19 = arr18.clone\n        val arr20 = arr19.clone\n\
    \        val arr21 = arr20.clone\n        val arr22 = arr21.clone\n        val\
    \ arr23 = arr22.clone\n        val arr24 = arr23.clone\n        val arr25 = arr24.clone\n\
    \        val arr26 = arr25.clone\n        val arr27 = arr26.clone\n        val\
    \ arr28 = arr27.clone\n        val arr29 = arr28.clone\n        val arr30 = arr29.clone\n\
    \        val arr31 = arr30.clone\n        val arr32 = arr31.clone\n        val\
    \ arr33 = arr32.clone\n        val arr34 = arr33.clone\n        val arr35 = arr34.clone\n\
    \        val arr36 = arr35.clone\n        val arr37 = arr36.clone\n        val\
    \ arr38 = arr37.clone\n        val arr39 = arr38.clone\n        val arr40 = arr39.clone\n\
    \        val arr41 = arr40.clone\n        val arr42 = arr41.clone\n        val\
    \ arr43 = arr42.clone\n        val arr44 = arr43.clone\n        val arr45 = arr44.clone\n\
    \        val arr46 = arr45.clone\n        val arr47 = arr46.clone\n        val\
    \ arr48 = arr47.clone\n        val arr49 = arr48.clone\n        val arr50 = arr49.clone\n\
    \        val arr51 = arr50.clone\n        val arr52 = arr51.clone\n        val\
    \ arr53 = arr52.clone\n        val arr54 = arr53.clone\n        val arr55 = arr54.clone\n\
    \        val arr\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpklw3ap4m.scala:84:4 ----------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpklw3ap4m.scala:27:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpklw3ap4m.scala:84:5\
    \ ---------------------\e[0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:33:12 ---------------------------\e\
    [0m\e[0"
  stdout: ''
  timestamp: 1660009388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val arr1 = arr.toArray\n        val arr2 = arr1.clone()\n        val arr3\
    \ = arr2.clone()\n        val arr4 = arr3.clone()\n        val arr5 = arr4.clone()\n\
    \        val arr6 = arr5.clone()\n        val arr7 = arr6.clone()\n        val\
    \ arr8 = arr7.clone()\n        val arr9 = arr8.clone()\n        val arr10 = arr9.clone()\n\
    \        val arr11 = arr10.clone()\n        val arr12 = arr11.clone()\n      \
    \  val arr13 = arr12.clone()\n        val arr14 = arr13.clone()\n        val arr15\
    \ = arr14.clone()\n        val arr16 = arr15.clone()\n        val arr17 = arr16.clone()\n\
    \        val arr18 = arr17.clone()\n        val arr19 = arr18.clone()\n      \
    \  val arr20 = arr19.clone()\n        val arr21 = arr20.clone()\n        val arr22\
    \ = arr21.clone()\n        val arr23 = arr22.clone()\n        val arr24 = arr23.clone()\n\
    \        val arr25 = arr24.clone()\n        val arr26 = arr25.clone()\n      \
    \  val arr27 = arr26.clone()\n        val arr28 = arr27.clone()\n        val arr29\
    \ = arr28.clone()\n        val arr30 = arr29.clone()\n        val arr31 = arr30.clone()\n\
    \        val arr32 = arr31.clone()\n        val arr33 = arr32.clone()\n      \
    \  val arr34 = arr33.clone()\n        val arr35 = arr34.clone()\n        val arr36\
    \ = arr35.clone()\n        val arr37 = arr36.clone()\n        val arr38 = arr37.clone()\n\
    \        val arr39 = arr38.clone()\n        val arr40 = arr39.clone()\n      \
    \  val arr41 = arr40.clone()\n        val arr42 = arr41.clone()\n        val arr43\
    \ = arr42.clone()\n        val arr44 = arr43.clone()\n        val arr45 = arr44.clone()\n\
    \        val arr46 = arr45.clone()\n        val arr47 = arr46.clone()\n      \
    \  val arr48 = arr47.clone()\n        val arr49 = arr48.clone()\n        val arr50\
    \ = arr49.clone()\n        val arr51 = arr50.clone()\n        val arr52 = arr51.clone()\n\
    \        val arr53 = arr52.clone()\n        val arr54 = arr53.clone()\n      \
    \  val arr55 = arr54.clone()\n        val arr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5c2caf7i.scala:84:4 ----------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5c2caf7i.scala:27:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5c2caf7i.scala:84:5\
    \ ---------------------\e[0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val result = new Array[Boolean](n)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var flag = false\n        var\
    \ temp2 = new Array[Long](n)\n        var temp3 = new Array[Long](n)\n       \
    \ var temp4 = new Array[Long](n)\n        var temp5 = new Array[Long](n)\n   \
    \     var temp6 = new Array[Long](n)\n        var temp7 = new Array[Long](n)\n\
    \        var temp8 = new Array[Long](n)\n        var temp9 = new Array[Long](n)\n\
    \        var temp10 = new Array[Long](n)\n        var temp11 = new Array[Long](n)\n\
    \        var temp12 = new Array[Long](n)\n        var temp13 = new Array[Long](n)\n\
    \        var temp14 = new Array[Long](n)\n        var temp15 = new Array[Long](n)\n\
    \        var temp16 = new Array[Long](n)\n        var temp17 = new Array[Long](n)\n\
    \        var temp18 = new Array[Long](n)\n        var temp19 = new Array[Long](n)\n\
    \        var temp20 = new Array[Long](n)\n        var temp21 = new Array[Long](n)\n\
    \        var temp22 = new Array[Long](n)\n        var temp23 = new Array[Long](n)\n\
    \        var temp24 = new Array[Long](n)\n        var temp25 = new Array[Long](n)\n\
    \        var temp26 = new Array[Long](n)\n        var temp27 = new Array[Long](n)\n\
    \        var temp28 = new Array[Long](n)\n        var temp29 = new Array[Long](n)\n\
    \        var temp30 = new Array[Long](n)\n        var temp31 = new Array[Long](n)\n\
    \        var temp32 = new Array[Long](n)\n        var temp33 = new Array[Long](n)\n\
    \        var temp34 = new Array[Long](n)\n        var temp35 = new Array[Long](n)\n\
    \        var temp36 = new Array[Long](n)\n        var temp37 = new Array[Long](n)\n\
    \        var temp38 = new Array[Long](n)\n        var temp39 = new Array[Long](n)\n\
    \        var temp40 = new Array[Long](n)\n        var temp41 = new Array[Long](n)\n\
    \        var temp42 = new Array[Long](n)\n        var temp43 = new Array[Long](n)\n\
    \        var temp44 = new Array[Long](n)\n        var temp45 = new Array[Long](n)\n\
    \        var temp46 = new Array[Long](n)\n        var temp47 = new Array[Long](n)\n\
    \        var temp48 = new \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbv34gvb5.scala:81:4 ----------------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpbv34gvb5.scala:27:18 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpbv34gvb5.scala:81:5 ---------------------\e[0m\e[0m\n\e[31m81\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val arr1 = arr.toArray\n        val arr2 = arr1.clone\n        val arr3\
    \ = arr2.clone\n        val arr4 = arr3.clone\n        val arr5 = arr4.clone\n\
    \        val arr6 = arr5.clone\n        val arr7 = arr6.clone\n        val arr8\
    \ = arr7.clone\n        val arr9 = arr8.clone\n        val arr10 = arr9.clone\n\
    \        val arr11 = arr10.clone\n        val arr12 = arr11.clone\n        val\
    \ arr13 = arr12.clone\n        val arr14 = arr13.clone\n        val arr15 = arr14.clone\n\
    \        val arr16 = arr15.clone\n        val arr17 = arr16.clone\n        val\
    \ arr18 = arr17.clone\n        val arr19 = arr18.clone\n        val arr20 = arr19.clone\n\
    \        val arr21 = arr20.clone\n        val arr22 = arr21.clone\n        val\
    \ arr23 = arr22.clone\n        val arr24 = arr23.clone\n        val arr25 = arr24.clone\n\
    \        val arr26 = arr25.clone\n        val arr27 = arr26.clone\n        val\
    \ arr28 = arr27.clone\n        val arr29 = arr28.clone\n        val arr30 = arr29.clone\n\
    \        val arr31 = arr30.clone\n        val arr32 = arr31.clone\n        val\
    \ arr33 = arr32.clone\n        val arr34 = arr33.clone\n        val arr35 = arr34.clone\n\
    \        val arr36 = arr35.clone\n        val arr37 = arr36.clone\n        val\
    \ arr38 = arr37.clone\n        val arr39 = arr38.clone\n        val arr40 = arr39.clone\n\
    \        val arr41 = arr40.clone\n        val arr42 = arr41.clone\n        val\
    \ arr43 = arr42.clone\n        val arr44 = arr43.clone\n        val arr45 = arr44.clone\n\
    \        val arr46 = arr45.clone\n        val arr47 = arr46.clone\n        val\
    \ arr48 = arr47.clone\n        val arr49 = arr48.clone\n        val arr50 = arr49.clone\n\
    \        val arr51 = arr50.clone\n        val arr52 = arr51.clone\n        val\
    \ arr53 = arr52.clone\n        val arr54 = arr53.clone\n        val arr55 = arr54.clone\n\
    \        val arr\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpklw3ap4m.scala:84:4 ----------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpklw3ap4m.scala:27:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpklw3ap4m.scala:84:5\
    \ ---------------------\e[0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val len = arr.length\n        val arr1 = arr.toArray\n        val arr2\
    \ = arr.toBuffer\n        val arr3 = arr.toSeq\n        val arr4 = arr.toSet\n\
    \        val arr5 = arr.toMap\n        val arr6 = arr.toIterator\n        val\
    \ arr7 = arr.toStream\n        val arr8 = arr.toSeq\n        val arr9 = arr.toSet\n\
    \        val arr10 = arr.toMap\n        val arr11 = arr.toIterator\n        val\
    \ arr12 = arr.toStream\n        val arr13 = arr.toSeq\n        val arr14 = arr.toSet\n\
    \        val arr15 = arr.toMap\n        val arr16 = arr.toIterator\n        val\
    \ arr17 = arr.toStream\n        val arr18 = arr.toSeq\n        val arr19 = arr.toSet\n\
    \        val arr20 = arr.toMap\n        val arr21 = arr.toIterator\n        val\
    \ arr22 = arr.toStream\n        val arr23 = arr.toSeq\n        val arr24 = arr.toSet\n\
    \        val arr25 = arr.toMap\n        val arr26 = arr.toIterator\n        val\
    \ arr27 = arr.toStream\n        val arr28 = arr.toSeq\n        val arr29 = arr.toSet\n\
    \        val arr30 = arr.toMap\n        val arr31 = arr.toIterator\n        val\
    \ arr32 = arr.toStream\n        val arr33 = arr.toSeq\n        val arr34 = arr.toSet\n\
    \        val arr35 = arr.toMap\n        val arr36 = arr.toIterator\n        val\
    \ arr37 = arr.toStream\n        val arr38 = arr.toSeq\n        val arr39 = arr.toSet\n\
    \        val arr40 = arr.toMap\n        val arr41 = arr.toIterator\n        val\
    \ arr42 = arr.toStream\n        val arr43 = arr.toSeq\n        val arr44 = arr.toSet\n\
    \        val arr45 = arr.toMap\n        val arr46 = arr.toIterator\n        val\
    \ arr47 = arr.toStream\n        val arr48 = arr.toSeq\n        val arr49 = arr.toSet\n\
    \        val arr50 = arr.toMap\n        val arr51 = arr.toIterator\n        val\
    \ arr52 = arr.toStream\n        val arr53 = arr.toSeq\n        val arr54 = arr.toSet\n\
    \        val arr55 = arr.toMap\n        val arr56 = arr.toIterator\n        \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8nwu52fm.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp8nwu52fm.scala:86:5 ---------------------\e\
    [0m\e[0m\n\e[31m86 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val result = new mutable.ListBuffer[Long]()\n        val temp = new mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var temp1 =\
    \ new mutable.ListBuffer[Long]()\n        var temp2 = new mutable.ListBuffer[Long]()\n\
    \        var temp3 = new mutable.ListBuffer[Long]()\n        var temp4 = new mutable.ListBuffer[Long]()\n\
    \        var temp5 = new mutable.ListBuffer[Long]()\n        var temp6 = new mutable.ListBuffer[Long]()\n\
    \        var temp7 = new mutable.ListBuffer[Long]()\n        var temp8 = new mutable.ListBuffer[Long]()\n\
    \        var temp9 = new mutable.ListBuffer[Long]()\n        var temp10 = new\
    \ mutable.ListBuffer[Long]()\n        var temp11 = new mutable.ListBuffer[Long]()\n\
    \        var temp12 = new mutable.ListBuffer[Long]()\n        var temp13 = new\
    \ mutable.ListBuffer[Long]()\n        var temp14 = new mutable.ListBuffer[Long]()\n\
    \        var temp15 = new mutable.ListBuffer[Long]()\n        var temp16 = new\
    \ mutable.ListBuffer[Long]()\n        var temp17 = new mutable.ListBuffer[Long]()\n\
    \        var temp18 = new mutable.ListBuffer[Long]()\n        var temp19 = new\
    \ mutable.ListBuffer[Long]()\n        var temp20 = new mutable.ListBuffer[Long]()\n\
    \        var temp21 = new mutable.ListBuffer[Long]()\n        var temp22 = new\
    \ mutable.ListBuffer[Long]()\n        var temp23 = new mutable.ListBuffer[Long]()\n\
    \        var temp24 = new mutable.ListBuffer[Long]()\n        var temp25 = new\
    \ mutable.ListBuffer[Long]()\n        var temp26 = new mutable.ListBuffer[Long]()\n\
    \        var temp27 = new mutable.ListBuffer[Long]()\n        var temp28 = new\
    \ mutable.ListBuffer[Long]()\n        var temp29 = new mutable.ListBuffer[Long]()\n\
    \        var temp30 = new mutable.ListBuffer[Long]()\n        var temp31 = new\
    \ mutable.ListBuffer[Long]()\n        var temp32 = new mutable.ListBuffer[Long]()\n\
    \        var temp33 = new mutable.ListBuffer[Long]()\n        var temp34 = new\
    \ mutable.ListBuffer[Long]()\n        var temp35 = new mutable.ListBuffer[Long]()\n\
    \        var temp36 = new mut\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5y45_frs.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5y45_frs.scala:28:25 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5y45_frs.scala:29:23\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mtemp\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp5y45_frs.scala:33:24 ------------------------\e[0m\e[0m\n\e[31m33 |\e\
    [0m        \e[33mvar\e[0m \e[36mtemp1\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5y45_frs.scala:34:24 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mvar\e[0m \e[36mtemp2\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5y45_frs.scala:35:24\
    \ ------------------------\e"
  stdout: ''
  timestamp: 1660009387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val maxLen = len - 1\n        val maxVal = arr(maxLen)\n        val minVal\
    \ = arr(0)\n        val minLen = len\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minLenIndex = arr.indexOf(minVal)\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minValIndex = arr.indexOf(minVal)\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minValIndex = arr.indexOf(minVal)\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minValIndex = arr.indexOf(minVal)\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minValIndex = arr.indexOf(minVal)\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minValIndex = arr.indexOf(minVal)\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minValIndex = arr.indexOf(minVal)\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minValIndex = arr.indexOf(minVal)\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minValIndex = arr.indexOf(minVal)\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minValIndex = arr.indexOf(minVal)\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minValIndex = arr.indexOf(minVal)\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minValIndex = arr.indexOf(minVal)\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minValIndex = arr.indexOf(minVal)\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minValIndex = arr.indexOf(minVal)\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minValIndex = arr.indexOf(minVal)\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minValIndex = arr.indexOf(minVal)\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minValIndex = arr.indexOf(minVal)\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minValIndex = arr.indexOf(minVal)\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minValIndex = arr.indexOf(minVal)\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minValIndex = arr.indexOf(minVal)\n        val minValIndex = arr.indexOf(minVal)\n\
    \        val minValIndex = arr.indexOf(minVal)\n        val min\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwqf_duq0.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwqf_duq0.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mminValIndex\e[0m = arr.indexOf(minVal)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminValIndex is already defined as \e[33mvalue\e[0m \e[35mminValIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpwqf_duq0.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mminValIndex\e[0m = arr.indexOf(minVal)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mminValIndex is already defined as \e[33mvalue\e[0m \e[35mminValIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpwqf_duq0.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mminValIndex\e[0m = arr.indexOf(minVal)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mminValIndex is already defined as \e[33mvalue\e[0m \e[35mminValIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpwqf_duq0.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mminValIndex\e[0m = arr.indexOf(minVal)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mminValIndex is already defined as \e[33mvalue\e[0m \e[35mminValIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpwqf_duq0.scala:38:12 --------------"
  stdout: ''
  timestamp: 1660009388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val sortedArr = arr.sortBy(x => x)\n        val result = sortedArr.tail.head\
    \ > sortedArr.head.head\n        result && sortedArr.tail.head == sortedArr.head.head\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprme59tcb.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009382
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val max = arr.max\n        val min = arr.min\n        val mid = len/2\n\
    \        val midVal = arr[mid]\n        val leftVal = arr.take(mid)\n        val\
    \ rightVal = arr.drop(mid)\n        val leftMax = leftVal.max\n        val leftMin\
    \ = leftVal.min\n        val rightMax = rightVal.max\n        val rightMin = rightVal.min\n\
    \        val leftMaxVal = leftMax\n        val leftMinVal = leftMin\n        val\
    \ rightMaxVal = rightMax\n        val rightMinVal = rightMin\n        val leftMaxVal2\
    \ = leftMaxVal\n        val leftMinVal2 = leftMinVal\n        val rightMaxVal2\
    \ = rightMaxVal\n        val rightMinVal2 = rightMinVal\n        val leftMaxVal3\
    \ = leftMaxVal2\n        val leftMinVal3 = leftMinVal2\n        val rightMaxVal3\
    \ = rightMaxVal2\n        val rightMinVal3 = rightMinVal2\n        val leftMaxVal4\
    \ = leftMaxVal3\n        val leftMinVal4 = leftMinVal3\n        val rightMaxVal4\
    \ = rightMaxVal3\n        val rightMinVal4 = rightMinVal3\n        val leftMaxVal5\
    \ = leftMaxVal4\n        val leftMinVal5 = leftMinVal4\n        val rightMaxVal5\
    \ = rightMaxVal4\n        val rightMinVal5 = rightMinVal4\n        val leftMaxVal6\
    \ = leftMaxVal5\n        val leftMinVal6 = leftMinVal5\n        val rightMaxVal6\
    \ = rightMaxVal5\n        val rightMinVal6 = rightMinVal5\n        val leftMaxVal7\
    \ = leftMaxVal6\n        val leftMinVal7 = leftMinVal6\n        val rightMaxVal7\
    \ = rightMaxVal6\n        val rightMinVal7 = rightMinVal6\n        val leftMaxVal8\
    \ = leftMaxVal7\n        val leftMinVal8 = leftMinVal7\n        val rightMaxVal8\
    \ = rightMaxVal7\n        val rightMinVal8 = rightMinVal7\n        val leftMaxVal9\
    \ = leftMaxVal8\n        val leftMinVal9 = leftMinVal8\n        val rightMaxVal9\
    \ = rightMaxVal8\n        val rightMinVal9 = rightMinVal8\n        val leftMaxVal10\
    \ = leftMaxVal9\n        val leftMinVal10 = leftMinVal9\n        val right\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_xb6tzd0.scala:77:4 ----------------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_xb6tzd0.scala:26:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_xb6tzd0.scala:31:25\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mmidVal\e[0m = arr[\e[35mmid\e[0m]\n\e[31m\e[31m   |\e[0m                 \
    \        ^^^\e[0m\n\e[31m   |\e[0m                         Not found: type mid\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_xb6tzd0.scala:77:5\
    \ ---------------------\e[0m\e[0m\n\e[31m77 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if(arr.isEmpty) true\n        else {\n            val\
    \ l = arr.head\n            val r = arr.last\n            val m = arr.length\n\
    \            val s = arr.tail.head\n            val t = arr.tail.last\n      \
    \      val u = arr.tail.tail.head\n            val v = arr.tail.tail.last\n  \
    \          val w = arr.tail.tail.tail.head\n            val x = arr.tail.tail.tail.last\n\
    \            val y = arr.tail.tail.tail.tail.head\n            val z = arr.tail.tail.tail.tail.last\n\
    \            val a = arr.tail.tail.tail.tail.tail.head\n            val b = arr.tail.tail.tail.tail.tail.last\n\
    \            val c = arr.tail.tail.tail.tail.tail.tail.head\n            val d\
    \ = arr.tail.tail.tail.tail.tail.tail.last\n            val e = arr.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val f = arr.tail.tail.tail.tail.tail.tail.tail.last\n           \
    \ val g = arr.tail.tail.tail.tail.tail.tail.tail.tail.head\n            val h\
    \ = arr.tail.tail.tail.tail.tail.tail.tail.tail.last\n            val i = arr.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val j = arr.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.last\n\
    \            val k = arr.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val l = arr.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.last\n\
    \            val m = arr.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val n = arr.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.last\n\
    \            val o = arr.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val p = arr.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.last\n\
    \            val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpcxgyrafl.scala:55:15 ---------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m            \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m  \
    \             ^\e[0m\n\e[31m   |\e[0m               pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcxgyrafl.scala:66:0 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcxgyrafl.scala:50:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m50 |\e[0m            \e[33mval\e\
    [0m \e[36ml\e[0m = arr.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.last\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0ml is already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpcxgyrafl.scala:51:16 ---------------------------\e[0m\e[0m\n\e[31m51\
    \ |\e[0m            \e[33mval\e[0m \e[36mm\e[0m = arr.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpcxgyrafl.scala:65:1 ---------------------\e[0m\e[0m\n\e[31m65\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m\
    \   |\e[0m Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpcxgyrafl.scala:57:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m57 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is in"
  stdout: ''
  timestamp: 1660009387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:34:12 ----------"
  stdout: ''
  timestamp: 1660009387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toArray\n \
    \       val arr1 = arr.toList\n        val arr2 = arr.toSet\n        val arr3\
    \ = arr.toSeq\n        val arr4 = arr.toArray\n        val arr5 = arr.toMap\n\
    \        val arr6 = arr.toSeq\n        val arr7 = arr.toSet\n        val arr8\
    \ = arr.toMap\n        val arr9 = arr.toSeq\n        val arr10 = arr.toSet\n \
    \       val arr11 = arr.toMap\n        val arr12 = arr.toSeq\n        val arr13\
    \ = arr.toSet\n        val arr14 = arr.toMap\n        val arr15 = arr.toSeq\n\
    \        val arr16 = arr.toSet\n        val arr17 = arr.toMap\n        val arr18\
    \ = arr.toSeq\n        val arr19 = arr.toSet\n        val arr20 = arr.toMap\n\
    \        val arr21 = arr.toSeq\n        val arr22 = arr.toSet\n        val arr23\
    \ = arr.toMap\n        val arr24 = arr.toSeq\n        val arr25 = arr.toSet\n\
    \        val arr26 = arr.toMap\n        val arr27 = arr.toSeq\n        val arr28\
    \ = arr.toSet\n        val arr29 = arr.toMap\n        val arr30 = arr.toSeq\n\
    \        val arr31 = arr.toSet\n        val arr32 = arr.toMap\n        val arr33\
    \ = arr.toSeq\n        val arr34 = arr.toSet\n        val arr35 = arr.toMap\n\
    \        val arr36 = arr.toSeq\n        val arr37 = arr.toSet\n        val arr38\
    \ = arr.toMap\n        val arr39 = arr.toSeq\n        val arr40 = arr.toSet\n\
    \        val arr41 = arr.toMap\n        val arr42 = arr.toSeq\n        val arr43\
    \ = arr.toSet\n        val arr44 = arr.toMap\n        val arr45 = arr.toSeq\n\
    \        val arr46 = arr.toSet\n        val arr47 = arr.toMap\n        val arr48\
    \ = arr.toSeq\n        val arr49 = arr.toSet\n        val arr50 = arr.toMap\n\
    \        val arr51 = arr.toSeq\n        val arr52 = arr.toSet\n        val arr53\
    \ = arr.toMap\n        val arr54 = arr.toSeq\n        val arr55 = arr.toSet\n\
    \        val arr56 = arr.toMap\n        val arr57 = arr.to\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpg8mgy44h.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg8mgy44h.scala:85:5 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val sorted = arr.sortBy(x => x)\n        val sorted = sorted.reverse\n  \
    \      val sorted = sorted.take(n)\n        val sorted = sorted.reverse\n    \
    \    val sorted = sorted.take(n)\n        val sorted = sorted.reverse\n      \
    \  val sorted = sorted.take(n)\n        val sorted = sorted.reverse\n        val\
    \ sorted = sorted.take(n)\n        val sorted = sorted.reverse\n        val sorted\
    \ = sorted.take(n)\n        val sorted = sorted.reverse\n        val sorted =\
    \ sorted.take(n)\n        val sorted = sorted.reverse\n        val sorted = sorted.take(n)\n\
    \        val sorted = sorted.reverse\n        val sorted = sorted.take(n)\n  \
    \      val sorted = sorted.reverse\n        val sorted = sorted.take(n)\n    \
    \    val sorted = sorted.reverse\n        val sorted = sorted.take(n)\n      \
    \  val sorted = sorted.reverse\n        val sorted = sorted.take(n)\n        val\
    \ sorted = sorted.reverse\n        val sorted = sorted.take(n)\n        val sorted\
    \ = sorted.reverse\n        val sorted = sorted.take(n)\n        val sorted =\
    \ sorted.reverse\n        val sorted = sorted.take(n)\n        val sorted = sorted.reverse\n\
    \        val sorted = sorted.take(n)\n        val sorted = sorted.reverse\n  \
    \      val sorted = sorted.take(n)\n        val sorted = sorted.reverse\n    \
    \    val sorted = sorted.take(n)\n        val sorted = sorted.reverse\n      \
    \  val sorted = sorted.take(n)\n        val sorted = sorted.reverse\n        val\
    \ sorted = sorted.take(n)\n        val sorted = sorted.reverse\n        val sorted\
    \ = sorted.take(n)\n        val sorted = sorted.reverse\n        val sorted =\
    \ sorted.take(n)\n        val sorted = sorted.reverse\n        val sorted = sorted.take(n)\n\
    \        val sorted = sorted.reverse\n        val sorted = sorted.take(n)\n  \
    \      val sorted = sorted.reverse\n        val sorted = sorted.take(n)\n    \
    \    val sorted = sorted.reverse\n        val sorted = sorted.take(n)\n      \
    \  val sorted = sorted.reverse\n        val sorted = sorted.take(n)\n        val\
    \ sorted = sorted.reverse\n        val sorted = sorted.take(n)\n        val sorted\
    \ = sorted.reverse\n        val sorted = sorted.take(n)\n        val sorted =\
    \ sorted.reverse\n        val sorted = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp06r7u07d.scala:86:20 ---------------------------\e\
    [0m\e[0m\n\e[31m86 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = \n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp06r7u07d.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msorted is already\
    \ defined as \e[33mvalue\e[0m \e[35msorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp06r7u07d.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36msorted\e[0m = sorted.take(n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp06r7u07d.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msorted is\
    \ already defined as \e[33mvalue\e[0m \e[35msorted\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp06r7u07d.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36msorted\e[0m = sorted.take(n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ E"
  stdout: ''
  timestamp: 1660009387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val len = arr.length\n        val arr1 = arr.toArray\n        val arr2 =\
    \ arr.toBuffer\n        val arr3 = arr.toSeq\n        val arr4 = arr.toSet\n \
    \       val arr5 = arr.toSeq\n        val arr6 = arr.toMap\n        val arr7 =\
    \ arr.toSet\n        val arr8 = arr.toMap\n        val arr9 = arr.toSeq\n    \
    \    val arr10 = arr.toSet\n        val arr11 = arr.toMap\n        val arr12 =\
    \ arr.toSeq\n        val arr13 = arr.toSet\n        val arr14 = arr.toMap\n  \
    \      val arr15 = arr.toSeq\n        val arr16 = arr.toSet\n        val arr17\
    \ = arr.toMap\n        val arr18 = arr.toSeq\n        val arr19 = arr.toSet\n\
    \        val arr20 = arr.toMap\n        val arr21 = arr.toSeq\n        val arr22\
    \ = arr.toSet\n        val arr23 = arr.toMap\n        val arr24 = arr.toSeq\n\
    \        val arr25 = arr.toSet\n        val arr26 = arr.toMap\n        val arr27\
    \ = arr.toSeq\n        val arr28 = arr.toSet\n        val arr29 = arr.toMap\n\
    \        val arr30 = arr.toSeq\n        val arr31 = arr.toSet\n        val arr32\
    \ = arr.toMap\n        val arr33 = arr.toSeq\n        val arr34 = arr.toSet\n\
    \        val arr35 = arr.toMap\n        val arr36 = arr.toSeq\n        val arr37\
    \ = arr.toSet\n        val arr38 = arr.toMap\n        val arr39 = arr.toSeq\n\
    \        val arr40 = arr.toSet\n        val arr41 = arr.toMap\n        val arr42\
    \ = arr.toSeq\n        val arr43 = arr.toSet\n        val arr44 = arr.toMap\n\
    \        val arr45 = arr.toSeq\n        val arr46 = arr.toSet\n        val arr47\
    \ = arr.toMap\n        val arr48 = arr.toSeq\n        val arr49 = arr.toSet\n\
    \        val arr50 = arr.toMap\n        val arr51 = arr.toSeq\n        val arr52\
    \ = arr.toSet\n        val arr53 = arr.toMap\n        val arr54 = arr.toSeq\n\
    \        val arr55 = arr.toSet\n        val arr56 = arr.toMap\n        \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb67umovj.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpb67umovj.scala:86:5 ---------------------\e\
    [0m\e[0m\n\e[31m86 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val len = arr.length\n        val arr1 = arr.toArray\n        val arr2\
    \ = arr1.clone\n        val arr3 = arr2.clone\n        val arr4 = arr3.clone\n\
    \        val arr5 = arr4.clone\n        val arr6 = arr5.clone\n        val arr7\
    \ = arr6.clone\n        val arr8 = arr7.clone\n        val arr9 = arr8.clone\n\
    \        val arr10 = arr9.clone\n        val arr11 = arr10.clone\n        val\
    \ arr12 = arr11.clone\n        val arr13 = arr12.clone\n        val arr14 = arr13.clone\n\
    \        val arr15 = arr14.clone\n        val arr16 = arr15.clone\n        val\
    \ arr17 = arr16.clone\n        val arr18 = arr17.clone\n        val arr19 = arr18.clone\n\
    \        val arr20 = arr19.clone\n        val arr21 = arr20.clone\n        val\
    \ arr22 = arr21.clone\n        val arr23 = arr22.clone\n        val arr24 = arr23.clone\n\
    \        val arr25 = arr24.clone\n        val arr26 = arr25.clone\n        val\
    \ arr27 = arr26.clone\n        val arr28 = arr27.clone\n        val arr29 = arr28.clone\n\
    \        val arr30 = arr29.clone\n        val arr31 = arr30.clone\n        val\
    \ arr32 = arr31.clone\n        val arr33 = arr32.clone\n        val arr34 = arr33.clone\n\
    \        val arr35 = arr34.clone\n        val arr36 = arr35.clone\n        val\
    \ arr37 = arr36.clone\n        val arr38 = arr37.clone\n        val arr39 = arr38.clone\n\
    \        val arr40 = arr39.clone\n        val arr41 = arr40.clone\n        val\
    \ arr42 = arr41.clone\n        val arr43 = arr42.clone\n        val arr44 = arr43.clone\n\
    \        val arr45 = arr44.clone\n        val arr46 = arr45.clone\n        val\
    \ arr47 = arr46.clone\n        val arr48 = arr47.clone\n        val arr49 = arr48.clone\n\
    \        val arr50 = arr49.clone\n        val arr51 = arr50.clone\n        val\
    \ arr52 = arr51.clone\n        val arr53 = arr52.clone\n        val arr54 = arr53.clone\n\
    \        val arr55 = arr54\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgxui0o03.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpgxui0o03.scala:84:5 ---------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) true\n      \
    \  else {\n            val m = arr.head\n            val r = arr.tail\n      \
    \      val x = r.head\n            val y = r.tail\n            val z = r.tail\n\
    \            val w = r.tail\n            val a = r.tail\n            val b = r.tail\n\
    \            val c = r.tail\n            val d = r.tail\n            val e = r.tail\n\
    \            val f = r.tail\n            val g = r.tail\n            val h = r.tail\n\
    \            val i = r.tail\n            val j = r.tail\n            val k = r.tail\n\
    \            val l = r.tail\n            val m = r.tail\n            val n = r.tail\n\
    \            val o = r.tail\n            val p = r.tail\n            val q = r.tail\n\
    \            val r = r.tail\n            val s = r.tail\n            val t = r.tail\n\
    \            val u = r.tail\n            val v = r.tail\n            val w = r.tail\n\
    \            val x = r.tail\n            val y = r.tail\n            val z = r.tail\n\
    \            val a = r.tail\n            val b = r.tail\n            val c = r.tail\n\
    \            val d = r.tail\n            val e = r.tail\n            val f = r.tail\n\
    \            val g = r.tail\n            val h = r.tail\n            val i = r.tail\n\
    \            val j = r.tail\n            val k = r.tail\n            val l = r.tail\n\
    \            val m = r.tail\n            val n = r.tail\n            val o = r.tail\n\
    \            val p = r.tail\n            val q = r.tail\n            val r = r.tail\n\
    \            val s = r.tail\n            val t = r.tail\n            val u = r.tail\n\
    \            val v = r.tail\n            val w = r.tail\n            val x = r.tail\n\
    \            val y = r.tail\n            val z = r.tail\n            val a = r.tail\n\
    \            val b = r.tail\n            val c = r.tail\n            val d = r.tail\n\
    \            val e = r.tail\n            val f = r.tail\n            val g = r.tail\n\
    \            val h = r.tail\n            val i = r.tail\n            val j = r.tail\n\
    \            val k = r.tail\n            val l = r.tail\n            val m = r.tail\n\
    \            val n = r.tail\n            val o = r.tail\n            val p = r.tail\n\
    \            val q = r.tail\n            val r = r.tail\n            val s = r.tail\n\
    \            val t = r.tail\n            val u = r.tail\n            val v = r.tail\n\
    \            val w = r.tail\n            val x = r.tail\n            val y = r.tail\n\
    \            \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe7c4tkjv.scala:123:0 ---------------------------\e\
    [0m\e[0m\n\e[31m123 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe7c4tkjv.scala:47:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m            \e[33mval\e\
    [0m \e[36mm\e[0m = r.tail\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpe7c4tkjv.scala:52:16 ---------------------------\e[0m\e[0m\n\e[31m52\
    \ |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = r.tail\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e\
    [0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpe7c4tkjv.scala:57:16 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m            \e[33mval\e[0m \e[36mw\e[0m = r.tail\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mw is already\
    \ defined as \e[33mvalue\e[0m \e[35mw\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe7c4tkjv.scala:58:16 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m            \e[33mval\e[0m \e[36mx\e[0m = r.tail\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mx is already\
    \ defined as \e[33mvalue\e[0m \e[35mx\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe7c4tkjv.scala:59:16 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m            \e[33mval\e[0m \e[36my\e[0m = r.tail\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0my is already\
    \ defined as \e[33mvalue\e[0m \e[35my\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded me"
  stdout: ''
  timestamp: 1660009388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr1 = arr.toList\n        val arr2 = arr1.reverse\n\
    \        val arr3 = arr2.reverse\n        val arr4 = arr3.reverse\n        val\
    \ arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n        val arr7 = arr6.reverse\n\
    \        val arr8 = arr7.reverse\n        val arr9 = arr8.reverse\n        val\
    \ arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n        val arr12 =\
    \ arr11.reverse\n        val arr13 = arr12.reverse\n        val arr14 = arr13.reverse\n\
    \        val arr15 = arr14.reverse\n        val arr16 = arr15.reverse\n      \
    \  val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n        val arr19\
    \ = arr18.reverse\n        val arr20 = arr19.reverse\n        val arr21 = arr20.reverse\n\
    \        val arr22 = arr21.reverse\n        val arr23 = arr22.reverse\n      \
    \  val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n        val arr26\
    \ = arr25.reverse\n        val arr27 = arr26.reverse\n        val arr28 = arr27.reverse\n\
    \        val arr29 = arr28.reverse\n        val arr30 = arr29.reverse\n      \
    \  val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n        val arr33\
    \ = arr32.reverse\n        val arr34 = arr33.reverse\n        val arr35 = arr34.reverse\n\
    \        val arr36 = arr35.reverse\n        val arr37 = arr36.reverse\n      \
    \  val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n        val arr40\
    \ = arr39.reverse\n        val arr41 = arr40.reverse\n        val arr42 = arr41.reverse\n\
    \        val arr43 = arr42.reverse\n        val arr44 = arr43.reverse\n      \
    \  val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n        val arr47\
    \ = arr46.reverse\n        val arr48 = arr47.reverse\n        val arr49 = arr48.reverse\n\
    \        val arr50 = arr49.reverse\n        val arr51 = arr50.reverse\n      \
    \  val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n        val arr54\
    \ = arr53.reverse\n        val arr55 = arr54.reverse\n        val arr56 = arr55.reverse\n\
    \        val arr57 = arr56.reverse\n        val arr58\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp39ycrorm.scala:84:4 ----------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp39ycrorm.scala:84:5 ---------------------\e[0m\e[0m\n\e[31m84 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e"
  stdout: ''
  timestamp: 1660009388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ r = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var l = 0\n        var m1 = m\n        while(i < n) {\n       \
    \     val x = arr(i)\n            val y = arr(j)\n            val z = arr(k)\n\
    \            val w = arr(l)\n            val a = x - y\n            val b = x\
    \ - z\n            val c = x - w\n            val d = y - z\n            val e\
    \ = y - w\n            val f = z - w\n            val g = x - y\n            val\
    \ h = x - z\n            val i = x - w\n            val j = y - z\n          \
    \  val k = y - w\n            val l = z - w\n            val m = x - y\n     \
    \       val n = y - z\n            val o = x - w\n            val p = y - z\n\
    \            val q = y - w\n            val r = z - w\n            val s = x -\
    \ y\n            val t = y - z\n            val u = x - w\n            val v =\
    \ y - z\n            val w = z - w\n            val x = x - y\n            val\
    \ y = x - z\n            val z = x - w\n            val a = y - z\n          \
    \  val b = y - w\n            val c = z - w\n            val d = y - w\n     \
    \       val e = z - w\n            val f = y - w\n            val g = z - w\n\
    \            val h = y - w\n            val i = z - w\n            val j = y -\
    \ w\n            val k = z - w\n            val l = y - w\n            val m =\
    \ y - w\n            val n = z - w\n            val o = y - w\n            val\
    \ p = z - w\n            val q = y - w\n            val r = y - w\n          \
    \  val s = z - w\n            val t = y - w\n            val u = y - w\n     \
    \       val v = z - w\n            val w = y - w\n            val x = z - w\n\
    \            val y = z - w\n            val z = z - w\n            val a = z -\
    \ w\n            val b = y - w\n            val c = y - w\n            val d =\
    \ z - w\n            val e = y - w\n            val f = z - w\n            val\
    \ g = y - w\n            val h = z - w\n            val i = y - w\n          \
    \  val j = z - w\n            val k = y - w\n            val l = z - w\n     \
    \       val m = z - w\n            val n = y - w\n            val o = z - w\n\
    \            val p = y - w\n            val q = z - w\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpi5y606ma.scala:118:0 ---------------------------\e\
    [0m\e[0m\n\e[31m118 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi5y606ma.scala:61:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m61 |\e[0m            \e[33mval\e\
    [0m \e[36mw\e[0m = z - w\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mw is already defined as \e[33mvalue\e[0m \e[35mw\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpi5y606ma.scala:62:16 ---------------------------\e[0m\e[0m\n\e[31m62\
    \ |\e[0m            \e[33mval\e[0m \e[36mx\e[0m = x - y\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mx is already defined as \e[33mvalue\e\
    [0m \e[35mx\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpi5y606ma.scala:63:16 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m            \e[33mval\e[0m \e[36my\e[0m = x - z\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0my is already defined\
    \ as \e[33mvalue\e[0m \e[35my\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi5y606ma.scala:64:16 ---------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m            \e[33mval\e[0m \e[36mz\e[0m = x - w\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mz is already defined\
    \ as \e[33mvalue\e[0m \e[35mz\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi5y606ma.scala:65:16 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m            \e[33mval\e[0m \e[36ma\e[0m = y - z\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ma is already defined\
    \ as \e[33mvalue\e[0m \e[35ma\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must"
  stdout: ''
  timestamp: 1660009389
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val len = arr.length\n        val arr1 = arr.toArray\n        val arr2\
    \ = arr1.clone\n        val arr3 = arr2.clone\n        val arr4 = arr3.clone\n\
    \        val arr5 = arr4.clone\n        val arr6 = arr5.clone\n        val arr7\
    \ = arr6.clone\n        val arr8 = arr7.clone\n        val arr9 = arr8.clone\n\
    \        val arr10 = arr9.clone\n        val arr11 = arr10.clone\n        val\
    \ arr12 = arr11.clone\n        val arr13 = arr12.clone\n        val arr14 = arr13.clone\n\
    \        val arr15 = arr14.clone\n        val arr16 = arr15.clone\n        val\
    \ arr17 = arr16.clone\n        val arr18 = arr17.clone\n        val arr19 = arr18.clone\n\
    \        val arr20 = arr19.clone\n        val arr21 = arr20.clone\n        val\
    \ arr22 = arr21.clone\n        val arr23 = arr22.clone\n        val arr24 = arr23.clone\n\
    \        val arr25 = arr24.clone\n        val arr26 = arr25.clone\n        val\
    \ arr27 = arr26.clone\n        val arr28 = arr27.clone\n        val arr29 = arr28.clone\n\
    \        val arr30 = arr29.clone\n        val arr31 = arr30.clone\n        val\
    \ arr32 = arr31.clone\n        val arr33 = arr32.clone\n        val arr34 = arr33.clone\n\
    \        val arr35 = arr34.clone\n        val arr36 = arr35.clone\n        val\
    \ arr37 = arr36.clone\n        val arr38 = arr37.clone\n        val arr39 = arr38.clone\n\
    \        val arr40 = arr39.clone\n        val arr41 = arr40.clone\n        val\
    \ arr42 = arr41.clone\n        val arr43 = arr42.clone\n        val arr44 = arr43.clone\n\
    \        val arr45 = arr44.clone\n        val arr46 = arr45.clone\n        val\
    \ arr47 = arr46.clone\n        val arr48 = arr47.clone\n        val arr49 = arr48.clone\n\
    \        val arr50 = arr49.clone\n        val arr51 = arr50.clone\n        val\
    \ arr52 = arr51.clone\n        val arr53 = arr52.clone\n        val arr54 = arr53.clone\n\
    \        val arr55 = arr54\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgxui0o03.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpgxui0o03.scala:84:5 ---------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val arr1 = arr.toList\n        val arr2 = arr1.reverse\n\
    \        val arr3 = arr2.reverse\n        val arr4 = arr3.reverse\n        val\
    \ arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n        val arr7 = arr6.reverse\n\
    \        val arr8 = arr7.reverse\n        val arr9 = arr8.reverse\n        val\
    \ arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n        val arr12 =\
    \ arr11.reverse\n        val arr13 = arr12.reverse\n        val arr14 = arr13.reverse\n\
    \        val arr15 = arr14.reverse\n        val arr16 = arr15.reverse\n      \
    \  val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n        val arr19\
    \ = arr18.reverse\n        val arr20 = arr19.reverse\n        val arr21 = arr20.reverse\n\
    \        val arr22 = arr21.reverse\n        val arr23 = arr22.reverse\n      \
    \  val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n        val arr26\
    \ = arr25.reverse\n        val arr27 = arr26.reverse\n        val arr28 = arr27.reverse\n\
    \        val arr29 = arr28.reverse\n        val arr30 = arr29.reverse\n      \
    \  val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n        val arr33\
    \ = arr32.reverse\n        val arr34 = arr33.reverse\n        val arr35 = arr34.reverse\n\
    \        val arr36 = arr35.reverse\n        val arr37 = arr36.reverse\n      \
    \  val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n        val arr40\
    \ = arr39.reverse\n        val arr41 = arr40.reverse\n        val arr42 = arr41.reverse\n\
    \        val arr43 = arr42.reverse\n        val arr44 = arr43.reverse\n      \
    \  val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n        val arr47\
    \ = arr46.reverse\n        val arr48 = arr47.reverse\n        val arr49 = arr48.reverse\n\
    \        val arr50 = arr49.reverse\n        val arr51 = arr50.reverse\n      \
    \  val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n        val arr54\
    \ = arr53.reverse\n        val arr55 = arr54.reverse\n        val arr5\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzzengloi.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzzengloi.scala:28:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzzengloi.scala:85:5\
    \ ---------------------\e[0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:34:12 ----------"
  stdout: ''
  timestamp: 1660009387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val arr1 = arr.slice(1, n).reverse\n        val arr2 = arr.slice(1, n).reverse\n\
    \        val arr3 = arr.slice(1, n).reverse\n        val arr4 = arr.slice(1, n).reverse\n\
    \        val arr5 = arr.slice(1, n).reverse\n        val arr6 = arr.slice(1, n).reverse\n\
    \        val arr7 = arr.slice(1, n).reverse\n        val arr8 = arr.slice(1, n).reverse\n\
    \        val arr9 = arr.slice(1, n).reverse\n        val arr10 = arr.slice(1,\
    \ n).reverse\n        val arr11 = arr.slice(1, n).reverse\n        val arr12 =\
    \ arr.slice(1, n).reverse\n        val arr13 = arr.slice(1, n).reverse\n     \
    \   val arr14 = arr.slice(1, n).reverse\n        val arr15 = arr.slice(1, n).reverse\n\
    \        val arr16 = arr.slice(1, n).reverse\n        val arr17 = arr.slice(1,\
    \ n).reverse\n        val arr18 = arr.slice(1, n).reverse\n        val arr19 =\
    \ arr.slice(1, n).reverse\n        val arr20 = arr.slice(1, n).reverse\n     \
    \   val arr21 = arr.slice(1, n).reverse\n        val arr22 = arr.slice(1, n).reverse\n\
    \        val arr23 = arr.slice(1, n).reverse\n        val arr24 = arr.slice(1,\
    \ n).reverse\n        val arr25 = arr.slice(1, n).reverse\n        val arr26 =\
    \ arr.slice(1, n).reverse\n        val arr27 = arr.slice(1, n).reverse\n     \
    \   val arr28 = arr.slice(1, n).reverse\n        val arr29 = arr.slice(1, n).reverse\n\
    \        val arr30 = arr.slice(1, n).reverse\n        val arr31 = arr.slice(1,\
    \ n).reverse\n        val arr32 = arr.slice(1, n).reverse\n        val arr33 =\
    \ arr.slice(1, n).reverse\n        val arr34 = arr.slice(1, n).reverse\n     \
    \   val arr35 = arr.slice(1, n).reverse\n        val arr36 = arr.slice(1, n).reverse\n\
    \        val arr37 = arr.slice(1, n).reverse\n        val arr38 = arr.slice(1,\
    \ n).reverse\n        val arr39 = arr.slice(1, n).reverse\n        val arr40 =\
    \ arr.slice(1, n).reverse\n        val arr41 = arr.slice(1, n).reverse\n     \
    \   val arr42 = arr.slice(1, n).reverse\n        val arr43 = arr.slice\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5ymu2qtd.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5ymu2qtd.scala:71:5 ---------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val arr1 = arr.toArray\n        val arr2 = arr1.clone\n        val arr3 =\
    \ arr2.clone\n        val arr4 = arr3.clone\n        val arr5 = arr4.clone\n \
    \       val arr6 = arr5.clone\n        val arr7 = arr6.clone\n        val arr8\
    \ = arr7.clone\n        val arr9 = arr8.clone\n        val arr10 = arr9.clone\n\
    \        val arr11 = arr10.clone\n        val arr12 = arr11.clone\n        val\
    \ arr13 = arr12.clone\n        val arr14 = arr13.clone\n        val arr15 = arr14.clone\n\
    \        val arr16 = arr15.clone\n        val arr17 = arr16.clone\n        val\
    \ arr18 = arr17.clone\n        val arr19 = arr18.clone\n        val arr20 = arr19.clone\n\
    \        val arr21 = arr20.clone\n        val arr22 = arr21.clone\n        val\
    \ arr23 = arr22.clone\n        val arr24 = arr23.clone\n        val arr25 = arr24.clone\n\
    \        val arr26 = arr25.clone\n        val arr27 = arr26.clone\n        val\
    \ arr28 = arr27.clone\n        val arr29 = arr28.clone\n        val arr30 = arr29.clone\n\
    \        val arr31 = arr30.clone\n        val arr32 = arr31.clone\n        val\
    \ arr33 = arr32.clone\n        val arr34 = arr33.clone\n        val arr35 = arr34.clone\n\
    \        val arr36 = arr35.clone\n        val arr37 = arr36.clone\n        val\
    \ arr38 = arr37.clone\n        val arr39 = arr38.clone\n        val arr40 = arr39.clone\n\
    \        val arr41 = arr40.clone\n        val arr42 = arr41.clone\n        val\
    \ arr43 = arr42.clone\n        val arr44 = arr43.clone\n        val arr45 = arr44.clone\n\
    \        val arr46 = arr45.clone\n        val arr47 = arr46.clone\n        val\
    \ arr48 = arr47.clone\n        val arr49 = arr48.clone\n        val arr50 = arr49.clone\n\
    \        val arr51 = arr50.clone\n        val arr52 = arr51.clone\n        val\
    \ arr53 = arr52.clone\n        val arr54 = arr53.clone\n        val arr55 = arr54.clone\n\
    \        val arr\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5v3nzk6h.scala:84:4 ----------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5v3nzk6h.scala:27:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5v3nzk6h.scala:84:5\
    \ ---------------------\e[0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val result = new Array[Boolean](n)\n        val left = new Array[Long](n)\n\
    \        val right = new Array[Long](n)\n        val leftIndex = 0\n        val\
    \ rightIndex = 0\n        val leftCount = 0\n        val rightCount = 0\n    \
    \    val leftMax = arr.head\n        val rightMax = arr.last\n        val leftMaxIndex\
    \ = arr.indexOf(0)\n        val rightMaxIndex = arr.length - 1\n        val leftMin\
    \ = arr.head\n        val rightMin = arr.last\n        val leftMinIndex = arr.indexOf(0)\n\
    \        val rightMinIndex = arr.length - 1\n        val leftMaxCount = arr.count(x\
    \ => x == leftMax)\n        val rightMaxCount = arr.count(x => x == rightMax)\n\
    \        val leftMinCount = arr.count(x => x == leftMin)\n        val rightMinCount\
    \ = arr.count(x => x == rightMin)\n        val leftMaxIndex = arr.indexOf(0)\n\
    \        val rightMaxIndex = arr.length - 1\n        val leftMinIndex = arr.indexOf(0)\n\
    \        val rightMinIndex = arr.length - 1\n        val leftMaxCount = arr.count(x\
    \ => x == leftMax)\n        val rightMaxCount = arr.count(x => x == rightMax)\n\
    \        val leftMinCount = arr.count(x => x == leftMin)\n        val rightMinCount\
    \ = arr.count(x => x == rightMin)\n        val leftMaxIndex = arr.indexOf(0)\n\
    \        val rightMaxIndex = arr.length - 1\n        val leftMinIndex = arr.indexOf(0)\n\
    \        val rightMinIndex = arr.length - 1\n        val leftMaxCount = arr.count(x\
    \ => x == leftMax)\n        val rightMaxCount = arr.count(x => x == rightMax)\n\
    \        val leftMinCount = arr.count(x => x == leftMin)\n        val rightMinCount\
    \ = arr.count(x => x == rightMin)\n        val leftMaxIndex = arr.indexOf(0)\n\
    \        val rightMaxIndex = arr.length - 1\n        val leftMinIndex = arr.indexOf(0)\n\
    \        val rightMinIndex = arr.length - 1\n        val leftMaxCount = arr.count(x\
    \ => x == leftMax)\n        val rightMaxCount = arr.count(x => x == rightMax)\n\
    \        val leftMinCount = arr.count(x => x == leftMin)\n        val rightMinCount\
    \ = arr.count(x => x == rightMin)\n        val leftMaxIndex = arr.indexOf(0)\n\
    \        val rightMaxIndex = arr.length - 1\n        val leftMinIndex = arr.indexOf(0)\n\
    \        val rightMinIndex = arr.length - 1\n        val leftMaxCount = arr.count(x\
    \ => \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8zwtb3ac.scala:75:41 ---------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m        \e[33mval\e[0m \e[36mleftMaxCount\e[0m = arr.count(\e\
    [36mx\e[0m => \n\e[31m\e[31m   |\e[0m                                        \
    \ ^\e[0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8zwtb3ac.scala:47:12 ---------------------------\e[0m\e[0m\n\e[31m47\
    \ |\e[0m        \e[33mval\e[0m \e[36mleftMaxIndex\e[0m = arr.indexOf(\e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mleftMaxIndex is already defined as \e[33mvalue\e[0m \e[35mleftMaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8zwtb3ac.scala:48:12 ---------------------------\e[0m\e[0m\n\e\
    [31m48 |\e[0m        \e[33mval\e[0m \e[36mrightMaxIndex\e[0m = arr.length - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightMaxIndex is already defined as \e[33mvalue\e[0m \e[35mrightMaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8zwtb3ac.scala:49:12 ---------------------------\e[0m\e[0m\n\e\
    [31m49 |\e[0m        \e[33mval\e[0m \e[36mleftMinIndex\e[0m = arr.indexOf(\e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mleftMinIndex is already defined as \e[33mvalue\e[0m \e[35mleftMinIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8zwtb3ac.scala:50:12 ---------------------------\e[0m\e[0m\n\e\
    [31m50 |\e[0m        \e[33mval\e[0m \e[36mrightMinIndex\e[0m = arr.length - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightMinIn"
  stdout: ''
  timestamp: 1660009395
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val arr1 = arr.toList\n        val arr2 = arr1.reverse\n        val arr3\
    \ = arr2.toList\n        val arr4 = arr3.reverse\n        val arr5 = arr4.reverse\n\
    \        val arr6 = arr5.reverse\n        val arr7 = arr6.reverse\n        val\
    \ arr8 = arr7.reverse\n        val arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n\
    \        val arr11 = arr10.reverse\n        val arr12 = arr11.reverse\n      \
    \  val arr13 = arr12.reverse\n        val arr14 = arr13.reverse\n        val arr15\
    \ = arr14.reverse\n        val arr16 = arr15.reverse\n        val arr17 = arr16.reverse\n\
    \        val arr18 = arr17.reverse\n        val arr19 = arr18.reverse\n      \
    \  val arr20 = arr19.reverse\n        val arr21 = arr20.reverse\n        val arr22\
    \ = arr21.reverse\n        val arr23 = arr22.reverse\n        val arr24 = arr23.reverse\n\
    \        val arr25 = arr24.reverse\n        val arr26 = arr25.reverse\n      \
    \  val arr27 = arr26.reverse\n        val arr28 = arr27.reverse\n        val arr29\
    \ = arr28.reverse\n        val arr30 = arr29.reverse\n        val arr31 = arr30.reverse\n\
    \        val arr32 = arr31.reverse\n        val arr33 = arr32.reverse\n      \
    \  val arr34 = arr33.reverse\n        val arr35 = arr34.reverse\n        val arr36\
    \ = arr35.reverse\n        val arr37 = arr36.reverse\n        val arr38 = arr37.reverse\n\
    \        val arr39 = arr38.reverse\n        val arr40 = arr39.reverse\n      \
    \  val arr41 = arr40.reverse\n        val arr42 = arr41.reverse\n        val arr43\
    \ = arr42.reverse\n        val arr44 = arr43.reverse\n        val arr45 = arr44.reverse\n\
    \        val arr46 = arr45.reverse\n        val arr47 = arr46.reverse\n      \
    \  val arr48 = arr47.reverse\n        val arr49 = arr48.reverse\n        val arr50\
    \ = arr49.reverse\n        val arr51 = arr50.reverse\n        val arr52 = arr51.reverse\n\
    \        val arr53 = arr52.reverse\n        val arr54 = arr53.reverse\n      \
    \  val arr55 = arr54.reverse\n        val arr56 = arr55.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp542gd0nh.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp542gd0nh.scala:84:5 ---------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009399
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if(arr.isEmpty) true\n        else if(arr.size == 1)\
    \ true\n        else {\n            val n = arr.size\n            val m = arr.head\n\
    \            val l = arr.last\n            val r = arr.init\n            val m\
    \ = m >> 1\n            val l = l >> 1\n            val r = r >> 1\n         \
    \   val m = m >> 1\n            val l = l >> 1\n            val r = r >> 1\n \
    \           val m = m >> 1\n            val l = l >> 1\n            val r = r\
    \ >> 1\n            val m = m >> 1\n            val l = l >> 1\n            val\
    \ r = r >> 1\n            val m = m >> 1\n            val l = l >> 1\n       \
    \     val r = r >> 1\n            val m = m >> 1\n            val l = l >> 1\n\
    \            val r = r >> 1\n            val m = m >> 1\n            val l = l\
    \ >> 1\n            val r = r >> 1\n            val m = m >> 1\n            val\
    \ l = l >> 1\n            val r = r >> 1\n            val m = m >> 1\n       \
    \     val l = l >> 1\n            val r = r >> 1\n            val m = m >> 1\n\
    \            val l = l >> 1\n            val r = r >> 1\n            val m = m\
    \ >> 1\n            val l = l >> 1\n            val r = r >> 1\n            val\
    \ m = m >> 1\n            val l = l >> 1\n            val r = r >> 1\n       \
    \     val m = m >> 1\n            val l = l >> 1\n            val r = r >> 1\n\
    \            val m = m >> 1\n            val l = l >> 1\n            val r = r\
    \ >> 1\n            val m = m >> 1\n            val l = l >> 1\n            val\
    \ r = r >> 1\n            val m = m >> 1\n            val l = l >> 1\n       \
    \     val r = r >> 1\n            val m = m >> 1\n            val l = l >> 1\n\
    \            val r = r >> 1\n            val m = m >> 1\n            val l = l\
    \ >> 1\n            val r = r >> 1\n            val m = m >> 1\n            val\
    \ l = l >> 1\n            val r = r >> 1\n            val m = m >> 1\n       \
    \     val l = l >> 1\n            val r = r >> 1\n            val m = m >> 1\n\
    \            val l = l >> 1\n            val r = r >> 1\n            val m = m\
    \ >> 1\n            val l = l >> 1\n            val r = r >> 1\n            val\
    \ m = m >> 1\n            val l = l \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpeyb9zva9.scala:111:0 ---------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpeyb9zva9.scala:33:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e\
    [0m \e[36mm\e[0m = m >> \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpeyb9zva9.scala:34:16 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m            \e[33mval\e[0m \e[36ml\e[0m = l >> \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpeyb9zva9.scala:35:16 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = r >> \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is\
    \ already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpeyb9zva9.scala:36:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e\
    [0m \e[36mm\e[0m = m >> \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpeyb9zva9.scala:37:16 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m            \e[33mval\e[0m \e[36ml\e[0m = l >> \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1660009401
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val n = arr.size\n    \
    \    val m = arr.head\n        val arr1 = arr.tail\n        val arr2 = arr1.reverse\n\
    \        val arr3 = arr2.reverse\n        val arr4 = arr3.reverse\n        val\
    \ arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n        val arr7 = arr6.reverse\n\
    \        val arr8 = arr7.reverse\n        val arr9 = arr8.reverse\n        val\
    \ arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n        val arr12 =\
    \ arr11.reverse\n        val arr13 = arr12.reverse\n        val arr14 = arr13.reverse\n\
    \        val arr15 = arr14.reverse\n        val arr16 = arr15.reverse\n      \
    \  val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n        val arr19\
    \ = arr18.reverse\n        val arr20 = arr19.reverse\n        val arr21 = arr20.reverse\n\
    \        val arr22 = arr21.reverse\n        val arr23 = arr22.reverse\n      \
    \  val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n        val arr26\
    \ = arr25.reverse\n        val arr27 = arr26.reverse\n        val arr28 = arr27.reverse\n\
    \        val arr29 = arr28.reverse\n        val arr30 = arr29.reverse\n      \
    \  val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n        val arr33\
    \ = arr32.reverse\n        val arr34 = arr33.reverse\n        val arr35 = arr34.reverse\n\
    \        val arr36 = arr35.reverse\n        val arr37 = arr36.reverse\n      \
    \  val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n        val arr40\
    \ = arr39.reverse\n        val arr41 = arr40.reverse\n        val arr42 = arr41.reverse\n\
    \        val arr43 = arr42.reverse\n        val arr44 = arr43.reverse\n      \
    \  val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n        val arr47\
    \ = arr46.reverse\n        val arr48 = arr47.reverse\n        val arr49 = arr48.reverse\n\
    \        val arr50 = arr49.reverse\n        val arr51 = arr50.reverse\n      \
    \  val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n        val arr54\
    \ = arr53.reverse\n        val arr55 = arr54.reverse\n        val arr5\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpar73vt_4.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpar73vt_4.scala:26:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpar73vt_4.scala:85:5\
    \ ---------------------\e[0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009399
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.to\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpczvepghc.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpczvepghc.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpczvepghc.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpczvepghc.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpczvepghc.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpczvepghc.scala:33:12 ----------"
  stdout: ''
  timestamp: 1660009398
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n        else\
    \ {\n            val sortedArr = arr.sortBy(x => x)\n            val sortedArr\
    \ = sortedArr.drop(n - 1)\n            val sortedArr = sortedArr.take(n - 1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \            val sortedArr = sortedArr.drop(1)\n            val sortedArr = sortedArr.take(1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxddl7fjd.scala:84:0 ----------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxddl7fjd.scala:30:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e\
    [0m \e[36msortedArr\e[0m = sortedArr.drop(n - \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxddl7fjd.scala:31:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e\
    [0m \e[36msortedArr\e[0m = sortedArr.take(n - \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxddl7fjd.scala:32:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36msortedArr\e[0m = sortedArr.drop(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxddl7fjd.scala:33:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e\
    [0m \e[36msortedArr\e[0m = sortedArr.take(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxddl7fjd.sca"
  stdout: ''
  timestamp: 1660009400
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arrSize = arr.size\n        if(arrSize == 0) return\
    \ true\n        val arr = arr.toArray\n        val arrSize = arr.size\n      \
    \  val arr1 = arr.toArray\n        val arr2 = arr.toArray\n        val arr3 =\
    \ arr.toArray\n        val arr4 = arr.toArray\n        val arr5 = arr.toArray\n\
    \        val arr6 = arr.toArray\n        val arr7 = arr.toArray\n        val arr8\
    \ = arr.toArray\n        val arr9 = arr.toArray\n        val arr10 = arr.toArray\n\
    \        val arr11 = arr.toArray\n        val arr12 = arr.toArray\n        val\
    \ arr13 = arr.toArray\n        val arr14 = arr.toArray\n        val arr15 = arr.toArray\n\
    \        val arr16 = arr.toArray\n        val arr17 = arr.toArray\n        val\
    \ arr18 = arr.toArray\n        val arr19 = arr.toArray\n        val arr20 = arr.toArray\n\
    \        val arr21 = arr.toArray\n        val arr22 = arr.toArray\n        val\
    \ arr23 = arr.toArray\n        val arr24 = arr.toArray\n        val arr25 = arr.toArray\n\
    \        val arr26 = arr.toArray\n        val arr27 = arr.toArray\n        val\
    \ arr28 = arr.toArray\n        val arr29 = arr.toArray\n        val arr30 = arr.toArray\n\
    \        val arr31 = arr.toArray\n        val arr32 = arr.toArray\n        val\
    \ arr33 = arr.toArray\n        val arr34 = arr.toArray\n        val arr35 = arr.toArray\n\
    \        val arr36 = arr.toArray\n        val arr37 = arr.toArray\n        val\
    \ arr38 = arr.toArray\n        val arr39 = arr.toArray\n        val arr40 = arr.toArray\n\
    \        val arr41 = arr.toArray\n        val arr42 = arr.toArray\n        val\
    \ arr43 = arr.toArray\n        val arr44 = arr.toArray\n        val arr45 = arr.toArray\n\
    \        val arr46 = arr.toArray\n        val arr47 = arr.toArray\n        val\
    \ arr48 = arr.toArray\n        val arr49 = arr.toArray\n        val arr50 = arr.toArray\n\
    \        val arr51 = arr.toArray\n        val arr52 = arr.toArray\n        val\
    \ arr53 = arr.toArray\n        val arr54 = arr.toArray\n        val arr55 = arr.toArray\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmbj6_bwc.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marrSize\e[0m = arr.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marrSize\
    \ is already defined as \e[33mvalue\e[0m \e[35marrSize\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmbj6_bwc.scala:28:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmbj6_bwc.scala:86:5\
    \ ---------------------\e[0m\e[0m\n\e[31m86 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009400
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val n = arr.size\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr1 = arr.toArray\n        val\
    \ arr2 = arr.toArray\n        val arr3 = arr.toArray\n        val arr4 = arr.toArray\n\
    \        val arr5 = arr.toArray\n        val arr6 = arr.toArray\n        val arr7\
    \ = arr.toArray\n        val arr8 = arr.toArray\n        val arr9 = arr.toArray\n\
    \        val arr10 = arr.toArray\n        val arr11 = arr.toArray\n        val\
    \ arr12 = arr.toArray\n        val arr13 = arr.toArray\n        val arr14 = arr.toArray\n\
    \        val arr15 = arr.toArray\n        val arr16 = arr.toArray\n        val\
    \ arr17 = arr.toArray\n        val arr18 = arr.toArray\n        val arr19 = arr.toArray\n\
    \        val arr20 = arr.toArray\n        val arr21 = arr.toArray\n        val\
    \ arr22 = arr.toArray\n        val arr23 = arr.toArray\n        val arr24 = arr.toArray\n\
    \        val arr25 = arr.toArray\n        val arr26 = arr.toArray\n        val\
    \ arr27 = arr.toArray\n        val arr28 = arr.toArray\n        val arr29 = arr.toArray\n\
    \        val arr30 = arr.toArray\n        val arr31 = arr.toArray\n        val\
    \ arr32 = arr.toArray\n        val arr33 = arr.toArray\n        val arr34 = arr.toArray\n\
    \        val arr35 = arr.toArray\n        val arr36 = arr.toArray\n        val\
    \ arr37 = arr.toArray\n        val arr38 = arr.toArray\n        val arr39 = arr.toArray\n\
    \        val arr40 = arr.toArray\n        val arr41 = arr.toArray\n        val\
    \ arr42 = arr.toArray\n        val arr43 = arr.toArray\n        val arr44 = arr.toArray\n\
    \        val arr45 = arr.toArray\n        val arr46 = arr.toArray\n        val\
    \ arr47 = arr.toArray\n        val arr48 = arr.toArray\n        val arr49 = arr.toArray\n\
    \        val arr50 = arr.toArray\n        val arr51 = arr.toArray\n        val\
    \ arr52 = arr.toArray\n        val arr53 = arr.toArray\n        val arr54 = arr.toArray\n\
    \        val arr55 = arr.toArray\n        val arr56 = arr.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptym6da6s.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmptym6da6s.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptym6da6s.scala:26:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptym6da6s.scala:85:5\
    \ ---------------------\e[0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009399
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toSet\n        val len = arr.size\n   \
    \     val set = new mutable.HashSet[Long]()\n        var i = 0\n        var j\
    \ = 0\n        var k = 0\n        var temp = 0\n        var flag = false\n   \
    \     while(i < len) {\n            temp = arr(i)\n            while(j < len)\
    \ {\n                if(arr(j) < temp) {\n                    set.add(arr(j))\n\
    \                    j++\n                } else {\n                    set.add(temp);\n\
    \                    j = 0\n                    flag = true\n                }\n\
    \            }\n            if(flag) {\n                set.add(temp);\n     \
    \           k++\n                flag = false\n            }\n            i +=\
    \ 1\n        }\n        set.size == arr.size\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmptz7zsjdg.scala:39:23 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmptz7zsjdg.scala:49:21\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m49 |\e[0m       \
    \         flag = \e[31mfalse\e[0m\n\e[31m\e[31m   |\e[0m                     ^\e\
    [0m\n\e[31m   |\e[0m                     end of statement expected but '=' found\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptz7zsjdg.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toSet\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmptz7zsjdg.scala:28:22 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mset\e[0m = \e[33mnew\e[0m\
    \ mutable.HashSet[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                  \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptz7zsjdg.scala:48:17\
    \ ------------------------\e[0m\e[0m\n\e[31m48 |\e[0m                k++\n\e[31m\e\
    [31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m                value ++\
    \ is not a member of Int\n5 errors found\n"
  stdout: ''
  timestamp: 1660009400
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n        else\
    \ {\n            val l = arr.head\n            val r = arr.last\n            val\
    \ m = arr.lastIndexOf(l) + 1\n            val n = arr.lastIndexOf(r)\n       \
    \     val k = arr.lastIndexOf(l) + 2\n            val m = arr.lastIndexOf(r) +\
    \ 2\n            val l = arr.take(m)\n            val r = arr.drop(n)\n      \
    \      val m = arr.lastIndexOf(l) + 1\n            val n = arr.lastIndexOf(r)\n\
    \            val k = arr.lastIndexOf(l) + 2\n            val m = arr.lastIndexOf(r)\
    \ + 2\n            val l = arr.take(m)\n            val r = arr.drop(n)\n    \
    \        val m = arr.lastIndexOf(l) + 1\n            val n = arr.lastIndexOf(r)\n\
    \            val k = arr.lastIndexOf(l) + 2\n            val m = arr.lastIndexOf(r)\
    \ + 2\n            val l = arr.take(m)\n            val r = arr.drop(n)\n    \
    \        val m = arr.lastIndexOf(l) + 1\n            val n = arr.lastIndexOf(r)\n\
    \            val k = arr.lastIndexOf(l) + 2\n            val m = arr.lastIndexOf(r)\
    \ + 2\n            val l = arr.take(m)\n            val r = arr.drop(n)\n    \
    \        val m = arr.lastIndexOf(l) + 1\n            val n = arr.lastIndexOf(r)\n\
    \            val k = arr.lastIndexOf(l) + 2\n            val m = arr.lastIndexOf(r)\
    \ + 2\n            val l = arr.take(m)\n            val r = arr.drop(n)\n    \
    \        val m = arr.lastIndexOf(l) + 1\n            val n = arr.lastIndexOf(r)\n\
    \            val k = arr.lastIndexOf(l) + 2\n            val m = arr.lastIndexOf(r)\
    \ + 2\n            val l = arr.take(m)\n            val r = arr.drop(n)\n    \
    \        val m = arr.lastIndexOf(l) + 1\n            val n = arr.lastIndexOf(r)\n\
    \            val k = arr.lastIndexOf(l) + 2\n            val m = arr.lastIndexOf(r)\
    \ + 2\n            val l = arr.take(m)\n            val r = arr.drop(n)\n    \
    \        val m = arr.lastIndexOf(l) + 1\n            val n = arr.lastIndexOf(r)\n\
    \            val k = arr.lastIndexOf(l) + 2\n            val m = arr.lastIndexOf(r)\
    \ + 2\n            val l = arr.take(m)\n            val r = arr.drop(n)\n    \
    \        val m = arr.lastIndexOf(l) + 1\n            val n = arr.lastIndexOf(r)\n\
    \            val k = arr.lastIndexOf(l) + 2\n            val m = arr.lastIndexOf(r)\
    \ + 2\n            val l = arr.take(m)\n            val r = arr.drop(n)\n    \
    \        val m = arr.lastIndexOf(l) + 1\n            val n = arr.lastIndexOf(r)\n\
    \            val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpalttoz3p.scala:87:15 ---------------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m            \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m  \
    \             ^\e[0m\n\e[31m   |\e[0m               pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpalttoz3p.scala:98:0 ----------------------------\e\
    [0m\e[0m\n\e[31m98 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpalttoz3p.scala:34:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e\
    [0m \e[36mm\e[0m = arr.lastIndexOf(r) + \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpalttoz3p.scala:35:16 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36ml\e[0m = arr.take(m)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is\
    \ already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpalttoz3p.scala:36:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e\
    [0m \e[36mr\e[0m = arr.drop(n)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpalttoz3p.scala:37:16 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m            \e[33mval\e[0m \e[36mm\e[0m = arr.lastIndexOf(l) + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mN"
  stdout: ''
  timestamp: 1660009401
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr1 = arr.toArray\n        val arr2 = arr.toArray\n        val arr3\
    \ = arr.toArray\n        val arr4 = arr.toArray\n        val arr5 = arr.toArray\n\
    \        val arr6 = arr.toArray\n        val arr7 = arr.toArray\n        val arr8\
    \ = arr.toArray\n        val arr9 = arr.toArray\n        val arr10 = arr.toArray\n\
    \        val arr11 = arr.toArray\n        val arr12 = arr.toArray\n        val\
    \ arr13 = arr.toArray\n        val arr14 = arr.toArray\n        val arr15 = arr.toArray\n\
    \        val arr16 = arr.toArray\n        val arr17 = arr.toArray\n        val\
    \ arr18 = arr.toArray\n        val arr19 = arr.toArray\n        val arr20 = arr.toArray\n\
    \        val arr21 = arr.toArray\n        val arr22 = arr.toArray\n        val\
    \ arr23 = arr.toArray\n        val arr24 = arr.toArray\n        val arr25 = arr.toArray\n\
    \        val arr26 = arr.toArray\n        val arr27 = arr.toArray\n        val\
    \ arr28 = arr.toArray\n        val arr29 = arr.toArray\n        val arr30 = arr.toArray\n\
    \        val arr31 = arr.toArray\n        val arr32 = arr.toArray\n        val\
    \ arr33 = arr.toArray\n        val arr34 = arr.toArray\n        val arr35 = arr.toArray\n\
    \        val arr36 = arr.toArray\n        val arr37 = arr.toArray\n        val\
    \ arr38 = arr.toArray\n        val arr39 = arr.toArray\n        val arr40 = arr.toArray\n\
    \        val arr41 = arr.toArray\n        val arr42 = arr.toArray\n        val\
    \ arr43 = arr.toArray\n        val arr44 = arr.toArray\n        val arr45 = arr.toArray\n\
    \        val arr46 = arr.toArray\n        val arr47 = arr.toArray\n        val\
    \ arr48 = arr.toArray\n        val arr49 = arr.toArray\n        val arr50 = arr.toArray\n\
    \        val arr51 = arr.toArray\n        val arr52 = arr.toArray\n        val\
    \ arr53 = arr.toArray\n        val arr54 = arr.toArray\n        val arr55 = arr.toArray\n\
    \        val arr56 = arr.toArray\n        val arr57 = arr.to\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6je09d7i.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp6je09d7i.scala:85:5 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009400
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toSet\n        val len = arr.length\n        val arr =\
    \ arr.toSeq\n        val len = arr.length\n        val arr = arr.toIterator\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toList\n        val len = arr.length\n \
    \       val arr = arr.toSet\n        val len = arr.length\n        val arr = arr.toSeq\n\
    \        val len = arr.length\n        val arr = arr.toIterator\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toSet\n        val len = arr.length\n        val arr = arr.toSeq\n     \
    \   val len = arr.length\n        val arr = arr.toIterator\n        val len =\
    \ arr.length\n        val arr = arr.toArray\n        val len = arr.length\n  \
    \      val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toSet\n\
    \        val len = arr.length\n        val arr = arr.toSeq\n        val len =\
    \ arr.length\n        val arr = arr.toIterator\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toList\n        val len = arr.length\n        val arr = arr.toSet\n  \
    \      val len = arr.length\n        val arr = arr.toSeq\n        val len = arr.length\n\
    \        val arr = arr.toIterator\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toSet\n        val len =\
    \ arr.length\n        val arr = arr.toSeq\n        val len = arr.length\n    \
    \    val arr = arr.toIterator\n        val len = arr.length\n        val arr =\
    \ arr.toArray\n        val len = arr.length\n        val arr = arr.toList\n  \
    \      val len = arr.length\n        val arr = arr.toSet\n        val len = arr.length\n\
    \        val arr = arr.toSeq\n        val len = arr.length\n        val arr =\
    \ arr.toIterator\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toSet\n        val len = arr.length\n    \
    \    val arr = arr.toSeq\n        val len = arr.length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7ed4rjv_.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7ed4rjv_.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7ed4rjv_.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toSet\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7ed4rjv_.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7ed4rjv_.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toSeq\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7ed4rjv_.scala:34:12 --------------"
  stdout: ''
  timestamp: 1660009400
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n        else\
    \ {\n            val arr = arr.toList\n            val first = arr(0)\n      \
    \      val last = arr(n)\n            val first = arr.head\n            val last\
    \ = arr.last\n            val first = arr.head\n            val last = arr.last\n\
    \            val first = arr.head\n            val last = arr.last\n         \
    \   val first = arr.head\n            val last = arr.last\n            val first\
    \ = arr.head\n            val last = arr.last\n            val first = arr.head\n\
    \            val last = arr.last\n            val first = arr.head\n         \
    \   val last = arr.last\n            val first = arr.head\n            val last\
    \ = arr.last\n            val first = arr.head\n            val last = arr.last\n\
    \            val first = arr.head\n            val last = arr.last\n         \
    \   val first = arr.head\n            val last = arr.last\n            val first\
    \ = arr.head\n            val last = arr.last\n            val first = arr.head\n\
    \            val last = arr.last\n            val first = arr.head\n         \
    \   val last = arr.last\n            val first = arr.head\n            val last\
    \ = arr.last\n            val first = arr.head\n            val last = arr.last\n\
    \            val first = arr.head\n            val last = arr.last\n         \
    \   val first = arr.head\n            val last = arr.last\n            val first\
    \ = arr.head\n            val last = arr.last\n            val first = arr.head\n\
    \            val last = arr.last\n            val first = arr.head\n         \
    \   val last = arr.last\n            val first = arr.head\n            val last\
    \ = arr.last\n            val first = arr.head\n            val last = arr.last\n\
    \            val first = arr.head\n            val last = arr.last\n         \
    \   val first = arr.head\n            val last = arr.last\n            val first\
    \ = arr.head\n            val last = arr.last\n            val first = arr.head\n\
    \            val last = arr.last\n            val first = arr.head\n         \
    \   val last = arr.last\n            val first = arr.head\n            val last\
    \ = arr.last\n            val first = arr.head\n            val last = arr.last\n\
    \            val first = arr.head\n            val last = arr.last\n         \
    \   val first = arr.head\n            val last = arr.last\n            val first\
    \ = arr.head\n            val last = arr.last\n            val first = arr.head\n\
    \            val last = arr.last\n            val first = arr.head\n         \
    \   val last = arr.last\n            val first = arr.head\n            val last\
    \ = arr.last\n            val first = arr.head\n            val last = arr.last\n\
    \            val first = arr.head\n            val last = arr.last\n         \
    \   val first = arr.head\n            val last = arr.last\n            val first\
    \ = arr.head\n            val last = arr.last\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9l3gdbs2.scala:123:0 ---------------------------\e\
    [0m\e[0m\n\e[31m123 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9l3gdbs2.scala:32:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mfirst\e[0m = arr.head\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mfirst is already defined as \e[33mvalue\e[0m \e[35mfirst\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9l3gdbs2.scala:33:16 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m            \e[33mval\e[0m \e[36mlast\e[0m = arr.last\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlast is already\
    \ defined as \e[33mvalue\e[0m \e[35mlast\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9l3gdbs2.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mfirst\e[0m = arr.head\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mfirst\
    \ is already defined as \e[33mvalue\e[0m \e[35mfirst\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9l3gdbs2.scala:35:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e\
    [0m \e[36mlast\e[0m = arr.last\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlast is already defined as \e[33mvalue\e[0m \e[35mlast\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9l3gdbs2.scala:36:16 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m            \e[33mval\e[0m \e[36mfirst\e[0m = arr.head\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mfirst is already"
  stdout: ''
  timestamp: 1660009401
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val result = new Array[Boolean](n)\n        val left = new Array[Long](n)\n\
    \        val right = new Array[Long](n)\n        val temp = new Array[Long](n)\n\
    \        val leftIndex = 0\n        val rightIndex = 0\n        val tempIndex\
    \ = 0\n        val leftMax = arr(leftIndex)\n        val rightMax = arr(rightIndex)\n\
    \        val tempMax = arr(tempIndex)\n        while(leftIndex < n && rightIndex\
    \ < n && tempIndex < n) {\n            while(leftIndex < n && arr(leftIndex) <\
    \ leftMax) {\n                leftIndex += 1\n            }\n            while(rightIndex\
    \ < n && arr(rightIndex) < rightMax) {\n                rightIndex += 1\n    \
    \        }\n            while(tempIndex < n && arr(tempIndex) < tempMax) {\n \
    \               tempIndex += 1\n            }\n            while(leftIndex < n\
    \ && rightIndex < n && tempIndex < n && arr(leftIndex) < arr(rightIndex) && arr(tempIndex)\
    \ < arr(leftIndex)) {\n                temp(tempIndex) = arr(tempIndex)\n    \
    \            tempIndex += 1\n            }\n            while(leftIndex < n &&\
    \ rightIndex < n && tempIndex < n && arr(leftIndex) < arr(rightIndex) && arr(tempIndex)\
    \ < arr(rightIndex)) {\n                temp(tempIndex) = arr(tempIndex)\n   \
    \             tempIndex += 1\n            }\n            while(leftIndex < n &&\
    \ rightIndex < n && tempIndex < n && arr(leftIndex) < arr(rightIndex) && arr(tempIndex)\
    \ < arr(rightIndex)) {\n                temp(tempIndex) = arr(tempIndex)\n   \
    \             tempIndex += 1\n            }\n            while(leftIndex < n &&\
    \ rightIndex < n && tempIndex < n && arr(leftIndex) < arr(rightIndex) && arr(tempIndex)\
    \ < arr(rightIndex)) {\n                temp(tempIndex) = arr(tempIndex)\n   \
    \             tempIndex += 1\n            }\n            while(leftIndex < n &&\
    \ rightIndex < n && tempIndex < n && arr(leftIndex) < arr(rightIndex) && arr(tempIndex)\
    \ < arr(rightIndex)) {\n                temp(tempIndex) = arr(tempIndex)\n   \
    \             tempIndex += 1\n            }\n            while(leftIndex < n &&\
    \ rightIndex < n && tempIndex < n && arr(leftIndex) < arr(rightIndex) && arr(tempIndex)\
    \ < arr(rightIndex)) {\n                temp(tempIndex) = arr\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnlsenso6.scala:80:0 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnlsenso6.scala:27:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnlsenso6.scala:40:26\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                leftIndex\
    \ += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m            value += is not a member of Int - did you mean leftIndex.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnlsenso6.scala:43:27 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                rightIndex += \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value\
    \ += is not a member of Int - did you mean rightIndex.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpnlsenso6.scala:46:26 ------------------------\e[0m\e\
    [0m\n\e[31m46 |\e[0m                tempIndex += \e[31m1\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of Int - did you mean tempIndex.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpnlsenso6.scala:50:26 ------------------------\e[0m\e[0m\n\
    \e[31m50 |\e[0m                tempIndex += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of Int - did you mean tempIndex.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpnlsenso6.scala:54:26 ------------------------\e[0m\e[0m\n\e[31m54\
    \ |\e[0m                tempIndex += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean tempIndex.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpnlsenso6"
  stdout: ''
  timestamp: 1660009400
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) true\n      \
    \  else {\n            val arr = arr.sortBy(x => x)\n            val l = arr.head\n\
    \            val r = arr.last\n            val m = arr.length\n            val\
    \ k = arr.lastIndex\n            val x = arr.take(m)\n            val y = arr.drop(m)\n\
    \            val z = arr.takeRight(m)\n            val w = arr.dropRight(m)\n\
    \            val a = arr.take(k)\n            val b = arr.drop(k)\n          \
    \  val c = arr.takeRight(k)\n            val d = arr.dropRight(k)\n          \
    \  val e = arr.take(l)\n            val f = arr.drop(l)\n            val g = arr.takeRight(l)\n\
    \            val h = arr.dropRight(l)\n            val i = arr.take(x)\n     \
    \       val j = arr.drop(x)\n            val k = arr.takeRight(x)\n          \
    \  val l = arr.dropRight(x)\n            val m = arr.take(y)\n            val\
    \ n = arr.drop(y)\n            val o = arr.takeRight(y)\n            val p = arr.dropRight(y)\n\
    \            val q = arr.take(z)\n            val r = arr.drop(z)\n          \
    \  val s = arr.takeRight(z)\n            val t = arr.dropRight(z)\n          \
    \  val u = arr.take(w)\n            val v = arr.drop(w)\n            val w = arr.takeRight(w)\n\
    \            val x = arr.dropRight(w)\n            val y = arr.take(a)\n     \
    \       val z = arr.drop(a)\n            val a = arr.take(b)\n            val\
    \ b = arr.drop(b)\n            val c = arr.takeRight(b)\n            val d = arr.dropRight(b)\n\
    \            val e = arr.take(c)\n            val f = arr.drop(c)\n          \
    \  val g = arr.takeRight(c)\n            val h = arr.dropRight(c)\n          \
    \  val i = arr.take(d)\n            val j = arr.drop(d)\n            val k = arr.takeRight(d)\n\
    \            val l = arr.dropRight(d)\n            val m = arr.take(e)\n     \
    \       val n = arr.drop(e)\n            val o = arr.takeRight(e)\n          \
    \  val p = arr.dropRight(e)\n            val q = arr.take(f)\n            val\
    \ r = arr.drop(f)\n            val s = arr.takeRight(f)\n            val t = arr.dropRight(f)\n\
    \            val u = arr.take(g)\n            val v = arr.drop(g)\n          \
    \  val w = arr.takeRight(g)\n            val x = arr.dropRight(g)\n          \
    \  val y = arr.take(h)\n            val z = arr.drop(h)\n            val a = arr.take(i)\n\
    \            val b = arr.drop(i)\n            val c = \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp23v5qdo9.scala:92:19 ---------------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m            \e[33mval\e[0m \e[36mc\e[0m = \n\e[31m\e\
    [31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                   expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp23v5qdo9.scala:103:0 ---------------------------\e[0m\e[0m\n\e[31m103\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof\
    \ found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp23v5qdo9.scala:48:16 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m            \e[33mval\e[0m \e[36mk\e[0m = arr.takeRight(x)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mk\
    \ is already defined as \e[33mvalue\e[0m \e[35mk\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp23v5qdo9.scala:49:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m49 |\e[0m            \e[33mval\e\
    [0m \e[36ml\e[0m = arr.dropRight(x)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0ml is already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp23v5qdo9.scala:50:16 ---------------------------\e[0m\e[0m\n\e[31m50\
    \ |\e[0m            \e[33mval\e[0m \e[36mm\e[0m = arr.take(y)\n\e[31m\e[31m  \
    \ |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp23v5qdo9.scala:55:16 ---------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = arr.drop(z)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is\
    \ already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m "
  stdout: ''
  timestamp: 1660009401
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val n = arr.length\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_9o861mn.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_9o861mn.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(arr.length-\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_9o861mn.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.take(arr.length-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined\
    \ as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_9o861mn.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_9o861mn.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(arr.length-\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overl"
  stdout: ''
  timestamp: 1660009400
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val n = arr.length\n  \
    \      val m = arr.last\n        val arr = arr.dropRight(1)\n        val arr =\
    \ arr.takeRight(n)\n        val arr = arr.sortBy(x => x)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n    \
    \    val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val\
    \ arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr\
    \ = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n    \
    \    val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val\
    \ arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr\
    \ = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n    \
    \    val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val\
    \ arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr\
    \ = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n    \
    \    val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val\
    \ arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr\
    \ = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n    \
    \    val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val\
    \ arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr\
    \ = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n    \
    \    val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val\
    \ arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr\
    \ = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.takeRight(n)\n        val arr = arr.takeRight(n)\n    \
    \    val arr = arr.takeRight(n)\n        val arr = \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpp41ucwv7.scala:90:17 ---------------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = \n\e[31m\e[31m\
    \   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpp41ucwv7.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpp41ucwv7.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.takeRight(n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpp41ucwv7.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpp41ucwv7.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.takeRight(n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpp41uc"
  stdout: ''
  timestamp: 1660009400
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val\
    \ arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val\
    \ arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val\
    \ arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val\
    \ arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(x => x)\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpphrzdjyq.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpphrzdjyq.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpphrzdjyq.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpphrzdjyq.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpphrzdjyq.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Nam"
  stdout: ''
  timestamp: 1660009401
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val maxLen = len - 1\n        val maxVal = arr(maxLen)\n        val minVal\
    \ = arr(0)\n        val maxIndex = 0\n        val minIndex = 0\n        var maxValIndex\
    \ = 0\n        var minValIndex = 0\n        var maxValIndex = 0\n        var minValIndex\
    \ = 0\n        var maxValIndex = 0\n        var minValIndex = 0\n        var maxValIndex\
    \ = 0\n        var minValIndex = 0\n        var maxValIndex = 0\n        var minValIndex\
    \ = 0\n        var maxValIndex = 0\n        var minValIndex = 0\n        var maxValIndex\
    \ = 0\n        var minValIndex = 0\n        var maxValIndex = 0\n        var minValIndex\
    \ = 0\n        var maxValIndex = 0\n        var minValIndex = 0\n        var maxValIndex\
    \ = 0\n        var minValIndex = 0\n        var maxValIndex = 0\n        var minValIndex\
    \ = 0\n        var maxValIndex = 0\n        var minValIndex = 0\n        var maxValIndex\
    \ = 0\n        var minValIndex = 0\n        var maxValIndex = 0\n        var minValIndex\
    \ = 0\n        var maxValIndex = 0\n        var minValIndex = 0\n        var maxValIndex\
    \ = 0\n        var minValIndex = 0\n        var maxValIndex = 0\n        var minValIndex\
    \ = 0\n        var maxValIndex = 0\n        var minValIndex = 0\n        var maxValIndex\
    \ = 0\n        var minValIndex = 0\n        var maxValIndex = 0\n        var minValIndex\
    \ = 0\n        var maxValIndex = 0\n        var minValIndex = 0\n        var maxValIndex\
    \ = 0\n        var minValIndex = 0\n        var maxValIndex = 0\n        var minValIndex\
    \ = 0\n        var maxValIndex = 0\n        var minValIndex = 0\n        var maxValIndex\
    \ = 0\n        var minValIndex = 0\n        var maxValIndex = 0\n        var minValIndex\
    \ = 0\n        var maxValIndex = 0\n        var minValIndex = 0\n        var maxValIndex\
    \ = 0\n        var minValIndex = 0\n        var maxValIndex = 0\n        var minValIndex\
    \ = 0\n        var maxValIndex = 0\n        var minValIndex = 0\n        var maxValIndex\
    \ = 0\n        var minValIndex = 0\n        var maxValIndex = 0\n        var minValIndex\
    \ = 0\n        var maxValIndex = 0\n        var minValIndex = 0\n        var maxValIndex\
    \ = 0\n        var minValIndex = 0\n        var maxValIndex = 0\n        var minValIndex\
    \ = 0\n        var maxValIndex = 0\n        var minValIndex = 0\n        var maxValIndex\
    \ = 0\n        var minValIndex = 0\n        var maxValIndex = 0\n        var minValIndex\
    \ = 0\n        var maxValIndex\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3w4wi7or.scala:110:4 ---------------------------\e\
    [0m\e[0m\n\e[31m110 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3w4wi7or.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mmaxValIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxValIndex is already defined as \e[33mvariable\e[0m \e[35mmaxValIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3w4wi7or.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mvar\e[0m \e[36mminValIndex\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminValIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mminValIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3w4wi7or.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mmaxValIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxValIndex is already defined as \e[33mvariable\e[0m \e[35mmaxValIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3w4wi7or.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mvar\e[0m \e[36mminValIndex\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminValIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mminValIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3w4wi7or.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mmaxValIndex\e[0m = \e[31m0\e[0m\n\e[3"
  stdout: ''
  timestamp: 1660009401
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toArray\n \
    \       val len = arr.length\n        val arr1 = arr.slice(1, len)\n        val\
    \ arr2 = arr.slice(0, len)\n        val arr3 = arr.slice(1, len)\n        val\
    \ arr4 = arr.slice(0, len)\n        val arr5 = arr.slice(1, len)\n        val\
    \ arr6 = arr.slice(0, len)\n        val arr7 = arr.slice(1, len)\n        val\
    \ arr8 = arr.slice(0, len)\n        val arr9 = arr.slice(1, len)\n        val\
    \ arr10 = arr.slice(0, len)\n        val arr11 = arr.slice(1, len)\n        val\
    \ arr12 = arr.slice(0, len)\n        val arr13 = arr.slice(1, len)\n        val\
    \ arr14 = arr.slice(0, len)\n        val arr15 = arr.slice(1, len)\n        val\
    \ arr16 = arr.slice(0, len)\n        val arr17 = arr.slice(1, len)\n        val\
    \ arr18 = arr.slice(0, len)\n        val arr19 = arr.slice(1, len)\n        val\
    \ arr20 = arr.slice(0, len)\n        val arr21 = arr.slice(1, len)\n        val\
    \ arr22 = arr.slice(0, len)\n        val arr23 = arr.slice(1, len)\n        val\
    \ arr24 = arr.slice(0, len)\n        val arr25 = arr.slice(1, len)\n        val\
    \ arr26 = arr.slice(0, len)\n        val arr27 = arr.slice(1, len)\n        val\
    \ arr28 = arr.slice(0, len)\n        val arr29 = arr.slice(1, len)\n        val\
    \ arr30 = arr.slice(0, len)\n        val arr31 = arr.slice(1, len)\n        val\
    \ arr32 = arr.slice(0, len)\n        val arr33 = arr.slice(1, len)\n        val\
    \ arr34 = arr.slice(0, len)\n        val arr35 = arr.slice(1, len)\n        val\
    \ arr36 = arr.slice(0, len)\n        val arr37 = arr.slice(1, len)\n        val\
    \ arr38 = arr.slice(0, len)\n        val arr39 = arr.slice(1, len)\n        val\
    \ arr40 = arr.slice(0, len)\n        val arr41 = arr.slice(1, len)\n        val\
    \ arr42 = arr.slice(0, len)\n        val arr43 = arr.slice(1, len)\n        val\
    \ arr44 = arr.slice(0, len)\n        val arr45 = arr.slice(1, len)\n        val\
    \ arr46 = arr.slice(0, len)\n        val arr47 = arr.slice(1, len)\n        val\
    \ arr48 = arr.slice(0, len)\n        val arr49 = arr.slice(1, len)\n        val\
    \ arr50 = arr.slice(0, len)\n        val arr51 = arr.slice(1, len)\n        val\
    \ arr52 = arr.slice(0, len)\n        val arr53 = arr.slice(1, len)\n        \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjq_fp7oc.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjq_fp7oc.scala:83:5 ---------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009401
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val m = arr.head\n      \
    \  val r = new Array[Long](n)\n        val s = new Array[Long](n)\n        val\
    \ t = new Array[Long](n)\n        val u = new Array[Long](n)\n        val v =\
    \ new Array[Long](n)\n        val w = new Array[Long](n)\n        val x = new\
    \ Array[Long](n)\n        val y = new Array[Long](n)\n        val z = new Array[Long](n)\n\
    \        val a = new Array[Long](n)\n        val b = new Array[Long](n)\n    \
    \    val c = new Array[Long](n)\n        val d = new Array[Long](n)\n        val\
    \ e = new Array[Long](n)\n        val f = new Array[Long](n)\n        val g =\
    \ new Array[Long](n)\n        val h = new Array[Long](n)\n        val i = new\
    \ Array[Long](n)\n        val j = new Array[Long](n)\n        val k = new Array[Long](n)\n\
    \        val l = new Array[Long](n)\n        val m1 = new Array[Long](n)\n   \
    \     val m2 = new Array[Long](n)\n        val m3 = new Array[Long](n)\n     \
    \   val m4 = new Array[Long](n)\n        val m5 = new Array[Long](n)\n       \
    \ val m6 = new Array[Long](n)\n        val m7 = new Array[Long](n)\n        val\
    \ m8 = new Array[Long](n)\n        val m9 = new Array[Long](n)\n        val m10\
    \ = new Array[Long](n)\n        val m11 = new Array[Long](n)\n        val m12\
    \ = new Array[Long](n)\n        val m13 = new Array[Long](n)\n        val m14\
    \ = new Array[Long](n)\n        val m15 = new Array[Long](n)\n        val m16\
    \ = new Array[Long](n)\n        val m17 = new Array[Long](n)\n        val m18\
    \ = new Array[Long](n)\n        val m19 = new Array[Long](n)\n        val m20\
    \ = new Array[Long](n)\n        val m21 = new Array[Long](n)\n        val m22\
    \ = new Array[Long](n)\n        val m23 = new Array[Long](n)\n        val m24\
    \ = new Array[Long](n)\n        val m25 = new Array[Long](n)\n        val m26\
    \ = new Array[Long](n)\n        val m27 = new \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0uty06ur.scala:76:4 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp0uty06ur.scala:76:5 ---------------------\e[0m\e[0m\n\e[31m76\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009399
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val sortedArr = arr.sortBy(_)\n        val lastElement = sortedArr.last\n\
    \        val lastElementIndex = arr.lastIndexOf(lastElement)\n        val lastElementIndex\
    \ = lastElementIndex + 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = last\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpaouzlp_q.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlastElementIndex\e[0m =\
    \ lastElementIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlastElementIndex is already defined as \e[33mvalue\e[0m \e\
    [35mlastElementIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpaouzlp_q.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlastElementIndex\e[0m =\
    \ lastElementIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlastElementIndex is already defined as \e[33mvalue\e[0m \e\
    [35mlastElementIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpaouzlp_q.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mlastElementIndex\e[0m =\
    \ lastElementIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlastElementIndex is already defined as \e[33mvalue\e[0m \e\
    [35mlastElementIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpaouzlp_q.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mlastElementIndex\e[0m =\
    \ lastElementIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlastElementIndex is already defined as \e[33mvalue\e[0m \e\
    [35mlastElementIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpaouzlp_q.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mlastEl"
  stdout: ''
  timestamp: 1660009402
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e"
  stdout: ''
  timestamp: 1660009388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:34:12 ----------"
  stdout: ''
  timestamp: 1660009387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val m = arr.head\n        val arr = arr.tail\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2g219ebn.scala:100:4 ---------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp2g219ebn.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as \e\
    [33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2g219ebn.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2g219ebn.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2g219ebn.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2g219ebn.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35"
  stdout: ''
  timestamp: 1660009403
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toArray\n \
    \       val result = new Array[Boolean](n)\n        var i = 0\n        var j =\
    \ 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n =\
    \ 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r =\
    \ 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v =\
    \ 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z =\
    \ 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d =\
    \ 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h =\
    \ 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l =\
    \ 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p =\
    \ 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t =\
    \ 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x =\
    \ 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b =\
    \ 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f =\
    \ 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j =\
    \ 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n =\
    \ 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r =\
    \ 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v =\
    \ 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z =\
    \ 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d =\
    \ 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h =\
    \ 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l =\
    \ 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p =\
    \ 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t =\
    \ 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x =\
    \ 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b =\
    \ 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f =\
    \ 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j =\
    \ 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n =\
    \ 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r =\
    \ 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v =\
    \ 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z =\
    \ 0\n        var a = 0\n        var b = 0\n        var c = 0\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprwz6gmg1.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mvar\e[0m \e[36mn\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprwz6gmg1.scala:55:12 ---------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m        \e[33mvar\e[0m \e[36mi\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mi is already defined\
    \ as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprwz6gmg1.scala:56:12 ---------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m        \e[33mvar\e[0m \e[36mj\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mj is already defined\
    \ as \e[33mvariable\e[0m \e[35mj\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprwz6gmg1.scala:57:12 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mvar\e[0m \e[36mk\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mk is already defined\
    \ as \e[33mvariable\e[0m \e[35mk\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprwz6gmg1.scala:58:12 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mvar\e[0m \e[36ml\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvariable\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprwz6gmg1.scala:59:12 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mvar\e[0m \e[36mm\e[0m = "
  stdout: ''
  timestamp: 1660009409
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val result = new Array[Boolean](n)\n        var i = 0\n        var j =\
    \ 0\n        var k = 0\n        var temp = 0\n        while(i < n) {\n       \
    \     while(j < n) {\n                while(k >= 0) {\n                    if(arr(i)\
    \ > arr(j)) {\n                        temp = arr(i)\n                       \
    \ arr(i) = arr(j)\n                        arr(j) = temp\n                   \
    \ }\n                    k = k - 1\n                }\n                j = j +\
    \ 1\n            }\n            i = i + 1\n        }\n        for(i<-n;i<n;i++)\
    \ {\n            result(i) = arr(i) > arr(0)\n        }\n        for(i<-n;i<n;i++)\
    \ {\n            result(i) = result(i) && arr(i) > arr(0)\n        }\n       \
    \ for(i<-n;i<n;i++) {\n            result(i) = result(i) && arr(i) > arr(0)\n\
    \        }\n        for(i<-n;i<n;i++) {\n            result(i) = result(i) &&\
    \ arr(i) > arr(0)\n        }\n        for(i<-n;i<n;i++) {\n            result(i)\
    \ = result(i) && arr(i) > arr(0)\n        }\n        for(i<-n;i<n;i++) {\n   \
    \         result(i) = result(i) && arr(i) > arr(0)\n        }\n        for(i<-n;i<n;i++)\
    \ {\n            result(i) = result(i) && arr(i) > arr(0)\n        }\n       \
    \ for(i<-n;i<n;i++) {\n            result(i) = result(i) && arr(i) > arr(0)\n\
    \        }\n        for(i<-n;i<n;i++) {\n            result(i) = result(i) &&\
    \ arr(i) > arr(0)\n        }\n        for(i<-n;i<n;i++) {\n            result(i)\
    \ = result(i) && arr(i) > arr(0)\n        }\n        for(i<-n;i<n;i++) {\n   \
    \         result(i) = result(i) && arr(i) > arr(0)\n        }\n        for(i<-n;i<n;i++)\
    \ {\n            result(i) = result(i) && arr(i) > arr(0)\n        }\n       \
    \ for(i<-n;i<n;i++) {\n            result(i) = result(i) && arr(i) > arr(0)\n\
    \        }\n        for(i<-n;i<n;i++) {\n            result(i) = result(i) &&\
    \ arr(i) > arr(0)\n        }\n        for(i<-n;i<n;i++) {\n            result(i)\
    \ = result(i) && arr(i) > arr(0)\n        }\n        for(i<-n;i<n;i++) {\n   \
    \         result(i) = result(i) && arr(i) > arr(0)\n        }\n        for(i<-n;i<n;i++)\
    \ {\n            result(i) = result(i) && arr(i) > arr(0)\n        }\n       \
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpz4d3bupe.scala:47:20 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mfor\e[0m(i<-n;i<n;i++) {\n\e[31m\e[31m\
    \   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    '<-'\
    \ expected, but ';' found\n\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpz4d3bupe.scala:47:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mfor\e[0m(i<-n;i<n;i++)\
    \ {\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m    \
    \                    pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpz4d3bupe.scala:50:20 ---------------------------\e[0m\e\
    [0m\n\e[31m50 |\e[0m        \e[33mfor\e[0m(i<-n;i<n;i++) {\n\e[31m\e[31m   |\e\
    [0m                    ^\e[0m\n\e[31m   |\e[0m                    '<-' expected,\
    \ but ';' found\n\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpz4d3bupe.scala:50:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m50 |\e[0m        \e[33mfor\e[0m(i<-n;i<n;i++)\
    \ {\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m    \
    \                    pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpz4d3bupe.scala:53:20 ---------------------------\e[0m\e\
    [0m\n\e[31m53 |\e[0m        \e[33mfor\e[0m(i<-n;i<n;i++) {\n\e[31m\e[31m   |\e\
    [0m                    ^\e[0m\n\e[31m   |\e[0m                    '<-' expected,\
    \ but ';' found\n\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpz4d3bupe.scala:53:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m53 |\e[0m        \e[33mfor\e[0m(i<-n;i<n;i++)\
    \ {\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m    \
    \                    pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpz4d3bupe.scala:56:20 ---------------------------\e[0m\e\
    [0m\n\e[31m56 |\e[0m        \e[33mfor\e[0m(i<-n;i<n;i++) {\n\e[31m\e[31m   |\e\
    [0m                    ^\e[0m\n\e[31m   |\e[0m                    '<-' expected,\
    \ but ';' found\n\e[31m\e[31m-"
  stdout: ''
  timestamp: 1660009406
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val n = arr.size\n    \
    \    val m = arr.head\n        val arr = arr.tail\n        val arr1 = arr.toArray\n\
    \        val arr2 = arr.toArray\n        val arr3 = arr.toArray\n        val arr4\
    \ = arr.toArray\n        val arr5 = arr.toArray\n        val arr6 = arr.toArray\n\
    \        val arr7 = arr.toArray\n        val arr8 = arr.toArray\n        val arr9\
    \ = arr.toArray\n        val arr10 = arr.toArray\n        val arr11 = arr.toArray\n\
    \        val arr12 = arr.toArray\n        val arr13 = arr.toArray\n        val\
    \ arr14 = arr.toArray\n        val arr15 = arr.toArray\n        val arr16 = arr.toArray\n\
    \        val arr17 = arr.toArray\n        val arr18 = arr.toArray\n        val\
    \ arr19 = arr.toArray\n        val arr20 = arr.toArray\n        val arr21 = arr.toArray\n\
    \        val arr22 = arr.toArray\n        val arr23 = arr.toArray\n        val\
    \ arr24 = arr.toArray\n        val arr25 = arr.toArray\n        val arr26 = arr.toArray\n\
    \        val arr27 = arr.toArray\n        val arr28 = arr.toArray\n        val\
    \ arr29 = arr.toArray\n        val arr30 = arr.toArray\n        val arr31 = arr.toArray\n\
    \        val arr32 = arr.toArray\n        val arr33 = arr.toArray\n        val\
    \ arr34 = arr.toArray\n        val arr35 = arr.toArray\n        val arr36 = arr.toArray\n\
    \        val arr37 = arr.toArray\n        val arr38 = arr.toArray\n        val\
    \ arr39 = arr.toArray\n        val arr40 = arr.toArray\n        val arr41 = arr.toArray\n\
    \        val arr42 = arr.toArray\n        val arr43 = arr.toArray\n        val\
    \ arr44 = arr.toArray\n        val arr45 = arr.toArray\n        val arr46 = arr.toArray\n\
    \        val arr47 = arr.toArray\n        val arr48 = arr.toArray\n        val\
    \ arr49 = arr.toArray\n        val arr50 = arr.toArray\n        val arr51 = arr.toArray\n\
    \        val arr52 = arr.toArray\n        val arr53 = arr.toArray\n        val\
    \ arr54 = arr.toArray\n        val arr55 = arr.toArray\n        val arr5\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdofsg7m3.scala:86:4 ----------------------------\e\
    [0m\e[0m\n\e[31m86 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdofsg7m3.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpdofsg7m3.scala:26:18 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpdofsg7m3.scala:86:5 ---------------------\e[0m\e[0m\n\e[31m86\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009410
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val arr1 = arr.toArray\n        val arr2 = arr.toBuffer\n        val arr3\
    \ = arr.toSeq\n        val arr4 = arr.toSet\n        val arr5 = arr.toMap\n  \
    \      val arr6 = arr.toSeq.sortBy(-_)\n        val arr7 = arr.toSeq.sortBy(-_.reverse)\n\
    \        val arr8 = arr.toSeq.sortBy(-_.compareTo(_))\n        val arr9 = arr.toSeq.sortBy(-_.compareTo(_.reverse))\n\
    \        val arr10 = arr.toSeq.sortBy(-_.compareTo(_.reverse)).reverse\n     \
    \   val arr11 = arr.toSeq.sortBy(-_.compareTo(_.reverse)).reverse\n        val\
    \ arr12 = arr.toSeq.sortBy(-_.compareTo(_.reverse)).reverse\n        val arr13\
    \ = arr.toSeq.sortBy(-_.compareTo(_.reverse)).reverse\n        val arr14 = arr.toSeq.sortBy(-_.compareTo(_.reverse)).reverse\n\
    \        val arr15 = arr.toSeq.sortBy(-_.compareTo(_.reverse)).reverse\n     \
    \   val arr16 = arr.toSeq.sortBy(-_.compareTo(_.reverse)).reverse\n        val\
    \ arr17 = arr.toSeq.sortBy(-_.compareTo(_.reverse)).reverse\n        val arr18\
    \ = arr.toSeq.sortBy(-_.compareTo(_.reverse)).reverse\n        val arr19 = arr.toSeq.sortBy(-_.compareTo(_.reverse)).reverse\n\
    \        val arr20 = arr.toSeq.sortBy(-_.compareTo(_.reverse)).reverse\n     \
    \   val arr21 = arr.toSeq.sortBy(-_.compareTo(_.reverse)).reverse\n        val\
    \ arr22 = arr.toSeq.sortBy(-_.compareTo(_.reverse)).reverse\n        val arr23\
    \ = arr.toSeq.sortBy(-_.compareTo(_.reverse)).reverse\n        val arr24 = arr.toSeq.sortBy(-_.compareTo(_.reverse)).reverse\n\
    \        val arr25 = arr.toSeq.sortBy(-_.compareTo(_.reverse)).reverse\n     \
    \   val arr26 = arr.toSeq.sortBy(-_.compareTo(_.reverse)).reverse\n        val\
    \ arr27 = arr.toSeq.sortBy(-_.compareTo(_.reverse)).reverse\n        val arr28\
    \ = arr.toSeq.sortBy(-_.compareTo(_.reverse)).reverse\n        val arr29 = arr.toSeq.sortBy(-_.compareTo(_.reverse))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpueoc7m__.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpueoc7m__.scala:57:5 ---------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009411
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) true\n      \
    \  else {\n            val arr = arr.toList\n            val n = arr.length\n\
    \            val m = arr.last\n            val r = n - 1\n            val c =\
    \ arr.head\n            val d = arr.last\n            val a = arr.head\n     \
    \       val b = arr.last\n            val e = arr.head\n            val f = arr.last\n\
    \            val g = arr.head\n            val h = arr.last\n            val i\
    \ = arr.head\n            val j = arr.last\n            val k = arr.head\n   \
    \         val l = arr.last\n            val m = arr.head\n            val n =\
    \ arr.last\n            val o = arr.head\n            val p = arr.last\n     \
    \       val q = arr.head\n            val r = arr.last\n            val s = arr.head\n\
    \            val t = arr.last\n            val u = arr.head\n            val v\
    \ = arr.last\n            val w = arr.head\n            val x = arr.last\n   \
    \         val y = arr.head\n            val z = arr.last\n            val a =\
    \ arr.head\n            val b = arr.last\n            val c = arr.head\n     \
    \       val d = arr.last\n            val e = arr.head\n            val f = arr.last\n\
    \            val g = arr.head\n            val h = arr.last\n            val i\
    \ = arr.head\n            val j = arr.last\n            val k = arr.head\n   \
    \         val l = arr.last\n            val m = arr.head\n            val n =\
    \ arr.last\n            val o = arr.head\n            val p = arr.last\n     \
    \       val q = arr.head\n            val r = arr.last\n            val s = arr.head\n\
    \            val t = arr.last\n            val u = arr.head\n            val v\
    \ = arr.last\n            val w = arr.head\n            val x = arr.last\n   \
    \         val y = arr.head\n            val z = arr.last\n            val a =\
    \ arr.head\n            val b = arr.last\n            val c = arr.head\n     \
    \       val d = arr.last\n            val e = arr.head\n            val f = arr.last\n\
    \            val g = arr.head\n            val h = arr.last\n            val i\
    \ = arr.head\n            val j = arr.last\n            val k = arr.head\n   \
    \         val l = arr.last\n            val m = arr.head\n            val n =\
    \ arr.last\n            val o = arr.head\n            val p = arr.last\n     \
    \       val q = arr.head\n            val r = arr.last\n            val s = arr.head\n\
    \            val t = arr.last\n            val u = arr.head\n            val v\
    \ = arr.last\n            val w = arr.head\n            val x = arr.last\n   \
    \         val y = arr.head\n            val z = arr.last\n            val a =\
    \ arr.head\n\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4jide6qv.scala:123:0 ---------------------------\e\
    [0m\e[0m\n\e[31m123 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4jide6qv.scala:45:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m            \e[33mval\e\
    [0m \e[36mm\e[0m = arr.head\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp4jide6qv.scala:46:16 ---------------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m            \e[33mval\e[0m \e[36mn\e[0m = arr.last\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined as \e\
    [33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4jide6qv.scala:50:16 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = arr.last\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4jide6qv.scala:59:16 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m            \e[33mval\e[0m \e[36ma\e[0m = arr.head\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ma is already\
    \ defined as \e[33mvalue\e[0m \e[35ma\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4jide6qv.scala:60:16 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m            \e[33mval\e[0m \e[36mb\e[0m = arr.last\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mb is already\
    \ defined as \e[33mvalue\e[0m \e[35mb\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNot"
  stdout: ''
  timestamp: 1660009414
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e"
  stdout: ''
  timestamp: 1660009388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(_)\n        val arr = arr.drop(arr.length-1)\n     \
    \   val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(_)\n      \
    \  val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(_)\n        val arr = arr.drop(arr.length-1)\n \
    \       val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(_)\n  \
    \      val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(_)\n        val arr = arr.drop(arr.length-1)\n \
    \       val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(_)\n  \
    \      val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(_)\n        val arr = arr.drop(arr.length-1)\n \
    \       val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(_)\n  \
    \      val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(_)\n        val arr = arr.drop(arr.length-1)\n \
    \       val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(_)\n  \
    \      val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(_)\n        val arr = arr.drop(arr.length-1)\n \
    \       val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(_)\n  \
    \      val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(_)\n        val arr = arr.drop(arr.length-1)\n \
    \       val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(_)\n  \
    \      val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(_)\n        val arr = arr.drop(arr.length-1)\n \
    \       val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(_)\n  \
    \      val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.sortBy(_)\n        val arr = arr.drop(arr.length-1)\n \
    \       val arr = arr.take(arr.length-1)\n        val arr = arr.sortBy(\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpnzg2cte_.scala:79:29 ---------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnzg2cte_.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnzg2cte_.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.drop(arr.length-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined\
    \ as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnzg2cte_.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.take(arr.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpnzg2cte_.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined\
    \ as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31"
  stdout: ''
  timestamp: 1660009413
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e"
  stdout: ''
  timestamp: 1660009388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val result = new Array[Boolean](n + 1)\n        val arr = arr.toList\n\
    \        val n = arr.length\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var temp = 0\n        var flag = false\n        while(i < n)\
    \ {\n            temp = arr(i)\n            arr(i) = arr(j)\n            arr(j)\
    \ = temp\n            i += 1\n            j += 1\n            k += 1\n       \
    \ }\n        arr(0) = 0\n        arr(n) = 0\n        arr(k) = 0\n        arr(n\
    \ - 1) = 0\n        arr(n - 2) = 0\n        arr(n - 3) = 0\n        arr(n - 4)\
    \ = 0\n        arr(n - 5) = 0\n        arr(n - 6) = 0\n        arr(n - 7) = 0\n\
    \        arr(n - 8) = 0\n        arr(n - 9) = 0\n        arr(n - 10) = 0\n   \
    \     arr(n - 11) = 0\n        arr(n - 12) = 0\n        arr(n - 13) = 0\n    \
    \    arr(n - 14) = 0\n        arr(n - 15) = 0\n        arr(n - 16) = 0\n     \
    \   arr(n - 17) = 0\n        arr(n - 18) = 0\n        arr(n - 19) = 0\n      \
    \  arr(n - 20) = 0\n        arr(n - 21) = 0\n        arr(n - 22) = 0\n       \
    \ arr(n - 23) = 0\n        arr(n - 24) = 0\n        arr(n - 25) = 0\n        arr(n\
    \ - 26) = 0\n        arr(n - 27) = 0\n        arr(n - 28) = 0\n        arr(n -\
    \ 29) = 0\n        arr(n - 30) = 0\n        arr(n - 31) = 0\n        arr(n - 32)\
    \ = 0\n        arr(n - 33) = 0\n        arr(n - 34) = 0\n        arr(n - 35) =\
    \ 0\n        arr(n - 36) = 0\n        arr(n - 37) = 0\n        arr(n - 38) = 0\n\
    \        arr(n - 39) = 0\n        arr(n - 40) = 0\n        arr(n - 41) = 0\n \
    \       arr(n - 42) = 0\n        arr(n - 43) = 0\n        arr(n - 44) = 0\n  \
    \      arr(n - 45) = 0\n        arr(n - 46) = 0\n        arr(n - 47) = 0\n   \
    \     arr(n - 48) = 0\n        arr(n - 49) = 0\n        arr(n - 50) = 0\n    \
    \    arr(n - 51) = 0\n        arr(n - 52) = 0\n        arr(n - 53) = 0\n     \
    \   arr(n - 54)\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb_t10eo0.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb_t10eo0.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb_t10eo0.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009408
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val newArr = new mutable.ArrayBuffer[Long]()\n        val newArr2 = new\
    \ mutable.ArrayBuffer[Long]()\n        val newArr3 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr4 = new mutable.ArrayBuffer[Long]()\n        val newArr5 =\
    \ new mutable.ArrayBuffer[Long]()\n        val newArr6 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr7 = new mutable.ArrayBuffer[Long]()\n        val newArr8 =\
    \ new mutable.ArrayBuffer[Long]()\n        val newArr9 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr10 = new mutable.ArrayBuffer[Long]()\n        val newArr11\
    \ = new mutable.ArrayBuffer[Long]()\n        val newArr12 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr13 = new mutable.ArrayBuffer[Long]()\n        val newArr14\
    \ = new mutable.ArrayBuffer[Long]()\n        val newArr15 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr16 = new mutable.ArrayBuffer[Long]()\n        val newArr17\
    \ = new mutable.ArrayBuffer[Long]()\n        val newArr18 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr19 = new mutable.ArrayBuffer[Long]()\n        val newArr20\
    \ = new mutable.ArrayBuffer[Long]()\n        val newArr21 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr22 = new mutable.ArrayBuffer[Long]()\n        val newArr23\
    \ = new mutable.ArrayBuffer[Long]()\n        val newArr24 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr25 = new mutable.ArrayBuffer[Long]()\n        val newArr26\
    \ = new mutable.ArrayBuffer[Long]()\n        val newArr27 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr28 = new mutable.ArrayBuffer[Long]()\n        val newArr29\
    \ = new mutable.ArrayBuffer[Long]()\n        val newArr30 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr31 = new mutable.ArrayBuffer[Long]()\n        val newArr32\
    \ = new mutable.ArrayBuffer[Long]()\n        val newArr33 = new mutable.ArrayBuffer[Long]()\n\
    \        val newArr34 = new mutable.ArrayBuffer[Long]()\n        val newArr35\
    \ = new mutable.ArrayBuffer[Long]()\n        val newArr36 = new mut\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpf0czi2vw.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpf0czi2vw.scala:28:25 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mnewArr\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf0czi2vw.scala:29:26\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mnewArr2\e[0m = \e[33mnew\e[0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpf0czi2vw.scala:30:26 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mnewArr3\e[0m = \e[33mnew\e[0m\
    \ mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf0czi2vw.scala:31:26\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mnewArr4\e[0m = \e[33mnew\e[0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpf0czi2vw.scala:32:26 "
  stdout: ''
  timestamp: 1660009412
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val n = arr.length\n  \
    \      val m = arr.head\n        val arr = arr.tail\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = arr.drop(1).dropRight(1)\n\
    \        val arr = arr.drop(1).dropRight(1)\n        val arr = \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp80mi6s53.scala:74:17 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = \n\e[31m\e[31m\
    \   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp80mi6s53.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as \e\
    [33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp80mi6s53.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(\e[31m1\e\
    [0m).dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp80mi6s53.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(\e[31m1\e[0m).dropRight(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp80mi6s53.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(\e[31m1\e[0m).dropRight(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of topl"
  stdout: ''
  timestamp: 1660009413
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val sorted = arr.sortBy(x => x)\n        val first = sorted.head\n      \
    \  val last = sorted.last\n        val first = arr.take(n - 1).foldLeft(last)((x,\
    \ y) => x.rightShift(y))\n        val last = arr.take(n - 1).foldLeft(first)((x,\
    \ y) => x.rightShift(y))\n        val first = arr.take(n - 1).foldLeft(last)((x,\
    \ y) => x.rightShift(y))\n        val last = arr.take(n - 1).foldLeft(first)((x,\
    \ y) => x.rightShift(y))\n        val first = arr.take(n - 1).foldLeft(last)((x,\
    \ y) => x.rightShift(y))\n        val last = arr.take(n - 1).foldLeft(first)((x,\
    \ y) => x.rightShift(y))\n        val first = arr.take(n - 1).foldLeft(last)((x,\
    \ y) => x.rightShift(y))\n        val last = arr.take(n - 1).foldLeft(first)((x,\
    \ y) => x.rightShift(y))\n        val first = arr.take(n - 1).foldLeft(last)((x,\
    \ y) => x.rightShift(y))\n        val last = arr.take(n - 1).foldLeft(first)((x,\
    \ y) => x.rightShift(y))\n        val first = arr.take(n - 1).foldLeft(last)((x,\
    \ y) => x.rightShift(y))\n        val last = arr.take(n - 1).foldLeft(first)((x,\
    \ y) => x.rightShift(y))\n        val first = arr.take(n - 1).foldLeft(last)((x,\
    \ y) => x.rightShift(y))\n        val last = arr.take(n - 1).foldLeft(first)((x,\
    \ y) => x.rightShift(y))\n        val first = arr.take(n - 1).foldLeft(last)((x,\
    \ y) => x.rightShift(y))\n        val last = arr.take(n - 1).foldLeft(first)((x,\
    \ y) => x.rightShift(y))\n        val first = arr.take(n - 1).foldLeft(last)((x,\
    \ y) => x.rightShift(y))\n        val last = arr.take(n - 1).foldLeft(first)((x,\
    \ y) => x.rightShift(y))\n        val first = arr.take(n - 1).foldLeft(last)((x,\
    \ y) => x.rightShift(y))\n        val last = arr.take(n - 1).foldLeft(first)((x,\
    \ y) => x.rightShift(y))\n        val first = arr.take(n - 1).foldLeft(last)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0sng1ji3.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mfirst\e[0m = arr.take(n\
    \ - \e[31m1\e[0m).foldLeft(last)((\e[36mx\e[0m, \e[36my\e[0m) => x.rightShift(y))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mfirst is already defined as \e[33mvalue\e[0m \e[35mfirst\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0sng1ji3.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mlast\e[0m = arr.take(n - \e[31m1\e[0m).foldLeft(first)((\e\
    [36mx\e[0m, \e[36my\e[0m) => x.rightShift(y))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlast is already defined as \e[33mvalue\e[0m \e[35mlast\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp0sng1ji3.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36mfirst\e[0m = arr.take(n - \e[31m1\e[0m).foldLeft(last)((\e\
    [36mx\e[0m, \e[36my\e[0m) => x.rightShift(y))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mfirst is already defined as \e[33mvalue\e[0m \e[35mfirst\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0sng1ji3.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mlast\e[0m = arr.take(n - \e[31m1\e[0m).foldLeft(first)((\e\
    [36mx\e[0m, \e[36my\e[0m) => x.rightShift(y))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlast is already defined as \e[33mvalue\e[0m \e[35mlast\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be define"
  stdout: ''
  timestamp: 1660009413
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n        else\
    \ {\n            val arr = arr.sortBy(_)\n            val first = arr.head\n \
    \           val last = arr.last\n            val mid = arr.size / 2\n        \
    \    val left = arr.take(mid)\n            val right = arr.drop(mid)\n       \
    \     val leftSorted = left.sortBy(_)\n            val rightSorted = right.sortBy(_)\n\
    \            val leftSorted = left.sortBy(_)\n            val rightSorted = right.sortBy(_)\n\
    \            val leftSorted = left.sortBy(_)\n            val rightSorted = right.sortBy(_)\n\
    \            val leftSorted = left.sortBy(_)\n            val rightSorted = right.sortBy(_)\n\
    \            val leftSorted = left.sortBy(_)\n            val rightSorted = right.sortBy(_)\n\
    \            val leftSorted = left.sortBy(_)\n            val rightSorted = right.sortBy(_)\n\
    \            val leftSorted = left.sortBy(_)\n            val rightSorted = right.sortBy(_)\n\
    \            val leftSorted = left.sortBy(_)\n            val rightSorted = right.sortBy(_)\n\
    \            val leftSorted = left.sortBy(_)\n            val rightSorted = right.sortBy(_)\n\
    \            val leftSorted = left.sortBy(_)\n            val rightSorted = right.sortBy(_)\n\
    \            val leftSorted = left.sortBy(_)\n            val rightSorted = right.sortBy(_)\n\
    \            val leftSorted = left.sortBy(_)\n            val rightSorted = right.sortBy(_)\n\
    \            val leftSorted = left.sortBy(_)\n            val rightSorted = right.sortBy(_)\n\
    \            val leftSorted = left.sortBy(_)\n            val rightSorted = right.sortBy(_)\n\
    \            val leftSorted = left.sortBy(_)\n            val rightSorted = right.sortBy(_)\n\
    \            val leftSorted = left.sortBy(_)\n            val rightSorted = right.sortBy(_)\n\
    \            val leftSorted = left.sortBy(_)\n            val rightSorted = right.sortBy(_)\n\
    \            val leftSorted = left.sortBy(_)\n            val rightSorted = right.sortBy(_)\n\
    \            val leftSorted = left.sortBy(_)\n            val rightSorted = right.sortBy(_)\n\
    \            val leftSorted = left.sortBy(_)\n            val rightSorted = right.sortBy(_)\n\
    \            val leftSorted = left.sortBy(_)\n            \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp07m72czd.scala:87:0 ----------------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp07m72czd.scala:37:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e\
    [0m \e[36mleftSorted\e[0m = left.sortBy(_)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftSorted is already defined as \e[33mvalue\e[0m \e[35mleftSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp07m72czd.scala:38:16 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m            \e[33mval\e[0m \e[36mrightSorted\e[0m = right.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mrightSorted is already defined as \e[33mvalue\e[0m \e[35mrightSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp07m72czd.scala:39:16 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m            \e[33mval\e[0m \e[36mleftSorted\e[0m = left.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mleftSorted is already defined as \e[33mvalue\e[0m \e[35mleftSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp07m72czd.scala:40:16 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m            \e[33mval\e[0m \e[36mrightSorted\e[0m = right.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mrightSorted is already defined as \e[33mvalue\e[0m \e[35mrightSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp07m72czd.scala:41:16 ---------------------------\e[0m\e[0m\n\e\
    [3"
  stdout: ''
  timestamp: 1660009414
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) true\n      \
    \  else {\n            val sortedArr = arr.sortWith(_ < _)\n            val sortedArrLength\
    \ = sortedArr.length\n            val sortedArrLength = sortedArr.length\n   \
    \         val sortedArrLength = sortedArr.length\n            val sortedArrLength\
    \ = sortedArr.length\n            val sortedArrLength = sortedArr.length\n   \
    \         val sortedArrLength = sortedArr.length\n            val sortedArrLength\
    \ = sortedArr.length\n            val sortedArrLength = sortedArr.length\n   \
    \         val sortedArrLength = sortedArr.length\n            val sortedArrLength\
    \ = sortedArr.length\n            val sortedArrLength = sortedArr.length\n   \
    \         val sortedArrLength = sortedArr.length\n            val sortedArrLength\
    \ = sortedArr.length\n            val sortedArrLength = sortedArr.length\n   \
    \         val sortedArrLength = sortedArr.length\n            val sortedArrLength\
    \ = sortedArr.length\n            val sortedArrLength = sortedArr.length\n   \
    \         val sortedArrLength = sortedArr.length\n            val sortedArrLength\
    \ = sortedArr.length\n            val sortedArrLength = sortedArr.length\n   \
    \         val sortedArrLength = sortedArr.length\n            val sortedArrLength\
    \ = sortedArr.length\n            val sortedArrLength = sortedArr.length\n   \
    \         val sortedArrLength = sortedArr.length\n            val sortedArrLength\
    \ = sortedArr.length\n            val sortedArrLength = sortedArr.length\n   \
    \         val sortedArrLength = sortedArr.length\n            val sortedArrLength\
    \ = sortedArr.length\n            val sortedArrLength = sortedArr.length\n   \
    \         val sortedArrLength = sortedArr.length\n            val sortedArrLength\
    \ = sortedArr.length\n            val sortedArrLength = sortedArr.length\n   \
    \         val sortedArrLength = sortedArr.length\n            val sortedArrLength\
    \ = sortedArr.length\n            val sortedArrLength = sortedArr.length\n   \
    \         val sortedArrLength = sortedArr.length\n            val sortedArrLength\
    \ = sortedArr.length\n            val sortedArrLength = sortedArr.length\n   \
    \         val sortedArrLength = sortedArr.length\n            val sortedArrLength\
    \ = sortedArr.length\n            val sortedArrLength = sortedArr.length\n   \
    \         val sortedArrLength = sortedArr.length\n            val sortedArrLength\
    \ = sortedArr.length\n            val sortedArrLength = sortedArr.length\n   \
    \         val sortedArrLength = sortedArr.length\n            val sortedArrLength\
    \ = sortedArr.length\n            val sortedArrLength = sortedArr.length\n   \
    \         val sortedArrLength = sortedArr.length\n            val sortedArrLength\
    \ = sorted\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpun2nptn1.scala:89:0 ----------------------------\e\
    [0m\e[0m\n\e[31m89 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpun2nptn1.scala:31:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e\
    [0m \e[36msortedArrLength\e[0m = sortedArr.length\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArrLength\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArrLength\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpun2nptn1.scala:32:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36msortedArrLength\e[0m = sortedArr.length\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArrLength\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArrLength\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpun2nptn1.scala:33:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e\
    [0m \e[36msortedArrLength\e[0m = sortedArr.length\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArrLength\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArrLength\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpun2nptn1.scala:34:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e\
    [0m \e[36msortedArrLength\e[0m = sortedArr.length\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArrLength\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArrLength\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161"
  stdout: ''
  timestamp: 1660009413
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val sortedArr = arr.sortBy(_)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpph9udlts.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpph9udlts.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpph9udlts.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.takeRight(n)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpph9udlts.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpph9udlts.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36msortedArr\e[0m = sortedArr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already de"
  stdout: ''
  timestamp: 1660009414
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val n = arr.length\n  \
    \      val arr = arr.sortBy(_)\n        val arr = arr.drop(arr.length - 1)\n \
    \       val arr = arr.take(n)\n        val arr = arr.toArray\n        val arr\
    \ = arr.sortBy(_)\n        val arr = arr.drop(arr.length - 1)\n        val arr\
    \ = arr.take(n)\n        val arr = arr.toArray\n        val arr = arr.sortBy(_)\n\
    \        val arr = arr.drop(arr.length - 1)\n        val arr = arr.take(n)\n \
    \       val arr = arr.toArray\n        val arr = arr.sortBy(_)\n        val arr\
    \ = arr.drop(arr.length - 1)\n        val arr = arr.take(n)\n        val arr =\
    \ arr.toArray\n        val arr = arr.sortBy(_)\n        val arr = arr.drop(arr.length\
    \ - 1)\n        val arr = arr.take(n)\n        val arr = arr.toArray\n       \
    \ val arr = arr.sortBy(_)\n        val arr = arr.drop(arr.length - 1)\n      \
    \  val arr = arr.take(n)\n        val arr = arr.toArray\n        val arr = arr.sortBy(_)\n\
    \        val arr = arr.drop(arr.length - 1)\n        val arr = arr.take(n)\n \
    \       val arr = arr.toArray\n        val arr = arr.sortBy(_)\n        val arr\
    \ = arr.drop(arr.length - 1)\n        val arr = arr.take(n)\n        val arr =\
    \ arr.toArray\n        val arr = arr.sortBy(_)\n        val arr = arr.drop(arr.length\
    \ - 1)\n        val arr = arr.take(n)\n        val arr = arr.toArray\n       \
    \ val arr = arr.sortBy(_)\n        val arr = arr.drop(arr.length - 1)\n      \
    \  val arr = arr.take(n)\n        val arr = arr.toArray\n        val arr = arr.sortBy(_)\n\
    \        val arr = arr.drop(arr.length - 1)\n        val arr = arr.take(n)\n \
    \       val arr = arr.toArray\n        val arr = arr.sortBy(_)\n        val arr\
    \ = arr.drop(arr.length - 1)\n        val arr = arr.take(n)\n        val arr =\
    \ arr.toArray\n        val arr = arr.sortBy(_)\n        val arr = arr.drop(arr.length\
    \ - 1)\n        val arr = arr.take(n)\n        val arr = arr.toArray\n       \
    \ val arr = arr.sortBy(_)\n        val arr = arr.drop(arr.length - 1)\n      \
    \  val arr = arr.take(n)\n        val arr = arr.toArray\n        val arr = arr.sortBy(_)\n\
    \        val arr = arr.drop(arr.length - 1)\n        val arr = arr.take(n)\n \
    \       val arr = arr.toArray\n        val arr = arr.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx64chdff.scala:89:4 ----------------------------\e\
    [0m\e[0m\n\e[31m89 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpx64chdff.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined\
    \ as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx64chdff.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(arr.length\
    \ - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpx64chdff.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.take(n)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpx64chdff.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx64chdff.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31"
  stdout: ''
  timestamp: 1660009412
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val result = new Array[Boolean](n+1)\n        val arr = arr.toList\n    \
    \    val len = arr.length\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var temp = 0\n        var temp1 = 0\n        var temp2 = 0\n  \
    \      var temp3 = 0\n        var temp4 = 0\n        var temp5 = 0\n        var\
    \ temp6 = 0\n        var temp7 = 0\n        var temp8 = 0\n        var temp9 =\
    \ 0\n        var temp10 = 0\n        var temp11 = 0\n        var temp12 = 0\n\
    \        var temp13 = 0\n        var temp14 = 0\n        var temp15 = 0\n    \
    \    var temp16 = 0\n        var temp17 = 0\n        var temp18 = 0\n        var\
    \ temp19 = 0\n        var temp20 = 0\n        var temp21 = 0\n        var temp22\
    \ = 0\n        var temp23 = 0\n        var temp24 = 0\n        var temp25 = 0\n\
    \        var temp26 = 0\n        var temp27 = 0\n        var temp28 = 0\n    \
    \    var temp29 = 0\n        var temp30 = 0\n        var temp31 = 0\n        var\
    \ temp32 = 0\n        var temp33 = 0\n        var temp34 = 0\n        var temp35\
    \ = 0\n        var temp36 = 0\n        var temp37 = 0\n        var temp38 = 0\n\
    \        var temp39 = 0\n        var temp40 = 0\n        var temp41 = 0\n    \
    \    var temp42 = 0\n        var temp43 = 0\n        var temp44 = 0\n        var\
    \ temp45 = 0\n        var temp46 = 0\n        var temp47 = 0\n        var temp48\
    \ = 0\n        var temp49 = 0\n        var temp50 = 0\n        var temp51 = 0\n\
    \        var temp52 = 0\n        var temp53 = 0\n        var temp54 = 0\n    \
    \    var temp55 = 0\n        var temp56 = 0\n        var temp57 = 0\n        var\
    \ temp58 = 0\n        var temp59 = 0\n        var temp60 = 0\n        var temp61\
    \ = 0\n        var temp62 = 0\n        var temp63 = 0\n        var temp64 = 0\n\
    \        var temp65 = 0\n        var temp66 = 0\n        var temp67 = 0\n    \
    \    var temp68 = 0\n        var temp69 = 0\n        var temp70 = 0\n        var\
    \ temp71 = 0\n        var temp72 = 0\n        var temp73 = 0\n        var temp74\
    \ = 0\n        var temp75 = 0\n        var temp76 = 0\n        var temp77 = 0\n\
    \        var temp78 = 0\n        var temp79 = 0\n        var temp80 = 0\n    \
    \    var temp81 = 0\n        var temp82 = 0\n        var temp83 = 0\n        var\
    \ temp84 = 0\n        var temp85 = 0\n        var temp86 = 0\n        var temp87\
    \ = 0\n        var temp88 = 0\n        var temp89 = 0\n        var temp90 = 0\n\
    \        var temp91 = 0\n        var temp92 = 0\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqf_9wygz.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqf_9wygz.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpqf_9wygz.scala:128:5 --------------------\e\
    [0m\e[0m\n\e[31m128 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m   \
    \ |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required: Boolean\n\e[31m  \
    \  |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009413
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val len = arr.size\n  \
    \      val arr1 = arr.toArray\n        val arr2 = arr1.clone\n        val arr3\
    \ = arr2.clone\n        val arr4 = arr3.clone\n        val arr5 = arr4.clone\n\
    \        val arr6 = arr5.clone\n        val arr7 = arr6.clone\n        val arr8\
    \ = arr7.clone\n        val arr9 = arr8.clone\n        val arr10 = arr9.clone\n\
    \        val arr11 = arr10.clone\n        val arr12 = arr11.clone\n        val\
    \ arr13 = arr12.clone\n        val arr14 = arr13.clone\n        val arr15 = arr14.clone\n\
    \        val arr16 = arr15.clone\n        val arr17 = arr16.clone\n        val\
    \ arr18 = arr17.clone\n        val arr19 = arr18.clone\n        val arr20 = arr19.clone\n\
    \        val arr21 = arr20.clone\n        val arr22 = arr21.clone\n        val\
    \ arr23 = arr22.clone\n        val arr24 = arr23.clone\n        val arr25 = arr24.clone\n\
    \        val arr26 = arr25.clone\n        val arr27 = arr26.clone\n        val\
    \ arr28 = arr27.clone\n        val arr29 = arr28.clone\n        val arr30 = arr29.clone\n\
    \        val arr31 = arr30.clone\n        val arr32 = arr31.clone\n        val\
    \ arr33 = arr32.clone\n        val arr34 = arr33.clone\n        val arr35 = arr34.clone\n\
    \        val arr36 = arr35.clone\n        val arr37 = arr36.clone\n        val\
    \ arr38 = arr37.clone\n        val arr39 = arr38.clone\n        val arr40 = arr39.clone\n\
    \        val arr41 = arr40.clone\n        val arr42 = arr41.clone\n        val\
    \ arr43 = arr42.clone\n        val arr44 = arr43.clone\n        val arr45 = arr44.clone\n\
    \        val arr46 = arr45.clone\n        val arr47 = arr46.clone\n        val\
    \ arr48 = arr47.clone\n        val arr49 = arr48.clone\n        val arr50 = arr49.clone\n\
    \        val arr51 = arr50.clone\n        val arr52 = arr51.clone\n        val\
    \ arr53 = arr52.clone\n        val arr54 = arr53.clone\n        val arr55 = arr54.clone\n\
    \        val arr\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbrr23n9k.scala:84:4 ----------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbrr23n9k.scala:26:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbrr23n9k.scala:84:5\
    \ ---------------------\e[0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009413
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) true\n      \
    \  else {\n            val m = arr.head\n            val r = arr.tail\n      \
    \      val m = m.toLong\n            val r = r.toLong\n            val l = r.length\n\
    \            val r = r.drop(l)\n            val r = r.take(l)\n            val\
    \ r = r.toLong\n            val r = r.toLong\n            val r = r.toLong\n \
    \           val r = r.toLong\n            val r = r.toLong\n            val r\
    \ = r.toLong\n            val r = r.toLong\n            val r = r.toLong\n   \
    \         val r = r.toLong\n            val r = r.toLong\n            val r =\
    \ r.toLong\n            val r = r.toLong\n            val r = r.toLong\n     \
    \       val r = r.toLong\n            val r = r.toLong\n            val r = r.toLong\n\
    \            val r = r.toLong\n            val r = r.toLong\n            val r\
    \ = r.toLong\n            val r = r.toLong\n            val r = r.toLong\n   \
    \         val r = r.toLong\n            val r = r.toLong\n            val r =\
    \ r.toLong\n            val r = r.toLong\n            val r = r.toLong\n     \
    \       val r = r.toLong\n            val r = r.toLong\n            val r = r.toLong\n\
    \            val r = r.toLong\n            val r = r.toLong\n            val r\
    \ = r.toLong\n            val r = r.toLong\n            val r = r.toLong\n   \
    \         val r = r.toLong\n            val r = r.toLong\n            val r =\
    \ r.toLong\n            val r = r.toLong\n            val r = r.toLong\n     \
    \       val r = r.toLong\n            val r = r.toLong\n            val r = r.toLong\n\
    \            val r = r.toLong\n            val r = r.toLong\n            val r\
    \ = r.toLong\n            val r = r.toLong\n            val r = r.toLong\n   \
    \         val r = r.toLong\n            val r = r.toLong\n            val r =\
    \ r.toLong\n            val r = r.toLong\n            val r = r.toLong\n     \
    \       val r = r.toLong\n            val r = r.toLong\n            val r = r.toLong\n\
    \            val r = r.toLong\n            val r = r.toLong\n            val r\
    \ = r.toLong\n            val r = r.toLong\n            val r = r.toLong\n   \
    \         val r = r.toLong\n            val r = r.toLong\n            val r =\
    \ r.toLong\n            val r = r.toLong\n            val r = \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpcesg9h71.scala:100:19 --------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = \n\e[31m\e\
    [31m    |\e[0m                   ^\e[0m\n\e[31m    |\e[0m                   expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpcesg9h71.scala:111:0 ---------------------------\e[0m\e\
    [0m\n\e[31m111 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcesg9h71.scala:31:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e\
    [0m \e[36mm\e[0m = m.toLong\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpcesg9h71.scala:32:16 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = r.toLong\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined as \e\
    [33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpcesg9h71.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = r.drop(l)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcesg9h71.scala:35:16 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = r.take(l)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods"
  stdout: ''
  timestamp: 1660009415
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortWith(_ < _)\n        val arr = arr.drop(n-1)\n       \
    \ val arr = arr.take(n-1)\n        val arr = arr.toList\n        val arr = arr.sortWith(_\
    \ < _)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n   \
    \     val arr = arr.toArray\n        val arr = arr.sortWith(_ < _)\n        val\
    \ arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n        val arr = arr.toList\n\
    \        val arr = arr.sortWith(_ < _)\n        val arr = arr.drop(n-1)\n    \
    \    val arr = arr.take(n-1)\n        val arr = arr.toArray\n        val arr =\
    \ arr.sortWith(_ < _)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n\
    \        val arr = arr.toList\n        val arr = arr.sortWith(_ < _)\n       \
    \ val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n        val arr =\
    \ arr.toArray\n        val arr = arr.sortWith(_ < _)\n        val arr = arr.drop(n-1)\n\
    \        val arr = arr.take(n-1)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortWith(_ < _)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n\
    \        val arr = arr.toArray\n        val arr = arr.sortWith(_ < _)\n      \
    \  val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n        val arr =\
    \ arr.toList\n        val arr = arr.sortWith(_ < _)\n        val arr = arr.drop(n-1)\n\
    \        val arr = arr.take(n-1)\n        val arr = arr.toArray\n        val arr\
    \ = arr.sortWith(_ < _)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n\
    \        val arr = arr.toList\n        val arr = arr.sortWith(_ < _)\n       \
    \ val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n        val arr =\
    \ arr.toArray\n        val arr = arr.sortWith(_ < _)\n        val arr = arr.drop(n-1)\n\
    \        val arr = arr.take(n-1)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortWith(_ < _)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n\
    \        val arr = arr.toArray\n        val arr = arr.sortWith(_ < _)\n      \
    \  val arr = arr.drop(n-1)\n        val arr = arr.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzbw3jq9z.scala:87:4 ----------------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzbw3jq9z.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_ < _)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzbw3jq9z.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.drop(n-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzbw3jq9z.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.take(n-\e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzbw3jq9z.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzbw3jq9z.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009414
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n        else\
    \ {\n            val m = arr.head\n            val l = arr.last\n            val\
    \ r = arr.last\n            val s = arr.head\n            val t = arr.last\n \
    \           val u = arr.last\n            val v = arr.last\n            val w\
    \ = arr.last\n            val x = arr.last\n            val y = arr.last\n   \
    \         val z = arr.last\n            val a = arr.last\n            val b =\
    \ arr.last\n            val c = arr.last\n            val d = arr.last\n     \
    \       val e = arr.last\n            val f = arr.last\n            val g = arr.last\n\
    \            val h = arr.last\n            val i = arr.last\n            val j\
    \ = arr.last\n            val k = arr.last\n            val l = arr.last\n   \
    \         val m = arr.last\n            val n = arr.last\n            val o =\
    \ arr.last\n            val p = arr.last\n            val q = arr.last\n     \
    \       val r = arr.last\n            val s = arr.last\n            val t = arr.last\n\
    \            val u = arr.last\n            val v = arr.last\n            val w\
    \ = arr.last\n            val x = arr.last\n            val y = arr.last\n   \
    \         val z = arr.last\n            val a = arr.last\n            val b =\
    \ arr.last\n            val c = arr.last\n            val d = arr.last\n     \
    \       val e = arr.last\n            val f = arr.last\n            val g = arr.last\n\
    \            val h = arr.last\n            val i = arr.last\n            val j\
    \ = arr.last\n            val k = arr.last\n            val l = arr.last\n   \
    \         val m = arr.last\n            val n = arr.last\n            val o =\
    \ arr.last\n            val p = arr.last\n            val q = arr.last\n     \
    \       val r = arr.last\n            val s = arr.last\n            val t = arr.last\n\
    \            val u = arr.last\n            val v = arr.last\n            val w\
    \ = arr.last\n            val x = arr.last\n            val y = arr.last\n   \
    \         val z = arr.last\n            val a = arr.last\n            val b =\
    \ arr.last\n            val c = arr.last\n            val d = arr.last\n     \
    \       val e = arr.last\n            val f = arr.last\n            val g = arr.last\n\
    \            val h = arr.last\n            val i = arr.last\n            val j\
    \ = arr.last\n            val k = arr.last\n            val l = arr.last\n   \
    \         val m = arr.last\n            val n = arr.last\n            val o =\
    \ arr.last\n            val p = arr.last\n            val q = arr.last\n     \
    \       val r = arr.last\n            val s = arr.last\n            val t = arr.last\n\
    \            \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbvs52zl3.scala:123:0 ---------------------------\e\
    [0m\e[0m\n\e[31m123 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbvs52zl3.scala:51:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m51 |\e[0m            \e[33mval\e\
    [0m \e[36ml\e[0m = arr.last\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0ml is already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpbvs52zl3.scala:52:16 ---------------------------\e[0m\e[0m\n\e[31m52\
    \ |\e[0m            \e[33mval\e[0m \e[36mm\e[0m = arr.last\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined as \e\
    [33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpbvs52zl3.scala:57:16 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = arr.last\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbvs52zl3.scala:58:16 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m            \e[33mval\e[0m \e[36ms\e[0m = arr.last\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already\
    \ defined as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbvs52zl3.scala:59:16 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m            \e[33mval\e[0m \e[36mt\e[0m = arr.last\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mt is already\
    \ defined as \e[33mvalue\e[0m \e[35mt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNot"
  stdout: ''
  timestamp: 1660009413
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x => x)\n\
    \        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x =>\
    \ x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpyf8x5u2k.scala:73:20 ---------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = \n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpyf8x5u2k.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = arr.sortBy(\e[36mx\e[0m =>\
    \ x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpyf8x5u2k.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = arr.sortBy(\e[36mx\e[0m =>\
    \ x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpyf8x5u2k.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = arr.sortBy(\e[36mx\e[0m =>\
    \ x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpyf8x5u2k.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = arr.sortBy(\e[36mx\e[0m =>\
    \ x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in"
  stdout: ''
  timestamp: 1660009414
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val result = new Array[Long](n)\n        val left = new Array[Long](n)\n\
    \        val right = new Array[Long](n)\n        val leftCount = new Array[Int](n)\n\
    \        val rightCount = new Array[Int](n)\n        val leftCountArray = new\
    \ Array[Int](n)\n        val rightCountArray = new Array[Int](n)\n        val\
    \ leftCountArray2 = new Array[Int](n)\n        val rightCountArray2 = new Array[Int](n)\n\
    \        val leftCountArray3 = new Array[Int](n)\n        val rightCountArray3\
    \ = new Array[Int](n)\n        val leftCountArray4 = new Array[Int](n)\n     \
    \   val rightCountArray4 = new Array[Int](n)\n        val leftCountArray5 = new\
    \ Array[Int](n)\n        val rightCountArray5 = new Array[Int](n)\n        val\
    \ leftCountArray6 = new Array[Int](n)\n        val rightCountArray6 = new Array[Int](n)\n\
    \        val leftCountArray7 = new Array[Int](n)\n        val rightCountArray7\
    \ = new Array[Int](n)\n        val leftCountArray8 = new Array[Int](n)\n     \
    \   val rightCountArray8 = new Array[Int](n)\n        val leftCountArray9 = new\
    \ Array[Int](n)\n        val rightCountArray9 = new Array[Int](n)\n        val\
    \ leftCountArray10 = new Array[Int](n)\n        val rightCountArray10 = new Array[Int](n)\n\
    \        val leftCountArray11 = new Array[Int](n)\n        val rightCountArray11\
    \ = new Array[Int](n)\n        val leftCountArray12 = new Array[Int](n)\n    \
    \    val rightCountArray12 = new Array[Int](n)\n        val leftCountArray13 =\
    \ new Array[Int](n)\n        val rightCountArray13 = new Array[Int](n)\n     \
    \   val leftCountArray14 = new Array[Int](n)\n        val rightCountArray14 =\
    \ new Array[Int](n)\n        val leftCountArray15 = new Array[Int](n)\n      \
    \  val rightCountArray15 = new Array[Int](n)\n        val leftCountArray16 = new\
    \ Array[Int](n)\n        val rightCountArray16 = new Array[Int](n)\n        val\
    \ leftCountArray17 = new Array[Int](n)\n        val rightCountArray17 = new Array[Int](n)\n\
    \        val leftCountArray18 = new \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpthdo6o49.scala:68:4 ----------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpthdo6o49.scala:27:18 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpthdo6o49.scala:68:5 ---------------------\e[0m\e[0m\n\e[31m68\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009414
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val sorted = arr.sort\n        val result = arr.zipWithIndex.foldLeft(true){\n\
    \            case (acc, (elem, index)) =>\n                if(index == 0)\n  \
    \                  acc\n                else\n                    if(elem > sorted[index-1])\n\
    \                        acc\n                    else\n                     \
    \   false\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpf_bzlbnj.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009411
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val arr1 = arr.toList\n        val arr2 = arr1.reverse\n        val arr3\
    \ = arr2.toList\n        val arr4 = arr3.toArray\n        val arr5 = arr4.toList\n\
    \        val arr6 = arr5.toArray\n        val arr7 = arr6.toList\n        val\
    \ arr8 = arr7.reverse\n        val arr9 = arr8.toList\n        val arr10 = arr9.toArray\n\
    \        val arr11 = arr10.toList\n        val arr12 = arr11.reverse\n       \
    \ val arr13 = arr12.toList\n        val arr14 = arr13.toArray\n        val arr15\
    \ = arr14.toList\n        val arr16 = arr15.reverse\n        val arr17 = arr16.toList\n\
    \        val arr18 = arr17.toArray\n        val arr19 = arr18.toList\n       \
    \ val arr20 = arr19.reverse\n        val arr21 = arr20.toList\n        val arr22\
    \ = arr21.toArray\n        val arr23 = arr22.toList\n        val arr24 = arr23.toArray\n\
    \        val arr25 = arr24.toList\n        val arr26 = arr25.reverse\n       \
    \ val arr27 = arr26.toList\n        val arr28 = arr27.toArray\n        val arr29\
    \ = arr28.toList\n        val arr30 = arr29.reverse\n        val arr31 = arr30.toList\n\
    \        val arr32 = arr31.toArray\n        val arr33 = arr32.toList\n       \
    \ val arr34 = arr33.reverse\n        val arr35 = arr34.toList\n        val arr36\
    \ = arr35.toArray\n        val arr37 = arr36.toList\n        val arr38 = arr37.reverse\n\
    \        val arr39 = arr38.toList\n        val arr40 = arr39.toArray\n       \
    \ val arr41 = arr40.toList\n        val arr42 = arr41.toArray\n        val arr43\
    \ = arr42.toList\n        val arr44 = arr43.toArray\n        val arr45 = arr44.toList\n\
    \        val arr46 = arr45.reverse\n        val arr47 = arr46.toList\n       \
    \ val arr48 = arr47.toArray\n        val arr49 = arr48.toList\n        val arr50\
    \ = arr49.reverse\n        val arr51 = arr50.toList\n        val arr52 = arr51.to\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7bser9g7.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7bser9g7.scala:80:5 ---------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009415
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val result = new mutable.ListBuffer[Long]()\n        val shiftCount = arr.length\n\
    \        val shifts = mutable.ListBuffer[Long]()\n        val shiftIndex = 0\n\
    \        val shiftVal = arr(shiftIndex)\n        val shiftVal2 = arr(shiftIndex\
    \ + 1)\n        val shiftVal3 = arr(shiftIndex + 2)\n        val shiftVal4 = arr(shiftIndex\
    \ + 3)\n        val shiftVal5 = arr(shiftIndex + 4)\n        val shiftVal6 = arr(shiftIndex\
    \ + 5)\n        val shiftVal7 = arr(shiftIndex + 6)\n        val shiftVal8 = arr(shiftIndex\
    \ + 7)\n        val shiftVal9 = arr(shiftIndex + 8)\n        val shiftVal10 =\
    \ arr(shiftIndex + 9)\n        val shiftVal11 = arr(shiftIndex + 10)\n       \
    \ val shiftVal12 = arr(shiftIndex + 11)\n        val shiftVal13 = arr(shiftIndex\
    \ + 12)\n        val shiftVal14 = arr(shiftIndex + 13)\n        val shiftVal15\
    \ = arr(shiftIndex + 14)\n        val shiftVal16 = arr(shiftIndex + 15)\n    \
    \    val shiftVal17 = arr(shiftIndex + 16)\n        val shiftVal18 = arr(shiftIndex\
    \ + 17)\n        val shiftVal19 = arr(shiftIndex + 18)\n        val shiftVal20\
    \ = arr(shiftIndex + 19)\n        val shiftVal21 = arr(shiftIndex + 20)\n    \
    \    val shiftVal22 = arr(shiftIndex + 21)\n        val shiftVal23 = arr(shiftIndex\
    \ + 22)\n        val shiftVal24 = arr(shiftIndex + 23)\n        val shiftVal25\
    \ = arr(shiftIndex + 24)\n        val shiftVal26 = arr(shiftIndex + 25)\n    \
    \    val shiftVal27 = arr(shiftIndex + 26)\n        val shiftVal28 = arr(shiftIndex\
    \ + 27)\n        val shiftVal29 = arr(shiftIndex + 28)\n        val shiftVal30\
    \ = arr(shiftIndex + 29)\n        val shiftVal31 = arr(shiftIndex + 30)\n    \
    \    val shiftVal32 = arr(shiftIndex + 31)\n        val shiftVal33 = arr(shiftIndex\
    \ + 32)\n        val shiftVal34 = arr(shiftIndex + 33)\n        val shiftVal35\
    \ = arr(shiftIndex + 34)\n        val shiftVal36 = arr(shiftIndex + \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6q71yk12.scala:67:41 ---------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m        \e[33mval\e[0m \e[36mshiftVal36\e[0m = arr(shiftIndex\
    \ + \n\e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e\
    [31m   |\e[0m                                       expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6q71yk12.scala:27:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6q71yk12.scala:28:25\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp6q71yk12.scala:30:21 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36mshifts\e[0m = mutable.ListBuffer[\e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp6q71yk12.scala:68:5 ---------------------\e[0m\e\
    [0m\n\e[31m68 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009420
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n-1)\n       \
    \ val arr = arr.take(n-1)\n        val arr = arr.sortBy(x => x)\n        val arr\
    \ = arr.drop(n-1)\n        val arr = arr.take(n-1)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n-1)\n       \
    \ val arr = arr.take(n-1)\n        val arr = arr.sortBy(x => x)\n        val arr\
    \ = arr.drop(n-1)\n        val arr = arr.take(n-1)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n-1)\n       \
    \ val arr = arr.take(n-1)\n        val arr = arr.sortBy(x => x)\n        val arr\
    \ = arr.drop(n-1)\n        val arr = arr.take(n-1)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n-1)\n       \
    \ val arr = arr.take(n-1)\n        val arr = arr.sortBy(x => x)\n        val arr\
    \ = arr.drop(n-1)\n        val arr = arr.take(n-1)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n-1)\n       \
    \ val arr = arr.take(n-1)\n        val arr = arr.sortBy(x => x)\n        val arr\
    \ = arr.drop(n-1)\n        val arr = arr.take(n-1)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n-1)\n       \
    \ val arr = arr.take(n-1)\n        val arr = arr.sortBy(x => x)\n        val arr\
    \ = arr.drop(n-1)\n        val arr = arr.take(n-1)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n-1)\n       \
    \ val arr = arr.take(n-1)\n        val arr = arr.sort\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj1aaougs.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpj1aaougs.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(n-\e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj1aaougs.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.take(n-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj1aaougs.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpj1aaougs.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(n-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toSet.toList\n        val len = arr.size\n\
    \        val arr2 = arr.toList\n        val arr3 = arr.toList\n        val arr4\
    \ = arr.toList\n        val arr5 = arr.toList\n        val arr6 = arr.toList\n\
    \        val arr7 = arr.toList\n        val arr8 = arr.toList\n        val arr9\
    \ = arr.toList\n        val arr10 = arr.toList\n        val arr11 = arr.toList\n\
    \        val arr12 = arr.toList\n        val arr13 = arr.toList\n        val arr14\
    \ = arr.toList\n        val arr15 = arr.toList\n        val arr16 = arr.toList\n\
    \        val arr17 = arr.toList\n        val arr18 = arr.toList\n        val arr19\
    \ = arr.toList\n        val arr20 = arr.toList\n        val arr21 = arr.toList\n\
    \        val arr22 = arr.toList\n        val arr23 = arr.toList\n        val arr24\
    \ = arr.toList\n        val arr25 = arr.toList\n        val arr26 = arr.toList\n\
    \        val arr27 = arr.toList\n        val arr28 = arr.toList\n        val arr29\
    \ = arr.toList\n        val arr30 = arr.toList\n        val arr31 = arr.toList\n\
    \        val arr32 = arr.toList\n        val arr33 = arr.toList\n        val arr34\
    \ = arr.toList\n        val arr35 = arr.toList\n        val arr36 = arr.toList\n\
    \        val arr37 = arr.toList\n        val arr38 = arr.toList\n        val arr39\
    \ = arr.toList\n        val arr40 = arr.toList\n        val arr41 = arr.toList\n\
    \        val arr42 = arr.toList\n        val arr43 = arr.toList\n        val arr44\
    \ = arr.toList\n        val arr45 = arr.toList\n        val arr46 = arr.toList\n\
    \        val arr47 = arr.toList\n        val arr48 = arr.toList\n        val arr49\
    \ = arr.toList\n        val arr50 = arr.toList\n        val arr51 = arr.toList\n\
    \        val arr52 = arr.toList\n        val arr53 = arr.toList\n        val arr54\
    \ = arr.toList\n        val arr55 = arr.toList\n        val arr56 = arr.toList\n\
    \        val arr57 = arr.toList\n        val arr58\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpa2xu_sei.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpa2xu_sei.scala:26:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toSet.toList\n\e[31m\e[31m   |\e[0m                  ^\e\
    [0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa2xu_sei.scala:85:5\
    \ ---------------------\e[0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009422
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.dropRight(1)\n      \
    \  val arr = arr.takeRight(n)\n        val arr = arr.toArray\n        val arr\
    \ = arr.sortBy(x => x)\n        val arr = arr.dropRight(1)\n        val arr =\
    \ arr.takeRight(n)\n        val arr = arr.toArray\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.dropRight(1)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.toArray\n        val arr = arr.sortBy(x => x)\n       \
    \ val arr = arr.dropRight(1)\n        val arr = arr.takeRight(n)\n        val\
    \ arr = arr.toArray\n        val arr = arr.sortBy(x => x)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.takeRight(n)\n        val arr = arr.toArray\n        val\
    \ arr = arr.sortBy(x => x)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.takeRight(n)\n        val arr = arr.toArray\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.dropRight(1)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.toArray\n        val arr = arr.sortBy(x => x)\n       \
    \ val arr = arr.dropRight(1)\n        val arr = arr.takeRight(n)\n        val\
    \ arr = arr.toArray\n        val arr = arr.sortBy(x => x)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.takeRight(n)\n        val arr = arr.toArray\n        val\
    \ arr = arr.sortBy(x => x)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.takeRight(n)\n        val arr = arr.toArray\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.dropRight(1)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.toArray\n        val arr = arr.sortBy(x => x)\n       \
    \ val arr = arr.dropRight(1)\n        val arr = arr.takeRight(n)\n        val\
    \ arr = arr.toArray\n        val arr = arr.sortBy(x => x)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.takeRight(n)\n        val arr = arr.toArray\n        val\
    \ arr = arr.sortBy(x => x)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.takeRight(n)\n        val arr = arr.toArray\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.dropRight(1)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.toArray\n        val arr = arr.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf3g3ea8k.scala:89:4 ----------------------------\e\
    [0m\e[0m\n\e[31m89 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpf3g3ea8k.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpf3g3ea8k.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpf3g3ea8k.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.takeRight(n)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpf3g3ea8k.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpf3g3ea8k.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^"
  stdout: ''
  timestamp: 1660009423
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val result = new mutable.ListBuffer[Long]()\n        val arrSize = arr.size\n\
    \        val arrSize = arr.size\n        val arrSize = arr.size\n        val arrSize\
    \ = arr.size\n        val arrSize = arr.size\n        val arrSize = arr.size\n\
    \        val arrSize = arr.size\n        val arrSize = arr.size\n        val arrSize\
    \ = arr.size\n        val arrSize = arr.size\n        val arrSize = arr.size\n\
    \        val arrSize = arr.size\n        val arrSize = arr.size\n        val arrSize\
    \ = arr.size\n        val arrSize = arr.size\n        val arrSize = arr.size\n\
    \        val arrSize = arr.size\n        val arrSize = arr.size\n        val arrSize\
    \ = arr.size\n        val arrSize = arr.size\n        val arrSize = arr.size\n\
    \        val arrSize = arr.size\n        val arrSize = arr.size\n        val arrSize\
    \ = arr.size\n        val arrSize = arr.size\n        val arrSize = arr.size\n\
    \        val arrSize = arr.size\n        val arrSize = arr.size\n        val arrSize\
    \ = arr.size\n        val arrSize = arr.size\n        val arrSize = arr.size\n\
    \        val arrSize = arr.size\n        val arrSize = arr.size\n        val arrSize\
    \ = arr.size\n        val arrSize = arr.size\n        val arrSize = arr.size\n\
    \        val arrSize = arr.size\n        val arrSize = arr.size\n        val arrSize\
    \ = arr.size\n        val arrSize = arr.size\n        val arrSize = arr.size\n\
    \        val arrSize = arr.size\n        val arrSize = arr.size\n        val arrSize\
    \ = arr.size\n        val arrSize = arr.size\n        val arrSize = arr.size\n\
    \        val arrSize = arr.size\n        val arrSize = arr.size\n        val arrSize\
    \ = arr.size\n        val arrSize = arr.size\n        val arrSize = arr.size\n\
    \        val arrSize = arr.size\n        val arrSize = arr.size\n        val arrSize\
    \ = arr.size\n        val arrSize = arr.size\n        val arrSize = arr.size\n\
    \        val arrSize = arr.size\n        val arrSize = arr.size\n        val arrSize\
    \ = arr.size\n        val arrSize = arr.size\n        val arrSize = arr.size\n\
    \        val arrSize = arr.size\n        val arrSize = arr.size\n        val arrSize\
    \ = arr.size\n        val arrSize = arr.size\n        val arrSize = arr.size\n\
    \        val arrSize = arr.size\n        val arrSize = arr.size\n        val arrSize\
    \ = arr.size\n        val arr\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwm2vbo5x.scala:99:4 ----------------------------\e\
    [0m\e[0m\n\e[31m99 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwm2vbo5x.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36marrSize\e[0m = arr.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marrSize is already defined as \e[33mvalue\e[0m \e[35marrSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpwm2vbo5x.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36marrSize\e[0m = arr.size\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marrSize is already\
    \ defined as \e[33mvalue\e[0m \e[35marrSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwm2vbo5x.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36marrSize\e[0m = arr.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marrSize is already defined as \e[33mvalue\e[0m \e[35marrSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpwm2vbo5x.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36marrSize\e[0m = arr.size\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marrSize is already\
    \ defined as \e[33mvalue\e[0m \e[35marrSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwm2vbo5x.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36marrSize\e[0m = arr.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mar"
  stdout: ''
  timestamp: 1660009422
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val len = arr.length\n        val max = (len - 1).toLong\n        val min\
    \ = 0l\n        var i = 0\n        var j = 0\n        var k = 0\n        var temp\
    \ = 0\n        var flag = false\n        var temp1 = arr.head\n        var temp2\
    \ = arr.last\n        var temp3 = arr.last\n        var temp4 = arr.last\n   \
    \     var temp5 = arr.last\n        var temp6 = arr.last\n        var temp7 =\
    \ arr.last\n        var temp8 = arr.last\n        var temp9 = arr.last\n     \
    \   var temp10 = arr.last\n        var temp11 = arr.last\n        var temp12 =\
    \ arr.last\n        var temp13 = arr.last\n        var temp14 = arr.last\n   \
    \     var temp15 = arr.last\n        var temp16 = arr.last\n        var temp17\
    \ = arr.last\n        var temp18 = arr.last\n        var temp19 = arr.last\n \
    \       var temp20 = arr.last\n        var temp21 = arr.last\n        var temp22\
    \ = arr.last\n        var temp23 = arr.last\n        var temp24 = arr.last\n \
    \       var temp25 = arr.last\n        var temp26 = arr.last\n        var temp27\
    \ = arr.last\n        var temp28 = arr.last\n        var temp29 = arr.last\n \
    \       var temp30 = arr.last\n        var temp31 = arr.last\n        var temp32\
    \ = arr.last\n        var temp33 = arr.last\n        var temp34 = arr.last\n \
    \       var temp35 = arr.last\n        var temp36 = arr.last\n        var temp37\
    \ = arr.last\n        var temp38 = arr.last\n        var temp39 = arr.last\n \
    \       var temp40 = arr.last\n        var temp41 = arr.last\n        var temp42\
    \ = arr.last\n        var temp43 = arr.last\n        var temp44 = arr.last\n \
    \       var temp45 = arr.last\n        var temp46 = arr.last\n        var temp47\
    \ = arr.last\n        var temp48 = arr.last\n        var temp49 = arr.last\n \
    \       var temp50 = arr.last\n        var temp51 = arr.last\n        var temp52\
    \ = arr.last\n        var temp53 = arr.last\n        var temp54 = arr.last\n \
    \       var temp55 = arr.last\n        var temp56 = arr.last\n        var temp57\
    \ = arr.last\n        var temp58 = arr.last\n        var temp59 = arr.last\n \
    \       var temp60 = arr.last\n        var temp61 = arr.last\n        var temp62\
    \ = arr.last\n        var temp63 = arr.last\n        var temp64 = arr.last\n \
    \       var temp65 = arr.last\n        var temp66 = arr.last\n        var temp67\
    \ = arr.last\n        var temp\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8rdq5pxa.scala:104:4 ---------------------------\e\
    [0m\e[0m\n\e[31m104 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8rdq5pxa.scala:27:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8rdq5pxa.scala:104:5\
    \ --------------------\e[0m\e[0m\n\e[31m104 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009423
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) true\n      \
    \  else if (n == 1) false\n        else {\n            val arr = arr.sortBy(x\
    \ => x)\n            val first = arr(0)\n            val last = arr(n)\n     \
    \       val diff = last - first\n            val shifts = diff / 2\n         \
    \   val shift = (diff / 2).toInt\n            val result = arr.take(shift).drop(shift)\n\
    \            val result2 = arr.takeRight(shift).drop(shift)\n            val result3\
    \ = arr.take(shift).dropRight(shift)\n            val result4 = arr.takeRight(shift).dropRight(shift)\n\
    \            val result5 = arr.take(shift).drop(shift).dropRight(shift)\n    \
    \        val result6 = arr.takeRight(shift).drop(shift).dropRight(shift)\n   \
    \         val result7 = arr.take(shift).dropRight(shift).drop(shift)\n       \
    \     val result8 = arr.takeRight(shift).dropRight(shift).drop(shift)\n      \
    \      val result9 = arr.take(shift).drop(shift).dropRight(shift).dropRight(shift)\n\
    \            val result10 = arr.takeRight(shift).drop(shift).dropRight(shift).drop(shift)\n\
    \            val result11 = arr.take(shift).dropRight(shift).drop(shift).dropRight(shift).drop(shift)\n\
    \            val result12 = arr.takeRight(shift).drop(shift).dropRight(shift).dropRight(shift).drop(shift)\n\
    \            val result13 = arr.take(shift).drop(shift).dropRight(shift).drop(shift).dropRight(shift).drop(shift)\n\
    \            val result14 = arr.takeRight(shift).drop(shift).dropRight(shift).dropRight(shift).drop(shift).drop(shift)\n\
    \            val result15 = arr.take(shift).drop(shift).dropRight(shift).dropRight(shift).drop(shift).dropRight(shift).drop(shift)\n\
    \            val result16 = arr.takeRight(shift).drop(shift).dropRight(shift).drop(shift).dropRight(shift).dropRight(shift).drop(shift)\n\
    \            val result17 = arr.take(shift).drop(shift).dropRight(shift).drop(shift).dropRight(shift).drop(shift).dropRight(shift).drop(shift)\n\
    \            val result18 = arr.takeRight(shift).drop(shift).dropRight(shift\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpl2hrqawp.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpl2hrqawp.scala:64:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m64 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpl2hrqawp.scala:30:22 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m            \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e[36mx\e\
    [0m => x)\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m\
    \                      Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl2hrqawp.scala:63:1\
    \ ---------------------\e[0m\e[0m\n\e[31m63 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpl2hrqawp.scala:55:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m55 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660009426
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e"
  stdout: ''
  timestamp: 1660009388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val len = arr.length\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpazcclqym.scala:99:17 ---------------------------\e\
    [0m\e[0m\n\e[31m99 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = \n\e[31m\e[31m\
    \   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpazcclqym.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpazcclqym.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpazcclqym.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpazcclqym.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpazcclqym.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m     "
  stdout: ''
  timestamp: 1660009425
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val arr2 = arr.toList\n        val arr3 = arr2.reverse\n\
    \        val arr4 = arr3.toList\n        val arr5 = arr4.reverse\n        val\
    \ arr6 = arr5.reverse\n        val arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n\
    \        val arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n        val\
    \ arr11 = arr10.reverse\n        val arr12 = arr11.reverse\n        val arr13\
    \ = arr12.reverse\n        val arr14 = arr13.reverse\n        val arr15 = arr14.reverse\n\
    \        val arr16 = arr15.reverse\n        val arr17 = arr16.reverse\n      \
    \  val arr18 = arr17.reverse\n        val arr19 = arr18.reverse\n        val arr20\
    \ = arr19.reverse\n        val arr21 = arr20.reverse\n        val arr22 = arr21.reverse\n\
    \        val arr23 = arr22.reverse\n        val arr24 = arr23.reverse\n      \
    \  val arr25 = arr24.reverse\n        val arr26 = arr25.reverse\n        val arr27\
    \ = arr26.reverse\n        val arr28 = arr27.reverse\n        val arr29 = arr28.reverse\n\
    \        val arr30 = arr29.reverse\n        val arr31 = arr30.reverse\n      \
    \  val arr32 = arr31.reverse\n        val arr33 = arr32.reverse\n        val arr34\
    \ = arr33.reverse\n        val arr35 = arr34.reverse\n        val arr36 = arr35.reverse\n\
    \        val arr37 = arr36.reverse\n        val arr38 = arr37.reverse\n      \
    \  val arr39 = arr38.reverse\n        val arr40 = arr39.reverse\n        val arr41\
    \ = arr40.reverse\n        val arr42 = arr41.reverse\n        val arr43 = arr42.reverse\n\
    \        val arr44 = arr43.reverse\n        val arr45 = arr44.reverse\n      \
    \  val arr46 = arr45.reverse\n        val arr47 = arr46.reverse\n        val arr48\
    \ = arr47.reverse\n        val arr49 = arr48.reverse\n        val arr50 = arr49.reverse\n\
    \        val arr51 = arr50.reverse\n        val arr52 = arr51.reverse\n      \
    \  val arr53 = arr52.reverse\n        val arr54 = arr53.reverse\n        val arr55\
    \ = arr54.reverse\n        val arr56 = arr55.reverse\n        val \n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp2oozhc1f.scala:84:11 ---------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2oozhc1f.scala:28:18 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp2oozhc1f.scala:85:5 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009426
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val arr1 = arr.toList\n        val arr2 = arr.toBuffer\n        val arr3\
    \ = arr.toSeq\n        val arr4 = arr.toSet\n        val arr5 = arr.toMap\n  \
    \      val arr6 = arr.toIterator\n        val arr7 = arr.toArray\n        val\
    \ arr8 = arr.toSeq\n        val arr9 = arr.toSet\n        val arr10 = arr.toMap\n\
    \        val arr11 = arr.toIterator\n        val arr12 = arr.toArray\n       \
    \ val arr13 = arr.toSeq\n        val arr14 = arr.toSet\n        val arr15 = arr.toMap\n\
    \        val arr16 = arr.toIterator\n        val arr17 = arr.toArray\n       \
    \ val arr18 = arr.toSeq\n        val arr19 = arr.toSet\n        val arr20 = arr.toMap\n\
    \        val arr21 = arr.toIterator\n        val arr22 = arr.toArray\n       \
    \ val arr23 = arr.toSeq\n        val arr24 = arr.toSet\n        val arr25 = arr.toMap\n\
    \        val arr26 = arr.toIterator\n        val arr27 = arr.toArray\n       \
    \ val arr28 = arr.toSeq\n        val arr29 = arr.toSet\n        val arr30 = arr.toMap\n\
    \        val arr31 = arr.toIterator\n        val arr32 = arr.toArray\n       \
    \ val arr33 = arr.toSeq\n        val arr34 = arr.toSet\n        val arr35 = arr.toMap\n\
    \        val arr36 = arr.toIterator\n        val arr37 = arr.toArray\n       \
    \ val arr38 = arr.toSeq\n        val arr39 = arr.toSet\n        val arr40 = arr.toMap\n\
    \        val arr41 = arr.toIterator\n        val arr42 = arr.toArray\n       \
    \ val arr43 = arr.toSeq\n        val arr44 = arr.toSet\n        val arr45 = arr.toMap\n\
    \        val arr46 = arr.toIterator\n        val arr47 = arr.toArray\n       \
    \ val arr48 = arr.toSeq\n        val arr49 = arr.toSet\n        val arr50 = arr.toMap\n\
    \        val arr51 = arr.toIterator\n        val arr52 = arr.toArray\n       \
    \ val arr53 = arr.toSeq\n        val arr54 = arr.toSet\n        val arr55 = arr.toMap\n\
    \        val arr56 = arr.toIterator\n        val arr57 = arr.to\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqw9wcims.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqw9wcims.scala:85:5 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009425
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val len = arr.length\n\
    \        if (len == 0) return true\n        val first = arr(0)\n        val last\
    \ = arr[len-1]\n        val mid = len/2\n        val left = arr.take(mid)\n  \
    \      val right = arr.drop(mid)\n        val leftSorted = left.sortBy(x => x)\n\
    \        val rightSorted = right.sortBy(x => x)\n        val leftSortedSet = leftSorted.toSet\n\
    \        val rightSortedSet = rightSorted.toSet\n        if (leftSortedSet ==\
    \ rightSortedSet) return true\n        if (leftSortedSet < rightSortedSet) return\
    \ false\n        if (leftSortedSet > rightSortedSet) return true\n        val\
    \ leftSortedList = leftSorted.toList\n        val rightSortedList = rightSorted.toList\n\
    \        val leftSortedListSet = leftSortedList.toSet\n        val rightSortedListSet\
    \ = rightSortedList.toSet\n        if (leftSortedListSet == rightSortedListSet)\
    \ return true\n        if (leftSortedListSet < rightSortedListSet) return false\n\
    \        if (leftSortedListSet > rightSortedListSet) return true\n        val\
    \ leftSortedSetList = leftSortedSet.toList\n        val rightSortedSetList = rightSortedSet.toList\n\
    \        val leftSortedSetListSet = leftSortedSetList.toSet\n        val rightSortedSetListSet\
    \ = rightSortedSetList.toSet\n        if (leftSortedSetListSet == rightSortedSetListSet)\
    \ return true\n        if (leftSortedSetListSet < rightSortedSetListSet) return\
    \ false\n        if (leftSortedSetListSet > rightSortedSetListSet) return true\n\
    \        val leftSortedMapList = leftSortedSet.toMap\n        val rightSortedMapList\
    \ = rightSortedSet.toMap\n        val leftSortedMapListSet = leftSortedMapList.toSet\n\
    \        val rightSortedMapListSet = rightSortedMapList.toSet\n        if (leftSortedMapListSet\
    \ == rightSortedMapListSet) return true\n        if (leftSortedMapListSet < rightSortedMapListSet)\
    \ return false\n        if (leftSortedMapListSet > rightSortedMapListSet) return\
    \ true\n        val leftSortedSortedSetList = leftSortedSet.toSortedSet\n    \
    \    val rightSortedSortedSetList = rightSortedSet.toSortedSet\n        val leftSortedSortedSetListSet\
    \ = leftSortedSortedSetList.toSet\n        val rightSortedSortedSetListSet = rightSortedSortedSetList.toSet\n\
    \        if (leftSortedSortedSetListSet == rightSortedSortedSetListSet) return\
    \ true\n        if (leftSortedSortedSetListSet < right\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnvtx9js8.scala:68:4 ----------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnvtx9js8.scala:26:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnvtx9js8.scala:30:26\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mlast\e[0m = arr[\e[35mlen-\e[31m1\e[0m]\n\e[31m\e[31m   |\e[0m           \
    \               ^\e[0m\n\e[31m   |\e[0m                          Not found: type\
    \ -\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009422
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) true\n      \
    \  else {\n            val m = arr.head\n            val r = arr.tail\n      \
    \      val d = r.head\n            val c = r.tail\n            val a = r.tail.head\n\
    \            val b = r.tail.tail\n            val e = r.tail.tail.head\n     \
    \       val f = r.tail.tail.tail\n            val g = r.tail.tail.tail.head\n\
    \            val h = r.tail.tail.tail.tail\n            val i = r.tail.tail.tail.tail.head\n\
    \            val j = r.tail.tail.tail.tail.tail\n            val k = r.tail.tail.tail.tail.tail.head\n\
    \            val l = r.tail.tail.tail.tail.tail.tail.head\n            val m =\
    \ r.tail.tail.tail.tail.tail.tail.tail.head\n            val n = r.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val o = r.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n   \
    \         val p = r.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n \
    \           val q = r.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val r = r.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val s = r.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val t = r.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val u = r.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val v = r.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val w = r.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptp7jfb7l.scala:64:0 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptp7jfb7l.scala:43:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m            \e[33mval\e\
    [0m \e[36mm\e[0m = r.tail.tail.tail.tail.tail.tail.tail.head\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptp7jfb7l.scala:48:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m48 |\e[0m            \e[33mval\e\
    [0m \e[36mr\e[0m = r.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmptp7jfb7l.scala:63:1 ---------------------\e[0m\e[0m\n\e[31m63\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m\
    \   |\e[0m Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmptp7jfb7l.scala:55:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m55 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1660009426
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:34:12 ----------"
  stdout: ''
  timestamp: 1660009387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.sortBy(x => x)\n        val len = arr.length\n        val\
    \ arr = arr.sortBy(x => x)\n        val len = arr.length\n        val arr = arr.sortBy(x\
    \ => x)\n        val len = arr.length\n        val arr = arr.sortBy(x => x)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(x => x)\n        val\
    \ len = arr.length\n        val arr = arr.sortBy(x => x)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(x => x)\n        val len = arr.length\n        val\
    \ arr = arr.sortBy(x => x)\n        val len = arr.length\n        val arr = arr.sortBy(x\
    \ => x)\n        val len = arr.length\n        val arr = arr.sortBy(x => x)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(x => x)\n        val\
    \ len = arr.length\n        val arr = arr.sortBy(x => x)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(x => x)\n        val len = arr.length\n        val\
    \ arr = arr.sortBy(x => x)\n        val len = arr.length\n        val arr = arr.sortBy(x\
    \ => x)\n        val len = arr.length\n        val arr = arr.sortBy(x => x)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(x => x)\n        val\
    \ len = arr.length\n        val arr = arr.sortBy(x => x)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(x => x)\n        val len = arr.length\n        val\
    \ arr = arr.sortBy(x => x)\n        val len = arr.length\n        val arr = arr.sortBy(x\
    \ => x)\n        val len = arr.length\n        val arr = arr.sortBy(x => x)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(x => x)\n        val\
    \ len = arr.length\n        val arr = arr.sortBy(x => x)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(x => x)\n        val len = arr.length\n        val\
    \ arr = arr.sortBy(x => x)\n        val len = arr.length\n        val arr = arr.sortBy(x\
    \ => x)\n        val len = arr.length\n        val arr = arr.sortBy(x => x)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(x => x)\n        val\
    \ len = arr.length\n        val arr = arr.sortBy(x => x)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(x => x)\n        val len = arr.length\n        val\
    \ arr = \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpc3ob8nen.scala:90:17 ---------------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = \n\e[31m\e[31m\
    \   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpc3ob8nen.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc3ob8nen.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlen\e[0m = arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlen is already defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpc3ob8nen.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc3ob8nen.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlen\e[0m = arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlen is already defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpc3ob8nen.scala:32:12 ----"
  stdout: ''
  timestamp: 1660009425
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val arr2 = arr.toList\n        val arr3 = arr2.reverse\n\
    \        val arr4 = arr3.toList\n        val arr5 = arr4.toList\n        val arr6\
    \ = arr5.toList\n        val arr7 = arr6.toList\n        val arr8 = arr7.toList\n\
    \        val arr9 = arr8.toList\n        val arr10 = arr9.toList\n        val\
    \ arr11 = arr10.toList\n        val arr12 = arr11.toList\n        val arr13 =\
    \ arr12.toList\n        val arr14 = arr13.toList\n        val arr15 = arr14.toList\n\
    \        val arr16 = arr15.toList\n        val arr17 = arr16.toList\n        val\
    \ arr18 = arr17.toList\n        val arr19 = arr18.toList\n        val arr20 =\
    \ arr19.toList\n        val arr21 = arr20.toList\n        val arr22 = arr21.toList\n\
    \        val arr23 = arr22.toList\n        val arr24 = arr23.toList\n        val\
    \ arr25 = arr24.toList\n        val arr26 = arr25.toList\n        val arr27 =\
    \ arr26.toList\n        val arr28 = arr27.toList\n        val arr29 = arr28.toList\n\
    \        val arr30 = arr29.toList\n        val arr31 = arr30.toList\n        val\
    \ arr32 = arr31.toList\n        val arr33 = arr32.toList\n        val arr34 =\
    \ arr33.toList\n        val arr35 = arr34.toList\n        val arr36 = arr35.toList\n\
    \        val arr37 = arr36.toList\n        val arr38 = arr37.toList\n        val\
    \ arr39 = arr38.toList\n        val arr40 = arr39.toList\n        val arr41 =\
    \ arr40.toList\n        val arr42 = arr41.toList\n        val arr43 = arr42.toList\n\
    \        val arr44 = arr43.toList\n        val arr45 = arr44.toList\n        val\
    \ arr46 = arr45.toList\n        val arr47 = arr46.toList\n        val arr48 =\
    \ arr47.toList\n        val arr49 = arr48.toList\n        val arr50 = arr49.toList\n\
    \        val arr51 = arr50.toList\n        val arr\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpl_wfpsnt.scala:80:4 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpl_wfpsnt.scala:28:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl_wfpsnt.scala:80:5\
    \ ---------------------\e[0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009425
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val arr2 = arr.toList\n        val arr3 = arr2.reverse\n\
    \        val arr4 = arr3.toList\n        val arr5 = arr4.reverse\n        val\
    \ arr6 = arr5.reverse\n        val arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n\
    \        val arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n        val\
    \ arr11 = arr10.reverse\n        val arr12 = arr11.reverse\n        val arr13\
    \ = arr12.reverse\n        val arr14 = arr13.reverse\n        val arr15 = arr14.reverse\n\
    \        val arr16 = arr15.reverse\n        val arr17 = arr16.reverse\n      \
    \  val arr18 = arr17.reverse\n        val arr19 = arr18.reverse\n        val arr20\
    \ = arr19.reverse\n        val arr21 = arr20.reverse\n        val arr22 = arr21.reverse\n\
    \        val arr23 = arr22.reverse\n        val arr24 = arr23.reverse\n      \
    \  val arr25 = arr24.reverse\n        val arr26 = arr25.reverse\n        val arr27\
    \ = arr26.reverse\n        val arr28 = arr27.reverse\n        val arr29 = arr28.reverse\n\
    \        val arr30 = arr29.reverse\n        val arr31 = arr30.reverse\n      \
    \  val arr32 = arr31.reverse\n        val arr33 = arr32.reverse\n        val arr34\
    \ = arr33.reverse\n        val arr35 = arr34.reverse\n        val arr36 = arr35.reverse\n\
    \        val arr37 = arr36.reverse\n        val arr38 = arr37.reverse\n      \
    \  val arr39 = arr38.reverse\n        val arr40 = arr39.reverse\n        val arr41\
    \ = arr40.reverse\n        val arr42 = arr41.reverse\n        val arr43 = arr42.reverse\n\
    \        val arr44 = arr43.reverse\n        val arr45 = arr44.reverse\n      \
    \  val arr46 = arr45.reverse\n        val arr47 = arr46.reverse\n        val arr48\
    \ = arr47.reverse\n        val arr49 = arr48.reverse\n        val arr50 = arr49.reverse\n\
    \        val arr51 = arr50.reverse\n        val arr52 = arr51.reverse\n      \
    \  val arr53 = arr52.reverse\n        val arr54 = arr53.reverse\n        val arr55\
    \ = arr54.reverse\n        val arr56 = arr55.reverse\n        val \n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp2oozhc1f.scala:84:11 ---------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2oozhc1f.scala:28:18 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp2oozhc1f.scala:85:5 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009426
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toArray\n \
    \       val result = new Array[Boolean](n)\n        var i = 0\n        var j =\
    \ 0\n        var k = 0\n        var temp = 0\n        var flag = false\n     \
    \   while(i < n) {\n            while(j < n) {\n                if(arr(i) < arr(j))\
    \ {\n                    temp = arr(i)\n                    arr(i) = arr(j)\n\
    \                    arr(j) = temp\n                    i = i + 1\n          \
    \          j = j + 1\n                }\n                else {\n            \
    \        temp = arr(j)\n                    arr(j) = arr(i)\n                \
    \    arr(i) = temp\n                    j = j + 1\n                }\n       \
    \     }\n            k = i\n            while(k >= 0) {\n                if(arr(k)\
    \ < arr(k - 1)) {\n                    temp = arr(k)\n                    arr(k)\
    \ = arr(k - 1)\n                    arr(k - 1) = temp\n                    k =\
    \ k - 1\n                }\n                else {\n                    temp =\
    \ arr(k)\n                    arr(k) = arr(k + 1)\n                    arr(k +\
    \ 1) = temp\n                    k = k + 1\n                }\n            }\n\
    \            i = k\n            flag = true\n            while(i < n) {\n    \
    \            if(arr(i) < arr(i + 1)) {\n                    temp = arr(i)\n  \
    \                  arr(i) = arr(i + 1)\n                    arr(i + 1) = temp\n\
    \                    i = i + 1\n                }\n                else {\n  \
    \                  temp = arr(i)\n                    arr(i) = arr(i - 1)\n  \
    \                  arr(i - 1) = temp\n                    i = i - 1\n        \
    \        }\n            }\n            if(flag) {\n                flag = false\n\
    \                i = k\n                while(i < n) {\n                    if(arr(i)\
    \ < arr(i + 1)) {\n                        temp = arr(i)\n                   \
    \     arr(i) = arr(i + 1)\n                        arr(i + 1) = temp\n       \
    \                 i = i + 1\n                    }\n                    else {\n\
    \                        temp = arr(i)\n                        arr(i) = arr(i\
    \ - 1)\n                        arr(i - 1) = temp\n                        i =\
    \ i - 1\n                    }\n                }\n            }\n        }\n\
    \        for(i<-n;i>=0;i--) {\n            if(arr(i) < arr(i + 1)) {\n       \
    \         temp = arr(i)\n                arr(i) = arr(i + 1)\n               \
    \ arr(i + 1) = temp\n            }\n            else {\n                temp =\
    \ arr(i)\n                arr(i) = arr(i - 1)\n                arr(i - 1) = temp\n\
    \            }\n        }\n        for(i<-n;i>=0;i--) {\n            if(arr(i)\
    \ < arr(i + 1)) {\n                temp = arr(i)\n                arr(i) = arr(i\
    \ + 1)\n                arr(i + 1) = temp\n            }\n            else {\n\
    \                temp = arr(i)\n                arr(i) = arr(i - 1)\n        \
    \        arr(i - \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmps35g4dft.scala:100:21 --------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m        \e[33mfor\e[0m(i<-n;i>=\e[31m0\e[0m;i--) {\n\
    \e[31m\e[31m    |\e[0m                     ^\e[0m\n\e[31m    |\e[0m          \
    \           '<-' expected, but ';' found\n\e[31m\e[31m-- [E032] Syntax Error:\
    \ /tmp/tmps35g4dft.scala:100:25 --------------------------\e[0m\e[0m\n\e[31m100\
    \ |\e[0m        \e[33mfor\e[0m(i<-n;i>=\e[31m0\e[0m;i--) {\n\e[31m\e[31m    |\e\
    [0m                         ^\e[0m\n\e[31m    |\e[0m                         pattern\
    \ expected\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmps35g4dft.scala:112:21\
    \ --------------------------\e[0m\e[0m\n\e[31m112 |\e[0m        \e[33mfor\e[0m(i<-n;i>=\e\
    [31m0\e[0m;i--) {\n\e[31m\e[31m    |\e[0m                     ^\e[0m\n\e[31m \
    \   |\e[0m                     '<-' expected, but ';' found\n\e[31m\e[31m-- [E032]\
    \ Syntax Error: /tmp/tmps35g4dft.scala:112:25 --------------------------\e[0m\e\
    [0m\n\e[31m112 |\e[0m        \e[33mfor\e[0m(i<-n;i>=\e[31m0\e[0m;i--) {\n\e[31m\e\
    [31m    |\e[0m                         ^\e[0m\n\e[31m    |\e[0m              \
    \           pattern expected\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmps35g4dft.scala:121:23 --------------------------\e[0m\e[0m\n\e[31m121\
    \ |\e[0m                arr(i - \n\e[31m\e[31m    |\e[0m                     \
    \  ^\e[0m\n\e[31m    |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmps35g4dft.scala:132:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m132 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmps35g4dft.scala:27:18 ---------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\e[31m\e\
    [31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val result = new Array[Long](n)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var flag = false\n        var\
    \ temp1 = new Array[Long](n)\n        var temp2 = new Array[Long](n)\n       \
    \ var temp3 = new Array[Long](n)\n        var temp4 = new Array[Long](n)\n   \
    \     var temp5 = new Array[Long](n)\n        var temp6 = new Array[Long](n)\n\
    \        var temp7 = new Array[Long](n)\n        var temp8 = new Array[Long](n)\n\
    \        var temp9 = new Array[Long](n)\n        var temp10 = new Array[Long](n)\n\
    \        var temp11 = new Array[Long](n)\n        var temp12 = new Array[Long](n)\n\
    \        var temp13 = new Array[Long](n)\n        var temp14 = new Array[Long](n)\n\
    \        var temp15 = new Array[Long](n)\n        var temp16 = new Array[Long](n)\n\
    \        var temp17 = new Array[Long](n)\n        var temp18 = new Array[Long](n)\n\
    \        var temp19 = new Array[Long](n)\n        var temp20 = new Array[Long](n)\n\
    \        var temp21 = new Array[Long](n)\n        var temp22 = new Array[Long](n)\n\
    \        var temp23 = new Array[Long](n)\n        var temp24 = new Array[Long](n)\n\
    \        var temp25 = new Array[Long](n)\n        var temp26 = new Array[Long](n)\n\
    \        var temp27 = new Array[Long](n)\n        var temp28 = new Array[Long](n)\n\
    \        var temp29 = new Array[Long](n)\n        var temp30 = new Array[Long](n)\n\
    \        var temp31 = new Array[Long](n)\n        var temp32 = new Array[Long](n)\n\
    \        var temp33 = new Array[Long](n)\n        var temp34 = new Array[Long](n)\n\
    \        var temp35 = new Array[Long](n)\n        var temp36 = new Array[Long](n)\n\
    \        var temp37 = new Array[Long](n)\n        var temp38 = new Array[Long](n)\n\
    \        var temp39 = new Array[Long](n)\n        var temp40 = new Array[Long](n)\n\
    \        var temp41 = new Array[Long](n)\n        var temp42 = new Array[Long](n)\n\
    \        var temp43 = new Array[Long](n)\n        var temp44 = new Array[Long](n)\n\
    \        var temp45 = new Array[Long](n)\n        var temp46 = new Array[Long](n)\n\
    \        var temp47 = new \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp26r7h30p.scala:81:4 ----------------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp26r7h30p.scala:27:18 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp26r7h30p.scala:81:5 ---------------------\e[0m\e[0m\n\e[31m81\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009426
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val startIndex = len - 1 \n        val endIndex = startIndex - 1\n  \
    \      val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = arr.lastIndex\n        val endIndex = arr.lastIndex\
    \ - 1\n        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = arr.lastIndex\n        val endIndex = arr.lastIndex\
    \ - 1\n        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = arr.lastIndex\n        val endIndex = arr.lastIndex\
    \ - 1\n        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = arr.lastIndex\n        val endIndex = arr.lastIndex\
    \ - 1\n        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = arr.lastIndex\n        val endIndex = arr.lastIndex\
    \ - 1\n        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = arr.lastIndex\n        val endIndex = arr.lastIndex\
    \ - 1\n        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = arr.lastIndex\n        val endIndex = arr.lastIndex\
    \ - 1\n        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = arr.lastIndex\n        val endIndex = arr.lastIndex\
    \ - 1\n        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = arr.lastIndex\n        val endIndex = arr.lastIndex\
    \ - 1\n        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = arr.lastIndex\n        val endIndex = arr.lastIndex\
    \ - 1\n        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = arr.lastIndex\n        val endIndex = arr.lastIndex\
    \ - 1\n        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = arr.lastIndex\n        val endIndex = arr.lastIndex\
    \ - 1\n        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = arr.lastIndex\n        val endIndex = arr.lastIndex\
    \ - 1\n        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = arr.lastIndex\n        val endIndex = arr.lastIndex\
    \ - 1\n        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxe0lq_vy.scala:88:24 ---------------------------\e\
    [0m\e[0m\n\e[31m88 |\e[0m        \e[33mval\e[0m \e[36mstartIndex\e[0m = \n\e[31m\e\
    [31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                 \
    \       expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxe0lq_vy.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mstartIndex\e[0m = arr.lastIndex\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mstartIndex is already defined as \e[33mvalue\e[0m \e[35mstartIndex\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpxe0lq_vy.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36mendIndex\e[0m = arr.lastIndex - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mendIndex is already defined as \e[33mvalue\e[0m \e[35mendIndex\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpxe0lq_vy.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mstartValue\e[0m = arr(startIndex)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstartValue\
    \ is already defined as \e[33mvalue\e[0m \e[35mstartValue\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxe0lq_vy.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mendValue\e[0m = arr(endIndex)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mendValue is already defined as \e[33mvalue\e[0m \e[35mendValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defin"
  stdout: ''
  timestamp: 1660009427
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if(arr.isEmpty) true\n        else {\n            val\
    \ n = arr.size\n            val arr = arr.toArray\n            val arr1 = arr.slice(1,\
    \ n-1)\n            val arr2 = arr.slice(1, n-1)\n            val arr3 = arr.slice(1,\
    \ n-1)\n            val arr4 = arr.slice(1, n-1)\n            val arr5 = arr.slice(1,\
    \ n-1)\n            val arr6 = arr.slice(1, n-1)\n            val arr7 = arr.slice(1,\
    \ n-1)\n            val arr8 = arr.slice(1, n-1)\n            val arr9 = arr.slice(1,\
    \ n-1)\n            val arr10 = arr.slice(1, n-1)\n            val arr11 = arr.slice(1,\
    \ n-1)\n            val arr12 = arr.slice(1, n-1)\n            val arr13 = arr.slice(1,\
    \ n-1)\n            val arr14 = arr.slice(1, n-1)\n            val arr15 = arr.slice(1,\
    \ n-1)\n            val arr16 = arr.slice(1, n-1)\n            val arr17 = arr.slice(1,\
    \ n-1)\n            val arr18 = arr.slice(1, n-1)\n            val arr19 = arr.slice(1,\
    \ n-1)\n            val arr20 = arr.slice(1, n-1)\n            val arr21 = arr.slice(1,\
    \ n-1)\n            val arr22 = arr.slice(1, n-1)\n            val arr23 = arr.slice(1,\
    \ n-1)\n            val arr24 = arr.slice(1, n-1)\n            val arr25 = arr.slice(1,\
    \ n-1)\n            val arr26 = arr.slice(1, n-1)\n            val arr27 = arr.slice(1,\
    \ n-1)\n            val arr28 = arr.slice(1, n-1)\n            val arr29 = arr.slice(1,\
    \ n-1)\n            val arr30 = arr.slice(1, n-1)\n            val arr31 = arr.slice(1,\
    \ n-1)\n            val arr32 = arr.slice(1, n-1)\n            val arr33 = arr.slice(1,\
    \ n-1)\n            val arr34 = arr.slice(1, n-1)\n            val arr35 = arr.slice(1,\
    \ n-1)\n            val arr36 = arr.slice(1, n-1)\n            val arr37 = arr.slice(1,\
    \ n-1)\n            val arr38 = arr.slice(1, n-1)\n            val arr39 = arr.slice(1,\
    \ n-1)\n            val arr40 = arr.slice(1, n-1)\n            val arr41 = arr.slice(1,\
    \ n-1)\n            val arr42 = arr.slice(1, n-1)\n            val arr43 = arr.slice(1,\
    \ n-1)\n            val arr44 = arr.slice(1, n-1)\n            val arr45 = arr.slice(1,\
    \ n-1)\n            val arr46 = arr.slice(1, \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwwjo6v9u.scala:76:4 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwwjo6v9u.scala:86:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m86 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpwwjo6v9u.scala:29:22 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m            \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwwjo6v9u.scala:85:1 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpwwjo6v9u.scala:77:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m77 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660009427
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val l = arr.last\n        val r = arr.head\n        val arr = arr.drop(1).dropRight(1).drop(1).dropRight(1)\n\
    \        val l = arr.last\n        val r = arr.head\n        val arr = arr.drop(1).dropRight(1).drop(1).dropRight(1)\n\
    \        val l = arr.last\n        val r = arr.head\n        val arr = arr.drop(1).dropRight(1).drop(1).dropRight(1)\n\
    \        val l = arr.last\n        val r = arr.head\n        val arr = arr.drop(1).dropRight(1).drop(1).dropRight(1)\n\
    \        val l = arr.last\n        val r = arr.head\n        val arr = arr.drop(1).dropRight(1).drop(1).dropRight(1)\n\
    \        val l = arr.last\n        val r = arr.head\n        val arr = arr.drop(1).dropRight(1).drop(1).dropRight(1)\n\
    \        val l = arr.last\n        val r = arr.head\n        val arr = arr.drop(1).dropRight(1).drop(1).dropRight(1)\n\
    \        val l = arr.last\n        val r = arr.head\n        val arr = arr.drop(1).dropRight(1).drop(1).dropRight(1)\n\
    \        val l = arr.last\n        val r = arr.head\n        val arr = arr.drop(1).dropRight(1).drop(1).dropRight(1)\n\
    \        val l = arr.last\n        val r = arr.head\n        val arr = arr.drop(1).dropRight(1).drop(1).dropRight(1)\n\
    \        val l = arr.last\n        val r = arr.head\n        val arr = arr.drop(1).dropRight(1).drop(1).dropRight(1)\n\
    \        val l = arr.last\n        val r = arr.head\n        val arr = arr.drop(1).dropRight(1).drop(1).dropRight(1)\n\
    \        val l = arr.last\n        val r = arr.head\n        val arr = arr.drop(1).dropRight(1).drop(1).dropRight(1)\n\
    \        val l = arr.last\n        val r = arr.head\n        val arr = arr.drop(1).dropRight(1).drop(1).dropRight(1)\n\
    \        val l = arr.last\n        val r = arr.head\n        val arr = arr.drop(1).dropRight(1).drop(1).dropRight(1)\n\
    \        val l = arr.last\n        val r = arr.head\n        val arr = arr.drop(1).dropRight(1).drop(1).dropRight(1)\n\
    \        val l = arr.last\n        val r = arr.head\n        val arr = arr.drop(1).\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp76nzzivm.scala:79:4 ----------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp76nzzivm.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(\e[31m1\e[0m).dropRight(\e\
    [31m1\e[0m).drop(\e[31m1\e[0m).dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp76nzzivm.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36ml\e[0m = arr.last\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0ml is already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp76nzzivm.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.head\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e\
    [0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp76nzzivm.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(\e[31m1\e\
    [0m).dropRight(\e[31m1\e[0m).drop(\e[31m1\e[0m).dropRight(\e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp76nzzivm.scala:34:12 ----------------"
  stdout: ''
  timestamp: 1660009427
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val sortedArr = arr.sortBy(_)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpph9udlts.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpph9udlts.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpph9udlts.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.takeRight(n)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpph9udlts.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpph9udlts.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36msortedArr\e[0m = sortedArr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already de"
  stdout: ''
  timestamp: 1660009414
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val m = arr.head\n      \
    \  val arr = arr.tail\n        val arr = arr.toList\n        val arr = arr.sortBy(_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(_)\n        val arr = arr.toList\n        val arr = arr.sortBy(_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(_)\n        val arr = arr.toList\n        val arr = arr.sortBy(_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(_)\n        val arr = arr.toList\n        val arr = arr.sortBy(_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(_)\n        val arr = arr.toList\n        val arr = arr.sortBy(_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(_)\n        val arr = arr.toList\n        val arr = arr.sortBy(_)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(_)\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(_)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(_)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(_)\n        val arr = arr.toList\n        val arr = arr.sortBy(_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj6nl5vpf.scala:91:4 ----------------------------\e\
    [0m\e[0m\n\e[31m91 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj6nl5vpf.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpj6nl5vpf.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined\
    \ as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj6nl5vpf.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj6nl5vpf.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj6nl5vpf.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e"
  stdout: ''
  timestamp: 1659798344
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val m = arr.head\n      \
    \  val arr = arr.tail\n        val arr2 = arr.toList\n        val arr3 = arr2.reverse\n\
    \        val arr4 = arr3.toList\n        val arr5 = arr4.reverse\n        val\
    \ arr6 = arr5.reverse\n        val arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n\
    \        val arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n        val\
    \ arr11 = arr10.reverse\n        val arr12 = arr11.reverse\n        val arr13\
    \ = arr12.reverse\n        val arr14 = arr13.reverse\n        val arr15 = arr14.reverse\n\
    \        val arr16 = arr15.reverse\n        val arr17 = arr16.reverse\n      \
    \  val arr18 = arr17.reverse\n        val arr19 = arr18.reverse\n        val arr20\
    \ = arr19.reverse\n        val arr21 = arr20.reverse\n        val arr22 = arr21.reverse\n\
    \        val arr23 = arr22.reverse\n        val arr24 = arr23.reverse\n      \
    \  val arr25 = arr24.reverse\n        val arr26 = arr25.reverse\n        val arr27\
    \ = arr26.reverse\n        val arr28 = arr27.reverse\n        val arr29 = arr28.reverse\n\
    \        val arr30 = arr29.reverse\n        val arr31 = arr30.reverse\n      \
    \  val arr32 = arr31.reverse\n        val arr33 = arr32.reverse\n        val arr34\
    \ = arr33.reverse\n        val arr35 = arr34.reverse\n        val arr36 = arr35.reverse\n\
    \        val arr37 = arr36.reverse\n        val arr38 = arr37.reverse\n      \
    \  val arr39 = arr38.reverse\n        val arr40 = arr39.reverse\n        val arr41\
    \ = arr40.reverse\n        val arr42 = arr41.reverse\n        val arr43 = arr42.reverse\n\
    \        val arr44 = arr43.reverse\n        val arr45 = arr44.reverse\n      \
    \  val arr46 = arr45.reverse\n        val arr47 = arr46.reverse\n        val arr48\
    \ = arr47.reverse\n        val arr49 = arr48.reverse\n        val arr50 = arr49.reverse\n\
    \        val arr51 = arr50.reverse\n        val arr52 = arr51.reverse\n      \
    \  val arr53 = arr52.reverse\n        val arr54 = arr53.reverse\n        val arr55\
    \ = arr54.reverse\n        val arr56 = arr55.reverse\n        val \n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpu31c7u77.scala:84:11 ---------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpu31c7u77.scala:28:18 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpu31c7u77.scala:85:5 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798343
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val m = arr.head\n      \
    \  val arr = arr.tail\n        val arr2 = arr.toList\n        val arr3 = arr2.reverse\n\
    \        val arr4 = arr3.toList\n        val arr5 = arr4.reverse\n        val\
    \ arr6 = arr5.reverse\n        val arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n\
    \        val arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n        val\
    \ arr11 = arr10.reverse\n        val arr12 = arr11.reverse\n        val arr13\
    \ = arr12.reverse\n        val arr14 = arr13.reverse\n        val arr15 = arr14.reverse\n\
    \        val arr16 = arr15.reverse\n        val arr17 = arr16.reverse\n      \
    \  val arr18 = arr17.reverse\n        val arr19 = arr18.reverse\n        val arr20\
    \ = arr19.reverse\n        val arr21 = arr20.reverse\n        val arr22 = arr21.reverse\n\
    \        val arr23 = arr22.reverse\n        val arr24 = arr23.reverse\n      \
    \  val arr25 = arr24.reverse\n        val arr26 = arr25.reverse\n        val arr27\
    \ = arr26.reverse\n        val arr28 = arr27.reverse\n        val arr29 = arr28.reverse\n\
    \        val arr30 = arr29.reverse\n        val arr31 = arr30.reverse\n      \
    \  val arr32 = arr31.reverse\n        val arr33 = arr32.reverse\n        val arr34\
    \ = arr33.reverse\n        val arr35 = arr34.reverse\n        val arr36 = arr35.reverse\n\
    \        val arr37 = arr36.reverse\n        val arr38 = arr37.reverse\n      \
    \  val arr39 = arr38.reverse\n        val arr40 = arr39.reverse\n        val arr41\
    \ = arr40.reverse\n        val arr42 = arr41.reverse\n        val arr43 = arr42.reverse\n\
    \        val arr44 = arr43.reverse\n        val arr45 = arr44.reverse\n      \
    \  val arr46 = arr45.reverse\n        val arr47 = arr46.reverse\n        val arr48\
    \ = arr47.reverse\n        val arr49 = arr48.reverse\n        val arr50 = arr49.reverse\n\
    \        val arr51 = arr50.reverse\n        val arr52 = arr51.reverse\n      \
    \  val arr53 = arr52.reverse\n        val arr54 = arr53.reverse\n        val arr55\
    \ = arr54.reverse\n        val arr56 = arr55.reverse\n        val \n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpu31c7u77.scala:84:11 ---------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpu31c7u77.scala:28:18 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpu31c7u77.scala:85:5 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798343
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val len = arr.length\n\
    \        if(arr.isEmpty) true\n        else {\n            val maxVal = arr.max\n\
    \            val minVal = arr.min\n            val maxValIndex = arr.lastIndexWhere(_\
    \ == maxVal)\n            val minValIndex = arr.lastIndexWhere(_ == minVal)\n\
    \            val maxValIndexInt = maxValIndex.toInt\n            val minValIndexInt\
    \ = minValIndex.toInt\n            val maxValInt = maxVal.toInt\n            val\
    \ minValInt = minVal.toInt\n            val maxValIndexInt = maxValIndex.toInt\n\
    \            val minValIndexInt = minValIndex.toInt\n            val maxValInt\
    \ = maxVal.toInt\n            val minValInt = minVal.toInt\n            val maxValIndexInt\
    \ = maxValIndex.toInt\n            val minValIndexInt = minValIndex.toInt\n  \
    \          val maxValInt = maxVal.toInt\n            val minValInt = minVal.toInt\n\
    \            val maxValIndexInt = maxValIndex.toInt\n            val minValIndexInt\
    \ = minValIndex.toInt\n            val maxValInt = maxVal.toInt\n            val\
    \ minValInt = minVal.toInt\n            val maxValIndexInt = maxValIndex.toInt\n\
    \            val minValIndexInt = minValIndex.toInt\n            val maxValInt\
    \ = maxVal.toInt\n            val minValInt = minVal.toInt\n            val maxValIndexInt\
    \ = maxValIndex.toInt\n            val minValIndexInt = minValIndex.toInt\n  \
    \          val maxValInt = maxVal.toInt\n            val minValInt = minVal.toInt\n\
    \            val maxValIndexInt = maxValIndex.toInt\n            val minValIndexInt\
    \ = minValIndex.toInt\n            val maxValInt = maxVal.toInt\n            val\
    \ minValInt = minVal.toInt\n            val maxValIndexInt = maxValIndex.toInt\n\
    \            val minValIndexInt = minValIndex.toInt\n            val maxValInt\
    \ = maxVal.toInt\n            val minValInt = minVal.toInt\n            val maxValIndexInt\
    \ = maxValIndex.toInt\n            val minValIndexInt = minValIndex.toInt\n  \
    \          val maxValInt = maxVal.toInt\n            val minValInt = minVal.toInt\n\
    \            val maxValIndexInt = maxValIndex.toInt\n            val \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpens04i_f.scala:71:15 ---------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m            \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m  \
    \             ^\e[0m\n\e[31m   |\e[0m               pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpens04i_f.scala:82:0 ----------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpens04i_f.scala:26:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpens04i_f.scala:38:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e\
    [0m \e[36mmaxValIndexInt\e[0m = maxValIndex.toInt\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValIndexInt\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxValIndexInt\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpens04i_f.scala:39:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m            \e[33mval\e\
    [0m \e[36mminValIndexInt\e[0m = minValIndex.toInt\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminValIndexInt\
    \ is already defined as \e[33mvalue\e[0m \e[35mminValIndexInt\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpens04i_f.scala:40:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m            \e[33mval\e\
    [0m \e[36mmaxValInt\e[0m = maxVal.toInt\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxValInt is already d"
  stdout: ''
  timestamp: 1660009426
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n        else\
    \ {\n            val arr = arr.sortBy(_)\n            val first = arr(0)\n   \
    \         val last = arr(n)\n            val mid = first + last\n            val\
    \ left = arr.filter(_ < mid)\n            val right = arr.filter(_ >= mid)\n \
    \           val leftSorted = moveOneBall(left)\n            val rightSorted =\
    \ moveOneBall(right)\n            if (leftSorted && rightSorted) true\n      \
    \      else moveOneBall(leftSorted) || moveOneBall(rightSorted)\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpx8ypqp5q.scala:29:33 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m\
    \   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer\
    \ the type of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 =>\
    \ arr.sortBy(_$1).\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx8ypqp5q.scala:29:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e\
    [0m \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m   |\e[0m                    \
    \  ^\e[0m\n\e[31m   |\e[0m                      Recursive \e[33mvalue\e[0m \e\
    [35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx8ypqp5q.scala:38:29\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m            \e[33melse\e[0m moveOneBall(leftSorted)\
    \ || moveOneBall(rightSorted)\n\e[31m\e[31m   |\e[0m                         \
    \    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             Found:    (leftSorted\
    \ : Boolean)\n\e[31m   |\e[0m                             Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx8ypqp5q.scala:38:56\
    \ --------------------\e[0m\e[0m\n\e[31m38 |\e[0m            \e[33melse\e[0m moveOneBall(leftSorted)\
    \ || moveOneBall(rightSorted)\n\e[31m\e[31m   |\e[0m                         \
    \                               ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                           Found:    (rightSorted : Boolean)\n\e[31m   |\e[0m\
    \                                       Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009428
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val result = new mutable.ListBuffer[Long]()\n        val shifts = mutable.ListBuffer[Int]()\n\
    \        val shift = 0\n        val shiftCount = 1\n        val shiftCountLimit\
    \ = math.pow(2, n).toInt\n        val shiftLimit = math.pow(2, n).toInt\n    \
    \    val shiftLimitLimit = math.pow(2, n).toInt\n        val shiftLimitLimitLimit\
    \ = math.pow(2, n).toInt\n        val shiftLimitLimitLimit = math.pow(2, n).toInt\n\
    \        val shiftLimitLimitLimit = math.pow(2, n).toInt\n        val shiftLimitLimitLimit\
    \ = math.pow(2, n).toInt\n        val shiftLimitLimitLimit = math.pow(2, n).toInt\n\
    \        val shiftLimitLimitLimit = math.pow(2, n).toInt\n        val shiftLimitLimitLimit\
    \ = math.pow(2, n).toInt\n        val shiftLimitLimitLimit = math.pow(2, n).toInt\n\
    \        val shiftLimitLimitLimit = math.pow(2, n).toInt\n        val shiftLimitLimitLimit\
    \ = math.pow(2, n).toInt\n        val shiftLimitLimitLimit = math.pow(2, n).toInt\n\
    \        val shiftLimitLimitLimit = math.pow(2, n).toInt\n        val shiftLimitLimitLimit\
    \ = math.pow(2, n).toInt\n        val shiftLimitLimitLimit = math.pow(2, n).toInt\n\
    \        val shiftLimitLimitLimit = math.pow(2, n).toInt\n        val shiftLimitLimitLimit\
    \ = math.pow(2, n).toInt\n        val shiftLimitLimitLimit = math.pow(2, n).toInt\n\
    \        val shiftLimitLimitLimit = math.pow(2, n).toInt\n        val shiftLimitLimitLimit\
    \ = math.pow(2, n).toInt\n        val shiftLimitLimitLimit = math.pow(2, n).toInt\n\
    \        val shiftLimitLimitLimit = math.pow(2, n).toInt\n        val shiftLimitLimitLimit\
    \ = math.pow(2, n).toInt\n        val shiftLimitLimitLimit = math.pow(2, n).toInt\n\
    \        val shiftLimitLimitLimit = math.pow(2, n).toInt\n        val shiftLimitLimitLimit\
    \ = math.pow(2, n).toInt\n        val shiftLimitLimitLimit = math.pow(2, n).toInt\n\
    \        val shiftLimitLimitLimit = math.pow(2, n).toInt\n        val shiftLimitLimitLimit\
    \ = math.pow(2, n).toInt\n        val shiftLimitLimitLimit = math.pow(2, n).toInt\n\
    \        val shiftLimitLimitLimit = math.pow(2, n).toInt\n        val shiftLimit\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph0tyure3.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph0tyure3.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mshiftLimitLimitLimit\e[0m = math.pow(\e[31m2\e[0m, n).toInt\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mshiftLimitLimitLimit is already defined as \e[33mvalue\e[0m \e[35mshiftLimitLimitLimit\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmph0tyure3.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mshiftLimitLimitLimit\e[0m = math.pow(\e\
    [31m2\e[0m, n).toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mshiftLimitLimitLimit is already defined as \e[33mvalue\e[0m\
    \ \e[35mshiftLimitLimitLimit\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmph0tyure3.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mshiftLimitLimitLimit\e[0m\
    \ = math.pow(\e[31m2\e[0m, n).toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mshiftLimitLimitLimit is already defined as \e[33mvalue\e[0m\
    \ \e[35mshiftLimitLimitLimit\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmph0tyure3.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mshiftLimitLimitLimit\e[0m\
    \ = math.pow(\e[31m2\e[0m, n).toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mshiftLimitLimitLimit is already defined as \e[33mvalue\e[0m\
    \ \e[35mshiftLimitLimitLimit\e[0m\n\e[31m  "
  stdout: ''
  timestamp: 1660009428
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val arr1 = arr.sortBy(x => x)\n        val arr2 = arr1.reverse\n        val\
    \ arr3 = arr2.sortBy(x => x)\n        val arr4 = arr3.reverse\n        val arr5\
    \ = arr4.reverse\n        val arr6 = arr5.reverse\n        val arr7 = arr6.reverse\n\
    \        val arr8 = arr7.reverse\n        val arr9 = arr8.reverse\n        val\
    \ arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n        val arr12 =\
    \ arr11.reverse\n        val arr13 = arr12.reverse\n        val arr14 = arr13.reverse\n\
    \        val arr15 = arr14.reverse\n        val arr16 = arr15.reverse\n      \
    \  val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n        val arr19\
    \ = arr18.reverse\n        val arr20 = arr19.reverse\n        val arr21 = arr20.reverse\n\
    \        val arr22 = arr21.reverse\n        val arr23 = arr22.reverse\n      \
    \  val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n        val arr26\
    \ = arr25.reverse\n        val arr27 = arr26.reverse\n        val arr28 = arr27.reverse\n\
    \        val arr29 = arr28.reverse\n        val arr30 = arr29.reverse\n      \
    \  val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n        val arr33\
    \ = arr32.reverse\n        val arr34 = arr33.reverse\n        val arr35 = arr34.reverse\n\
    \        val arr36 = arr35.reverse\n        val arr37 = arr36.reverse\n      \
    \  val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n        val arr40\
    \ = arr39.reverse\n        val arr41 = arr40.reverse\n        val arr42 = arr41.reverse\n\
    \        val arr43 = arr42.reverse\n        val arr44 = arr43.reverse\n      \
    \  val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n        val arr47\
    \ = arr46.reverse\n        val arr48 = arr47.reverse\n        val arr49 = arr48.reverse\n\
    \        val arr50 = arr49.reverse\n        val arr51 = arr50.reverse\n      \
    \  val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n        val arr54\
    \ = arr53.reverse\n        val arr55 = arr54.reverse\n        val \n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmped98vu10.scala:83:11 ---------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmped98vu10.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmped98vu10.scala:84:5 ---------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009428
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toArray\n \
    \       val result = new Array[Boolean](n)\n        var i = 0\n        var j =\
    \ 0\n        var k = 0\n        var temp = 0\n        var flag = false\n     \
    \   while(i < n) {\n            while(j < n) {\n                if(arr(j) < arr(i))\
    \ {\n                    temp = arr(j)\n                    arr(j) = arr(i)\n\
    \                    arr(i) = temp\n                    flag = true\n        \
    \        }\n                j++\n            }\n            if(flag) {\n     \
    \           k = 0\n                while(j < n) {\n                    if(arr(j)\
    \ < arr(k)) {\n                        temp = arr(j)\n                       \
    \ arr(j) = arr(k)\n                        arr(k) = temp\n                   \
    \     flag = true\n                    }\n                    k++\n          \
    \      }\n            }\n            if(flag) {\n                k = 0\n     \
    \           while(j < n) {\n                    if(arr(j) < arr(k)) {\n      \
    \                  temp = arr(j)\n                        arr(j) = arr(k)\n  \
    \                      arr(k) = temp\n                        flag = true\n  \
    \                  }\n                    k++\n                }\n           \
    \ }\n            if(flag) {\n                k = 0\n                while(j <\
    \ n) {\n                    if(arr(j) < arr(k)) {\n                        temp\
    \ = arr(j)\n                        arr(j) = arr(k)\n                        arr(k)\
    \ = temp\n                        flag = true\n                    }\n       \
    \             k++\n                }\n            }\n            if(flag) {\n\
    \                k = 0\n                while(j < n) {\n                    if(arr(j)\
    \ < arr(k)) {\n                        temp = arr(j)\n                       \
    \ arr(j) = arr(k)\n                        arr(k) = temp\n                   \
    \     flag = true\n                    }\n                    k++\n          \
    \      }\n            }\n            if(flag) {\n                k = 0\n     \
    \           while(j < n) {\n                    if(arr(j) < arr(k)) {\n      \
    \                  temp = arr(j)\n                        arr(j) = arr(k)\n  \
    \                      arr(k) = temp\n                        flag = true\n  \
    \                  }\n                    k++\n                }\n           \
    \ }\n            if(flag) {\n                k = 0\n                while(j <\
    \ n) {\n                    if(arr(j) < arr(k)) {\n                        temp\
    \ = arr(j)\n                        arr(j) = arr(k)\n                        arr(k)\
    \ = temp\n                        flag = true\n                    }\n       \
    \             k++\n                }\n            }\n            if(flag) {\n\
    \                k = 0\n                while(j < n) {\n                    if(arr(j)\
    \ < arr(k)) {\n                        temp = arr(j)\n                       \
    \ arr(j) = arr(k)\n                        arr(k) = temp\n                   \
    \     flag = true\n                    }\n                    k++\n          \
    \      }\n            }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpx1wznrw0.scala:42:19 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpx1wznrw0.scala:53:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m53 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpx1wznrw0.scala:65:23 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpx1wznrw0.scala:77:23 ---------------------------\e[0m\e[0m\n\e[31m77\
    \ |\e[0m                    k++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpx1wznrw0.scala:89:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m89 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpx1wznrw0.scala:101:23 --------------------------\e\
    [0m\e[0m\n\e[31m101 |\e[0m                    k++\n\e[31m\e[31m    |\e[0m    \
    \                   ^\e[0m\n\e[31m    |\e[0m                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer\
    \ explanat"
  stdout: ''
  timestamp: 1660009433
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toArray\n \
    \       val arr2 = arr.clone\n        val arr3 = arr.clone\n        val arr4 =\
    \ arr.clone\n        val arr5 = arr.clone\n        val arr6 = arr.clone\n    \
    \    val arr7 = arr.clone\n        val arr8 = arr.clone\n        val arr9 = arr.clone\n\
    \        val arr10 = arr.clone\n        val arr11 = arr.clone\n        val arr12\
    \ = arr.clone\n        val arr13 = arr.clone\n        val arr14 = arr.clone\n\
    \        val arr15 = arr.clone\n        val arr16 = arr.clone\n        val arr17\
    \ = arr.clone\n        val arr18 = arr.clone\n        val arr19 = arr.clone\n\
    \        val arr20 = arr.clone\n        val arr21 = arr.clone\n        val arr22\
    \ = arr.clone\n        val arr23 = arr.clone\n        val arr24 = arr.clone\n\
    \        val arr25 = arr.clone\n        val arr26 = arr.clone\n        val arr27\
    \ = arr.clone\n        val arr28 = arr.clone\n        val arr29 = arr.clone\n\
    \        val arr30 = arr.clone\n        val arr31 = arr.clone\n        val arr32\
    \ = arr.clone\n        val arr33 = arr.clone\n        val arr34 = arr.clone\n\
    \        val arr35 = arr.clone\n        val arr36 = arr.clone\n        val arr37\
    \ = arr.clone\n        val arr38 = arr.clone\n        val arr39 = arr.clone\n\
    \        val arr40 = arr.clone\n        val arr41 = arr.clone\n        val arr42\
    \ = arr.clone\n        val arr43 = arr.clone\n        val arr44 = arr.clone\n\
    \        val arr45 = arr.clone\n        val arr46 = arr.clone\n        val arr47\
    \ = arr.clone\n        val arr48 = arr.clone\n        val arr49 = arr.clone\n\
    \        val arr50 = arr.clone\n        val arr51 = arr.clone\n        val arr52\
    \ = arr.clone\n        val arr53 = arr.clone\n        val arr54 = arr.clone\n\
    \        val arr55 = arr.clone\n        val arr56 = arr.clone\n        val arr57\
    \ = arr.clone\n        val arr58 = arr.clone\n        val arr59 = arr.clone\n\
    \        val arr60 = arr.clone\n        val arr61 = arr.clone\n        val arr62\
    \ = arr.clone\n        val arr63 = arr.clone\n        val arr64 = arr.clone\n\
    \        val arr65 = arr.\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphqt4moz7.scala:92:4 ----------------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmphqt4moz7.scala:27:18 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmphqt4moz7.scala:92:5 ---------------------\e[0m\e[0m\n\e[31m92\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009433
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val len = arr.length\n        val arr1 = arr.toArray\n        val arr2\
    \ = arr1.clone()\n        val arr3 = arr2.clone()\n        val arr4 = arr3.clone()\n\
    \        val arr5 = arr4.clone()\n        val arr6 = arr5.clone()\n        val\
    \ arr7 = arr6.clone()\n        val arr8 = arr7.clone()\n        val arr9 = arr8.clone()\n\
    \        val arr10 = arr9.clone()\n        val arr11 = arr10.clone()\n       \
    \ val arr12 = arr11.clone()\n        val arr13 = arr12.clone()\n        val arr14\
    \ = arr13.clone()\n        val arr15 = arr14.clone()\n        val arr16 = arr15.clone()\n\
    \        val arr17 = arr16.clone()\n        val arr18 = arr17.clone()\n      \
    \  val arr19 = arr18.clone()\n        val arr20 = arr19.clone()\n        val arr21\
    \ = arr20.clone()\n        val arr22 = arr21.clone()\n        val arr23 = arr22.clone()\n\
    \        val arr24 = arr23.clone()\n        val arr25 = arr24.clone()\n      \
    \  val arr26 = arr25.clone()\n        val arr27 = arr26.clone()\n        val arr28\
    \ = arr27.clone()\n        val arr29 = arr28.clone()\n        val arr30 = arr29.clone()\n\
    \        val arr31 = arr30.clone()\n        val arr32 = arr31.clone()\n      \
    \  val arr33 = arr32.clone()\n        val arr34 = arr33.clone()\n        val arr35\
    \ = arr34.clone()\n        val arr36 = arr35.clone()\n        val arr37 = arr36.clone()\n\
    \        val arr38 = arr37.clone()\n        val arr39 = arr38.clone()\n      \
    \  val arr40 = arr39.clone()\n        val arr41 = arr40.clone()\n        val arr42\
    \ = arr41.clone()\n        val arr43 = arr42.clone()\n        val arr44 = arr43.clone()\n\
    \        val arr45 = arr44.clone()\n        val arr46 = arr45.clone()\n      \
    \  val arr47 = arr46.clone()\n        val arr48 = arr47.clone()\n        val arr49\
    \ = arr48.clone()\n        val arr50 = arr49.clone()\n        val arr51 = arr50.clone()\n\
    \        val arr52 = arr51.clone()\n        val arr53 = arr52.clone()\n      \
    \  val arr54 = arr53.clone()\n        val arr55 = arr54\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpigmi3auc.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpigmi3auc.scala:84:5 ---------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009434
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val arr2 = arr.toList\n        val arr3 = arr2.reverse\n\
    \        val arr4 = arr3.toList\n        val arr5 = arr4.toList\n        val arr6\
    \ = arr5.toList\n        val arr7 = arr6.reverse\n        val arr8 = arr7.toList\n\
    \        val arr9 = arr8.toList\n        val arr10 = arr9.reverse\n        val\
    \ arr11 = arr10.toList\n        val arr12 = arr11.reverse\n        val arr13 =\
    \ arr12.toList\n        val arr14 = arr13.reverse\n        val arr15 = arr14.toList\n\
    \        val arr16 = arr15.reverse\n        val arr17 = arr16.toList\n       \
    \ val arr18 = arr17.reverse\n        val arr19 = arr18.toList\n        val arr20\
    \ = arr19.reverse\n        val arr21 = arr20.toList\n        val arr22 = arr21.reverse\n\
    \        val arr23 = arr22.toList\n        val arr24 = arr23.reverse\n       \
    \ val arr25 = arr24.toList\n        val arr26 = arr25.reverse\n        val arr27\
    \ = arr26.toList\n        val arr28 = arr27.reverse\n        val arr29 = arr28.toList\n\
    \        val arr30 = arr29.reverse\n        val arr31 = arr30.toList\n       \
    \ val arr32 = arr31.reverse\n        val arr33 = arr32.toList\n        val arr34\
    \ = arr33.reverse\n        val arr35 = arr34.toList\n        val arr36 = arr35.reverse\n\
    \        val arr37 = arr36.toList\n        val arr38 = arr37.reverse\n       \
    \ val arr39 = arr38.toList\n        val arr40 = arr39.reverse\n        val arr41\
    \ = arr40.toList\n        val arr42 = arr41.reverse\n        val arr43 = arr42.toList\n\
    \        val arr44 = arr43.reverse\n        val arr45 = arr44.toList\n       \
    \ val arr46 = arr45.reverse\n        val arr47 = arr46.toList\n        val arr48\
    \ = arr47.reverse\n        val arr49 = arr48.toList\n        val arr50 = arr49.reverse\n\
    \        val arr51 = arr50.toList\n        val arr52 = arr51.reverse\n       \
    \ val arr53 = arr52.toList\n        val arr54\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7s718m0u.scala:82:4 ----------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7s718m0u.scala:28:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7s718m0u.scala:82:5\
    \ ---------------------\e[0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009434
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n        else\
    \ {\n            val m = arr.head\n            val l = arr.tail\n            val\
    \ r = l.tail\n            val d = r.tail\n            val c = d.tail\n       \
    \     val b = c.tail\n            val a = b.tail\n            val s = a.tail\n\
    \            val r = s.tail\n            val d = r.tail\n            val c = d.tail\n\
    \            val b = c.tail\n            val a = b.tail\n            val s = a.tail\n\
    \            val r = s.tail\n            val d = r.tail\n            val c = d.tail\n\
    \            val b = c.tail\n            val a = b.tail\n            val s = a.tail\n\
    \            val r = s.tail\n            val d = r.tail\n            val c = d.tail\n\
    \            val b = c.tail\n            val a = b.tail\n            val s = a.tail\n\
    \            val r = s.tail\n            val d = r.tail\n            val c = d.tail\n\
    \            val b = c.tail\n            val a = b.tail\n            val s = a.tail\n\
    \            val r = s.tail\n            val d = r.tail\n            val c = d.tail\n\
    \            val b = c.tail\n            val a = b.tail\n            val s = a.tail\n\
    \            val r = s.tail\n            val d = r.tail\n            val c = d.tail\n\
    \            val b = c.tail\n            val a = b.tail\n            val s = a.tail\n\
    \            val r = s.tail\n            val d = r.tail\n            val c = d.tail\n\
    \            val b = c.tail\n            val a = b.tail\n            val s = a.tail\n\
    \            val r = s.tail\n            val d = r.tail\n            val c = d.tail\n\
    \            val b = c.tail\n            val a = b.tail\n            val s = a.tail\n\
    \            val r = s.tail\n            val d = r.tail\n            val c = d.tail\n\
    \            val b = c.tail\n            val a = b.tail\n            val s = a.tail\n\
    \            val r = s.tail\n            val d = r.tail\n            val c = d.tail\n\
    \            val b = c.tail\n            val a = b.tail\n            val s = a.tail\n\
    \            val r = s.tail\n            val d = r.tail\n            val c = d.tail\n\
    \            val b = c.tail\n            val a = b.tail\n            val s = a.tail\n\
    \            val r = s.tail\n            val d = r.tail\n            val c = d.tail\n\
    \            val b = c.tail\n            val a = b.tail\n            val s = a.tail\n\
    \            val r = s.tail\n            val d = r.tail\n            val c = d.tail\n\
    \            \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1th1rgpr.scala:123:0 ---------------------------\e\
    [0m\e[0m\n\e[31m123 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1th1rgpr.scala:37:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e\
    [0m \e[36mr\e[0m = s.tail\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp1th1rgpr.scala:38:16 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m            \e[33mval\e[0m \e[36md\e[0m = r.tail\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already defined as \e[33mvalue\e\
    [0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp1th1rgpr.scala:39:16 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m            \e[33mval\e[0m \e[36mc\e[0m = d.tail\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mc is already\
    \ defined as \e[33mvalue\e[0m \e[35mc\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1th1rgpr.scala:40:16 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            \e[33mval\e[0m \e[36mb\e[0m = c.tail\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mb is already\
    \ defined as \e[33mvalue\e[0m \e[35mb\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1th1rgpr.scala:41:16 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mval\e[0m \e[36ma\e[0m = b.tail\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ma is already\
    \ defined as \e[33mvalue\e[0m \e[35ma\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded me"
  stdout: ''
  timestamp: 1660009435
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:33:12 ---------------------------\e\
    [0m\e[0"
  stdout: ''
  timestamp: 1660009388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val l = arr.length\n        val m = arr.toSet.toArray\n        val r = arr.toSeq.toArray\n\
    \        val s = arr.toSeq.toSet.toArray\n        val t = arr.toSeq.toSet.toSeq.toArray\n\
    \        val u = arr.toSeq.toSet.toSeq.toSeq.toArray\n        val v = arr.toSeq.toSet.toSeq.toSeq.toSeq.toArray\n\
    \        val w = arr.toSeq.toSet.toSeq.toSeq.toSeq.toSeq.toArray\n        val\
    \ x = arr.toSeq.toSet.toSeq.toSeq.toSeq.toSeq.toSeq.toArray\n        val y = arr.toSeq.toSet.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toArray\n\
    \        val z = arr.toSeq.toSet.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toArray\n\
    \        val a = arr.toSeq.toSet.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toArray\n\
    \        val b = arr.toSeq.toSet.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toArray\n\
    \        val c = arr.toSeq.toSet.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toArray\n\
    \        val d = arr.toSeq.toSet.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toArray\n\
    \        val e = arr.toSeq.toSet.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toArray\n\
    \        val f = arr.toSeq.toSet.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toArray\n\
    \        val g = arr.toSeq.toSet.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toArray\n\
    \        val h = arr.toSeq.toSet.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toArray\n\
    \        val i = arr.toSeq.toSet.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toArray\n\
    \        val j = arr.toSeq.toSet.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3d7s30dp.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3d7s30dp.scala:49:5 ---------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009436
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val len = arr.length\n\
    \        if(len == 0) return true\n        val first = arr(0)\n        val last\
    \ = arr[len-1]\n        val mid = len/2\n        val left = (len-1)/2\n      \
    \  val right = len-1\n        val leftArr = (len-1)/2\n        val rightArr =\
    \ (len-1)/2\n        val leftArr2 = leftArr+1\n        val rightArr2 = rightArr-1\n\
    \        val leftArr3 = leftArr+2\n        val rightArr3 = rightArr-2\n      \
    \  val leftArr4 = leftArr+3\n        val rightArr4 = rightArr-3\n        val leftArr5\
    \ = leftArr+4\n        val rightArr5 = rightArr-4\n        val leftArr6 = leftArr+5\n\
    \        val rightArr6 = rightArr-5\n        val leftArr7 = leftArr+6\n      \
    \  val rightArr7 = rightArr-6\n        val leftArr8 = leftArr+7\n        val rightArr8\
    \ = rightArr-7\n        val leftArr9 = leftArr+8\n        val rightArr9 = rightArr-8\n\
    \        val leftArr10 = leftArr+9\n        val rightArr10 = rightArr-9\n    \
    \    val leftArr11 = leftArr+10\n        val rightArr11 = rightArr-10\n      \
    \  val leftArr12 = leftArr+11\n        val rightArr12 = rightArr-11\n        val\
    \ leftArr13 = leftArr+12\n        val rightArr13 = rightArr-12\n        val leftArr14\
    \ = leftArr+13\n        val rightArr14 = rightArr-13\n        val leftArr15 =\
    \ leftArr+14\n        val rightArr15 = rightArr-14\n        val leftArr16 = leftArr+15\n\
    \        val rightArr16 = rightArr-15\n        val leftArr17 = leftArr+16\n  \
    \      val rightArr17 = rightArr-16\n        val leftArr18 = leftArr+17\n    \
    \    val rightArr18 = rightArr-17\n        val leftArr19 = leftArr+18\n      \
    \  val rightArr19 = rightArr-18\n        val leftArr20 = leftArr+19\n        val\
    \ rightArr20 = rightArr-19\n        val leftArr21 = leftArr+20\n        val rightArr21\
    \ = rightArr-20\n        val leftArr22 = leftArr+21\n        val rightArr22 =\
    \ rightArr-21\n        val leftArr23 = leftArr+22\n        val rightArr23 = rightArr-22\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmps24hcn9d.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmps24hcn9d.scala:30:26 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlast\e[0m = arr[\e[35mlen-\e\
    [31m1\e[0m]\n\e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e\
    [0m                          Not found: type -\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmps24hcn9d.scala:80:5 ---------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009436
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if(arr.isEmpty) true\n        else if(arr.head == arr.last)\
    \ moveOneBall(arr.tail)\n        else {\n            val temp = arr.head\n   \
    \         val temp1 = arr.last\n            val temp2 = arr.tail\n           \
    \ val temp3 = arr.init\n            val temp4 = arr.tail.init\n            val\
    \ temp5 = arr.tail.tail.init\n            val temp6 = arr.tail.tail.tail.init\n\
    \            val temp7 = arr.tail.tail.tail.tail.init\n            val temp8 =\
    \ arr.tail.tail.tail.tail.tail.init\n            val temp9 = arr.tail.tail.tail.tail.tail.tail.init\n\
    \            val temp10 = arr.tail.tail.tail.tail.tail.tail.tail.init\n      \
    \      val temp11 = arr.tail.tail.tail.tail.tail.tail.tail.tail.init\n       \
    \     val temp12 = arr.tail.tail.tail.tail.tail.tail.tail.tail.tail.init\n   \
    \         val temp13 = arr.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.init\n\
    \            val temp14 = arr.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.init\n\
    \            val temp15 = arr.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.init\n\
    \            val temp16 = arr.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.init\n\
    \            val temp17 = arr.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.init\n\
    \            val temp18 = arr.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.init\n\
    \            val temp19 = arr.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.init\n\
    \            val temp20 = arr.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.init\n\
    \            val temp2\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph6muewi4.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph6muewi4.scala:61:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m61 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmph6muewi4.scala:60:1 ---------------------\e[0m\e[0m\n\
    \e[31m60 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmph6muewi4.scala:52:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m52 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660009438
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val result = new mutable.ListBuffer[Long]()\n        val left = new mutable.ListBuffer[Long]()\n\
    \        val right = new mutable.ListBuffer[Long]()\n        val leftCount = new\
    \ mutable.ListBuffer[Long]()\n        val rightCount = new mutable.ListBuffer[Long]()\n\
    \        val leftCount2 = new mutable.ListBuffer[Long]()\n        val rightCount2\
    \ = new mutable.ListBuffer[Long]()\n        val leftCount3 = new mutable.ListBuffer[Long]()\n\
    \        val rightCount3 = new mutable.ListBuffer[Long]()\n        val leftCount4\
    \ = new mutable.ListBuffer[Long]()\n        val rightCount4 = new mutable.ListBuffer[Long]()\n\
    \        val leftCount5 = new mutable.ListBuffer[Long]()\n        val rightCount5\
    \ = new mutable.ListBuffer[Long]()\n        val leftCount6 = new mutable.ListBuffer[Long]()\n\
    \        val rightCount6 = new mutable.ListBuffer[Long]()\n        val leftCount7\
    \ = new mutable.ListBuffer[Long]()\n        val rightCount7 = new mutable.ListBuffer[Long]()\n\
    \        val leftCount8 = new mutable.ListBuffer[Long]()\n        val rightCount8\
    \ = new mutable.ListBuffer[Long]()\n        val leftCount9 = new mutable.ListBuffer[Long]()\n\
    \        val rightCount9 = new mutable.ListBuffer[Long]()\n        val leftCount10\
    \ = new mutable.ListBuffer[Long]()\n        val rightCount10 = new mutable.ListBuffer[Long]()\n\
    \        val leftCount11 = new mutable.ListBuffer[Long]()\n        val rightCount11\
    \ = new mutable.ListBuffer[Long]()\n        val leftCount12 = new mutable.ListBuffer[Long]()\n\
    \        val rightCount12 = new mutable.ListBuffer[Long]()\n        val leftCount13\
    \ = new mutable.ListBuffer[Long]()\n        val rightCount13 = new mutable.ListBuffer[Long]()\n\
    \        val leftCount14 = new mutable.ListBuffer[Long]()\n        val rightCount14\
    \ = new mutable.ListBuffer[Long]()\n        val leftCount15 = new mutable.ListBuffer[Long]()\n\
    \        val rightCount15 = new mutable.ListBuffer[Long]()\n        val leftCount16\
    \ = new mutable.ListBuffer[Long\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpa4sjsk0t.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpa4sjsk0t.scala:27:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa4sjsk0t.scala:28:25\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpa4sjsk0t.scala:29:23 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mleft\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpa4sjsk0t.scala:30:24 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mright\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa4sjsk0t.scala:31:28\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mleftCount\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                      "
  stdout: ''
  timestamp: 1660009437
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val n = arr.size\n    \
    \    val arr = arr.toArray\n        val arr = arr.toList\n        val arr = arr.toArray\n\
    \        val arr = arr.toList\n        val arr = arr.toArray\n        val arr\
    \ = arr.toList\n        val arr = arr.toArray\n        val arr = arr.toList\n\
    \        val arr = arr.toArray\n        val arr = arr.toList\n        val arr\
    \ = arr.toArray\n        val arr = arr.toList\n        val arr = arr.toArray\n\
    \        val arr = arr.toList\n        val arr = arr.toArray\n        val arr\
    \ = arr.toList\n        val arr = arr.toArray\n        val arr = arr.toList\n\
    \        val arr = arr.toArray\n        val arr = arr.toList\n        val arr\
    \ = arr.toArray\n        val arr = arr.toList\n        val arr = arr.toArray\n\
    \        val arr = arr.toList\n        val arr = arr.toArray\n        val arr\
    \ = arr.toList\n        val arr = arr.toArray\n        val arr = arr.toList\n\
    \        val arr = arr.toArray\n        val arr = arr.toList\n        val arr\
    \ = arr.toArray\n        val arr = arr.toList\n        val arr = arr.toArray\n\
    \        val arr = arr.toList\n        val arr = arr.toArray\n        val arr\
    \ = arr.toList\n        val arr = arr.toArray\n        val arr = arr.toList\n\
    \        val arr = arr.toArray\n        val arr = arr.toList\n        val arr\
    \ = arr.toArray\n        val arr = arr.toList\n        val arr = arr.toArray\n\
    \        val arr = arr.toList\n        val arr = arr.toArray\n        val arr\
    \ = arr.toList\n        val arr = arr.toArray\n        val arr = arr.toList\n\
    \        val arr = arr.toArray\n        val arr = arr.toList\n        val arr\
    \ = arr.toArray\n        val arr = arr.toList\n        val arr = arr.toArray\n\
    \        val arr = arr.toList\n        val arr = arr.toArray\n        val arr\
    \ = arr.toList\n        val arr = arr.toArray\n        val arr = arr.toList\n\
    \        val arr = arr.toArray\n        val arr = arr.toList\n        val arr\
    \ = arr.toArray\n        val arr = arr.toList\n        val arr = arr.toArray\n\
    \        val arr = arr.toList\n        val arr = arr.toArray\n        val arr\
    \ = arr.toList\n        val arr = arr.toArray\n        val arr = arr.toList\n\
    \        val arr = arr.toArray\n        val arr = arr.toList\n        val arr\
    \ = arr.toArray\n        val \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp00c9la2f.scala:99:11 ---------------------------\e\
    [0m\e[0m\n\e[31m99 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp00c9la2f.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp00c9la2f.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp00c9la2f.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp00c9la2f.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp00c9la2f.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e"
  stdout: ''
  timestamp: 1660009438
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val n = arr.size\n    \
    \    val arr = arr.toArray\n        val arr = arr.toBuffer\n        val arr =\
    \ arr.toList\n        val arr = arr.toArray\n        val arr = arr.toBuffer\n\
    \        val arr = arr.toList\n        val arr = arr.toArray\n        val arr\
    \ = arr.toBuffer\n        val arr = arr.toList\n        val arr = arr.toArray\n\
    \        val arr = arr.toBuffer\n        val arr = arr.toList\n        val arr\
    \ = arr.toArray\n        val arr = arr.toBuffer\n        val arr = arr.toList\n\
    \        val arr = arr.toArray\n        val arr = arr.toBuffer\n        val arr\
    \ = arr.toList\n        val arr = arr.toArray\n        val arr = arr.toBuffer\n\
    \        val arr = arr.toList\n        val arr = arr.toArray\n        val arr\
    \ = arr.toBuffer\n        val arr = arr.toList\n        val arr = arr.toArray\n\
    \        val arr = arr.toBuffer\n        val arr = arr.toList\n        val arr\
    \ = arr.toArray\n        val arr = arr.toBuffer\n        val arr = arr.toList\n\
    \        val arr = arr.toArray\n        val arr = arr.toBuffer\n        val arr\
    \ = arr.toList\n        val arr = arr.toArray\n        val arr = arr.toBuffer\n\
    \        val arr = arr.toList\n        val arr = arr.toArray\n        val arr\
    \ = arr.toBuffer\n        val arr = arr.toList\n        val arr = arr.toArray\n\
    \        val arr = arr.toBuffer\n        val arr = arr.toList\n        val arr\
    \ = arr.toArray\n        val arr = arr.toBuffer\n        val arr = arr.toList\n\
    \        val arr = arr.toArray\n        val arr = arr.toBuffer\n        val arr\
    \ = arr.toList\n        val arr = arr.toArray\n        val arr = arr.toBuffer\n\
    \        val arr = arr.toList\n        val arr = arr.toArray\n        val arr\
    \ = arr.toBuffer\n        val arr = arr.toList\n        val arr = arr.toArray\n\
    \        val arr = arr.toBuffer\n        val arr = arr.toList\n        val arr\
    \ = arr.toArray\n        val arr = arr.toBuffer\n        val arr = arr.toList\n\
    \        val arr = arr.toArray\n        val arr = arr.toBuffer\n        val arr\
    \ = arr.toList\n        val arr = arr.toArray\n        val arr = arr.toBuffer\n\
    \        val arr = arr.toList\n        val arr = arr.toArray\n        val arr\
    \ = arr.toBuffer\n        val arr = arr.toList\n        val arr = arr.toArray\n\
    \        val arr = arr.toBuffer\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpkdox__o1.scala:99:11 ---------------------------\e\
    [0m\e[0m\n\e[31m99 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpkdox__o1.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkdox__o1.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toBuffer\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpkdox__o1.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpkdox__o1.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkdox__o1.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toBuffer\n\e"
  stdout: ''
  timestamp: 1660009437
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val sorted = arr.sort\n        val result = if (sorted == arr) true else\
    \ false\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4gndezll.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009434
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val max = (len - 1).toLong\n        val min = 0l\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var temp = 0\n        var flag\
    \ = true\n        var tempArr : List[Long] = Nil\n        while(i < len) {\n \
    \           while(j < len) {\n                if(arr(i) > arr(j)) {\n        \
    \            temp = arr(i)\n                    arr(i) = arr(j)\n            \
    \        arr(j) = temp\n                }\n                j++\n            }\n\
    \            i++\n            j = 0\n            k = i\n            while(k >=\
    \ min) {\n                tempArr = arr(k - 1).toLong :: arr(k).toLong :: tempArr\n\
    \                arr(k - 1) = arr(k)\n                arr(k) = tempArr.last\n\
    \                k--\n            }\n            flag = flag && arr.toList.sorted\
    \ == arr.toList\n        }\n        flag\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpbj98feiy.scala:43:19 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpbj98feiy.scala:46:14\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m46 |\e[0m       \
    \     j = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e\
    [0m              end of statement expected but '=' found\n\e[31m\e[31m-- [E018]\
    \ Syntax Error: /tmp/tmpbj98feiy.scala:52:19 ---------------------------\e[0m\e\
    [0m\n\e[31m52 |\e[0m                k--\n\e[31m\e[31m   |\e[0m               \
    \    ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbj98feiy.scala:26:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbj98feiy.scala:45:13\
    \ ------------------------\e[0m\e[0m\n\e[31m45 |\e[0m            i++\n\e[31m\e\
    [31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m            value ++ is not\
    \ a member of Int\n5 errors found\n"
  stdout: ''
  timestamp: 1660009439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.size - 1)\n\
    \        val arr = arr.take(arr.size - 1)\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.drop(arr.size - 1)\n        val arr = arr.take(arr.size\
    \ - 1)\n        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.size\
    \ - 1)\n        val arr = arr.take(arr.size - 1)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(arr.size - 1)\n        val arr = arr.take(arr.size\
    \ - 1)\n        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.size\
    \ - 1)\n        val arr = arr.take(arr.size - 1)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(arr.size - 1)\n        val arr = arr.take(arr.size\
    \ - 1)\n        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.size\
    \ - 1)\n        val arr = arr.take(arr.size - 1)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(arr.size - 1)\n        val arr = arr.take(arr.size\
    \ - 1)\n        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.size\
    \ - 1)\n        val arr = arr.take(arr.size - 1)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(arr.size - 1)\n        val arr = arr.take(arr.size\
    \ - 1)\n        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.size\
    \ - 1)\n        val arr = arr.take(arr.size - 1)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(arr.size - 1)\n        val arr = arr.take(arr.size\
    \ - 1)\n        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.size\
    \ - 1)\n        val arr = arr.take(arr.size - 1)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(arr.size - 1)\n        val arr = arr.take(arr.size\
    \ - 1)\n        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.size\
    \ - 1)\n        val arr = arr.take(arr.size - 1)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(arr.size - 1)\n        val arr = arr.take(arr.size\
    \ - 1)\n        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.size\
    \ - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppvru47zl.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmppvru47zl.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(arr.size - \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppvru47zl.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.take(arr.size - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined\
    \ as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppvru47zl.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmppvru47zl.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(arr.size - \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overl"
  stdout: ''
  timestamp: 1660009439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortWith(_ < _)\n        val arr = arr.drop(n-1)\n       \
    \ val arr = arr.take(n-1)\n        val arr = arr.toList\n        val arr = arr.sortWith(_\
    \ < _)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n   \
    \     val arr = arr.toArray\n        val arr = arr.sortWith(_ < _)\n        val\
    \ arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n        val arr = arr.toList\n\
    \        val arr = arr.sortWith(_ < _)\n        val arr = arr.drop(n-1)\n    \
    \    val arr = arr.take(n-1)\n        val arr = arr.toArray\n        val arr =\
    \ arr.sortWith(_ < _)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n\
    \        val arr = arr.toList\n        val arr = arr.sortWith(_ < _)\n       \
    \ val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n        val arr =\
    \ arr.toArray\n        val arr = arr.sortWith(_ < _)\n        val arr = arr.drop(n-1)\n\
    \        val arr = arr.take(n-1)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortWith(_ < _)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n\
    \        val arr = arr.toArray\n        val arr = arr.sortWith(_ < _)\n      \
    \  val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n        val arr =\
    \ arr.toList\n        val arr = arr.sortWith(_ < _)\n        val arr = arr.drop(n-1)\n\
    \        val arr = arr.take(n-1)\n        val arr = arr.toArray\n        val arr\
    \ = arr.sortWith(_ < _)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n\
    \        val arr = arr.toList\n        val arr = arr.sortWith(_ < _)\n       \
    \ val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n        val arr =\
    \ arr.toArray\n        val arr = arr.sortWith(_ < _)\n        val arr = arr.drop(n-1)\n\
    \        val arr = arr.take(n-1)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortWith(_ < _)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n\
    \        val arr = arr.toArray\n        val arr = arr.sortWith(_ < _)\n      \
    \  val arr = arr.drop(n-1)\n        val arr = arr.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzbw3jq9z.scala:87:4 ----------------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzbw3jq9z.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_ < _)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzbw3jq9z.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.drop(n-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzbw3jq9z.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.take(n-\e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzbw3jq9z.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzbw3jq9z.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009414
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) {\n         \
    \   return true\n        }\n        val arr = arr.sortBy(x => x)\n        val\
    \ first = arr(0)\n        val last = arr(n)\n        val mid = first + last\n\
    \        val left = arr.drop(1)\n        val right = arr.dropRight(1)\n      \
    \  val leftSorted = left.sortBy(x => x)\n        val rightSorted = right.sortBy(x\
    \ => x)\n        val leftSortedLength = leftSorted.length\n        val rightSortedLength\
    \ = rightSorted.length\n        if (leftSortedLength == rightSortedLength) {\n\
    \            if (leftSortedLength == 1) {\n                if (leftSortedLength\
    \ == 1) {\n                    if (leftSortedLength == 1) {\n                \
    \        if (leftSortedLength == 1) {\n                            if (leftSortedLength\
    \ == 1) {\n                                if (leftSortedLength == 1) {\n    \
    \                                if (leftSortedLength == 1) {\n              \
    \                          if (leftSortedLength == 1) {\n                    \
    \                        if (leftSortedLength == 1) {\n                      \
    \                          if (leftSortedLength == 1) {\n                    \
    \                                if (leftSortedLength == 1) {\n              \
    \                                          return true\n                     \
    \                           }\n                                            }\n\
    \                                        }\n                                 \
    \   }\n                                }\n                            }\n    \
    \                    }\n                    }\n                }\n           \
    \ }\n        }\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_eeou9yp.scala:75:0 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_eeou9yp.scala:30:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m      \
    \            ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp_eeou9yp.scala:74:1 ---------------------\e[0m\e[0m\n\e[31m74\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m\
    \   |\e[0m Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp_eeou9yp.scala:64:8\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m64 |\e[0m        \e\
    [33mreturn\e[0m \e[31mfalse\e[0m\n\e[33m\e[33m   |\e[0m        ^\e[0m\n\e[33m\
    \   |\e[0m        Line is indented too far to the left, or a `}` is missing\n\e\
    [33m\e[33m-- Warning: /tmp/tmp_eeou9yp.scala:66:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m66 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n2 warnings\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1660009439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toArray\n \
    \       val result = new Array[Boolean](n+1)\n        var i = 0\n        var j\
    \ = 0\n        var k = 0\n        var temp = 0\n        var flag = false\n   \
    \     var temp2 = new Array[Long](n)\n        for(i <- 0 until n){\n         \
    \   for(j <- 0 until n){\n                if(j != i){\n                    temp2\
    \ = arr(j)\n                    temp2 = temp2 >> 1\n                    arr(j)\
    \ = temp2\n                    if(arr(j) < arr(i)){\n                        flag\
    \ = true\n                    }\n                }\n            }\n          \
    \  if(flag){\n                temp2 = arr(i)\n                temp2 = temp2 >>\
    \ 1\n                arr(i) = temp2\n                flag = false\n          \
    \  }\n        }\n        for(i <- 0 until n){\n            for(j <- 0 until n){\n\
    \                if(j != i){\n                    temp2 = arr(j)\n           \
    \         temp2 = temp2 >> 1\n                    arr(j) = temp2\n           \
    \         if(arr(j) < arr(i)){\n                        flag = true\n        \
    \            }\n                }\n            }\n            if(flag){\n    \
    \            temp2 = arr(i)\n                temp2 = temp2 >> 1\n            \
    \    arr(i) = temp2\n                flag = false\n            }\n        }\n\
    \        for(i <- 0 until n){\n            for(j <- 0 until n){\n            \
    \    if(j != i){\n                    temp2 = arr(j)\n                    temp2\
    \ = temp2 >> 1\n                    arr(j) = temp2\n                    if(arr(j)\
    \ < arr(i)){\n                        flag = true\n                    }\n   \
    \             }\n            }\n            if(flag){\n                temp2 =\
    \ arr(i)\n                temp2 = temp2 >> 1\n                arr(i) = temp2\n\
    \                flag = false\n            }\n        }\n        for(i <- 0 until\
    \ n){\n            for(j <- 0 until n){\n                if(j != i){\n       \
    \             temp2 = arr(j)\n                    temp2 = temp2 >> 1\n       \
    \             arr(j) = temp2\n                    if(arr(j) < arr(i)){\n     \
    \                   flag = true\n                    }\n                }\n  \
    \          }\n            if(flag){\n                temp2 = arr(i)\n        \
    \        temp2 = temp2 >> 1\n                arr(i) = temp2\n                flag\
    \ = false\n            }\n        }\n        for(i <- 0 until n){\n          \
    \  for(j <- 0 until n){\n                if(j != i){\n                    temp2\
    \ = arr(j)\n                    temp2 = temp2 >> 1\n                    arr(j)\
    \ = temp2\n                    if(arr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp98wmt41h.scala:114:4 ---------------------------\e\
    [0m\e[0m\n\e[31m114 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp98wmt41h.scala:124:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m124 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmp98wmt41h.scala:27:18 ---------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\e[31m\e\
    [31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp98wmt41h.scala:39:34 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                    temp2 = temp2 >> \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m                            ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            value >> is not a member of Array[Long]\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp98wmt41h.scala:48:30 ------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m                temp2 = temp2 >> \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \              value >> is not a member of Array[Long]\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp98wmt41h.scala:57:34 ------------------------\e[0m\e\
    [0m\n\e[31m57 |\e[0m                    temp2 = temp2 >> \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value >> is not a member of Array[Long]\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp98wmt41h.scala:66:30 ------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m                temp2 = temp2 >> \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \              value >> is not a member of Array[Long]\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp98wmt41h.scala:75:34 ------------------------\e[0m\e\
    [0m\n\e[31m75 |\e[0m               "
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val arr1 = arr.toArray\n        val arr2 = arr1.clone\n        val arr3\
    \ = arr2.clone\n        val arr4 = arr3.clone\n        val arr5 = arr4.clone\n\
    \        val arr6 = arr5.clone\n        val arr7 = arr6.clone\n        val arr8\
    \ = arr7.clone\n        val arr9 = arr8.clone\n        val arr10 = arr9.clone\n\
    \        val arr11 = arr10.clone\n        val arr12 = arr11.clone\n        val\
    \ arr13 = arr12.clone\n        val arr14 = arr13.clone\n        val arr15 = arr14.clone\n\
    \        val arr16 = arr15.clone\n        val arr17 = arr16.clone\n        val\
    \ arr18 = arr17.clone\n        val arr19 = arr18.clone\n        val arr20 = arr19.clone\n\
    \        val arr21 = arr20.clone\n        val arr22 = arr21.clone\n        val\
    \ arr23 = arr22.clone\n        val arr24 = arr23.clone\n        val arr25 = arr24.clone\n\
    \        val arr26 = arr25.clone\n        val arr27 = arr26.clone\n        val\
    \ arr28 = arr27.clone\n        val arr29 = arr28.clone\n        val arr30 = arr29.clone\n\
    \        val arr31 = arr30.clone\n        val arr32 = arr31.clone\n        val\
    \ arr33 = arr32.clone\n        val arr34 = arr33.clone\n        val arr35 = arr34.clone\n\
    \        val arr36 = arr35.clone\n        val arr37 = arr36.clone\n        val\
    \ arr38 = arr37.clone\n        val arr39 = arr38.clone\n        val arr40 = arr39.clone\n\
    \        val arr41 = arr40.clone\n        val arr42 = arr41.clone\n        val\
    \ arr43 = arr42.clone\n        val arr44 = arr43.clone\n        val arr45 = arr44.clone\n\
    \        val arr46 = arr45.clone\n        val arr47 = arr46.clone\n        val\
    \ arr48 = arr47.clone\n        val arr49 = arr48.clone\n        val arr50 = arr49.clone\n\
    \        val arr51 = arr50.clone\n        val arr52 = arr51.clone\n        val\
    \ arr53 = arr52.clone\n        val arr54 = arr53.clone\n        val arr55 = arr54.clone\n\
    \        val arr\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpklw3ap4m.scala:84:4 ----------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpklw3ap4m.scala:27:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpklw3ap4m.scala:84:5\
    \ ---------------------\e[0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toSet\n        val arr2 = arr.toSeq\n \
    \       val arr3 = arr.toArray\n        val arr4 = arr.toList\n        val arr5\
    \ = arr.toSeq\n        val arr6 = arr.toArray\n        val arr7 = arr.toList\n\
    \        val arr8 = arr.toSeq\n        val arr9 = arr.toArray\n        val arr10\
    \ = arr.toList\n        val arr11 = arr.toSeq\n        val arr12 = arr.toArray\n\
    \        val arr13 = arr.toList\n        val arr14 = arr.toSeq\n        val arr15\
    \ = arr.toArray\n        val arr16 = arr.toList\n        val arr17 = arr.toSeq\n\
    \        val arr18 = arr.toArray\n        val arr19 = arr.toList\n        val\
    \ arr20 = arr.toSeq\n        val arr21 = arr.toArray\n        val arr22 = arr.toList\n\
    \        val arr23 = arr.toSeq\n        val arr24 = arr.toArray\n        val arr25\
    \ = arr.toList\n        val arr26 = arr.toSeq\n        val arr27 = arr.toArray\n\
    \        val arr28 = arr.toList\n        val arr29 = arr.toSeq\n        val arr30\
    \ = arr.toArray\n        val arr31 = arr.toList\n        val arr32 = arr.toSeq\n\
    \        val arr33 = arr.toArray\n        val arr34 = arr.toList\n        val\
    \ arr35 = arr.toSeq\n        val arr36 = arr.toArray\n        val arr37 = arr.toList\n\
    \        val arr38 = arr.toSeq\n        val arr39 = arr.toArray\n        val arr40\
    \ = arr.toList\n        val arr41 = arr.toSeq\n        val arr42 = arr.toArray\n\
    \        val arr43 = arr.toList\n        val arr44 = arr.toSeq\n        val arr45\
    \ = arr.toArray\n        val arr46 = arr.toList\n        val arr47 = arr.toSeq\n\
    \        val arr48 = arr.toArray\n        val arr49 = arr.toList\n        val\
    \ arr50 = arr.toSeq\n        val arr51 = arr.toArray\n        val arr52 = arr.toList\n\
    \        val arr53 = arr.toSeq\n        val arr54 = arr.toArray\n        val arr55\
    \ = arr.toList\n        val arr56 = arr.toSeq\n        val arr57 = arr.toArray\n\
    \        val arr58 = arr.toList\n        val arr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_pou9vuk.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_pou9vuk.scala:26:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toSet\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_pou9vuk.scala:85:5\
    \ ---------------------\e[0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toArray\n \
    \       val arr1 = arr.slice(1, n)\n        val arr2 = arr.slice(0, 1)\n     \
    \   val arr3 = arr.slice(1, n)\n        val arr4 = arr.slice(0, 1)\n        val\
    \ arr5 = arr.slice(1, n)\n        val arr6 = arr.slice(0, 1)\n        val arr7\
    \ = arr.slice(1, n)\n        val arr8 = arr.slice(0, 1)\n        val arr9 = arr.slice(1,\
    \ n)\n        val arr10 = arr.slice(0, 1)\n        val arr11 = arr.slice(1, n)\n\
    \        val arr12 = arr.slice(0, 1)\n        val arr13 = arr.slice(1, n)\n  \
    \      val arr14 = arr.slice(0, 1)\n        val arr15 = arr.slice(1, n)\n    \
    \    val arr16 = arr.slice(0, 1)\n        val arr17 = arr.slice(1, n)\n      \
    \  val arr18 = arr.slice(0, 1)\n        val arr19 = arr.slice(1, n)\n        val\
    \ arr20 = arr.slice(0, 1)\n        val arr21 = arr.slice(1, n)\n        val arr22\
    \ = arr.slice(0, 1)\n        val arr23 = arr.slice(1, n)\n        val arr24 =\
    \ arr.slice(0, 1)\n        val arr25 = arr.slice(1, n)\n        val arr26 = arr.slice(0,\
    \ 1)\n        val arr27 = arr.slice(1, n)\n        val arr28 = arr.slice(0, 1)\n\
    \        val arr29 = arr.slice(1, n)\n        val arr30 = arr.slice(0, 1)\n  \
    \      val arr31 = arr.slice(1, n)\n        val arr32 = arr.slice(0, 1)\n    \
    \    val arr33 = arr.slice(1, n)\n        val arr34 = arr.slice(0, 1)\n      \
    \  val arr35 = arr.slice(1, n)\n        val arr36 = arr.slice(0, 1)\n        val\
    \ arr37 = arr.slice(1, n)\n        val arr38 = arr.slice(0, 1)\n        val arr39\
    \ = arr.slice(1, n)\n        val arr40 = arr.slice(0, 1)\n        val arr41 =\
    \ arr.slice(1, n)\n        val arr42 = arr.slice(0, 1)\n        val arr43 = arr.slice(1,\
    \ n)\n        val arr44 = arr.slice(0, 1)\n        val arr45 = arr.slice(1, n)\n\
    \        val arr46 = arr.slice(0, 1)\n        val arr47 = arr.slice(1, n)\n  \
    \      val arr48 = arr.slice(0, 1)\n        val arr49 = arr.slice(1, n)\n    \
    \    val arr50 = arr.slice(0, 1)\n        val arr51 = arr.slice(1, n)\n      \
    \  val arr52 = arr.slice(0, 1)\n        val arr53 = arr.slice(1, n)\n        val\
    \ arr54 = arr.slice(0, \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp76wk0mnv.scala:82:4 ----------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp76wk0mnv.scala:27:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp76wk0mnv.scala:82:5\
    \ ---------------------\e[0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009440
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val m = arr.head\n      \
    \  val arr = arr.tail\n        val arr2 = arr.toList\n        val arr3 = arr2.reverse\n\
    \        val arr4 = arr3.toList\n        val arr5 = arr4.toList\n        val arr6\
    \ = arr5.toList\n        val arr7 = arr6.reverse\n        val arr8 = arr7.toList\n\
    \        val arr9 = arr8.toList\n        val arr10 = arr9.reverse\n        val\
    \ arr11 = arr10.toList\n        val arr12 = arr11.reverse\n        val arr13 =\
    \ arr12.toList\n        val arr14 = arr13.reverse\n        val arr15 = arr14.toList\n\
    \        val arr16 = arr15.reverse\n        val arr17 = arr16.toList\n       \
    \ val arr18 = arr17.reverse\n        val arr19 = arr18.toList\n        val arr20\
    \ = arr19.reverse\n        val arr21 = arr20.toList\n        val arr22 = arr21.reverse\n\
    \        val arr23 = arr22.toList\n        val arr24 = arr23.reverse\n       \
    \ val arr25 = arr24.toList\n        val arr26 = arr25.reverse\n        val arr27\
    \ = arr26.toList\n        val arr28 = arr27.reverse\n        val arr29 = arr28.toList\n\
    \        val arr30 = arr29.reverse\n        val arr31 = arr30.toList\n       \
    \ val arr32 = arr31.reverse\n        val arr33 = arr32.toList\n        val arr34\
    \ = arr33.reverse\n        val arr35 = arr34.toList\n        val arr36 = arr35.reverse\n\
    \        val arr37 = arr36.toList\n        val arr38 = arr37.reverse\n       \
    \ val arr39 = arr38.toList\n        val arr40 = arr39.reverse\n        val arr41\
    \ = arr40.toList\n        val arr42 = arr41.reverse\n        val arr43 = arr42.toList\n\
    \        val arr44 = arr43.reverse\n        val arr45 = arr44.toList\n       \
    \ val arr46 = arr45.reverse\n        val arr47 = arr46.toList\n        val arr48\
    \ = arr47.reverse\n        val arr49 = arr48.toList\n        val arr50 = arr49.reverse\n\
    \        val arr51 = arr50.toList\n        val arr52 = arr51.reverse\n       \
    \ val arr53 = arr52.toList\n        val arr54\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiw9za5ae.scala:82:4 ----------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpiw9za5ae.scala:28:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiw9za5ae.scala:82:5\
    \ ---------------------\e[0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009440
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if(arr.isEmpty) true\n        else {\n            val\
    \ n = arr.size\n            val m = arr.last\n            val arr = arr.dropRight(1)\n\
    \            val arr2 = arr.toList\n            val arr3 = arr2.reverse\n    \
    \        val arr4 = arr3.takeRight(n)\n            val arr5 = arr4.toList\n  \
    \          val arr6 = arr5.takeRight(n)\n            val arr7 = arr6.takeRight(n)\n\
    \            val arr8 = arr7.takeRight(n)\n            val arr9 = arr8.takeRight(n)\n\
    \            val arr10 = arr9.takeRight(n)\n            val arr11 = arr10.takeRight(n)\n\
    \            val arr12 = arr11.takeRight(n)\n            val arr13 = arr12.takeRight(n)\n\
    \            val arr14 = arr13.takeRight(n)\n            val arr15 = arr14.takeRight(n)\n\
    \            val arr16 = arr15.takeRight(n)\n            val arr17 = arr16.takeRight(n)\n\
    \            val arr18 = arr17.takeRight(n)\n            val arr19 = arr18.takeRight(n)\n\
    \            val arr20 = arr19.takeRight(n)\n            val arr21 = arr20.takeRight(n)\n\
    \            val arr22 = arr21.takeRight(n)\n            val arr23 = arr22.takeRight(n)\n\
    \            val arr24 = arr23.takeRight(n)\n            val arr25 = arr24.takeRight(n)\n\
    \            val arr26 = arr25.takeRight(n)\n            val arr27 = arr26.takeRight(n)\n\
    \            val arr28 = arr27.takeRight(n)\n            val arr29 = arr28.takeRight(n)\n\
    \            val arr30 = arr29.takeRight(n)\n            val arr31 = arr30.takeRight(n)\n\
    \            val arr32 = arr31.takeRight(n)\n            val arr33 = arr32.takeRight(n)\n\
    \            val arr34 = arr33.takeRight(n)\n            val arr35 = arr34.takeRight(n)\n\
    \            val arr36 = arr35.takeRight(n)\n            val arr37 = arr36.takeRight(n)\n\
    \            val arr38 = arr37.takeRight(n)\n            val arr39 = arr38.takeRight(n)\n\
    \            val arr40 = arr39.takeRight(n)\n            val arr41 = arr40.takeRight(n)\n\
    \            val arr42 = arr41.takeRight(n)\n            val arr43 = arr42.takeRight(n)\n\
    \            val arr44 = arr43.takeRight(n)\n            val arr45 = arr44.takeRight(n)\n\
    \            val arr46 = arr45.takeRight(n)\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp60srcq92.scala:87:0 ----------------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp60srcq92.scala:30:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e\
    [0m \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \                ^\e[0m\n\e[31m   |\e[0m                      Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp60srcq92.scala:86:1 ---------------------\e[0m\e[0m\n\e[31m86\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m\
    \   |\e[0m Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp60srcq92.scala:78:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m78 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n        else\
    \ {\n            val l = arr.head\n            val r = arr.last\n            val\
    \ m = arr.indexOf(l) + 1\n            val n = arr.indexOf(r)\n            val\
    \ k = arr.indexOf(l) + n\n            val m = arr.indexOf(l) + n\n           \
    \ val n = arr.indexOf(r)\n            val m = arr.indexOf(l) + n\n           \
    \ val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l) + n\n       \
    \     val n = arr.indexOf(r)\n            val m = arr.indexOf(l) + n\n       \
    \     val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l) + n\n   \
    \         val n = arr.indexOf(r)\n            val m = arr.indexOf(l) + n\n   \
    \         val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l) + n\n\
    \            val n = arr.indexOf(r)\n            val m = arr.indexOf(l) + n\n\
    \            val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l) +\
    \ n\n            val n = arr.indexOf(r)\n            val m = arr.indexOf(l) +\
    \ n\n            val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l)\
    \ + n\n            val n = arr.indexOf(r)\n            val m = arr.indexOf(l)\
    \ + n\n            val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l)\
    \ + n\n            val n = arr.indexOf(r)\n            val m = arr.indexOf(l)\
    \ + n\n            val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l)\
    \ + n\n            val n = arr.indexOf(r)\n            val m = arr.indexOf(l)\
    \ + n\n            val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l)\
    \ + n\n            val n = arr.indexOf(r)\n            val m = arr.indexOf(l)\
    \ + n\n            val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l)\
    \ + n\n            val n = arr.indexOf(r)\n            val m = arr.indexOf(l)\
    \ + n\n            val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l)\
    \ + n\n            val n = arr.indexOf(r)\n            val m = arr.indexOf(l)\
    \ + n\n            val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l)\
    \ + n\n            val n = arr.indexOf(r)\n            val m = arr.indexOf(l)\
    \ + n\n            val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l)\
    \ + n\n            val n = arr.indexOf(r)\n            val m = arr.indexOf(l)\
    \ + n\n            val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l)\
    \ + n\n            val n = arr.indexOf(r)\n            val m = arr.indexOf\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgfj9lf6j.scala:99:0 ----------------------------\e\
    [0m\e[0m\n\e[31m99 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgfj9lf6j.scala:34:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e\
    [0m \e[36mm\e[0m = arr.indexOf(l) + n\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpgfj9lf6j.scala:35:16 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m            \e[33mval\e[0m \e[36mn\e[0m = arr.indexOf(r)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgfj9lf6j.scala:36:16 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36mm\e[0m = arr.indexOf(l)\
    \ + n\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgfj9lf6j.scala:37:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e\
    [0m \e[36mk\e[0m = arr.indexOf(l) + n\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mk is already defined as \e[33mvalue\e[0m \e[35mk\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpgfj9lf6j.scala:38:16 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m            \e[33mval\e[0m \e[36mm\e[0m = arr.indexOf(l) + n\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if(arr.isEmpty) true\n        else {\n            val\
    \ n = arr.size\n            val m = arr.head\n            val result = new Array[Long](n)\n\
    \            val shifts = mutable.ArrayBuffer.empty[Long]\n            for(i <-\
    \ 0 until n) {\n                val j = i\n                val k = n - i - 1\n\
    \                val temp = arr(j)\n                arr(j) = arr(k)\n        \
    \        arr(k) = temp\n                shifts += k\n            }\n         \
    \   val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n   \
    \         val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shiftCount = shifts.sum\n            val shiftCount = shifts.sum\n\
    \            val shift\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx_423bfs.scala:93:4 ----------------------------\e\
    [0m\e[0m\n\e[31m93 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx_423bfs.scala:103:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m103 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161]\
    \ Naming Error: /tmp/tmpx_423bfs.scala:41:16 ---------------------------\e[0m\e\
    [0m\n\e[31m41 |\e[0m            \e[33mval\e[0m \e[36mshiftCount\e[0m = shifts.sum\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mshiftCount is already defined as \e[33mvalue\e[0m \e[35mshiftCount\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpx_423bfs.scala:42:16 ---------------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m            \e[33mval\e[0m \e[36mshiftCount\e[0m = shifts.sum\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mshiftCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mshiftCount\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx_423bfs.scala:43:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m            \e[33mval\e\
    [0m \e[36mshiftCount\e[0m = shifts.sum\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mshiftCount is already defined as \e[33mvalue\e[0m \e[35mshiftCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpx_423bfs.scala:44:16 ---------------------------\e[0m\e[0m\n\e\
    [31m44 |\e[0m            \e[33mval\e[0m \e[36mshiftCount\e[0m = shifts.sum\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mshiftCount is already defined as \e[33mvalue\e[0m \e[35mshiftCount\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be de"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:34:12 ----------"
  stdout: ''
  timestamp: 1660009387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprf_mhhht.scala:82:4 ----------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprf_mhhht.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmprf_mhhht.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(arr.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmprf_mhhht.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.take(arr.length-\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprf_mhhht.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmprf_mhhht.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\
    \e[31m\e[3"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val result = new Array[Boolean](n)\n        val left = new Array[Long](n)\n\
    \        val right = new Array[Long](n)\n        val leftCount = 0\n        val\
    \ rightCount = 0\n        val leftIndex = 0\n        val rightIndex = 0\n    \
    \    val leftMax = arr.length - 1\n        val rightMax = arr.length - 1\n   \
    \     val leftMin = 0\n        val rightMin = 0\n        val leftMaxCount = 0\n\
    \        val rightMaxCount = 0\n        val leftMinCount = 0\n        val rightMinCount\
    \ = 0\n        val leftMaxCountIndex = 0\n        val rightMaxCountIndex = 0\n\
    \        val leftMinCountIndex = 0\n        val rightMinCountIndex = 0\n     \
    \   val leftMaxCountIndexIndex = 0\n        val rightMaxCountIndexIndex = 0\n\
    \        val leftMinCountIndexIndex = 0\n        val rightMinCountIndexIndex =\
    \ 0\n        val leftMaxCountIndexIndexIndex = 0\n        val rightMaxCountIndexIndex\
    \ = 0\n        val leftMinCountIndexIndex = 0\n        val rightMinCountIndexIndex\
    \ = 0\n        val leftMaxCountIndexIndex = 0\n        val rightMaxCountIndexIndex\
    \ = 0\n        val leftMinCountIndexIndex = 0\n        val rightMinCountIndexIndex\
    \ = 0\n        val leftMaxCountIndexIndex = 0\n        val rightMaxCountIndexIndex\
    \ = 0\n        val leftMinCountIndexIndex = 0\n        val rightMinCountIndexIndex\
    \ = 0\n        val leftMaxCountIndexIndex = 0\n        val rightMaxCountIndexIndex\
    \ = 0\n        val leftMinCountIndexIndex = 0\n        val rightMinCountIndexIndex\
    \ = 0\n        val leftMaxCountIndexIndex = 0\n        val rightMaxCountIndexIndex\
    \ = 0\n        val leftMinCountIndexIndex = 0\n        val rightMinCountIndexIndex\
    \ = 0\n        val leftMaxCountIndexIndex = 0\n        val rightMaxCountIndexIndex\
    \ = 0\n        val leftMinCountIndexIndex = 0\n        val rightMinCountIndexIndex\
    \ = 0\n        val leftMaxCountIndexIndex = 0\n        val rightMaxCountIndexIndex\
    \ = 0\n        val leftMinCountIndexIndex = 0\n        val rightMinCountIndexIndex\
    \ = 0\n        val leftMaxCountIndexIndex = 0\n        val rightMaxCountIndexIndex\
    \ = 0\n        val leftMinCountIndexIndex = 0\n        val rightMinCountIndexIndex\
    \ = 0\n        val leftMaxCountIndexIndex = 0\n        val rightMaxCountIndexIndex\
    \ = 0\n        val leftMinCountIndexIndex = 0\n        val right\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6ebudyu2.scala:87:4 ----------------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6ebudyu2.scala:52:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m\
    \ \e[36mrightMaxCountIndexIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrightMaxCountIndexIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mrightMaxCountIndexIndex\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp6ebudyu2.scala:53:12 ---------------------------\e[0m\e[0m\n\e[31m53\
    \ |\e[0m        \e[33mval\e[0m \e[36mleftMinCountIndexIndex\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mleftMinCountIndexIndex is already defined as \e[33mvalue\e[0m \e[35mleftMinCountIndexIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6ebudyu2.scala:54:12 ---------------------------\e[0m\e[0m\n\e\
    [31m54 |\e[0m        \e[33mval\e[0m \e[36mrightMinCountIndexIndex\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mrightMinCountIndexIndex is already defined as \e[33mvalue\e[0m \e[35mrightMinCountIndexIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6ebudyu2.scala:55:12 ---------------------------\e[0m\e[0m\n\e\
    [31m55 |\e[0m        \e[33mval\e[0m \e[36mleftMaxCountIndexIndex\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mleftMaxCountIndexIndex is already defined as \e[33mvalue\e[0m \e[35mleftMaxCountIndexIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e"
  stdout: ''
  timestamp: 1660009444
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val len = arr.length\n        val arr2 = arr.toArray\n        val arr3 =\
    \ arr2.toList\n        val arr4 = arr3.toArray\n        val arr5 = arr4.toList\n\
    \        val arr6 = arr5.toArray\n        val arr7 = arr6.toList\n        val\
    \ arr8 = arr7.toArray\n        val arr9 = arr8.toList\n        val arr10 = arr9.toArray\n\
    \        val arr11 = arr10.toList\n        val arr12 = arr11.toArray\n       \
    \ val arr13 = arr12.toList\n        val arr14 = arr13.toArray\n        val arr15\
    \ = arr14.toList\n        val arr16 = arr15.toArray\n        val arr17 = arr16.toList\n\
    \        val arr18 = arr17.toArray\n        val arr19 = arr18.toList\n       \
    \ val arr20 = arr19.toArray\n        val arr21 = arr20.toList\n        val arr22\
    \ = arr21.toArray\n        val arr23 = arr22.toList\n        val arr24 = arr23.toArray\n\
    \        val arr25 = arr24.toList\n        val arr26 = arr25.toArray\n       \
    \ val arr27 = arr26.toList\n        val arr28 = arr27.toArray\n        val arr29\
    \ = arr28.toList\n        val arr30 = arr29.toArray\n        val arr31 = arr30.toList\n\
    \        val arr32 = arr31.toArray\n        val arr33 = arr32.toList\n       \
    \ val arr34 = arr33.toArray\n        val arr35 = arr34.toList\n        val arr36\
    \ = arr35.toArray\n        val arr37 = arr36.toList\n        val arr38 = arr37.toArray\n\
    \        val arr39 = arr38.toList\n        val arr40 = arr39.toArray\n       \
    \ val arr41 = arr40.toList\n        val arr42 = arr41.toArray\n        val arr43\
    \ = arr42.toList\n        val arr44 = arr43.toArray\n        val arr45 = arr44.toList\n\
    \        val arr46 = arr45.toArray\n        val arr47 = arr46.toList\n       \
    \ val arr48 = arr47.toArray\n        val arr49 = arr48.toList\n        val arr50\
    \ = arr49.toArray\n        val arr51 = arr50.toList\n        \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9t7hmt1z.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp9t7hmt1z.scala:80:5 ---------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009447
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val len = arr.length\n        val result = new Array[Boolean](len)\n  \
    \      var i = 0\n        var j = 0\n        var k = 0\n        var temp = 0\n\
    \        var flag = false\n        while(i < len) {\n            while(j < len)\
    \ {\n                while(k >= 0) {\n                    if(arr(k) > arr(j))\
    \ {\n                        temp = arr(k)\n                        arr(k) = arr(j)\n\
    \                        arr(j) = temp\n                        flag = true\n\
    \                        k -= 1\n                    } else {\n              \
    \          k -= 1\n                    }\n                }\n                j++\n\
    \            }\n            i += 1\n        }\n        if(flag) {\n          \
    \  for(i <- 0 until len) {\n                result(i) = true\n            }\n\
    \            return true\n        } else {\n            for(i <- 0 until len)\
    \ {\n                result(i) = false\n            }\n            return false\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpa3h_lfsb.scala:48:19 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpa3h_lfsb.scala:27:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) true\n      \
    \  else {\n            val arr = arr.toList\n            val l = arr.last\n  \
    \          val r = arr.head\n            val m = arr.indexOf(l) + 1\n        \
    \    val n = arr.indexOf(r)\n            val k = arr.indexOf(l) + n\n        \
    \    val m = arr.indexOf(l) + n\n            val n = arr.indexOf(r)\n        \
    \    val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l) + n\n    \
    \        val n = arr.indexOf(r)\n            val k = arr.indexOf(l) + n\n    \
    \        val m = arr.indexOf(l) + n\n            val n = arr.indexOf(r)\n    \
    \        val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l) + n\n\
    \            val n = arr.indexOf(r)\n            val k = arr.indexOf(l) + n\n\
    \            val m = arr.indexOf(l) + n\n            val n = arr.indexOf(r)\n\
    \            val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l) +\
    \ n\n            val n = arr.indexOf(r)\n            val k = arr.indexOf(l) +\
    \ n\n            val m = arr.indexOf(l) + n\n            val n = arr.indexOf(r)\n\
    \            val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l) +\
    \ n\n            val n = arr.indexOf(r)\n            val k = arr.indexOf(l) +\
    \ n\n            val m = arr.indexOf(l) + n\n            val n = arr.indexOf(r)\n\
    \            val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l) +\
    \ n\n            val n = arr.indexOf(r)\n            val k = arr.indexOf(l) +\
    \ n\n            val m = arr.indexOf(l) + n\n            val n = arr.indexOf(r)\n\
    \            val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l) +\
    \ n\n            val n = arr.indexOf(r)\n            val k = arr.indexOf(l) +\
    \ n\n            val m = arr.indexOf(l) + n\n            val n = arr.indexOf(r)\n\
    \            val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l) +\
    \ n\n            val n = arr.indexOf(r)\n            val k = arr.indexOf(l) +\
    \ n\n            val m = arr.indexOf(l) + n\n            val n = arr.indexOf(r)\n\
    \            val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l) +\
    \ n\n            val n = arr.indexOf(r)\n            val k = arr.indexOf(l) +\
    \ n\n            val m = arr.indexOf(l) + n\n            val n = arr.indexOf(r)\n\
    \            val k = arr.indexOf(l) + n\n            val m = arr.indexOf(l) +\
    \ n\n            val n = arr.indexOf(r)\n            val k = arr.indexOf(l) +\
    \ n\n            val m = arr.indexOf(l\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw1ps55sf.scala:90:4 ----------------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw1ps55sf.scala:100:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m100 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161]\
    \ Naming Error: /tmp/tmpw1ps55sf.scala:35:16 ---------------------------\e[0m\e\
    [0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36mm\e[0m = arr.indexOf(l) +\
    \ n\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw1ps55sf.scala:36:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e\
    [0m \e[36mn\e[0m = arr.indexOf(r)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpw1ps55sf.scala:37:16 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m            \e[33mval\e[0m \e[36mk\e[0m = arr.indexOf(l) + n\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mk is\
    \ already defined as \e[33mvalue\e[0m \e[35mk\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw1ps55sf.scala:38:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e\
    [0m \e[36mm\e[0m = arr.indexOf(l) + n\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/t"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbmo8bt.scala:34:12 ----------"
  stdout: ''
  timestamp: 1660009387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val maxLen = len - 1 // max length of array\n        val maxVal = arr(maxLen)\
    \ // max value of array\n        val minVal = arr(0) // min value of array\n \
    \       val maxValIndex = arr.lastIndexWhere(_ == maxVal) // index of max value\
    \ in array\n        val minValIndex = arr.indexOf(minVal) // index of min value\
    \ in array\n        val maxValIndexInt = maxValIndex.toInt // max value index\
    \ in array\n        val minValIndexInt = minValIndex.toInt // min value index\
    \ in array\n        val maxValIndexInt = maxValIndexInt + 1 // max value index\
    \ in array\n        val minValIndexInt = minValIndexInt + 1 // min value index\
    \ in array\n        val maxValIndexInt = maxValIndexInt + 1 // max value index\
    \ in array\n        val minValIndexInt = minValIndexInt + 1 // min value index\
    \ in array\n        val maxValIndexInt = maxValIndexInt + 1 // max value index\
    \ in array\n        val minValIndexInt = minValIndexInt + 1 // min value index\
    \ in array\n        val maxValIndexInt = maxValIndexInt + 1 // max value index\
    \ in array\n        val minValIndexInt = minValIndexInt + 1 // min value index\
    \ in array\n        val maxValIndexInt = maxValIndexInt + 1 // max value index\
    \ in array\n        val minValIndexInt = minValIndexInt + 1 // min value index\
    \ in array\n        val maxValIndexInt = maxValIndexInt + 1 // max value index\
    \ in array\n        val minValIndexInt = minValIndexInt + 1 // min value index\
    \ in array\n        val maxValIndexInt = maxValIndexInt + 1 // max value index\
    \ in array\n        val minValIndexInt = minValIndexInt + 1 // min value index\
    \ in array\n        val maxValIndexInt = maxValIndexInt + 1 // max value index\
    \ in array\n        val minValIndexInt = minValIndexInt + 1 // min value index\
    \ in array\n        val maxValIndexInt = maxValIndexInt + 1 // max value index\
    \ in array\n        val minValIndexInt = minValIndexInt + 1 // min value index\
    \ in array\n        val maxValIndexInt = maxValIndexInt + 1 // max value index\
    \ in array\n        val minValIndexInt = minValIndexInt + 1 // min value index\
    \ in array\n        val maxValIndexInt = maxValIndexIn\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgin7vjqu.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mmaxValIndexInt\e[0m = maxValIndexInt\
    \ + \e[31m1\e[0m \e[34m// max value index in array\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValIndexInt\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxValIndexInt\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgin7vjqu.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mminValIndexInt\e[0m = minValIndexInt + \e[31m1\e[0m \e[34m// min value\
    \ index in array\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminValIndexInt is already defined as \e[33mvalue\e[0m \e[35mminValIndexInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgin7vjqu.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mmaxValIndexInt\e[0m = maxValIndexInt\
    \ + \e[31m1\e[0m \e[34m// max value index in array\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValIndexInt\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxValIndexInt\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgin7vjqu.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mminValIndexInt\e[0m = minValIndexInt + \e[31m1\e[0m \e[34m// min value\
    \ index in array\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminValIndexInt is already defined as \e[33mvalue\e[0m \e[35mminValIndexInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgi"
  stdout: ''
  timestamp: 1660009446
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val n = arr.size\n    \
    \    val result = new mutable.ListBuffer[Long]()\n        var i = 0\n        var\
    \ j = 0\n        var k = 0\n        var temp = 0\n        var temp2 = 0\n    \
    \    var temp3 = 0\n        var temp4 = 0\n        var temp5 = 0\n        var\
    \ temp6 = 0\n        var temp7 = 0\n        var temp8 = 0\n        var temp9 =\
    \ 0\n        var temp10 = 0\n        var temp11 = 0\n        var temp12 = 0\n\
    \        var temp13 = 0\n        var temp14 = 0\n        var temp15 = 0\n    \
    \    var temp16 = 0\n        var temp17 = 0\n        var temp18 = 0\n        var\
    \ temp19 = 0\n        var temp20 = 0\n        var temp21 = 0\n        var temp22\
    \ = 0\n        var temp23 = 0\n        var temp24 = 0\n        var temp25 = 0\n\
    \        var temp26 = 0\n        var temp27 = 0\n        var temp28 = 0\n    \
    \    var temp29 = 0\n        var temp30 = 0\n        var temp31 = 0\n        var\
    \ temp32 = 0\n        var temp33 = 0\n        var temp34 = 0\n        var temp35\
    \ = 0\n        var temp36 = 0\n        var temp37 = 0\n        var temp38 = 0\n\
    \        var temp39 = 0\n        var temp40 = 0\n        var temp41 = 0\n    \
    \    var temp42 = 0\n        var temp43 = 0\n        var temp44 = 0\n        var\
    \ temp45 = 0\n        var temp46 = 0\n        var temp47 = 0\n        var temp48\
    \ = 0\n        var temp49 = 0\n        var temp50 = 0\n        var temp51 = 0\n\
    \        var temp52 = 0\n        var temp53 = 0\n        var temp54 = 0\n    \
    \    var temp55 = 0\n        var temp56 = 0\n        var temp57 = 0\n        var\
    \ temp58 = 0\n        var temp59 = 0\n        var temp60 = 0\n        var temp61\
    \ = 0\n        var temp62 = 0\n        var temp63 = 0\n        var temp64 = 0\n\
    \        var temp65 = 0\n        var temp66 = 0\n        var temp67 = 0\n    \
    \    var temp68 = 0\n        var temp69 = 0\n        var temp70 = 0\n        var\
    \ temp71 = 0\n        var temp72 = 0\n        var temp73 = 0\n        var temp74\
    \ = 0\n        var temp75 = 0\n        var temp76 = 0\n        var temp77 = 0\n\
    \        var temp78 = 0\n        var temp79 = 0\n        var temp80 = 0\n    \
    \    var temp81 = 0\n        var temp82 = 0\n        var temp83 = 0\n        var\
    \ temp84 = 0\n        var temp85 = 0\n        var temp86 = 0\n        var temp87\
    \ = 0\n        var temp88 = 0\n        var temp89 = 0\n        var temp90 = 0\n\
    \        var temp91 = 0\n        var temp92 = 0\n        var temp93 = 0\n    \
    \    var temp94 = 0\n        var temp95 = 0\n        var \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpvytmg5xk.scala:127:11 --------------------------\e\
    [0m\e[0m\n\e[31m127 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvytmg5xk.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpvytmg5xk.scala:28:25 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvytmg5xk.scala:128:5\
    \ --------------------\e[0m\e[0m\n\e[31m128 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val len = arr.length\n        val arr1 = arr.toArray\n        val arr2 =\
    \ arr.toBuffer\n        val arr3 = arr.toSeq\n        val arr4 = arr.toSet\n \
    \       val arr5 = arr.toMap\n        val arr6 = arr.toSeq.sortBy(_)\n       \
    \ val arr7 = arr.toSeq.sortWith(_ < _)\n        val arr8 = arr.toSeq.sortBy(_\
    \ > _)\n        val arr9 = arr.toSeq.sortBy(_ < _)\n        val arr10 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr11 = arr.toSeq.sortBy(_ > _)\n        val arr12 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr13 = arr.toSeq.sortBy(_ > _)\n        val arr14 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr15 = arr.toSeq.sortBy(_ < _)\n        val arr16 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr17 = arr.toSeq.sortBy(_ > _)\n        val arr18 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr19 = arr.toSeq.sortBy(_ > _)\n        val arr20 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr21 = arr.toSeq.sortBy(_ > _)\n        val arr22 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr23 = arr.toSeq.sortBy(_ > _)\n        val arr24 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr25 = arr.toSeq.sortBy(_ > _)\n        val arr26 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr27 = arr.toSeq.sortBy(_ > _)\n        val arr28 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr29 = arr.toSeq.sortBy(_ > _)\n        val arr30 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr31 = arr.toSeq.sortBy(_ > _)\n        val arr32 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr33 = arr.toSeq.sortBy(_ > _)\n        val arr34 = arr.toSeq.sortWith(_\
    \ < _\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmploju8usn.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmploju8usn.scala:27:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmploju8usn.scala:34:36\
    \ -----------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e\
    [0m \e[36marr6\e[0m = arr.toSeq.sortBy(_)\n\e[31m\e[31m   |\e[0m             \
    \                       ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$1\
    \ of expanded function:\n\e[31m   |\e[0m   _$1 => arr.toSeq.sortBy(_$1).\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmploju8usn.scala:63:5 ---------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if(arr.isEmpty) true\n        else if(arr.size == 1)\
    \ true\n        else {\n            val temp = arr(0)\n            val arr = arr.tail\n\
    \            val newArr = arr.map(x => x - 1)\n            val newArr = newArr.take(arr.size\
    \ - 1).reverse\n            val newArr = newArr.take(arr.size - 1).reverse\n \
    \           val newArr = newArr.take(arr.size - 1).reverse\n            val newArr\
    \ = newArr.take(arr.size - 1).reverse\n            val newArr = newArr.take(arr.size\
    \ - 1).reverse\n            val newArr = newArr.take(arr.size - 1).reverse\n \
    \           val newArr = newArr.take(arr.size - 1).reverse\n            val newArr\
    \ = newArr.take(arr.size - 1).reverse\n            val newArr = newArr.take(arr.size\
    \ - 1).reverse\n            val newArr = newArr.take(arr.size - 1).reverse\n \
    \           val newArr = newArr.take(arr.size - 1).reverse\n            val newArr\
    \ = newArr.take(arr.size - 1).reverse\n            val newArr = newArr.take(arr.size\
    \ - 1).reverse\n            val newArr = newArr.take(arr.size - 1).reverse\n \
    \           val newArr = newArr.take(arr.size - 1).reverse\n            val newArr\
    \ = newArr.take(arr.size - 1).reverse\n            val newArr = newArr.take(arr.size\
    \ - 1).reverse\n            val newArr = newArr.take(arr.size - 1).reverse\n \
    \           val newArr = newArr.take(arr.size - 1).reverse\n            val newArr\
    \ = newArr.take(arr.size - 1).reverse\n            val newArr = newArr.take(arr.size\
    \ - 1).reverse\n            val newArr = newArr.take(arr.size - 1).reverse\n \
    \           val newArr = newArr.take(arr.size - 1).reverse\n            val newArr\
    \ = newArr.take(arr.size - 1).reverse\n            val newArr = newArr.take(arr.size\
    \ - 1).reverse\n            val newArr = newArr.take(arr.size - 1).reverse\n \
    \           val newArr = newArr.take(arr.size - 1).reverse\n            val newArr\
    \ = newArr.take(arr.size - 1).reverse\n            val newArr = newArr.take(arr.size\
    \ - 1).reverse\n            val newArr = newArr.take(arr.size - 1).reverse\n \
    \           val newArr = newArr.take(arr.size - 1).reverse\n            val newArr\
    \ = newArr.\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpp44ixkg_.scala:64:4 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpp44ixkg_.scala:74:0 ----------------------------\e[0m\e[0m\n\e[31m74\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpp44ixkg_.scala:32:16 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36mnewArr\e[0m = newArr.take(arr.size\
    \ - \e[31m1\e[0m).reverse\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewArr is already defined as \e[33mvalue\e[0m \e[35mnewArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpp44ixkg_.scala:33:16 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m            \e[33mval\e[0m \e[36mnewArr\e[0m = newArr.take(arr.size\
    \ - \e[31m1\e[0m).reverse\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewArr is already defined as \e[33mvalue\e[0m \e[35mnewArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpp44ixkg_.scala:34:16 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m            \e[33mval\e[0m \e[36mnewArr\e[0m = newArr.take(arr.size\
    \ - \e[31m1\e[0m).reverse\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewArr is already defined as \e[33mvalue\e[0m \e[35mnewArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpp44ixkg_.scala:35:16 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m            \e[33mval\e[0m \e[36mnewArr\e[0m = newArr.take(arr.size\
    \ - \e[31m1\e[0m).reverse\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n        else\
    \ {\n            val arr = arr.sortBy(x => x)\n            val first = arr(0)\n\
    \            val last = arr(n)\n            val first = arr(0)\n            val\
    \ last = arr(n)\n            val first = arr(0)\n            val last = arr(n)\n\
    \            val first = arr(0)\n            val last = arr(n)\n            val\
    \ first = arr(0)\n            val last = arr(n)\n            val first = arr(0)\n\
    \            val last = arr(n)\n            val first = arr(0)\n            val\
    \ last = arr(n)\n            val first = arr(0)\n            val last = arr(n)\n\
    \            val first = arr(0)\n            val last = arr(n)\n            val\
    \ first = arr(0)\n            val last = arr(n)\n            val first = arr(0)\n\
    \            val last = arr(n)\n            val first = arr(0)\n            val\
    \ last = arr(n)\n            val first = arr(0)\n            val last = arr(n)\n\
    \            val first = arr(0)\n            val last = arr(n)\n            val\
    \ first = arr(0)\n            val last = arr(n)\n            val first = arr(0)\n\
    \            val last = arr(n)\n            val first = arr(0)\n            val\
    \ last = arr(n)\n            val first = arr(0)\n            val last = arr(n)\n\
    \            val first = arr(0)\n            val last = arr(n)\n            val\
    \ first = arr(0)\n            val last = arr(n)\n            val first = arr(0)\n\
    \            val last = arr(n)\n            val first = arr(0)\n            val\
    \ last = arr(n)\n            val first = arr(0)\n            val last = arr(n)\n\
    \            val first = arr(0)\n            val last = arr(n)\n            val\
    \ first = arr(0)\n            val last = arr(n)\n            val first = arr(0)\n\
    \            val last = arr(n)\n            val first = arr(0)\n            val\
    \ last = arr(n)\n            val first = arr(0)\n            val last = arr(n)\n\
    \            val first = arr(0)\n            val last = arr(n)\n            val\
    \ first = arr(0)\n            val last = arr(n)\n            val first = arr(0)\n\
    \            val last = arr(n)\n            val first = arr(0)\n            val\
    \ last = arr(n)\n            val first = arr(0)\n            val last = arr(n)\n\
    \            val first = arr(0)\n            val last = arr(n)\n            val\
    \ first = arr(0)\n            val last = arr(n)\n            val first = arr(0)\n\
    \            val last = arr(n)\n            val first = arr(0)\n            val\
    \ last = arr(n)\n            val first = arr(0)\n            val last = arr(n)\n\
    \            val first = arr(0)\n            val last = arr(n)\n            val\
    \ first = arr(0)\n            val last = arr(n)\n            val first = arr(0)\n\
    \            val last = \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmphd7u228l.scala:111:22 --------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m            \e[33mval\e[0m \e[36mlast\e[0m = \n\e[31m\e\
    [31m    |\e[0m                      ^\e[0m\n\e[31m    |\e[0m                 \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m    |\e[0m\n\e[31m \
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmphd7u228l.scala:122:0 ---------------------------\e\
    [0m\e[0m\n\e[31m122 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphd7u228l.scala:32:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mfirst\e[0m = arr(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mfirst is already defined as \e[33mvalue\e[0m \e[35mfirst\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphd7u228l.scala:33:16 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m            \e[33mval\e[0m \e[36mlast\e[0m = arr(n)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlast is already defined\
    \ as \e[33mvalue\e[0m \e[35mlast\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphd7u228l.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mfirst\e[0m = arr(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mfirst is already defined as \e[33mvalue\e[0m \e[35mfirst\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphd7u228l.scala:35:16 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m            \e[33mval\e[0m \e[36mlast\e[0m = arr(n)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlast is already defined\
    \ as \e[33mvalue\e[0m \e[35ml"
  stdout: ''
  timestamp: 1660009450
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val n = arr.size\n        val arr = arr.toArray\n        val n = arr.size\n\
    \        val arr = arr.toArray\n        val n = arr.size\n        val arr = arr.toArray\n\
    \        val n = arr.size\n        val arr = arr.toArray\n        val n = arr.size\n\
    \        val arr = arr.toArray\n        val n = arr.size\n        val arr = arr.toArray\n\
    \        val n = arr.size\n        val arr = arr.toArray\n        val n = arr.size\n\
    \        val arr = arr.toArray\n        val n = arr.size\n        val arr = arr.toArray\n\
    \        val n = arr.size\n        val arr = arr.toArray\n        val n = arr.size\n\
    \        val arr = arr.toArray\n        val n = arr.size\n        val arr = arr.toArray\n\
    \        val n = arr.size\n        val arr = arr.toArray\n        val n = arr.size\n\
    \        val arr = arr.toArray\n        val n = arr.size\n        val arr = arr.toArray\n\
    \        val n = arr.size\n        val arr = arr.toArray\n        val n = arr.size\n\
    \        val arr = arr.toArray\n        val n = arr.size\n        val arr = arr.toArray\n\
    \        val n = arr.size\n        val arr = arr.toArray\n        val n = arr.size\n\
    \        val arr = arr.toArray\n        val n = arr.size\n        val arr = arr.toArray\n\
    \        val n = arr.size\n        val arr = arr.toArray\n        val n = arr.size\n\
    \        val arr = arr.toArray\n        val n = arr.size\n        val arr = arr.toArray\n\
    \        val n = arr.size\n        val arr = arr.toArray\n        val n = arr.size\n\
    \        val arr = arr.toArray\n        val n = arr.size\n        val arr = arr.toArray\n\
    \        val n = arr.size\n        val arr = arr.toArray\n        val n = arr.size\n\
    \        val arr = arr.toArray\n        val n = arr.size\n        val arr = arr.toArray\n\
    \        val n = arr.size\n        val arr = arr.toArray\n        val n = arr.size\n\
    \        val arr = arr.toArray\n        val n = arr.size\n        val arr = arr.toArray\n\
    \        val n = arr.size\n        val arr = arr.toArray\n        val n = arr.size\n\
    \        val arr = arr.toArray\n        val n = arr.size\n        val arr = arr.toArray\n\
    \        val n = arr.size\n        val arr = arr.toArray\n        val n = arr.size\n\
    \        val arr = arr.toArray\n        val n = arr.size\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp962st8vg.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp962st8vg.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp962st8vg.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mn\e[0m = arr.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp962st8vg.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp962st8vg.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp962st8vg.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m3"
  stdout: ''
  timestamp: 1660009449
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n - 1)\n      \
    \  val arr = arr.take(n)\n        val arr = arr.sortBy(x => x)\n        val arr\
    \ = arr.drop(n - 1)\n        val arr = arr.take(n)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(n - 1)\n        val arr = arr.take(n)\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n - 1)\n     \
    \   val arr = arr.take(n)\n        val arr = arr.sortBy(x => x)\n        val arr\
    \ = arr.drop(n - 1)\n        val arr = arr.take(n)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(n - 1)\n        val arr = arr.take(n)\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n - 1)\n     \
    \   val arr = arr.take(n)\n        val arr = arr.sortBy(x => x)\n        val arr\
    \ = arr.drop(n - 1)\n        val arr = arr.take(n)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(n - 1)\n        val arr = arr.take(n)\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n - 1)\n     \
    \   val arr = arr.take(n)\n        val arr = arr.sortBy(x => x)\n        val arr\
    \ = arr.drop(n - 1)\n        val arr = arr.take(n)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(n - 1)\n        val arr = arr.take(n)\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n - 1)\n     \
    \   val arr = arr.take(n)\n        val arr = arr.sortBy(x => x)\n        val arr\
    \ = arr.drop(n - 1)\n        val arr = arr.take(n)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(n - 1)\n        val arr = arr.take(n)\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n - 1)\n     \
    \   val arr = arr.take(n)\n        val arr = arr.sortBy(x => x)\n        val arr\
    \ = arr.drop(n - 1)\n        val arr = arr.take(n)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(n - 1)\n        val arr = arr.take(n)\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n - 1)\n     \
    \   val arr = arr.take(n)\n        val arr = arr.sort\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt5qhs1sl.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpt5qhs1sl.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(n - \e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt5qhs1sl.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.take(n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpt5qhs1sl.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt5qhs1sl.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.drop(n - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of topl"
  stdout: ''
  timestamp: 1660009451
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val maxVal = arr.max\n        val minVal = arr.min\n        val maxValIndex\
    \ = arr.lastIndexWhere(_ == maxVal)\n        val minValIndex = arr.lastIndexWhere(_\
    \ == minVal)\n        val maxValIndex = arr.lastIndexWhere(_ == maxVal)\n    \
    \    val minValIndex = arr.lastIndexWhere(_ == minVal)\n        val maxValIndex\
    \ = arr.lastIndexWhere(_ == maxVal)\n        val minValIndex = arr.lastIndexWhere(_\
    \ == minVal)\n        val maxValIndex = arr.lastIndexWhere(_ == maxVal)\n    \
    \    val minValIndex = arr.lastIndexWhere(_ == minVal)\n        val maxValIndex\
    \ = arr.lastIndexWhere(_ == maxVal)\n        val minValIndex = arr.lastIndexWhere(_\
    \ == minVal)\n        val maxValIndex = arr.lastIndexWhere(_ == maxVal)\n    \
    \    val minValIndex = arr.lastIndexWhere(_ == minVal)\n        val maxValIndex\
    \ = arr.lastIndexWhere(_ == maxVal)\n        val minValIndex = arr.lastIndexWhere(_\
    \ == minVal)\n        val maxValIndex = arr.lastIndexWhere(_ == maxVal)\n    \
    \    val minValIndex = arr.lastIndexWhere(_ == minVal)\n        val maxValIndex\
    \ = arr.lastIndexWhere(_ == maxVal)\n        val minValIndex = arr.lastIndexWhere(_\
    \ == minVal)\n        val maxValIndex = arr.lastIndexWhere(_ == maxVal)\n    \
    \    val minValIndex = arr.lastIndexWhere(_ == minVal)\n        val maxValIndex\
    \ = arr.lastIndexWhere(_ == maxVal)\n        val minValIndex = arr.lastIndexWhere(_\
    \ == minVal)\n        val maxValIndex = arr.lastIndexWhere(_ == maxVal)\n    \
    \    val minValIndex = arr.lastIndexWhere(_ == minVal)\n        val maxValIndex\
    \ = arr.lastIndexWhere(_ == maxVal)\n        val minValIndex = arr.lastIndexWhere(_\
    \ == minVal)\n        val maxValIndex = arr.lastIndexWhere(_ == maxVal)\n    \
    \    val minValIndex = arr.lastIndexWhere(_ == minVal)\n        val maxValIndex\
    \ = arr.lastIndexWhere(_ == maxVal)\n        val minValIndex = arr.lastIndexWhere(_\
    \ == minVal)\n        val maxValIndex = arr.lastIndexWhere(_ == maxVal)\n    \
    \    val minValIndex = arr.lastIndexWhere(_ == minVal)\n        val maxValIndex\
    \ = arr.lastIndexWhere(_ == maxVal)\n        val minValIndex = arr.lastIndexWhere(_\
    \ == minVal)\n        val maxValIndex = arr.lastIndex\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9by2zkm2.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxValIndex\e[0m = arr.lastIndexWhere(_\
    \ == maxVal)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxValIndex is already defined as \e[33mvalue\e[0m \e[35mmaxValIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9by2zkm2.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mminValIndex\e[0m = arr.lastIndexWhere(_\
    \ == minVal)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminValIndex is already defined as \e[33mvalue\e[0m \e[35mminValIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9by2zkm2.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mmaxValIndex\e[0m = arr.lastIndexWhere(_\
    \ == maxVal)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxValIndex is already defined as \e[33mvalue\e[0m \e[35mmaxValIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9by2zkm2.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mminValIndex\e[0m = arr.lastIndexWhere(_\
    \ == minVal)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminValIndex is already defined as \e[33mvalue\e[0m \e[35mminValIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9by2zkm2.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mmaxValIndex\e[0m = arr.lastIndexWhe"
  stdout: ''
  timestamp: 1660009450
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3yuj6sf8.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e"
  stdout: ''
  timestamp: 1660009388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr1 = arr.toArray\n        val arr2 = arr.toBuffer\n        val\
    \ arr3 = arr.toSeq\n        val arr4 = arr.toSet\n        val arr5 = arr.toSeq.sortBy(_)\n\
    \        val arr6 = arr.toSeq.sortWith(_ < _)\n        val arr7 = arr.toSeq.sortBy(_\
    \ > _)\n        val arr8 = arr.toSeq.sortBy(_ < _)\n        val arr9 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr10 = arr.toSeq.sortBy(_ > _)\n        val arr11 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr12 = arr.toSeq.sortBy(_ > _)\n        val arr13 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr14 = arr.toSeq.sortBy(_ > _)\n        val arr15 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr16 = arr.toSeq.sortBy(_ > _)\n        val arr17 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr18 = arr.toSeq.sortBy(_ > _)\n        val arr19 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr20 = arr.toSeq.sortBy(_ > _)\n        val arr21 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr22 = arr.toSeq.sortBy(_ > _)\n        val arr23 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr24 = arr.toSeq.sortBy(_ > _)\n        val arr25 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr26 = arr.toSeq.sortBy(_ > _)\n        val arr27 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr28 = arr.toSeq.sortBy(_ > _)\n        val arr29 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr30 = arr.toSeq.sortBy(_ > _)\n        val arr31 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr32 = arr.toSeq.sortBy(_ > _)\n        val arr33 = arr.toSeq.sortWith(_\
    \ < _)\n        val arr34 = arr.toSeq.sortBy(_ > \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6i1z380s.scala:61:40 ---------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m        \e[33mval\e[0m \e[36marr34\e[0m = arr.toSeq.sortBy(_\
    \ > \n\e[31m\e[31m   |\e[0m                                        ^\e[0m\n\e\
    [31m   |\e[0m                                       expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6i1z380s.scala:26:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmp6i1z380s.scala:32:36\
    \ -----------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e\
    [0m \e[36marr5\e[0m = arr.toSeq.sortBy(_)\n\e[31m\e[31m   |\e[0m             \
    \                       ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$1\
    \ of expanded function:\n\e[31m   |\e[0m   _$1 => arr.toSeq.sortBy(_$1).\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp6i1z380s.scala:62:5 ---------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009452
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toSet\n        val len = arr.size\n   \
    \     val arr = arr.toSeq\n        val len = arr.size\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toSeq\n        val len = arr.size\n      \
    \  val arr = arr.toArray\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.size\n        val arr = arr.toSeq\n        val len = arr.size\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toList\n        val len = arr.size\n        val arr = arr.toSeq\n    \
    \    val len = arr.size\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.size\n        val arr = arr.toSeq\n\
    \        val len = arr.size\n        val arr = arr.toArray\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.size\n     \
    \   val arr = arr.toSeq\n        val len = arr.size\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.size\n        val arr = arr.toSeq\n        val len = arr.size\n        val\
    \ arr = arr.toArray\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.size\n        val arr = arr.toSeq\n        val len = arr.size\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toList\n        val len = arr.size\n        val arr = arr.toSeq\n    \
    \    val len = arr.size\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.size\n        val arr = arr.toSeq\n\
    \        val len = arr.size\n        val arr = arr.toArray\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.size\n     \
    \   val arr = arr.toSeq\n        val len = arr.size\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.size\n        val arr = arr.toSeq\n        val len = arr.size\n        val\
    \ arr = arr.toArray\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.size\n        val arr = arr.toSeq\n        val len = arr.size\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.to\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpolkxdjk8.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toSeq\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpolkxdjk8.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.size\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpolkxdjk8.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpolkxdjk8.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlen\e[0m = arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlen is already defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpolkxdjk8.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpolkxdjk8.scala:33:12 --------------"
  stdout: ''
  timestamp: 1660009452
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toArray\n \
    \       val arr = arr.sortWith(_ < _)\n        val arr = arr.dropRight(1)\n  \
    \      val arr = arr.takeRight(n)\n        val arr = arr.toList\n        val arr\
    \ = arr.sortWith(_ < _)\n        val arr = arr.dropRight(1)\n        val arr =\
    \ arr.takeRight(n)\n        val arr = arr.toList\n        val arr = arr.sortWith(_\
    \ < _)\n        val arr = arr.dropRight(1)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.toList\n        val arr = arr.sortWith(_ < _)\n       \
    \ val arr = arr.dropRight(1)\n        val arr = arr.takeRight(n)\n        val\
    \ arr = arr.toList\n        val arr = arr.sortWith(_ < _)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.takeRight(n)\n        val arr = arr.toList\n        val\
    \ arr = arr.sortWith(_ < _)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.takeRight(n)\n        val arr = arr.toList\n        val arr = arr.sortWith(_\
    \ < _)\n        val arr = arr.dropRight(1)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.toList\n        val arr = arr.sortWith(_ < _)\n       \
    \ val arr = arr.dropRight(1)\n        val arr = arr.takeRight(n)\n        val\
    \ arr = arr.toList\n        val arr = arr.sortWith(_ < _)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.takeRight(n)\n        val arr = arr.toList\n        val\
    \ arr = arr.sortWith(_ < _)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.takeRight(n)\n        val arr = arr.toList\n        val arr = arr.sortWith(_\
    \ < _)\n        val arr = arr.dropRight(1)\n        val arr = arr.takeRight(n)\n\
    \        val arr = arr.toList\n        val arr = arr.sortWith(_ < _)\n       \
    \ val arr = arr.dropRight(1)\n        val arr = arr.takeRight(n)\n        val\
    \ arr = arr.toList\n        val arr = arr.sortWith(_ < _)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.takeRight(n)\n        val arr = arr.toList\n        val\
    \ arr = arr.sortWith(_ < _)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.takeRight(n)\n        val arr = arr.toList\n        val arr = arr.sortWith(_\
    \ < _)\n        val arr = arr.dropRight(1)\n        val arr = arr.\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdurj7bwu.scala:87:4 ----------------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpdurj7bwu.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_ < _)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdurj7bwu.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpdurj7bwu.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.takeRight(n)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdurj7bwu.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdurj7bwu.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009452
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val arr1 = arr.toList\n        val arr2 = arr1.sortWith(_\
    \ < _)\n        val arr3 = arr2.reverse\n        val arr4 = arr3.foldLeft(arr)\
    \ { (acc, x) => acc ++ x }\n        val arr5 = arr4.foldLeft(arr) { (acc, x) =>\
    \ acc ++ x }\n        val arr6 = arr5.foldLeft(arr) { (acc, x) => acc ++ x }\n\
    \        val arr7 = arr6.foldLeft(arr) { (acc, x) => acc ++ x }\n        val arr8\
    \ = arr7.foldLeft(arr) { (acc, x) => acc ++ x }\n        val arr9 = arr8.foldLeft(arr)\
    \ { (acc, x) => acc ++ x }\n        val arr10 = arr9.foldLeft(arr) { (acc, x)\
    \ => acc ++ x }\n        val arr11 = arr10.foldLeft(arr) { (acc, x) => acc ++\
    \ x }\n        val arr12 = arr11.foldLeft(arr) { (acc, x) => acc ++ x }\n    \
    \    val arr13 = arr12.foldLeft(arr) { (acc, x) => acc ++ x }\n        val arr14\
    \ = arr13.foldLeft(arr) { (acc, x) => acc ++ x }\n        val arr15 = arr14.foldLeft(arr)\
    \ { (acc, x) => acc ++ x }\n        val arr16 = arr15.foldLeft(arr) { (acc, x)\
    \ => acc ++ x }\n        val arr17 = arr16.foldLeft(arr) { (acc, x) => acc ++\
    \ x }\n        val arr18 = arr17.foldLeft(arr) { (acc, x) => acc ++ x }\n    \
    \    val arr19 = arr18.foldLeft(arr) { (acc, x) => acc ++ x }\n        val arr20\
    \ = arr19.foldLeft(arr) { (acc, x) => acc ++ x }\n        val arr21 = arr20.foldLeft(arr)\
    \ { (acc, x) => acc ++ x }\n        val arr22 = arr21.foldLeft(arr) { (acc, x)\
    \ => acc ++ x }\n        val arr23 = arr22.foldLeft(arr) { (acc, x) => acc ++\
    \ x }\n        val arr24 = arr23.foldLeft(arr) { (acc, x) => acc ++ x }\n    \
    \    val arr25 = arr24.foldLeft(arr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpd5jrbf04.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpd5jrbf04.scala:28:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd5jrbf04.scala:54:5\
    \ ---------------------\e[0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009451
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) true\n      \
    \  else {\n            val left = 0\n            val right = n - 1\n         \
    \   val mid = n / 2\n            val leftVal = arr(mid)\n            val rightVal\
    \ = arr(mid)\n            while (left < right) {\n                val temp = arr(left)\n\
    \                arr(left) = arr(right)\n                arr(right) = temp\n \
    \               left += 1\n                right -= 1\n            }\n       \
    \     if (leftVal > rightVal) moveOneBall(arr.drop(mid))\n            else moveOneBall(arr.take(mid))\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpymkr3u53.scala:36:16 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                arr(left) = arr(right)\n\e[31m\e[31m\
    \   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member\
    \ of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpymkr3u53.scala:37:16 ------------------------\e[0m\e[0m\n\e[31m37 |\e\
    [0m                arr(right) = temp\n\e[31m\e[31m   |\e[0m                ^^^\e\
    [0m\n\e[31m   |\e[0m  value update is not a member of List[Long] - did you mean\
    \ arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpymkr3u53.scala:38:21\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                left += \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                value += is not a member of Int - did you mean left.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpymkr3u53.scala:39:22 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                right -= \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m                value -=\
    \ is not a member of Int - did you mean right.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1660009453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toArray\n \
    \       val arr1 = arr.slice(1, n).toArray\n        val arr2 = arr.slice(0, n-1).toArray\n\
    \        val arr3 = arr.slice(1, n-1).toArray\n        val arr4 = arr.slice(0,\
    \ n-2).toArray\n        val arr5 = arr.slice(1, n-2).toArray\n        val arr6\
    \ = arr.slice(0, n-3).toArray\n        val arr7 = arr.slice(1, n-3).toArray\n\
    \        val arr8 = arr.slice(0, n-4).toArray\n        val arr9 = arr.slice(1,\
    \ n-4).toArray\n        val arr10 = arr.slice(0, n-5).toArray\n        val arr11\
    \ = arr.slice(1, n-5).toArray\n        val arr12 = arr.slice(0, n-6).toArray\n\
    \        val arr13 = arr.slice(1, n-6).toArray\n        val arr14 = arr.slice(0,\
    \ n-7).toArray\n        val arr15 = arr.slice(1, n-7).toArray\n        val arr16\
    \ = arr.slice(0, n-8).toArray\n        val arr17 = arr.slice(1, n-8).toArray\n\
    \        val arr18 = arr.slice(0, n-9).toArray\n        val arr19 = arr.slice(1,\
    \ n-9).toArray\n        val arr20 = arr.slice(0, n-10).toArray\n        val arr21\
    \ = arr.slice(1, n-10).toArray\n        val arr22 = arr.slice(0, n-11).toArray\n\
    \        val arr23 = arr.slice(1, n-11).toArray\n        val arr24 = arr.slice(0,\
    \ n-12).toArray\n        val arr25 = arr.slice(1, n-12).toArray\n        val arr26\
    \ = arr.slice(0, n-13).toArray\n        val arr27 = arr.slice(1, n-13).toArray\n\
    \        val arr28 = arr.slice(0, n-14).toArray\n        val arr29 = arr.slice(1,\
    \ n-14).toArray\n        val arr30 = arr.slice(0, n-15).toArray\n        val arr31\
    \ = arr.slice(1, n-15).toArray\n        val arr32 = arr.slice(0, n-16).toArray\n\
    \        val arr33 = arr.slice(1, n-16).toArray\n        val arr34 = arr.slice(0,\
    \ n-17).toArray\n        val arr35 = arr.slice(1, n-17).toArray\n        val arr36\
    \ = arr.slice(0, n-18).toArray\n        val arr37 = arr.slice(1, n-18).toArray\n\
    \        val arr38 = arr.slice(0, n-19).toArray\n        val arr39 = arr.slice(1,\
    \ n-19).toArray\n        val arr40 = arr.slice(0, n-20).toArray\n        val arr41\
    \ = arr.slice(1, n-20).toArray\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3a2j0blw.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3a2j0blw.scala:69:5 ---------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009452
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val arr2 = arr.tail\n        val arr3 = arr.init\n        val arr4 = arr.drop(1)\n\
    \        val arr5 = arr.take(1)\n        val arr6 = arr.dropRight(1)\n       \
    \ val arr7 = arr.takeRight(1)\n        val arr8 = arr.drop(1)\n        val arr9\
    \ = arr.take(1)\n        val arr10 = arr.dropRight(1)\n        val arr11 = arr.takeRight(1)\n\
    \        val arr12 = arr.drop(1)\n        val arr13 = arr.take(1)\n        val\
    \ arr14 = arr.dropRight(1)\n        val arr15 = arr.takeRight(1)\n        val\
    \ arr16 = arr.drop(1)\n        val arr17 = arr.take(1)\n        val arr18 = arr.dropRight(1)\n\
    \        val arr19 = arr.takeRight(1)\n        val arr20 = arr.drop(1)\n     \
    \   val arr21 = arr.take(1)\n        val arr22 = arr.dropRight(1)\n        val\
    \ arr23 = arr.takeRight(1)\n        val arr24 = arr.drop(1)\n        val arr25\
    \ = arr.take(1)\n        val arr26 = arr.dropRight(1)\n        val arr27 = arr.takeRight(1)\n\
    \        val arr28 = arr.drop(1)\n        val arr29 = arr.take(1)\n        val\
    \ arr30 = arr.dropRight(1)\n        val arr31 = arr.takeRight(1)\n        val\
    \ arr32 = arr.drop(1)\n        val arr33 = arr.take(1)\n        val arr34 = arr.dropRight(1)\n\
    \        val arr35 = arr.takeRight(1)\n        val arr36 = arr.drop(1)\n     \
    \   val arr37 = arr.take(1)\n        val arr38 = arr.dropRight(1)\n        val\
    \ arr39 = arr.takeRight(1)\n        val arr40 = arr.drop(1)\n        val arr41\
    \ = arr.take(1)\n        val arr42 = arr.dropRight(1)\n        val arr43 = arr.takeRight(1)\n\
    \        val arr44 = arr.drop(1)\n        val arr45 = arr.take(1)\n        val\
    \ arr46 = arr.dropRight(1)\n        val arr47 = arr.takeRight(1)\n        val\
    \ arr48 = arr.drop(1)\n        val arr49 = arr.take(1)\n        val arr50 = arr.dropRight(1)\n\
    \        val arr51 = arr.takeRight(1)\n        val arr52 = arr.drop(1)\n     \
    \   val arr53 = arr.take(1)\n        val arr54 = arr.dropRight(1)\n        val\
    \ arr55 = arr.takeRight(1)\n\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdwm8z4v7.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpdwm8z4v7.scala:83:5 ---------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val m = arr.head\n      \
    \  val arr = arr.tail\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(arr.length - 1)\n        val arr = arr.take(arr.length\
    \ - 1)\n        val arr = arr.drop(1)\n        val arr = arr.take(1)\n       \
    \ val arr = arr.drop(1)\n        val arr = arr.take(1)\n        val arr = arr.drop(1)\n\
    \        val arr = arr.take(1)\n        val arr = arr.drop(1)\n        val arr\
    \ = arr.take(1)\n        val arr = arr.drop(1)\n        val arr = arr.take(1)\n\
    \        val arr = arr.drop(1)\n        val arr = arr.take(1)\n        val arr\
    \ = arr.drop(1)\n        val arr = arr.take(1)\n        val arr = arr.drop(1)\n\
    \        val arr = arr.take(1)\n        val arr = arr.drop(1)\n        val arr\
    \ = arr.take(1)\n        val arr = arr.drop(1)\n        val arr = arr.take(1)\n\
    \        val arr = arr.drop(1)\n        val arr = arr.take(1)\n        val arr\
    \ = arr.drop(1)\n        val arr = arr.take(1)\n        val arr = arr.drop(1)\n\
    \        val arr = arr.take(1)\n        val arr = arr.drop(1)\n        val arr\
    \ = arr.take(1)\n        val arr = arr.drop(1)\n        val arr = arr.take(1)\n\
    \        val arr = arr.drop(1)\n        val arr = arr.take(1)\n        val arr\
    \ = arr.drop(1)\n        val arr = arr.take(1)\n        val arr = arr.drop(1)\n\
    \        val arr = arr.take(1)\n        val arr = arr.drop(1)\n        val arr\
    \ = arr.take(1)\n        val arr = arr.drop(1)\n        val arr = arr.take(1)\n\
    \        val arr = arr.drop(1)\n        val arr = arr.take(1)\n        val arr\
    \ = arr.drop(1)\n        val arr = arr.take(1)\n        val arr = arr.drop(1)\n\
    \        val arr = arr.take(1)\n        val arr = arr.drop(1)\n        val arr\
    \ = arr.take(1)\n        val arr = arr.drop(1)\n        val arr = arr.take(1)\n\
    \        val arr = arr.drop(1)\n        val arr = arr.take(1)\n        val arr\
    \ = arr.drop(1)\n        val arr = arr.take(1)\n        val arr = arr.drop(1)\n\
    \        val arr = arr.take(1)\n        val arr = arr.drop(1)\n        val arr\
    \ = arr.take(1)\n        val arr = arr.drop(1)\n        val arr = arr.take(1)\n\
    \        val arr = arr.drop(1)\n        val arr = arr.take(1)\n        val arr\
    \ = arr.drop(1)\n        val arr = arr.take(1)\n        val arr = arr.drop(1)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpx8afglcs.scala:98:11 ---------------------------\e\
    [0m\e[0m\n\e[31m98 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpx8afglcs.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx8afglcs.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpx8afglcs.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(arr.length - \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpx8afglcs.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.take(arr.length - \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpx8afglcs.scala:33:12 --------"
  stdout: ''
  timestamp: 1660009455
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toSet\n        val len = arr.size\n   \
    \     val arr1 = arr.toSeq\n        val arr2 = arr1.toSeq\n        val arr3 =\
    \ arr2.toSeq\n        val arr4 = arr3.toSeq\n        val arr5 = arr4.toSeq\n \
    \       val arr6 = arr5.toSeq\n        val arr7 = arr6.toSeq\n        val arr8\
    \ = arr7.toSeq\n        val arr9 = arr8.toSeq\n        val arr10 = arr9.toSeq\n\
    \        val arr11 = arr10.toSeq\n        val arr12 = arr11.toSeq\n        val\
    \ arr13 = arr12.toSeq\n        val arr14 = arr13.toSeq\n        val arr15 = arr14.toSeq\n\
    \        val arr16 = arr15.toSeq\n        val arr17 = arr16.toSeq\n        val\
    \ arr18 = arr17.toSeq\n        val arr19 = arr18.toSeq\n        val arr20 = arr19.toSeq\n\
    \        val arr21 = arr20.toSeq\n        val arr22 = arr21.toSeq\n        val\
    \ arr23 = arr22.toSeq\n        val arr24 = arr23.toSeq\n        val arr25 = arr24.toSeq\n\
    \        val arr26 = arr25.toSeq\n        val arr27 = arr26.toSeq\n        val\
    \ arr28 = arr27.toSeq\n        val arr29 = arr28.toSeq\n        val arr30 = arr29.toSeq\n\
    \        val arr31 = arr30.toSeq\n        val arr32 = arr31.toSeq\n        val\
    \ arr33 = arr32.toSeq\n        val arr34 = arr33.toSeq\n        val arr35 = arr34.toSeq\n\
    \        val arr36 = arr35.toSeq\n        val arr37 = arr36.toSeq\n        val\
    \ arr38 = arr37.toSeq\n        val arr39 = arr38.toSeq\n        val arr40 = arr39.toSeq\n\
    \        val arr41 = arr40.toSeq\n        val arr42 = arr41.toSeq\n        val\
    \ arr43 = arr42.toSeq\n        val arr44 = arr43.toSeq\n        val arr45 = arr44.toSeq\n\
    \        val arr46 = arr45.toSeq\n        val arr47 = arr46.toSeq\n        val\
    \ arr48 = arr47.toSeq\n        val arr49 = arr48.toSeq\n        val arr50 = arr49.toSeq\n\
    \        val arr51 = arr50.to\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpovsgc4jd.scala:26:18 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toSet\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpovsgc4jd.scala:79:5 ---------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) true\n      \
    \  else {\n            val maxIndex = n - 1\n            val maxValue = arr(maxIndex)\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n\
    \            val maxValueIndex = maxIndex - 1\n            val maxValueIndex =\
    \ maxIndex - 1\n            val maxValueIndex = maxIndex - 1\n            val\
    \ maxValueIndex = max\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpplvxa662.scala:95:0 ----------------------------\e\
    [0m\e[0m\n\e[31m95 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpplvxa662.scala:32:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mmaxValueIndex\e[0m = maxIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValueIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxValueIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpplvxa662.scala:33:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e\
    [0m \e[36mmaxValueIndex\e[0m = maxIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValueIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxValueIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpplvxa662.scala:34:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e\
    [0m \e[36mmaxValueIndex\e[0m = maxIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValueIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxValueIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpplvxa662.scala:35:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e\
    [0m \e[36mmaxValueIndex\e[0m = maxIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValueIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxValueIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpplvx"
  stdout: ''
  timestamp: 1660009455
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val arr1 = arr.sortBy(_)\n        val arr2 = arr1.reverse\n        val\
    \ arr3 = arr2.sortBy(_)\n        val arr4 = arr3.reverse\n        val arr5 = arr4.sortBy(_)\n\
    \        val arr6 = arr5.reverse\n        val arr7 = arr6.sortBy(_)\n        val\
    \ arr8 = arr7.reverse\n        val arr9 = arr8.sortBy(_)\n        val arr10 =\
    \ arr9.sortBy(_)\n        val arr11 = arr10.sortBy(_)\n        val arr12 = arr11.sortBy(_)\n\
    \        val arr13 = arr12.sortBy(_)\n        val arr14 = arr13.sortBy(_)\n  \
    \      val arr15 = arr14.sortBy(_)\n        val arr16 = arr15.sortBy(_)\n    \
    \    val arr17 = arr16.sortBy(_)\n        val arr18 = arr17.sortBy(_)\n      \
    \  val arr19 = arr18.sortBy(_)\n        val arr20 = arr19.sortBy(_)\n        val\
    \ arr21 = arr20.sortBy(_)\n        val arr22 = arr21.sortBy(_)\n        val arr23\
    \ = arr22.sortBy(_)\n        val arr24 = arr23.sortBy(_)\n        val arr25 =\
    \ arr24.sortBy(_)\n        val arr26 = arr25.sortBy(_)\n        val arr27 = arr26.sortBy(_)\n\
    \        val arr28 = arr27.sortBy(_)\n        val arr29 = arr28.sortBy(_)\n  \
    \      val arr30 = arr29.sortBy(_)\n        val arr31 = arr30.sortBy(_)\n    \
    \    val arr32 = arr31.sortBy(_)\n        val arr33 = arr32.sortBy(_)\n      \
    \  val arr34 = arr33.sortBy(_)\n        val arr35 = arr34.sortBy(_)\n        val\
    \ arr36 = arr35.sortBy(_)\n        val arr37 = arr36.sortBy(_)\n        val arr38\
    \ = arr37.sortBy(_)\n        val arr39 = arr38.sortBy(_)\n        val arr40 =\
    \ arr39.sortBy(_)\n        val arr41 = arr40.sortBy(_)\n        val arr42 = arr41.sortBy(_)\n\
    \        val arr43 = arr42.sortBy(_)\n        val arr44 = \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmppp45so1q.scala:71:19 ---------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m        \e[33mval\e[0m \e[36marr44\e[0m = \n\e[31m\e\
    [31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                   expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmppp45so1q.scala:27:18 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E081] Type Error:\
    \ /tmp/tmppp45so1q.scala:28:30 -----------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36marr1\e[0m = arr.sortBy(_)\n\e[31m\e[31m \
    \  |\e[0m                              ^\e[0m\n\e[31m   |\e[0m   Missing parameter\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).\n\e[31m\e\
    [31m-- [E081] Type Error: /tmp/tmppp45so1q.scala:30:31 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr3\e[0m = arr2.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m  \
    \ Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer\
    \ the type of the parameter _$2 of expanded function:\n\e[31m   |\e[0m   _$2 =>\
    \ arr2.sortBy(_$2).\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmppp45so1q.scala:32:31\
    \ -----------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e\
    [0m \e[36marr5\e[0m = arr4.sortBy(_)\n\e[31m\e[31m   |\e[0m                  \
    \             ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m   I could not infer the type of the parameter _$3 of expanded\
    \ function:\n\e[31m   |\e[0m   _$3 => arr4.sortBy(_$3).\n\e[31m\e[31m-- [E081]\
    \ Type Error: /tmp/tmppp45so1q.scala:34:31 -----------------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m        \e[33mval"
  stdout: ''
  timestamp: 1660009458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) true\n      \
    \  else {\n            val first = arr(0)\n            val last = arr(n)\n   \
    \         val mid = first + last\n            val mid1 = mid - 1\n           \
    \ val mid2 = mid + 1\n            val mid3 = mid - 2\n            val mid4 = mid\
    \ + 2\n            val mid5 = mid - 3\n            val mid6 = mid + 3\n      \
    \      val mid7 = mid - 4\n            val mid8 = mid + 4\n            val mid9\
    \ = mid - 5\n            val mid10 = mid + 5\n            val mid11 = mid - 6\n\
    \            val mid12 = mid + 6\n            val mid13 = mid - 7\n          \
    \  val mid14 = mid + 7\n            val mid15 = mid - 8\n            val mid16\
    \ = mid + 8\n            val mid17 = mid - 9\n            val mid18 = mid + 9\n\
    \            val mid19 = mid - 10\n            val mid20 = mid + 10\n        \
    \    val mid21 = mid - 11\n            val mid22 = mid + 11\n            val mid23\
    \ = mid - 12\n            val mid24 = mid + 12\n            val mid25 = mid -\
    \ 13\n            val mid26 = mid + 13\n            val mid27 = mid - 14\n   \
    \         val mid28 = mid + 14\n            val mid29 = mid - 15\n           \
    \ val mid30 = mid + 15\n            val mid31 = mid - 16\n            val mid32\
    \ = mid + 16\n            val mid33 = mid - 17\n            val mid34 = mid +\
    \ 17\n            val mid35 = mid - 18\n            val mid36 = mid + 18\n   \
    \         val mid37 = mid - 19\n            val mid38 = mid + 19\n           \
    \ val mid39 = mid - 20\n            val mid40 = mid + 20\n            val mid41\
    \ = mid - 21\n            val mid42 = mid + 21\n            val mid43 = mid -\
    \ 22\n            val mid44 = mid + 22\n            val mid45 = mid - 23\n   \
    \         val mid46 = mid + 23\n            val mid47 = mid - 24\n           \
    \ val mid48 = mid + 24\n            val mid49 = mid - 25\n            val mid50\
    \ = mid + 25\n            val mid51 = mid - 26\n            val mid52 = mid +\
    \ 26\n            val mid53 = mid - 27\n            val mid54 = mid + 27\n   \
    \         val mid55 = mid - 28\n            \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvq4ppo_j.scala:98:0 ----------------------------\e\
    [0m\e[0m\n\e[31m98 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvq4ppo_j.scala:97:1\
    \ ---------------------\e[0m\e[0m\n\e[31m97 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpvq4ppo_j.scala:89:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m89 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1660009457
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x => x)\n\
    \        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x =>\
    \ x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = arr.sortBy(x\
    \ => x)\n        val sorted = arr.sortBy(x => x)\n        val sorted = \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpyf8x5u2k.scala:73:20 ---------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = \n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpyf8x5u2k.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = arr.sortBy(\e[36mx\e[0m =>\
    \ x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpyf8x5u2k.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = arr.sortBy(\e[36mx\e[0m =>\
    \ x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpyf8x5u2k.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = arr.sortBy(\e[36mx\e[0m =>\
    \ x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpyf8x5u2k.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = arr.sortBy(\e[36mx\e[0m =>\
    \ x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in"
  stdout: ''
  timestamp: 1660009414
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val len = arr.length\n        val arr = arr.sortWith(_ < _)\n        val\
    \ len = arr.length\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n\
    \        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n       \
    \ val arr = arr.sortWith(_ < _)\n        val len = arr.length\n        val arr\
    \ = arr.sortWith(_ < _)\n        val len = arr.length\n        val arr = arr.sortWith(_\
    \ < _)\n        val len = arr.length\n        val arr = arr.sortWith(_ < _)\n\
    \        val len = arr.length\n        val arr = arr.sortWith(_ < _)\n       \
    \ val len = arr.length\n        val arr = arr.sortWith(_ < _)\n        val len\
    \ = arr.length\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n\
    \        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n       \
    \ val arr = arr.sortWith(_ < _)\n        val len = arr.length\n        val arr\
    \ = arr.sortWith(_ < _)\n        val len = arr.length\n        val arr = arr.sortWith(_\
    \ < _)\n        val len = arr.length\n        val arr = arr.sortWith(_ < _)\n\
    \        val len = arr.length\n        val arr = arr.sortWith(_ < _)\n       \
    \ val len = arr.length\n        val arr = arr.sortWith(_ < _)\n        val len\
    \ = arr.length\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n\
    \        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n       \
    \ val arr = arr.sortWith(_ < _)\n        val len = arr.length\n        val arr\
    \ = arr.sortWith(_ < _)\n        val len = arr.length\n        val arr = arr.sortWith(_\
    \ < _)\n        val len = arr.length\n        val arr = arr.sortWith(_ < _)\n\
    \        val len = arr.length\n        val arr = arr.sortWith(_ < _)\n       \
    \ val len = arr.length\n        val arr = arr.sortWith(_ < _)\n        val len\
    \ = arr.length\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n\
    \        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n       \
    \ val arr = arr.sortWith(_ < _)\n        val len = arr.length\n        val arr\
    \ = arr.sortWith(_ < _)\n        val len = arr.length\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbbddzvha.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbbddzvha.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlen\e[0m = arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlen is already defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpbbddzvha.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_ < _)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbbddzvha.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlen\e[0m = arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlen is already defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpbbddzvha.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_ < _)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161]"
  stdout: ''
  timestamp: 1660009457
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toSet\n        val len = arr.length\n        val arr =\
    \ arr.toMap\n        val len = arr.length\n        val arr = arr.toSeq\n     \
    \   val len = arr.length\n        val arr = arr.toStream\n        val len = arr.length\n\
    \        val arr = arr.toIterator\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toSet\n        val len =\
    \ arr.length\n        val arr = arr.toMap\n        val len = arr.length\n    \
    \    val arr = arr.toSeq\n        val len = arr.length\n        val arr = arr.toStream\n\
    \        val len = arr.length\n        val arr = arr.toIterator\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toSet\n        val len = arr.length\n        val arr = arr.toMap\n     \
    \   val len = arr.length\n        val arr = arr.toSeq\n        val len = arr.length\n\
    \        val arr = arr.toStream\n        val len = arr.length\n        val arr\
    \ = arr.toIterator\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toSet\n        val len = arr.length\n    \
    \    val arr = arr.toMap\n        val len = arr.length\n        val arr = arr.toSeq\n\
    \        val len = arr.length\n        val arr = arr.toStream\n        val len\
    \ = arr.length\n        val arr = arr.toIterator\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toList\n        val len = arr.length\n        val arr = arr.toSet\n  \
    \      val len = arr.length\n        val arr = arr.toMap\n        val len = arr.length\n\
    \        val arr = arr.toSeq\n        val len = arr.length\n        val arr =\
    \ arr.toStream\n        val len = arr.length\n        val arr = arr.toIterator\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toList\n        val len = arr.length\n \
    \       val arr = arr.toSet\n        val len = arr.length\n        val arr = arr.toMap\n\
    \        val len = arr.length\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe9bxl6uy.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe9bxl6uy.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe9bxl6uy.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toSet\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe9bxl6uy.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe9bxl6uy.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toMap\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe9bxl6uy.scala:34:12 --------------"
  stdout: ''
  timestamp: 1660009458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val result = new Array[Boolean](n)\n        val left = 0\n        val right\
    \ = 0\n        val mid = 0\n        val leftMax = arr.length - 1\n        val\
    \ rightMax = arr.length - 1\n        val midMax = arr.length - 1\n        val\
    \ leftMin = 0\n        val rightMin = 0\n        val midMin = 0\n        val leftMaxIndex\
    \ = 0\n        val rightMaxIndex = 0\n        val midMaxIndex = 0\n        val\
    \ leftMinIndex = 0\n        val rightMinIndex = 0\n        val midMinIndex = 0\n\
    \        val leftMaxVal = arr(leftMaxIndex)\n        val rightMaxVal = arr(rightMaxIndex)\n\
    \        val midMaxVal = arr(midMaxIndex)\n        val leftMinVal = arr(leftMinIndex)\n\
    \        val rightMinVal = arr(rightMinIndex)\n        val midMinVal = arr(midMinIndex)\n\
    \        val leftMaxIndex = leftMaxIndex + 1\n        val rightMaxIndex = rightMaxIndex\
    \ + 1\n        val midMaxIndex = midMaxIndex + 1\n        val leftMinIndex = leftMinIndex\
    \ + 1\n        val rightMinIndex = rightMinIndex + 1\n        val midMinIndex\
    \ = midMinIndex + 1\n        val leftMaxVal = leftMaxVal * 2\n        val rightMaxVal\
    \ = rightMaxVal * 2\n        val midMaxVal = midMaxVal * 2\n        val leftMinVal\
    \ = leftMinVal * 2\n        val rightMinVal = rightMinVal * 2\n        val midMinVal\
    \ = midMinVal * 2\n        val leftMaxIndex = leftMaxIndex + 1\n        val rightMaxIndex\
    \ = rightMaxIndex + 1\n        val midMaxIndex = midMaxIndex + 1\n        val\
    \ leftMinIndex = leftMinIndex + 1\n        val rightMinIndex = rightMinIndex +\
    \ 1\n        val midMinIndex = midMinIndex + 1\n        val leftMaxVal = leftMaxVal\
    \ * 3\n        val rightMaxVal = rightMaxVal * 3\n        val midMaxVal = midMaxVal\
    \ * 3\n        val leftMinVal = leftMinVal * 3\n        val rightMinVal = rightMinVal\
    \ * 3\n        val midMinVal = midMinVal * 3\n        val leftMaxIndex = leftMaxIndex\
    \ + 1\n        val rightMaxIndex = rightMaxIndex + 1\n        val midMaxIndex\
    \ = midMaxIndex + 1\n        val leftMinIndex = leftMinIndex + 1\n        val\
    \ rightMinIndex = rightMinIndex + 1\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnkrm1h3_.scala:50:12 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mleftMaxIndex\e[0m = leftMaxIndex\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftMaxIndex is already defined as \e[33mvalue\e[0m \e[35mleftMaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnkrm1h3_.scala:51:12 ---------------------------\e[0m\e[0m\n\e\
    [31m51 |\e[0m        \e[33mval\e[0m \e[36mrightMaxIndex\e[0m = rightMaxIndex +\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightMaxIndex is already defined as \e[33mvalue\e[0m \e[35mrightMaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnkrm1h3_.scala:52:12 ---------------------------\e[0m\e[0m\n\e\
    [31m52 |\e[0m        \e[33mval\e[0m \e[36mmidMaxIndex\e[0m = midMaxIndex + \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmidMaxIndex is already defined as \e[33mvalue\e[0m \e[35mmidMaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnkrm1h3_.scala:53:12 ---------------------------\e[0m\e[0m\n\e\
    [31m53 |\e[0m        \e[33mval\e[0m \e[36mleftMinIndex\e[0m = leftMinIndex + \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftMinIndex is already defined as \e[33mvalue\e[0m \e[35mleftMinIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnkrm1h3_.scala:54:12 ---------------------------\e[0m\e[0m\n\e\
    [31m54 |\e[0m        \e[33mval\e[0m \e[36mrightMinIndex\e[0m = rightMinIndex +\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009459
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val arr = arr.toSet.toList\n        val len = arr.size\n\
    \        val arr2 = arr.toList\n        val len = arr.size\n        val arr3 =\
    \ arr.toList\n        val len = arr.size\n        val arr4 = arr.toList\n    \
    \    val len = arr.size\n        val arr5 = arr.toList\n        val len = arr.size\n\
    \        val arr6 = arr.toList\n        val len = arr.size\n        val arr7 =\
    \ arr.toList\n        val len = arr.size\n        val arr8 = arr.toList\n    \
    \    val len = arr.size\n        val arr9 = arr.toList\n        val len = arr.size\n\
    \        val arr10 = arr.toList\n        val len = arr.size\n        val arr11\
    \ = arr.toList\n        val len = arr.size\n        val arr12 = arr.toList\n \
    \       val len = arr.size\n        val arr13 = arr.toList\n        val len =\
    \ arr.size\n        val arr14 = arr.toList\n        val len = arr.size\n     \
    \   val arr15 = arr.toList\n        val len = arr.size\n        val arr16 = arr.toList\n\
    \        val len = arr.size\n        val arr17 = arr.toList\n        val len =\
    \ arr.size\n        val arr18 = arr.toList\n        val len = arr.size\n     \
    \   val arr19 = arr.toList\n        val len = arr.size\n        val arr20 = arr.toList\n\
    \        val len = arr.size\n        val arr21 = arr.toList\n        val len =\
    \ arr.size\n        val arr22 = arr.toList\n        val len = arr.size\n     \
    \   val arr23 = arr.toList\n        val len = arr.size\n        val arr24 = arr.toList\n\
    \        val len = arr.size\n        val arr25 = arr.toList\n        val len =\
    \ arr.size\n        val arr26 = arr.toList\n        val len = arr.size\n     \
    \   val arr27 = arr.toList\n        val len = arr.size\n        val arr28 = arr.toList\n\
    \        val len = arr.size\n        val arr29 = arr.toList\n        val len =\
    \ arr.size\n        val arr30 = arr.toList\n        val len = arr.size\n     \
    \   val arr31 = arr.toList\n        val len = arr.size\n        val arr32 = arr.toList\n\
    \        val len = arr.size\n        val arr33 = arr.toList\n        val len =\
    \ arr.size\n        val arr34 = arr.toList\n        val len = arr.size\n     \
    \   val arr35 = arr.toList\n        val len = arr.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph8018lgp.scala:96:4 ----------------------------\e\
    [0m\e[0m\n\e[31m96 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmph8018lgp.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.size\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already defined as \e\
    [33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmph8018lgp.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.size\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmph8018lgp.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.size\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmph8018lgp.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.size\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmph8018lgp.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.size\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e"
  stdout: ''
  timestamp: 1660009459
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:33:12 ---------------------------\e\
    [0m\e[0"
  stdout: ''
  timestamp: 1660009388
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n        else\
    \ if (n == 1) true\n        else if (n % 2 == 0) moveOneBall(arr.tail) \n    \
    \    else moveOneBall(arr.tail ++ arr.takeRight(n/2))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660009465
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n        else\
    \ {\n            val m = arr.head\n            val r = arr.tail\n            val\
    \ m = m.toLong\n            val r = r.tail\n            val r = r.head\n     \
    \       val r = r.toLong\n            val r = r.toLong\n            val r = r.toLong\n\
    \            val r = r.toLong\n            val r = r.toLong\n            val r\
    \ = r.toLong\n            val r = r.toLong\n            val r = r.toLong\n   \
    \         val r = r.toLong\n            val r = r.toLong\n            val r =\
    \ r.toLong\n            val r = r.toLong\n            val r = r.toLong\n     \
    \       val r = r.toLong\n            val r = r.toLong\n            val r = r.toLong\n\
    \            val r = r.toLong\n            val r = r.toLong\n            val r\
    \ = r.toLong\n            val r = r.toLong\n            val r = r.toLong\n   \
    \         val r = r.toLong\n            val r = r.toLong\n            val r =\
    \ r.toLong\n            val r = r.toLong\n            val r = r.toLong\n     \
    \       val r = r.toLong\n            val r = r.toLong\n            val r = r.toLong\n\
    \            val r = r.toLong\n            val r = r.toLong\n            val r\
    \ = r.toLong\n            val r = r.toLong\n            val r = r.toLong\n   \
    \         val r = r.toLong\n            val r = r.toLong\n            val r =\
    \ r.toLong\n            val r = r.toLong\n            val r = r.toLong\n     \
    \       val r = r.toLong\n            val r = r.toLong\n            val r = r.toLong\n\
    \            val r = r.toLong\n            val r = r.toLong\n            val r\
    \ = r.toLong\n            val r = r.toLong\n            val r = r.toLong\n   \
    \         val r = r.toLong\n            val r = r.toLong\n            val r =\
    \ r.toLong\n            val r = r.toLong\n            val r = r.toLong\n     \
    \       val r = r.toLong\n            val r = r.toLong\n            val r = r.toLong\n\
    \            val r = r.toLong\n            val r = r.toLong\n            val r\
    \ = r.toLong\n            val r = r.toLong\n            val r = r.toLong\n   \
    \         val r = r.toLong\n            val r = r.toLong\n            val r =\
    \ r.toLong\n            val r = r.toLong\n            val r = r.toLong\n     \
    \       val r = r.toLong\n            val r = r.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpt9hfgiiq.scala:111:0 ---------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt9hfgiiq.scala:31:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e\
    [0m \e[36mm\e[0m = m.toLong\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpt9hfgiiq.scala:32:16 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = r.tail\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e\
    [0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpt9hfgiiq.scala:33:16 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = r.head\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt9hfgiiq.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = r.toLong\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt9hfgiiq.scala:35:16 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = r.toLong\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that o"
  stdout: ''
  timestamp: 1660009461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ l = arr.last\n        val r = arr.init\n        val arr1 = arr.toArray\n   \
    \     val arr2 = arr1.clone\n        val arr3 = arr2.clone\n        val arr4 =\
    \ arr3.clone\n        val arr5 = arr4.clone\n        val arr6 = arr5.clone\n \
    \       val arr7 = arr6.clone\n        val arr8 = arr7.clone\n        val arr9\
    \ = arr8.clone\n        val arr10 = arr9.clone\n        val arr11 = arr10.clone\n\
    \        val arr12 = arr11.clone\n        val arr13 = arr12.clone\n        val\
    \ arr14 = arr13.clone\n        val arr15 = arr14.clone\n        val arr16 = arr15.clone\n\
    \        val arr17 = arr16.clone\n        val arr18 = arr17.clone\n        val\
    \ arr19 = arr18.clone\n        val arr20 = arr19.clone\n        val arr21 = arr20.clone\n\
    \        val arr22 = arr21.clone\n        val arr23 = arr22.clone\n        val\
    \ arr24 = arr23.clone\n        val arr25 = arr24.clone\n        val arr26 = arr25.clone\n\
    \        val arr27 = arr26.clone\n        val arr28 = arr27.clone\n        val\
    \ arr29 = arr28.clone\n        val arr30 = arr29.clone\n        val arr31 = arr30.clone\n\
    \        val arr32 = arr31.clone\n        val arr33 = arr32.clone\n        val\
    \ arr34 = arr33.clone\n        val arr35 = arr34.clone\n        val arr36 = arr35.clone\n\
    \        val arr37 = arr36.clone\n        val arr38 = arr37.clone\n        val\
    \ arr39 = arr38.clone\n        val arr40 = arr39.clone\n        val arr41 = arr40.clone\n\
    \        val arr42 = arr41.clone\n        val arr43 = arr42.clone\n        val\
    \ arr44 = arr43.clone\n        val arr45 = arr44.clone\n        val arr46 = arr45.clone\n\
    \        val arr47 = arr46.clone\n        val arr48 = arr47.clone\n        val\
    \ arr49 = arr48.clone\n        val arr50 = arr49.clone\n        val arr51 = arr50.clone\n\
    \        val arr52 = arr51.clone\n        val arr53 = arr52.clone\n        val\
    \ arr54 = arr53.clone\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp43do2os9.scala:84:11 ---------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp43do2os9.scala:85:5 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_qfq4elf.scala:82:4 ----------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_qfq4elf.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_qfq4elf.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(arr.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_qfq4elf.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.take(arr.length-\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_qfq4elf.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_qfq4elf.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\
    \e[31m\e[31m"
  stdout: ''
  timestamp: 1660009461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val len = arr.length\n        val max = (len - 1).toLong\n        val min\
    \ = 0l\n        var i = 0\n        var j = 0\n        var k = 0\n        var temp\
    \ = 0\n        var flag = false\n        var tempArr: List[Long] = Nil\n     \
    \   var tempArr2 = List[Long]()\n        var tempArr3 = List[Long]()\n       \
    \ var tempArr4 = List[Long]()\n        var tempArr5 = List[Long]()\n        var\
    \ tempArr6 = List[Long]()\n        var tempArr7 = List[Long]()\n        var tempArr8\
    \ = List[Long]()\n        var tempArr9 = List[Long]()\n        var tempArr10 =\
    \ List[Long]()\n        var tempArr11 = List[Long]()\n        var tempArr12 =\
    \ List[Long]()\n        var tempArr13 = List[Long]()\n        var tempArr14 =\
    \ List[Long]()\n        var tempArr15 = List[Long]()\n        var tempArr16 =\
    \ List[Long]()\n        var tempArr17 = List[Long]()\n        var tempArr18 =\
    \ List[Long]()\n        var tempArr19 = List[Long]()\n        var tempArr20 =\
    \ List[Long]()\n        var tempArr21 = List[Long]()\n        var tempArr22 =\
    \ List[Long]()\n        var tempArr23 = List[Long]()\n        var tempArr24 =\
    \ List[Long]()\n        var tempArr25 = List[Long]()\n        var tempArr26 =\
    \ List[Long]()\n        var tempArr27 = List[Long]()\n        var tempArr28 =\
    \ List[Long]()\n        var tempArr29 = List[Long]()\n        var tempArr30 =\
    \ List[Long]()\n        var tempArr31 = List[Long]()\n        var tempArr32 =\
    \ List[Long]()\n        var tempArr33 = List[Long]()\n        var tempArr34 =\
    \ List[Long]()\n        var tempArr35 = List[Long]()\n        var tempArr36 =\
    \ List[Long]()\n        var tempArr37 = List[Long]()\n        var tempArr38 =\
    \ List[Long]()\n        var tempArr39 = List[Long]()\n        var tempArr40 =\
    \ List[Long]()\n        var tempArr41 = List[Long]()\n        var tempArr42 =\
    \ List[Long]()\n        var tempArr43 = List[Long]()\n        var tempArr44 =\
    \ List[Long]()\n        var tempArr45 = List[Long]()\n        var tempArr46 =\
    \ List[Long]()\n        var tempArr47 = List[Long]()\n        var \n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpnsxhdhvq.scala:83:11 ---------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnsxhdhvq.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpnsxhdhvq.scala:84:5 ---------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val sorted = arr.sortBy(x => x)\n        val arr2 = arr.toList\n      \
    \  val sorted2 = arr2.sortBy(x => x)\n        val arr3 = arr.toList\n        val\
    \ sorted3 = arr3.sortBy(x => x)\n        val arr4 = arr.toList\n        val sorted4\
    \ = arr4.sortBy(x => x)\n        val arr5 = arr.toList\n        val sorted5 =\
    \ arr5.sortBy(x => x)\n        val arr6 = arr.toList\n        val sorted6 = arr6.sortBy(x\
    \ => x)\n        val arr7 = arr.toList\n        val sorted7 = arr7.sortBy(x =>\
    \ x)\n        val arr8 = arr.toList\n        val sorted8 = arr8.sortBy(x => x)\n\
    \        val arr9 = arr.toList\n        val sorted9 = arr9.sortBy(x => x)\n  \
    \      val arr10 = arr.toList\n        val sorted10 = arr10.sortBy(x => x)\n \
    \       val arr11 = arr.toList\n        val sorted11 = arr11.sortBy(x => x)\n\
    \        val arr12 = arr.toList\n        val sorted12 = arr12.sortBy(x => x)\n\
    \        val arr13 = arr.toList\n        val sorted13 = arr13.sortBy(x => x)\n\
    \        val arr14 = arr.toList\n        val sorted14 = arr14.sortBy(x => x)\n\
    \        val arr15 = arr.toList\n        val sorted15 = arr15.sortBy(x => x)\n\
    \        val arr16 = arr.toList\n        val sorted16 = arr16.sortBy(x => x)\n\
    \        val arr17 = arr.toList\n        val sorted17 = arr17.sortBy(x => x)\n\
    \        val arr18 = arr.toList\n        val sorted18 = arr18.sortBy(x => x)\n\
    \        val arr19 = arr.toList\n        val sorted19 = arr19.sortBy(x => x)\n\
    \        val arr20 = arr.toList\n        val sorted20 = arr20.sortBy(x => x)\n\
    \        val arr21 = arr.toList\n        val sorted21 = arr21.sortBy(x => x)\n\
    \        val arr22 = arr.toList\n        val sorted22 = arr22.sortBy(x => x)\n\
    \        val arr23 = arr.toList\n        val sorted23 = arr23.sortBy(x => x)\n\
    \        val arr24 = arr.toList\n        val sorted24 = arr24.sortBy(x => x)\n\
    \        val arr25\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp44s_44mz.scala:76:4 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp44s_44mz.scala:27:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp44s_44mz.scala:76:5\
    \ ---------------------\e[0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009460
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val arr = arr.toList\n        val n = arr.length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already\
    \ defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmposgy5h1u.scala:33:12 ---------------------------\e\
    [0m\e[0"
  stdout: ''
  timestamp: 1660009388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n        else\
    \ {\n            val m = arr.head\n            val r = arr.tail\n            val\
    \ rr = r.tail\n            val rr = rr.tail\n            val rr = rr.tail\n  \
    \          val rr = rr.tail\n            val rr = rr.tail\n            val rr\
    \ = rr.tail\n            val rr = rr.tail\n            val rr = rr.tail\n    \
    \        val rr = rr.tail\n            val rr = rr.tail\n            val rr =\
    \ rr.tail\n            val rr = rr.tail\n            val rr = rr.tail\n      \
    \      val rr = rr.tail\n            val rr = rr.tail\n            val rr = rr.tail\n\
    \            val rr = rr.tail\n            val rr = rr.tail\n            val rr\
    \ = rr.tail\n            val rr = rr.tail\n            val rr = rr.tail\n    \
    \        val rr = rr.tail\n            val rr = rr.tail\n            val rr =\
    \ rr.tail\n            val rr = rr.tail\n            val rr = rr.tail\n      \
    \      val rr = rr.tail\n            val rr = rr.tail\n            val rr = rr.tail\n\
    \            val rr = rr.tail\n            val rr = rr.tail\n            val rr\
    \ = rr.tail\n            val rr = rr.tail\n            val rr = rr.tail\n    \
    \        val rr = rr.tail\n            val rr = rr.tail\n            val rr =\
    \ rr.tail\n            val rr = rr.tail\n            val rr = rr.tail\n      \
    \      val rr = rr.tail\n            val rr = rr.tail\n            val rr = rr.tail\n\
    \            val rr = rr.tail\n            val rr = rr.tail\n            val rr\
    \ = rr.tail\n            val rr = rr.tail\n            val rr = rr.tail\n    \
    \        val rr = rr.tail\n            val rr = rr.tail\n            val rr =\
    \ rr.tail\n            val rr = rr.tail\n            val rr = rr.tail\n      \
    \      val rr = rr.tail\n            val rr = rr.tail\n            val rr = rr.tail\n\
    \            val rr = rr.tail\n            val rr = rr.tail\n            val rr\
    \ = rr.tail\n            val rr = rr.tail\n            val rr = rr.tail\n    \
    \        val rr = rr.tail\n\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpz2wwcpcf.scala:103:0 ---------------------------\e\
    [0m\e[0m\n\e[31m103 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz2wwcpcf.scala:32:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mrr\e[0m = rr.tail\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrr is already defined as \e[33mvalue\e[0m \e[35mrr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpz2wwcpcf.scala:33:16 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m            \e[33mval\e[0m \e[36mrr\e[0m = rr.tail\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrr is already defined as\
    \ \e[33mvalue\e[0m \e[35mrr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpz2wwcpcf.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mrr\e[0m = rr.tail\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrr is already\
    \ defined as \e[33mvalue\e[0m \e[35mrr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz2wwcpcf.scala:35:16 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36mrr\e[0m = rr.tail\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrr is already\
    \ defined as \e[33mvalue\e[0m \e[35mrr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz2wwcpcf.scala:36:16 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36mrr\e[0m = rr.tail\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrr is already\
    \ defined as \e[33mvalue\e[0m \e[35mrr\e[0m\n\e[31m   |\e[0m\n\e[31m "
  stdout: ''
  timestamp: 1660009462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n-1)\n       \
    \ val arr = arr.take(n-1)\n        val arr = arr.sortBy(x => x)\n        val arr\
    \ = arr.drop(n-1)\n        val arr = arr.take(n-1)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n-1)\n       \
    \ val arr = arr.take(n-1)\n        val arr = arr.sortBy(x => x)\n        val arr\
    \ = arr.drop(n-1)\n        val arr = arr.take(n-1)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n-1)\n       \
    \ val arr = arr.take(n-1)\n        val arr = arr.sortBy(x => x)\n        val arr\
    \ = arr.drop(n-1)\n        val arr = arr.take(n-1)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n-1)\n       \
    \ val arr = arr.take(n-1)\n        val arr = arr.sortBy(x => x)\n        val arr\
    \ = arr.drop(n-1)\n        val arr = arr.take(n-1)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n-1)\n       \
    \ val arr = arr.take(n-1)\n        val arr = arr.sortBy(x => x)\n        val arr\
    \ = arr.drop(n-1)\n        val arr = arr.take(n-1)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n-1)\n       \
    \ val arr = arr.take(n-1)\n        val arr = arr.sortBy(x => x)\n        val arr\
    \ = arr.drop(n-1)\n        val arr = arr.take(n-1)\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(n-1)\n        val arr = arr.take(n-1)\n  \
    \      val arr = arr.sortBy(x => x)\n        val arr = arr.drop(n-1)\n       \
    \ val arr = arr.take(n-1)\n        val arr = arr.sort\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj1aaougs.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpj1aaougs.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(n-\e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj1aaougs.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.take(n-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj1aaougs.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpj1aaougs.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(n-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of"
  stdout: ''
  timestamp: 1660009421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n    \
    \    val arr1 = arr.toArray\n        val arr2 = arr.toBuffer\n        val arr3\
    \ = arr.toSeq\n        val arr4 = arr.toSet\n        val arr5 = arr.toMap\n  \
    \      val arr6 = arr.toSeq\n        val arr7 = arr.toSet\n        val arr8 =\
    \ arr.toMap\n        val arr9 = arr.toSeq\n        val arr10 = arr.toSet\n   \
    \     val arr11 = arr.toMap\n        val arr12 = arr.toSeq\n        val arr13\
    \ = arr.toSet\n        val arr14 = arr.toMap\n        val arr15 = arr.toSeq\n\
    \        val arr16 = arr.toSet\n        val arr17 = arr.toMap\n        val arr18\
    \ = arr.toSeq\n        val arr19 = arr.toSet\n        val arr20 = arr.toMap\n\
    \        val arr21 = arr.toSeq\n        val arr22 = arr.toSet\n        val arr23\
    \ = arr.toMap\n        val arr24 = arr.toSeq\n        val arr25 = arr.toSet\n\
    \        val arr26 = arr.toMap\n        val arr27 = arr.toSeq\n        val arr28\
    \ = arr.toSet\n        val arr29 = arr.toMap\n        val arr30 = arr.toSeq\n\
    \        val arr31 = arr.toSet\n        val arr32 = arr.toMap\n        val arr33\
    \ = arr.toSeq\n        val arr34 = arr.toSet\n        val arr35 = arr.toMap\n\
    \        val arr36 = arr.toSeq\n        val arr37 = arr.toSet\n        val arr38\
    \ = arr.toMap\n        val arr39 = arr.toSeq\n        val arr40 = arr.toSet\n\
    \        val arr41 = arr.toMap\n        val arr42 = arr.toSeq\n        val arr43\
    \ = arr.toSet\n        val arr44 = arr.toMap\n        val arr45 = arr.toSeq\n\
    \        val arr46 = arr.toSet\n        val arr47 = arr.toMap\n        val arr48\
    \ = arr.toSeq\n        val arr49 = arr.toSet\n        val arr50 = arr.toMap\n\
    \        val arr51 = arr.toSeq\n        val arr52 = arr.toSet\n        val arr53\
    \ = arr.toMap\n        val arr54 = arr.toSeq\n        val arr55 = arr.toSet\n\
    \        val arr56 = arr.toMap\n        val arr57 = arr.to\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsky44xwy.scala:27:18 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpsky44xwy.scala:85:5 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val arr2 = arr.toList\n        val arr3 = arr2.reverse\n\
    \        val arr4 = arr3.toList\n        val arr5 = arr4.toList\n        val arr6\
    \ = arr5.toList\n        val arr7 = arr6.toList\n        val arr8 = arr7.reverse\n\
    \        val arr9 = arr8.toList\n        val arr10 = arr9.toList\n        val\
    \ arr11 = arr10.reverse\n        val arr12 = arr11.toList\n        val arr13 =\
    \ arr12.toList\n        val arr14 = arr13.reverse\n        val arr15 = arr14.toList\n\
    \        val arr16 = arr15.toList\n        val arr17 = arr16.reverse\n       \
    \ val arr18 = arr17.toList\n        val arr19 = arr18.toList\n        val arr20\
    \ = arr19.toList\n        val arr21 = arr20.reverse\n        val arr22 = arr21.toList\n\
    \        val arr23 = arr22.toList\n        val arr24 = arr23.reverse\n       \
    \ val arr25 = arr24.toList\n        val arr26 = arr25.toList\n        val arr27\
    \ = arr26.reverse\n        val arr28 = arr27.toList\n        val arr29 = arr28.toList\n\
    \        val arr30 = arr29.reverse\n        val arr31 = arr30.toList\n       \
    \ val arr32 = arr31.toList\n        val arr33 = arr32.reverse\n        val arr34\
    \ = arr33.toList\n        val arr35 = arr34.toList\n        val arr36 = arr35.reverse\n\
    \        val arr37 = arr36.toList\n        val arr38 = arr37.toList\n        val\
    \ arr39 = arr38.reverse\n        val arr40 = arr39.toList\n        val arr41 =\
    \ arr40.reverse\n        val arr42 = arr41.toList\n        val arr43 = arr42.toList\n\
    \        val arr44 = arr43.reverse\n        val arr45 = arr44.toList\n       \
    \ val arr46 = arr45.reverse\n        val arr47 = arr46.toList\n        val arr48\
    \ = arr47.toList\n        val arr49 = arr48.reverse\n        val arr50 = arr49.toList\n\
    \        val arr51 = arr50.reverse\n        val arr52 = arr51.toList\n       \
    \ val arr53 = arr52.\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwms6_51l.scala:81:4 ----------------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpwms6_51l.scala:28:18 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m\
    \                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpwms6_51l.scala:81:5 ---------------------\e[0m\e[0m\n\e[31m81\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val n = arr.length\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpk0x489a0.scala:99:17 ---------------------------\e\
    [0m\e[0m\n\e[31m99 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = \n\e[31m\e[31m\
    \   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpk0x489a0.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined as \e[33mvalue\e\
    [0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpk0x489a0.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk0x489a0.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk0x489a0.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk0x489a0.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33m"
  stdout: ''
  timestamp: 1660009462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n  \
    \      val arr1 = arr.toArray\n        val arr2 = arr1.slice(1, n).reverse\n \
    \       val arr3 = arr2.slice(1, n).reverse\n        val arr4 = arr3.slice(1,\
    \ n).reverse\n        val arr5 = arr4.slice(1, n).reverse\n        val arr6 =\
    \ arr5.slice(1, n).reverse\n        val arr7 = arr6.slice(1, n).reverse\n    \
    \    val arr8 = arr7.slice(1, n).reverse\n        val arr9 = arr8.slice(1, n).reverse\n\
    \        val arr10 = arr9.slice(1, n).reverse\n        val arr11 = arr10.slice(1,\
    \ n).reverse\n        val arr12 = arr11.slice(1, n).reverse\n        val arr13\
    \ = arr12.slice(1, n).reverse\n        val arr14 = arr13.slice(1, n).reverse\n\
    \        val arr15 = arr14.slice(1, n).reverse\n        val arr16 = arr15.slice(1,\
    \ n).reverse\n        val arr17 = arr16.slice(1, n).reverse\n        val arr18\
    \ = arr17.slice(1, n).reverse\n        val arr19 = arr18.slice(1, n).reverse\n\
    \        val arr20 = arr19.slice(1, n).reverse\n        val arr21 = arr20.slice(1,\
    \ n).reverse\n        val arr22 = arr21.slice(1, n).reverse\n        val arr23\
    \ = arr22.slice(1, n).reverse\n        val arr24 = arr23.slice(1, n).reverse\n\
    \        val arr25 = arr24.slice(1, n).reverse\n        val arr26 = arr25.slice(1,\
    \ n).reverse\n        val arr27 = arr26.slice(1, n).reverse\n        val arr28\
    \ = arr27.slice(1, n).reverse\n        val arr29 = arr28.slice(1, n).reverse\n\
    \        val arr30 = arr29.slice(1, n).reverse\n        val arr31 = arr30.slice(1,\
    \ n).reverse\n        val arr32 = arr31.slice(1, n).reverse\n        val arr33\
    \ = arr32.slice(1, n).reverse\n        val arr34 = arr33.slice(1, n).reverse\n\
    \        val arr35 = arr34.slice(1, n).reverse\n        val arr36 = arr35.slice(1,\
    \ n).reverse\n        val arr37 = arr36.slice(1, n).reverse\n        val arr38\
    \ = arr37.slice(1, n).reverse\n        val arr39 = arr38.slice(1, n).reverse\n\
    \        val arr40 = arr39.\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpy82ap1ij.scala:68:4 ----------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpy82ap1ij.scala:27:18 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpy82ap1ij.scala:68:5 ---------------------\e[0m\e[0m\n\e[31m68\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.size\n        val m = arr.last\n        val\
    \ arr = arr.toArray\n        val arr1 = arr.slice(1, n-1)\n        val arr2 =\
    \ arr.slice(0, n-1)\n        val arr3 = arr.slice(1, n-1)\n        val arr4 =\
    \ arr.slice(0, n-1)\n        val arr5 = arr.slice(1, n-1)\n        val arr6 =\
    \ arr.slice(0, n-1)\n        val arr7 = arr.slice(1, n-1)\n        val arr8 =\
    \ arr.slice(0, n-1)\n        val arr9 = arr.slice(1, n-1)\n        val arr10 =\
    \ arr.slice(0, n-1)\n        val arr11 = arr.slice(1, n-1)\n        val arr12\
    \ = arr.slice(0, n-1)\n        val arr13 = arr.slice(1, n-1)\n        val arr14\
    \ = arr.slice(0, n-1)\n        val arr15 = arr.slice(1, n-1)\n        val arr16\
    \ = arr.slice(0, n-1)\n        val arr17 = arr.slice(1, n-1)\n        val arr18\
    \ = arr.slice(0, n-1)\n        val arr19 = arr.slice(1, n-1)\n        val arr20\
    \ = arr.slice(0, n-1)\n        val arr21 = arr.slice(1, n-1)\n        val arr22\
    \ = arr.slice(0, n-1)\n        val arr23 = arr.slice(1, n-1)\n        val arr24\
    \ = arr.slice(0, n-1)\n        val arr25 = arr.slice(1, n-1)\n        val arr26\
    \ = arr.slice(0, n-1)\n        val arr27 = arr.slice(1, n-1)\n        val arr28\
    \ = arr.slice(0, n-1)\n        val arr29 = arr.slice(1, n-1)\n        val arr30\
    \ = arr.slice(0, n-1)\n        val arr31 = arr.slice(1, n-1)\n        val arr32\
    \ = arr.slice(0, n-1)\n        val arr33 = arr.slice(1, n-1)\n        val arr34\
    \ = arr.slice(0, n-1)\n        val arr35 = arr.slice(1, n-1)\n        val arr36\
    \ = arr.slice(0, n-1)\n        val arr37 = arr.slice(1, n-1)\n        val arr38\
    \ = arr.slice(0, n-1)\n        val arr39 = arr.slice(1, n-1)\n        val arr40\
    \ = arr.slice(0, n-1)\n        val arr41 = arr.slice(1, n-1)\n        val arr42\
    \ = arr.slice(0, n-1)\n        val arr43 = arr.slice(1, n-1)\n        val arr44\
    \ = arr.slice(0, n-1)\n        val arr45 = arr.slice(1, n-1)\n        val arr46\
    \ = arr.slice(0, n-1)\n        val arr47 = arr.slice(1, n-1)\n        val arr48\
    \ = arr.slice(0, n-1)\n        \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3t_869_l.scala:28:18 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3t_869_l.scala:78:5 ---------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val m = arr.head\n      \
    \  val arr = arr.tail\n        val arr2 = arr.toList\n        val arr3 = arr2.reverse\n\
    \        val arr4 = arr3.toList\n        val arr5 = arr4.reverse\n        val\
    \ arr6 = arr5.reverse\n        val arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n\
    \        val arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n        val\
    \ arr11 = arr10.reverse\n        val arr12 = arr11.reverse\n        val arr13\
    \ = arr12.reverse\n        val arr14 = arr13.reverse\n        val arr15 = arr14.reverse\n\
    \        val arr16 = arr15.reverse\n        val arr17 = arr16.reverse\n      \
    \  val arr18 = arr17.reverse\n        val arr19 = arr18.reverse\n        val arr20\
    \ = arr19.reverse\n        val arr21 = arr20.reverse\n        val arr22 = arr21.reverse\n\
    \        val arr23 = arr22.reverse\n        val arr24 = arr23.reverse\n      \
    \  val arr25 = arr24.reverse\n        val arr26 = arr25.reverse\n        val arr27\
    \ = arr26.reverse\n        val arr28 = arr27.reverse\n        val arr29 = arr28.reverse\n\
    \        val arr30 = arr29.reverse\n        val arr31 = arr30.reverse\n      \
    \  val arr32 = arr31.reverse\n        val arr33 = arr32.reverse\n        val arr34\
    \ = arr33.reverse\n        val arr35 = arr34.reverse\n        val arr36 = arr35.reverse\n\
    \        val arr37 = arr36.reverse\n        val arr38 = arr37.reverse\n      \
    \  val arr39 = arr38.reverse\n        val arr40 = arr39.reverse\n        val arr41\
    \ = arr40.reverse\n        val arr42 = arr41.reverse\n        val arr43 = arr42.reverse\n\
    \        val arr44 = arr43.reverse\n        val arr45 = arr44.reverse\n      \
    \  val arr46 = arr45.reverse\n        val arr47 = arr46.reverse\n        val arr48\
    \ = arr47.reverse\n        val arr49 = arr48.reverse\n        val arr50 = arr49.reverse\n\
    \        val arr51 = arr50.reverse\n        val arr52 = arr51.reverse\n      \
    \  val arr53 = arr52.reverse\n        val arr54 = arr53.reverse\n        val arr55\
    \ = arr54.reverse\n        val arr56 = arr55.reverse\n        val \n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpu31c7u77.scala:84:11 ---------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpu31c7u77.scala:28:18 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpu31c7u77.scala:85:5 ---------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798343
