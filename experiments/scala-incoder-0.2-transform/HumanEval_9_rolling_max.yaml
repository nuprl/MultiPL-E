name: HumanEval_9_rolling_max
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers\
  \ : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
  \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
  \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
  \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
  \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
  \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
completions: ["        val max = new mutable.ListBuffer[Long]()\n        numbers.foreach{\
    \ n =>\n            val maxNr = max.maxBy(_.toLong)\n            if (maxNr < n.toLong)\
    \ {\n                max += n\n            }\n        }\n        max.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ number =>\n            val maxKey = number.toLong\n            val maxValue\
    \ = max.getOrElse(maxKey, 0L)\n            val newValue = maxValue + 1\n     \
    \       max.put(maxKey, newValue)\n        }\n        val result = new mutable.ArrayList[Long]()\n\
    \        max.foreach { case (maxKey, maxValue) =>\n            result.add(maxValue)\n\
    \        }\n        result", "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax,\
    \ number) => {\n            val maxIndex = rollingMax.lastIndex\n            val\
    \ maxValue = rollingMax(maxIndex)\n            if (number > maxValue) {\n    \
    \            rollingMax :+ number\n            } else {\n                rollingMax\n\
    \            }\n        })\n        rollingMax", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        var max = 0\n        var currentMax = 0\n        var currentIndex = 0\n\
    \        numbers.foreach{\n            number =>\n                max = number\n\
    \                currentMax = number\n                currentIndex = 0\n     \
    \   }\n        numbers.foreach{\n            number =>\n                currentMax\
    \ = number\n                currentIndex += 1\n                rollingMax.append(currentMax)\n\
    \        }\n        rollingMax.toList", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(x => maxes += x)\n        val maxesList = maxes.toList\n\
    \        val maxesListSize = maxesList.size\n        val maxesListIterator = maxesList.iterator\n\
    \        val maxesListIteratorSize = maxesListIterator.size\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = maxesListIterator.index\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = maxesListIterator.index\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = maxesListIterator.index\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = maxesListIterator.index\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = maxesListIterator.index\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = maxesListIterator.index\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = maxesListIterator.index\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = maxesListIterator.index\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = maxesListIterator.index\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = maxesListIterator.index\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = ", "       \
    \ val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n => max.put(n,\
    \ max.getOrElse(n, n) + n))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.values.foreach(n => result += n)\n        result.toList", "     \
    \   val rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n          \
    \  val maxIndex = acc.indexWhere(x => x > x)\n            if (maxIndex < acc.length)\
    \ x :: acc\n            else acc :+ x\n        })\n        rollingMax.reverse",
  "        val max = new mutable.HashMap[Long, Long]()\n        val maxList = new\
    \ mutable.ListBuffer[Long]()\n        numbers.foreach { n =>\n            val\
    \ maxKey = max.max.key\n            if (maxKey == null || n < maxKey) {\n    \
    \            max.put(n, n)\n            } else {\n                val maxValue\
    \ = max.max.value\n                if (maxValue < n) {\n                    max.put(n,\
    \ maxValue)\n                } else {\n                    max.remove(maxKey)\n\
    \                }\n            }\n        }\n        val maxList = max.values.toList\n\
    \        val maxList2 = maxList.sortWith(_ > _)\n        maxList2.reverse", " \
    \       val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l) + x))\n        val maxList = max.values.toList\n\
    \        val maxIndex = max.keys.toList\n        val maxElements = maxList.take(maxIndex.size)\n\
    \        val maxElementsIndex = maxIndex.zip(maxElements)\n        val maxElementsIndex\
    \ = maxElementsIndex.sortBy(_._1).reverse\n        val maxElementsIndex = maxElementsIndex.take(maxElementsIndex.size\
    \ - 1).map(_._2)\n        val maxElementsIndex = maxElementsIndex.map(x => max(x)\
    \ + x)\n        val maxElementsIndex = maxElementsIndex.take(maxElementsIndex.size\
    \ - 1).map(_._2)\n        val maxElementsIndex = maxElementsIndex.map(x => max(x)\
    \ + x)\n        val maxElementsIndex = maxElementsIndex.take(maxElementsIndex.size\
    \ - 1).map(_._2)\n        val maxElementsIndex = maxElementsIndex.map(x => max(x)\
    \ + x)\n        val maxElementsIndex = maxElementsIndex.take(maxElementsIndex.size\
    \ - 1).map(_._2)\n        val maxElementsIndex = maxElementsIndex.map(x => max(x)\
    \ + x)\n        val maxElementsIndex = maxElementsIndex.take(maxElementsIndex.size\
    \ - 1).map(_._2)\n        val maxElementsIndex = maxElementsIndex.map(x => max(x)\
    \ + x)\n        val maxElementsIndex = maxElementsIndex.take(maxElementsIndex.size\
    \ - 1).map(_._2)\n        val maxElementsIndex = maxElementsIndex.map(x => max(x)\
    \ + x)\n        val maxElementsIndex = maxElementsIndex.take(maxElementsIndex.size\
    \ - 1).map(_._2)\n        val maxElementsIndex = maxElementsIndex.map(x => max(x)\
    \ + x)\n        val maxElementsIndex = maxElementsIndex.take(maxElementsIndex.size\
    \ - 1).map(_._2)\n        val maxElementsIndex = maxElementsIndex.map(x => max(x)\
    \ + x)\n        val maxElementsIndex = maxElementsIndex.take(maxElementsIndex.size\
    \ - 1).map(_._2)\n        val maxElementsIndex = maxElementsIndex.map(x => max(x)\
    \ + x)\n        val maxElementsIndex = maxElementsIndex.take(maxElementsIndex.size\
    \ - ", "        val max = new mutable.ListBuffer[Long]()\n        val maxIndex\
    \ = new mutable.ListBuffer[Int]()\n        numbers.foreach(n => {\n          \
    \  if (max.length < n) {\n                max += n\n                maxIndex +=\
    \ 0\n            } else {\n                val index = maxIndex.last\n       \
    \         if (maxIndex.last < n) {\n                    max += n\n           \
    \         maxIndex += index + 1\n                } else {\n                  \
    \  maxIndex += index\n                }\n            }\n        })\n        max.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l) + x))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.values.foreach(x => if (x > result.last) result += x)\n        result.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l) + x))\n        val maxList = new mutable.ListBuffer[Long]()\n\
    \        max.foreach(x => maxList += x)\n        val maxList = maxList.toList\n\
    \        val maxIndex = maxList.lastIndex\n        val maxValue = maxList(maxIndex)\n\
    \        val maxList = maxList.drop(maxIndex)\n        val maxList = maxList.take(maxList.size\
    \ - maxIndex).toList\n        maxList.zip(maxValue).filter(_._1 > _._1).map(_._2)",
  "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            if (number >\
    \ rollingMax(maxIndex)) {\n                rollingMax :+ number\n            }\
    \ else {\n                rollingMax\n            }\n        })\n        rollingMax.reverse",
  "        val rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n       \
    \     val maxIndex = acc.indexWhere(x => x > x)\n            val maxValue = acc((maxIndex\
    \ + 1))\n            if (maxValue < x) acc else acc :+ maxValue\n        })\n\
    \        rollingMax.reverse", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(x => maxList += x)\n        val maxIndex = maxList.lastIndex\n\
    \        val maxElement = maxList(maxIndex)\n        val maxList2 = maxList.drop(maxIndex\
    \ + 1)\n        val maxElement2 = maxList2.last\n        val maxList3 = maxList2.drop(1)\n\
    \        val maxElement3 = maxList3.last\n        val maxList4 = maxList3.drop(2)\n\
    \        val maxElement4 = maxList4.last\n        val maxList5 = maxList4.drop(3)\n\
    \        val maxElement5 = maxList5.last\n        val maxList6 = maxList5.drop(4)\n\
    \        val maxElement6 = maxList6.last\n        val maxList7 = maxList6.drop(5)\n\
    \        val maxElement7 = maxList7.last\n        val maxList8 = maxList7.drop(6)\n\
    \        val maxElement8 = maxList8.last\n        val maxList9 = maxList8.drop(7)\n\
    \        val maxElement9 = maxList9.last\n        val maxList10 = maxList9.drop(8)\n\
    \        val maxElement10 = maxList10.last\n        val maxList11 = maxList10.drop(9)\n\
    \        val maxElement11 = maxList11.last\n        val maxList12 = maxList11.drop(10)\n\
    \        val maxElement12 = maxList12.last\n        val maxList13 = maxList12.drop(11)\n\
    \        val maxElement13 = maxList13.last\n        val maxList14 = maxList13.drop(12)\n\
    \        val maxElement14 = maxList14.last\n        val maxList15 = maxList14.drop(13)\n\
    \        val maxElement15 = maxList15.last\n        val maxList16 = maxList15.drop(14)\n\
    \        val maxElement16 = maxList16.last\n        val maxList17 = maxList16.drop(15)\n\
    \        val maxElement17 = maxList17.last\n        val maxList18 = maxList17.drop(16)\n\
    \        val maxElement18 = maxList18.last\n        val maxList19 = maxList18.drop(17)\n\
    \        val maxElement19 = maxList19.last\n        val maxList20 = maxList19.drop(18)\n\
    \        val maxElement20 = maxList20.last\n        val maxList21 = maxList20.drop(19)\n\
    \        val maxElement21 = maxList21.last\n        val maxList22 = maxList21.drop(20)\n\
    \        val ", "        val max = new mutable.HashMap[Long, Long]()\n       \
    \ numbers.foreach(n => max += (n->max.getOrElse(n,0)))\n        numbers.map(n\
    \ => max(n))", "        val rollingMax = numbers.foldLeft(List[Long]())((acc,\
    \ x) => if (acc.isEmpty) x :: acc else x :: acc.maxBy(_._2)._1)\n        rollingMax.reverse",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach(x\
    \ => {\n            val maxIndex = maxList.lastIndex\n            if (maxIndex\
    \ == -1) {\n                maxList += x\n            } else {\n             \
    \   val maxValue = maxList(maxIndex)\n                if (x > maxValue) {\n  \
    \                  maxList += x\n                }\n            }\n        })\n\
    \        maxList.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l) + x))\n        val\
    \ result = new mutable.ListBuffer[Long]()\n        max.foreach {\n           \
    \ case (k, v) => result += k\n        }\n        result.toList", "        val\
    \ maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number =>\n\
    \            val maxNumber = maxList.max\n            if (maxNumber < number)\
    \ {\n                maxList += number\n            }\n        }\n        maxList.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l)))\n        val result: List[Long] = new mutable.ListBuffer[Long]()\n\
    \        val currentMax = max.get(numbers.head)\n        while(numbers.nonEmpty)\
    \ {\n            val nextMax = max.get(numbers.head)\n            if(nextMax >\
    \ currentMax) {\n                result += currentMax\n                currentMax\
    \ = nextMax\n            } else {\n                result += nextMax\n       \
    \     }\n            numbers = numbers.tail\n        }\n        result += currentMax\n\
    \        result", "        val max = new mutable.HashMap[Long, Long]()\n     \
    \   numbers.foreach(x => max.put(x, max.getOrElse(x, 0l) + x))\n        max.values.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        val rollingMax = new\
    \ mutable.ArrayBuffer[Long]()\n        numbers.foreach(n => {\n            val\
    \ max = max.getOrElse(n, 0)\n            val rollingMax = rollingMax.filter(_\
    \ > max)\n            rollingMax.append(max)\n            max.updated(n, rollingMax.max)\n\
    \        })\n        rollingMax.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => {\n            val max = max.getOrElse(x,\
    \ x)\n            max.update(x, max.get(x))\n        })\n        val maxList =\
    \ max\n            .entrySet\n            .map(x => x._2.toLong)\n           \
    \ .toList\n        val maxListWithIndex = maxList\n            .zipWithIndex\n\
    \            .sortBy(x => x._1)\n            .map(x => x._2.toLong)\n        \
    \    .toList\n        val maxListWithIndex = maxListWithIndex.zipWithIndex.sortBy(x\
    \ => x._1).map(x => x._2.toLong).toList\n        val maxListWithIndex = maxListWithIndex.zipWithIndex.sortBy(x\
    \ => x._1).map(x => x._2.toLong).toList\n        val maxListWithIndex = maxListWithIndex.zipWithIndex.sortBy(x\
    \ => x._1).map(x => x._2.toLong).toList\n        val maxListWithIndex = maxListWithIndex.zipWithIndex.sortBy(x\
    \ => x._1).map(x => x._2.toLong).toList\n        val maxListWithIndex = maxListWithIndex.zipWithIndex.sortBy(x\
    \ => x._1).map(x => x._2.toLong).toList\n        val maxListWithIndex = maxListWithIndex.zipWithIndex.sortBy(x\
    \ => x._1).map(x => x._2.toLong).toList\n        val maxListWithIndex = maxListWithIndex.zipWithIndex.sortBy(x\
    \ => x._1).map(x => x._2.toLong).toList\n        val maxListWithIndex = maxListWithIndex.zipWithIndex.sortBy(x\
    \ => x._1).map(x => x._2.toLong).toList\n        val maxListWithIndex = maxListWithIndex.zipWithIndex.sortBy(x\
    \ => x._1).map(x => x._2.toLong).toList\n        val maxListWithIndex = maxListWithIndex.zipWithIndex.sortBy(x\
    \ => x._1).map(x => x._2.toLong).toList\n        val maxListWithIndex = maxListWithIndex.zipWithIndex.sortBy(x\
    \ => x._1).map(x => x._2.toLong).toList\n        val maxListWithIndex = maxListWithIndex.zipWithIndex.sortBy(x\
    \ => x._1).map(x => x._2.toLong).toList\n        val maxListWithIndex = maxListWithIndex.zip",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach{ n\
    \ =>\n            val maxKey = max(n, n)\n            max += n -> maxKey\n   \
    \     }\n        val maxList = max.toList\n        val maxListCopy = maxList.clone()\n\
    \        val maxListCopy2 = maxListCopy.clone()\n        val maxListCopy3 = maxListCopy2.clone()\n\
    \        val maxListCopy4 = maxListCopy3.clone()\n        val maxListCopy5 = maxListCopy4.clone()\n\
    \        val maxListCopy6 = maxListCopy5.clone()\n        val maxListCopy7 = maxListCopy6.clone()\n\
    \        val maxListCopy8 = maxListCopy7.clone()\n        val maxListCopy9 = maxListCopy8.clone()\n\
    \        val maxListCopy10 = maxListCopy9.clone()\n        val maxListCopy11 =\
    \ maxListCopy10.clone()\n        val maxListCopy12 = maxListCopy11.clone()\n \
    \       val maxListCopy13 = maxListCopy12.clone()\n        val maxListCopy14 =\
    \ maxListCopy13.clone()\n        val maxListCopy15 = maxListCopy14.clone()\n \
    \       val maxListCopy16 = maxListCopy15.clone()\n        val maxListCopy17 =\
    \ maxListCopy16.clone()\n        val maxListCopy18 = maxListCopy17.clone()\n \
    \       val maxListCopy19 = maxListCopy18.clone()\n        val maxListCopy20 =\
    \ maxListCopy19.clone()\n        val maxListCopy21 = maxListCopy20.clone()\n \
    \       val maxListCopy22 = maxListCopy21.clone()\n        val maxListCopy23 =\
    \ maxListCopy22.clone()\n        val maxListCopy24 = maxListCopy23.clone()\n \
    \       val maxListCopy25 = maxListCopy24.clone()\n        val maxListCopy26 =\
    \ maxListCopy25.clone()\n        val maxListCopy27 = maxListCopy26.clone()\n \
    \       val maxListCopy28 = maxListCopy27.clone()\n        val maxListCopy29 =\
    \ maxListCopy28.clone()\n        val maxListCopy30 = maxListCopy29.clone()\n \
    \       val maxListCopy31 = maxListCopy30.clone()\n        val maxListCopy32 =\
    \ maxListCopy31.clone()\n        val maxListCopy33 = maxListCopy32.clone()\n \
    \       val maxListCopy34 = maxListCopy33.clone()\n        val maxListCopy35 =\
    \ maxListCopy34.clone()\n        val maxListCopy36 = maxListCopy35.clone()\n \
    \       val maxListCopy37 = maxListCopy", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxNumber = maxList.max\n\
    \            if (number > maxNumber) {\n                maxList += number\n  \
    \          }\n        }\n        maxList.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(n => max.put(n, max.getOrElse(n, n) + n))\n\
    \        val maxes = max.toList.sortBy(_._2).reverse.take(numbers.size)\n    \
    \    val result: List[Long] = maxes.map(_._1)\n        result", "        val maxes\
    \ = mutable.ListBuffer.empty[Long]\n        numbers.foreach { n =>\n         \
    \   val maxIndex = numbers.indexWhere(x => x > n)\n            if (maxIndex >\
    \ 0) {\n                maxes += numbers(maxIndex)\n                numbers.remove(maxIndex)\n\
    \            }\n        }\n        maxes", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(number => {\n            val maxNumber = numbers.max\n\
    \            if (number > maxNumber) {\n                maxList += maxNumber\n\
    \            }\n        })\n        maxList.toList", "        val rollingMax =\
    \ numbers.foldLeft(List[Long]())((acc, number) => {\n            val maxIndex\
    \ = acc.lastIndexWhere(x => x > number)\n            if (maxIndex == -1) {\n \
    \               acc :+ number\n            } else {\n                acc :+ max(acc.take(maxIndex),\
    \ number)\n            }\n        })\n        rollingMax.reverse", "        val\
    \ max = new mutable.HashMap[Long, Long]()\n        val maxIndex = new mutable.HashMap[Long,\
    \ Int]()\n        numbers.foreach { number =>\n            if (max.contains(number))\
    \ {\n                val maxValue = max.get(number)\n                val maxIndex\
    \ = maxIndex.get(number)\n                if (maxIndex < maxValue) {\n       \
    \             maxIndex += 1\n                    maxIndex.foreach { index =>\n\
    \                        max.put(index, maxValue)\n                    }\n   \
    \             }\n            } else {\n                max.put(number, number)\n\
    \                maxIndex.put(number, 0)\n            }\n        }\n        val\
    \ maxList = max.values.toList\n        val maxIndex = maxIndex.values.toList\n\
    \        val maxIndex = maxIndex.zipWithIndex.map { case (number, index) =>\n\
    \            if (index == maxIndex.size - 1) {\n                number\n     \
    \       } else {\n                maxIndex.last\n            }\n        }\n  \
    \      val maxIndex = maxIndex.zipWithIndex.map { case (number, index) =>\n  \
    \          if (index == maxIndex.size - 1) {\n                number\n       \
    \     } else {\n                maxIndex.last\n            }\n        }\n    \
    \    val maxIndex = maxIndex.zipWithIndex.map { case (number, index) =>\n    \
    \        if (index == maxIndex.size - 1) {\n                number\n         \
    \   } else {\n                maxIndex.last\n            }\n        }\n      \
    \  val maxIndex = maxIndex.zipWithIndex.map { case (number, index) =>\n      \
    \      if (index == maxIndex.size - 1) {\n                number\n           \
    \ } else {\n                maxIndex.last\n            }\n        }\n        val\
    \ maxIndex = maxIndex.zipWithIndex.map { case (number, index) =>\n           \
    \ if (index == maxIndex.size - 1) {\n                number\n            } else\
    \ {\n                maxIndex.last\n            }\n        }\n        val maxIndex\
    \ = maxIndex.zipWithIndex.map { case (number, index) =>\n            if (index\
    \ == maxIndex.size - 1) {\n                number\n            } else {\n    \
    \            maxIndex.last\n            }\n        }\n        val maxIndex = maxIndex.zipWithIndex.map\
    \ { case (number, index) =>\n            if (index == maxIndex.size - 1) {\n \
    \               number\n            } else {\n                maxIndex.last\n\
    \            }\n        }\n        val maxIndex = maxIndex.zipWithIndex.map {\
    \ case (number, index) =>\n            if (index == maxIndex.size - 1) {\n   \
    \             number\n            } else {\n                maxIndex.last\n  \
    \          }\n        }\n        val maxIndex = maxIndex.zipWithIndex.map { case\
    \ (number, index) =>\n            if (index == maxIndex.size - ", "        val\
    \ max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x => max.put(x,\
    \ max.getOrElse(x, 0L) + x))\n        val maxList = max.values.toList\n      \
    \  val maxListWithIndex = numbers.zipWithIndex.filter(x => max(x) == x).map(x\
    \ => (x._2, x._1)).toList\n        val maxListWithIndexSortedByIndex = maxListWithIndex.sortBy(x\
    \ => x._1)\n        val maxListWithIndexSortedByIndexReversed = maxListWithIndexSortedByIndex.reverse\n\
    \        maxListWithIndexSortedByIndexReversed.take(numbers.size)", "        val\
    \ rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n            val max\
    \ = acc.max\n            if (x > max) x :: acc\n            else acc :+ max\n\
    \        })\n        rollingMax.reverse", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            rollingMax.append(number)\n\
    \            rollingMax.lastOption match {\n                case None => rollingMax.clear()\n\
    \                case Some(last) =>\n                    val rollingMaxTail =\
    \ rollingMax.tail\n                    val rollingMaxTailTail = rollingMaxTail.tail\n\
    \                    rollingMaxTailTail.foreach { tail =>\n                  \
    \      if (tail > last) rollingMax.clear()\n                    }\n          \
    \  }\n        }\n        rollingMax.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            if (max.containsKey(n))\
    \ {\n                max.put(n, max(n) + 1)\n            } else {\n          \
    \      max.put(n, 1l)\n            }\n        }\n        val maxList = new mutable.ListBuffer[Long]()\n\
    \        val maxKey = max.keys.toList.max\n        val maxValue = max.values.toList.max\n\
    \        val maxListIterator = maxList.iterator\n        for (n <- numbers) {\n\
    \            if (n == maxKey) {\n                maxListIterator += maxValue\n\
    \            } else {\n                maxListIterator += n\n            }\n \
    \       }\n        return maxList.toList", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(number => {\n            val maxIndex = numbers.indexOf(number).max\n\
    \            maxes += numbers(maxIndex)\n        })\n        maxes", "       \
    \ val rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n            val\
    \ maxIndex = acc.indexWhere(x => x > x)\n            if (maxIndex == acc.length\
    \ - 1) {\n                acc :+ x\n            } else {\n                acc\
    \ :+ max(acc(maxIndex), x)\n            }\n        })\n        rollingMax.reverse",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max += (x, x))\n        val maxList = max.toList.sortWith(_._2 > _._2).reverse\n\
    \        val result: List[Long] = new mutable.ListBuffer[Long]()\n        var\
    \ maxIndex = 0\n        var maxValue = maxList(maxIndex)._2\n        var maxIndex2\
    \ = 0\n        var maxValue2 = maxList(maxIndex2)._2\n        var maxIndex3 =\
    \ 0\n        var maxValue3 = maxList(maxIndex3)._2\n        var maxIndex4 = 0\n\
    \        var maxValue4 = maxList(maxIndex4)._2\n        var maxIndex5 = 0\n  \
    \      var maxValue5 = maxList(maxIndex5)._2\n        var maxIndex6 = 0\n    \
    \    var maxValue6 = maxList(maxIndex6)._2\n        var maxIndex7 = 0\n      \
    \  var maxValue7 = maxList(maxIndex7)._2\n        var maxIndex8 = 0\n        var\
    \ maxValue8 = maxList(maxIndex8)._2\n        var maxIndex9 = 0\n        var maxValue9\
    \ = maxList(maxIndex9)._2\n        var maxIndex10 = 0\n        var maxValue10\
    \ = maxList(maxIndex10)._2\n        var maxIndex11 = 0\n        var maxValue11\
    \ = maxList(maxIndex11)._2\n        var maxIndex12 = 0\n        var maxValue12\
    \ = maxList(maxIndex12)._2\n        var maxIndex13 = 0\n        var maxValue13\
    \ = maxList(maxIndex13)._2\n        var maxIndex14 = 0\n        var maxValue14\
    \ = maxList(maxIndex14)._2\n        var maxIndex15 = 0\n        var maxValue15\
    \ = maxList(maxIndex15)._2\n        var maxIndex16 = 0\n        var maxValue16\
    \ = maxList(maxIndex16)._2\n        var maxIndex17 = 0\n        var maxValue17\
    \ = maxList(maxIndex17)._2\n        var maxIndex18 = 0\n        var maxValue18\
    \ = maxList(maxIndex18)._2\n        var maxIndex19 = 0\n        var maxValue19\
    \ = maxList(maxIndex19)._2\n        var maxIndex20 = 0\n        var maxValue20\
    \ = maxList(maxIndex20)._2\n        var maxIndex21 = 0\n        var maxValue21\
    \ = maxList(maxIndex21)._2\n        var maxIndex22 = 0\n        var maxValue22\
    \ = maxList(maxIndex22)._2\n        var maxIndex23 = 0\n        var maxValue23\
    \ = maxList(maxIndex23)._2\n        var maxIndex24 = 0\n        var maxValue24\
    \ = maxList(maxIndex24)._2\n        var maxIndex25 = 0\n        var maxValue25\
    \ = maxList(max", "        val max = new mutable.HashMap[Long, Long]()\n     \
    \   numbers.foreach { n =>\n            val maxKey = max.max.key\n           \
    \ if (maxKey < n) max.updated(maxKey, n)\n        }\n        val maxList = max.values.toList\n\
    \        val maxListWithMax = maxList.zipWithIndex.filter(_._1 == maxList.max)\n\
    \        val maxListWithMaxWithIndex = maxListWithMax.zipWithIndex.filter(_._2\
    \ == maxListWithMax.max)\n        val maxListWithMaxWithIndexWithMax = maxListWithMaxWithIndex.filter(_._2\
    \ == maxListWithMaxWithIndex.max)\n        val maxListWithMaxWithIndexWithMaxWithMax\
    \ = maxListWithMaxWithIndexWithMax.filter(_._2 == maxListWithMaxWithIndexWithMax.max)\n\
    \        val maxListWithMaxWithIndexWithMaxWithMaxWithMax = maxListWithMaxWithIndexWithMaxWithMax.filter(_._2\
    \ == maxListWithMaxWithIndexWithMaxWithMax.max)\n        val maxListWithMaxWithIndexWithMaxWithMaxWithMax\
    \ = maxListWithMaxWithIndexWithMaxWithMax.filter(_._2 == maxListWithMaxWithIndexWithMaxWithMax.max)\n\
    \        val maxListWithMaxWithIndexWithMaxWithMaxWithMaxWithMax = maxListWithMaxWithIndexWithMaxWithMaxWithMax.filter(_._2\
    \ == maxListWithMaxWithIndexWithMaxWithMaxWithMax.max)\n        val maxListWithMaxWithIndexWithMaxWithMaxWithMaxWithMax\
    \ = maxListWithMaxWithIndexWithMaxWithMaxWithMaxWithMax.filter(_._2 == maxListWithMaxWithIndexWithMaxWithMaxWithMaxWithMax.max)\n\
    \        val maxListWithMaxWithIndexWithMaxWithMaxWithMaxWithMaxWithMax = maxListWithMaxWithIndexWithMaxWithMaxWithMaxWithMaxWithMax.filter(_._2\
    \ == maxListWithMaxWithIndexWithMaxWithMaxWithMaxWithMaxWithMax.max)\n       \
    \ val maxListWithMaxWithIndexWithMaxWithMaxWithMaxWithMaxWithMax = maxListWithMaxWithIndexWithMaxWithMaxWithMaxWithMaxWithMax.filter(_._2\
    \ == maxListWithMaxWithIndexWithMaxWithMaxWithMaxWithMaxWithMax.max)\n       \
    \ val maxListWithMaxWithIndexWithMaxWithMaxWithMaxWithMaxWithMaxWithMax = maxListWithMaxWithIndexWithMaxWithMaxWithMaxWithMax",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ number =>\n            if (max.contains(number)) {\n                val maxValue\
    \ = max.get(number)\n                if (number > maxValue) {\n              \
    \      max.put(number, number)\n                } else {\n                   \
    \ max.put(number, maxValue)\n                }\n            } else {\n       \
    \         max.put(number, number)\n            }\n        }\n        val maxList\
    \ = max.values.toList\n        val maxListWithIndex = maxList.zipWithIndex.map\
    \ { case (number, index) => number -> index }\n        val maxListWithIndexSortedByIndex\
    \ = maxListWithIndex.sortBy(_._2)\n        val maxListWithIndexSortedByValues\
    \ = maxListWithIndexSortedByIndex.map { case (number, index) => number -> maxListWithIndexSortedByIndex.take(index).map(x\
    \ => x._1) }\n        val maxListWithIndexSortedByValuesReversed = maxListWithIndexSortedByValues.reverse\n\
    \        val maxListWithIndexSortedByValuesReversedSortedByIndex = maxListWithIndexSortedByValuesReversed.sortBy(_._2)\n\
    \        val maxListWithIndexSortedByValuesReversedSortedByValues = maxListWithIndexSortedByValuesReversedSortedByIndex.map\
    \ { case (number, index) => number -> maxListWithIndexSortedByValuesReversedSortedByIndex.take(index).map(x\
    \ => x._1) }\n        val maxListWithIndexSortedByValuesReversedSortedByValuesReversed\
    \ = maxListWithIndexSortedByValuesReversedSortedByValues.reverse\n        val\
    \ maxListWithIndexSortedByValuesReversedSortedByValuesReversedSortedByIndex =\
    \ maxListWithIndexSortedByValuesReversedSortedByValuesReversed.sortBy(_._2)\n\
    \        val maxListWithIndexSortedByValuesReversedSortedByValuesReversedSortedByValues\
    \ = maxListWithIndexSortedByValuesReversedSortedByValuesReversedSortedByIndex.map\
    \ { case (number, index) => number -> maxListWithIndexSortedByValuesReversedSortedByValuesReversedSortedByIndex.take(index).map(x\
    \ => x._1) }\n        val maxListWithIndexSortedByValuesReversedSortedByValuesReversedSortedByValuesReversed\
    \ = maxListWithIndexSortedByValuesReversedSortedByValuesReversedSortedByValues.reverse\n\
    \        val maxListWithIndexSortedByValuesReversedSortedByValuesReversedSortedByValuesReversedSortedByIndex\
    \ = maxListWithIndexSortedByValuesReversedSortedByValuesReversedSortedByValues",
  "        val maxList = mutable.ListBuffer[Long]()\n        numbers.foreach(x =>\
    \ maxList += x)\n        val maxIndex = maxList.size - 1\n        val maxValue\
    \ = maxList(maxIndex)\n        val maxElements = maxList.drop(maxIndex + 1)\n\
    \        val maxElementsIndex = maxElements.size - 1\n        val maxElementsValue\
    \ = maxElements(maxElementsIndex)\n        val maxElementsIndex = maxElementsIndex\
    \ - 1\n        val maxElementsValue2 = maxElements(maxElementsIndex - 1)\n   \
    \     val maxElementsValue3 = maxElements(maxElementsIndex - 2)\n        val maxElementsValue4\
    \ = maxElements(maxElementsIndex - 3)\n        val maxElementsValue5 = maxElements(maxElementsIndex\
    \ - 4)\n        val maxElementsValue6 = maxElements(maxElementsIndex - 5)\n  \
    \      val maxElementsValue7 = maxElements(maxElementsIndex - 6)\n        val\
    \ maxElementsValue8 = maxElements(maxElementsIndex - 7)\n        val maxElementsValue9\
    \ = maxElements(maxElementsIndex - 8)\n        val maxElementsValue10 = maxElements(maxElementsIndex\
    \ - 9)\n        val maxElementsValue11 = maxElements(maxElementsIndex - 10)\n\
    \        val maxElementsValue12 = maxElements(maxElementsIndex - 11)\n       \
    \ val maxElementsValue13 = maxElements(maxElementsIndex - 12)\n        val maxElementsValue14\
    \ = maxElements(maxElementsIndex - 13)\n        val maxElementsValue15 = maxElements(maxElementsIndex\
    \ - 14)\n        val maxElementsValue16 = maxElements(maxElementsIndex - 15)\n\
    \        val maxElementsValue17 = maxElements(maxElementsIndex - 16)\n       \
    \ val maxElementsValue18 = maxElements(maxElementsIndex - 17)\n        val maxElementsValue19\
    \ = maxElements(maxElementsIndex - 18)\n        val maxElementsValue20 = maxElements(maxElementsIndex\
    \ - 19)\n        val maxElementsValue21 = maxElements(maxElementsIndex - 20)\n\
    \        val maxElementsValue22 = maxElements(maxElementsIndex - 21)\n       \
    \ val maxElementsValue23 = maxElements(maxElementsIndex - 22)\n        val maxElementsValue24\
    \ = maxElements(maxElementsIndex - 23)\n        val maxElementsValue25 = maxElements(maxElementsIndex",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxValue = number match {\n                case x\
    \ if x > maxList.length => x\n                case x => maxList.length\n     \
    \       }\n            maxList += maxValue\n        }\n        maxList.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l) + x))\n        max.values.toList", "    \
    \    val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0L) + x))\n        val maxList = max.toList.sortBy(_._1).reverse\n\
    \        val maxElement = maxList.head._2\n        val maxElements = maxList.tail.filter(_._2\
    \ > maxElement)\n        val maxElementsUntilMoment = maxElements.takeWhile(_._2\
    \ <= maxElement)\n        val maxElementsUntilMomentList = maxElementsUntilMoment.toList\n\
    \        val maxElementsUntilMomentListWithMaxElement = maxElementsUntilMomentList.reverse.filter(_._2\
    \ == maxElement)\n        val maxElementsUntilMomentListWithMaxElementWithMaxElement\
    \ = maxElementsUntilMomentListWithMaxElement.reverse.filter(_._2 == maxElement)\n\
    \        val maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementsUntilMomentListWithMaxElementWithMaxElement.reverse.filter(_._2\
    \ == maxElement)\n        val maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElement.reverse.filter(_._2\
    \ == maxElement)\n        val maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElementWithMaxElement.reverse.filter(_._2\
    \ == maxElement)\n        val maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement.reverse.filter(_._2\
    \ == maxElement)\n        val maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement.reverse.filter(_._2\
    \ == maxElement)\n        val maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement.reverse.filter(_._2\
    \ == maxElement)\n        ", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxIndex = maxes.indexWhere(_\
    \ > number)\n            if (maxIndex == -1) {\n                maxes += number\n\
    \            } else {\n                maxes += maxes(maxIndex - 1)\n        \
    \    }\n        }\n        maxes.toList", "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax,\
    \ number) => {\n            val maxIndex = rollingMax.lastIndex\n            val\
    \ maxValue = rollingMax(maxIndex).max(number)\n            rollingMax :+ maxValue\n\
    \        })\n        rollingMax.reverse", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        var max = 0\n        var i = 0\n        numbers.foreach{n =>\n      \
    \      max = math.max(max, n)\n            maxes += max\n            i += 1\n\
    \        }\n        val result = maxes.take(i).toList\n        result", "    \
    \    val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l)))\n        val maxList = max.toList.sortBy(_._1).reverse\n\
    \        val maxListSize = maxList.size\n        val rollingMax = new mutable.ArrayList[Long]()\n\
    \        var maxIndex = 0\n        var maxValue = maxList(0).get\n        for(i\
    \ <- 1 to maxListSize) {\n            if(maxList(i).get.equals(maxValue)) {\n\
    \                rollingMax.add(maxList(i).get)\n            } else {\n      \
    \          rollingMax.add(maxValue)\n                maxValue = maxList(i).get\n\
    \                maxIndex = i\n            }\n        }\n        rollingMax",
  "        val maxRollingNumbers = mutable.ListBuffer.empty[Long]\n        numbers.foreach(number\
    \ => {\n            val maxRollingNumber = maxRollingNumbers.max\n           \
    \ if (number > maxRollingNumber) {\n                maxRollingNumbers += number\n\
    \            }\n        })\n        maxRollingNumbers", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxIndex = numbers.lastIndexWhere(_\
    \ == number)\n            if (maxIndex > 0) {\n                maxes += number\n\
    \                numbers.remove(maxIndex)\n            }\n        }\n        maxes",
  "        val rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n       \
    \     val maxIndex = acc.lastIndexWhere(y => y > x)\n            if (maxIndex\
    \ == -1) acc :+ x\n            else acc :+ acc.apply(maxIndex)\n        })\n \
    \       rollingMax.reverse", "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax,\
    \ number) => {\n            val maxIndex = rollingMax.lastIndex\n            if\
    \ (number > rollingMax(maxIndex)) {\n                rollingMax :+ number\n  \
    \          } else {\n                rollingMax\n            }\n        })\n \
    \       rollingMax.reverse", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(x => max.put(x, Math.max(max.getOrElse(x, 0), x)))\n\
    \        max.values.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        val maxList = new mutable.ListBuffer[Long]()\n        numbers.foreach\
    \ { number =>\n            val maxKey = max max number\n            max += number\
    \ -> maxKey\n            maxList += maxKey\n        }\n        maxList.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ n =>\n            if (max.containsKey(n)) {\n                max.update(n, max(n)\
    \ + 1)\n            } else {\n                max.put(n, 1l)\n            }\n\
    \        }\n        val maxList = max.values.toList\n        val maxListWithMax\
    \ = maxList.takeWhile(_ > numbers.size).reverse\n        val maxListWithoutMax\
    \ = maxList.dropWhile(_ > numbers.size).reverse\n        val maxListWithMaxAndMaxListWithoutMax\
    \ = maxListWithMax.zip(maxListWithoutMax)\n        val maxListWithMaxAndMaxListWithoutMaxWithMax\
    \ = maxListWithMaxAndMaxListWithoutMax.map { case (maxValue, maxValueWithoutMax)\
    \ =>\n            if (maxValue == numbers.size) {\n                maxValueWithoutMax\n\
    \            } else {\n                maxValueWithoutMax + maxValue\n       \
    \     }\n        }\n        val maxListWithMaxAndMaxListWithoutMaxWithMaxAndMaxListWithoutMaxWithMax\
    \ = maxListWithMaxAndMaxListWithoutMaxWithMax.map { case (maxValue, maxValueWithoutMax,\
    \ maxValueWithoutMaxWithoutMax) =>\n            if (maxValue == numbers.size)\
    \ {\n                maxValueWithoutMaxWithoutMax\n            } else {\n    \
    \            maxValueWithoutMaxWithoutMax + maxValueWithoutMax\n            }\n\
    \        }\n        maxListWithMaxAndMaxListWithoutMaxWithMaxAndMaxListWithoutMaxWithMax",
  "        val max = new mutable.HashMap[Long, Long]()\n        val maxList = new\
    \ mutable.ListBuffer[Long]()\n        numbers.foreach(n => {\n            val\
    \ maxKey = max(n, n)\n            max += n -> maxKey\n            maxList += maxKey\n\
    \        })\n        maxList.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            val maxKey = max.max.key\n\
    \            if (maxKey == null || n > maxKey) {\n                max.put(n.toLong,\
    \ n)\n            }\n        }\n        val maxList = max.values.toList\n    \
    \    val maxListWithMax = maxList.map(_ + maxList.max)\n        val maxListWithoutMax\
    \ = maxList.filterNot(_ == maxList.max)\n        val maxListWithMaxAndMax = maxListWithMax\
    \ + maxListWithoutMax\n        val maxListWithMaxAndMaxAndMax = maxListWithMaxAndMax\
    \ + maxListWithMax\n        val maxListWithMaxAndMaxAndMaxAndMax = maxListWithMaxAndMaxAndMax\
    \ + maxListWithMaxAndMax\n        val maxListWithMaxAndMaxAndMaxAndMaxAndMax =\
    \ maxListWithMaxAndMaxAndMaxAndMaxAndMax + maxListWithMaxAndMaxAndMaxAndMax\n\
    \        val maxListWithMaxAndMaxAndMaxAndMaxAndMaxAndMax = maxListWithMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\
    \ + maxListWithMaxAndMaxAndMaxAndMaxAndMaxAndMax\n        val maxListWithMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\
    \ = maxListWithMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax + maxListWithMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\n\
    \        val maxListWithMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax = maxListWithMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\
    \ + maxListWithMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\n        val maxListWithMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\
    \ = maxListWithMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\
    \ + maxListWithMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\n   \
    \     val maxListWithMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\
    \ = maxListWithMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\
    \ + maxListWithMaxAndMaxAndMaxAndMaxAndMax", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => {\n            if (max.containsKey(x))\
    \ {\n                max.put(x, max(x) + x)\n            } else {\n          \
    \      max.put(x, x)\n            }\n        })\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.values.foreach(x => result += x)\n        result.toList", "     \
    \   val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach(number\
    \ => {\n            val maxValue = number match {\n                case x if x\
    \ > maxList.length => x\n                case x => maxList(x)\n            }\n\
    \            maxList += maxValue\n        })\n        maxList.toList", "     \
    \   val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number\
    \ =>\n            val maxIndex = maxes.indexWhere(x => x > number)\n         \
    \   if (maxIndex == -1) {\n                maxes += number\n            } else\
    \ {\n                maxes(maxIndex) = max(maxes(maxIndex), number)\n        \
    \    }\n        }\n        maxes.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            rollingMax += number\n     \
    \   }\n        rollingMax.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach{ n =>\n            val maxKey = max(n, n)\n\
    \            if (maxKey > 0) max.put(maxKey, max(n, n))\n        }\n        max.values.toList",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxElement = maxList.toList.max\n            if (number\
    \ > maxElement) {\n                maxList += number\n            }\n        }\n\
    \        maxList.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l) + x))\n        val\
    \ result: List[Long] = for (i <- numbers.indices) yield {\n            val max\
    \ = max(i)\n            val min = max\n            val rollingMax = numbers.take(i\
    \ + 1).foldLeft(0l)(_ + _)\n            val rollingMin = numbers.take(i).foldLeft(0l)(_\
    \ + _)\n            val rollingMaxMin = numbers.take(i + 1).foldLeft(0l)(_ + _)\n\
    \            val rollingMaxMinMin = numbers.take(i + 1).foldLeft(0l)(_ + _)\n\
    \            val rollingMaxMinMinMin = numbers.take(i + 1).foldLeft(0l)(_ + _)\n\
    \            val rollingMaxMinMinMinMin = numbers.take(i + 1).foldLeft(0l)(_ +\
    \ _)\n            val rollingMaxMinMinMinMinMin = numbers.take(i + 1).foldLeft(0l)(_\
    \ + _)\n            val rollingMaxMinMinMinMinMin = numbers.take(i + 1).foldLeft(0l)(_\
    \ + _)\n            val rollingMaxMinMinMinMinMinMin = numbers.take(i + 1).foldLeft(0l)(_\
    \ + _)\n            val rollingMaxMinMinMinMinMinMin = numbers.take(i + 1).foldLeft(0l)(_\
    \ + _)\n            val rollingMaxMinMinMinMinMinMin = numbers.take(i + 1).foldLeft(0l)(_\
    \ + _)\n            val rollingMaxMinMinMinMinMinMin = numbers.take(i + 1).foldLeft(0l)(_\
    \ + _)\n            val rollingMaxMinMinMinMinMinMin = numbers.take(i + 1).foldLeft(0l)(_\
    \ + _)\n            val rollingMaxMinMinMinMinMinMin = numbers.take(i + 1).foldLeft(0l)(_\
    \ + _)\n            val rollingMaxMinMinMinMinMinMin = numbers.take(i + 1).foldLeft(0l)(_\
    \ + _)\n            val rollingMaxMinMinMinMinMinMinMin = numbers.take(i + 1).foldLeft(0l)(_\
    \ + _)\n            val rollingMaxMinMinMinMinMinMinMin = numbers.take(i + ",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0L) + x))\n        val maxList = max.toList.sortBy(_._1).reverse\n\
    \        val maxElement = maxList(0)\n        val maxElementList = maxList.drop(1)\n\
    \        val maxElementListWithMaxElement = maxElementList.map(_._2)\n       \
    \ val maxElementListWithoutMaxElement = maxElementList.map(_._1)\n        val\
    \ maxElementListWithoutMaxElementWithMaxElement = maxElementListWithoutMaxElement.filter(_\
    \ != maxElement)\n        val maxElementListWithoutMaxElementWithoutMaxElement\
    \ = maxElementListWithoutMaxElement.filter(_ == maxElement)\n        val maxElementListWithoutMaxElementWithMaxElementWithoutMaxElement\
    \ = maxElementListWithoutMaxElement.filter(_ != maxElement)\n        val maxElementListWithoutMaxElementWithoutMaxElementWithMaxElement\
    \ = maxElementListWithoutMaxElement.filter(_ == maxElement)\n        val maxElementListWithoutMaxElementWithoutMaxElementWithMaxElementWithoutMaxElement\
    \ = maxElementListWithoutMaxElement.filter(_ != maxElement)\n        val maxElementListWithoutMaxElementWithoutMaxElementWithMaxElementWithoutMaxElement\
    \ = maxElementListWithoutMaxElement.filter(_ == maxElement)\n        val maxElementListWithoutMaxElementWithoutMaxElementWithMaxElementWithoutMaxElementWithoutMaxElement\
    \ = maxElementListWithoutMaxElement.filter(_ != maxElement)\n        val maxElementListWithoutMaxElementWithoutMaxElementWithMaxElementWithoutMaxElementWithoutMaxElement\
    \ = maxElementListWithoutMaxElement.filter(_ == maxElement)\n        val maxElementListWithoutMaxElementWithoutMaxElementWithMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElement\
    \ = maxElementListWithoutMaxElement.filter(_ != maxElement)\n        val maxElementListWithoutMaxElementWithoutMaxElementWithMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElement\
    \ = maxElementListWithoutMaxElement.filter(_ == maxElement)\n        val maxElementListWithoutMaxElementWithoutMaxElementWithMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElement\
    \ = maxElementListWithoutMaxElement.filter(_ != maxElement)\n        val maxElementListWithoutMaxElementWithoutMaxElementWithMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElementWithoutMaxElement\
    \ = maxElementListWithoutMaxElement.filter(_ == maxElement)\n        val maxElementListWithoutMaxElementWithoutMaxElementWithMaxElementWithoutMaxElementWithoutMaxElementWithoutMax",
  "        val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number\
    \ =>\n            val maxIndex = maxes.lastIndex\n            val maxValue = maxes.get(maxIndex)\n\
    \            if (number > maxValue) {\n                maxes += number\n     \
    \       }\n        }\n        maxes.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l) + x))\n\
    \        val result: List[Long] = new mutable.ListBuffer[Long]()\n        val\
    \ maxKey = max.keys.max\n        val maxValue = max.get(maxKey)\n        val maxIndex\
    \ = numbers.indexWhere(x => x == maxValue)\n        val maxIndexList = numbers.take(maxIndex).toList\n\
    \        val maxIndexListSize = maxIndexList.length\n        val maxIndexListSize\
    \ = maxIndexListSize.toLong\n        val maxIndexListSize = maxIndexListSize.toInt\n\
    \        val maxIndexListSize = maxIndexListSize.toLong\n        val maxIndexListSize\
    \ = maxIndexListSize.toInt\n        val maxIndexListSize = maxIndexListSize.toLong\n\
    \        val maxIndexListSize = maxIndexListSize.toInt\n        val maxIndexListSize\
    \ = maxIndexListSize.toLong\n        val maxIndexListSize = maxIndexListSize.toInt\n\
    \        val maxIndexListSize = maxIndexListSize.toLong\n        val maxIndexListSize\
    \ = maxIndexListSize.toInt\n        val maxIndexListSize = maxIndexListSize.toLong\n\
    \        val maxIndexListSize = maxIndexListSize.toInt\n        val maxIndexListSize\
    \ = maxIndexListSize.toLong\n        val maxIndexListSize = maxIndexListSize.toInt\n\
    \        val maxIndexListSize = maxIndexListSize.toLong\n        val maxIndexListSize\
    \ = maxIndexListSize.toInt\n        val maxIndexListSize = maxIndexListSize.toLong\n\
    \        val maxIndexListSize = maxIndexListSize.toInt\n        val maxIndexListSize\
    \ = maxIndexListSize.toLong\n        val maxIndexListSize = maxIndexListSize.toInt\n\
    \        val maxIndexListSize = maxIndexListSize.toLong\n        val maxIndexListSize\
    \ = maxIndexListSize.toInt\n        val maxIndexListSize = maxIndexListSize.toLong\n\
    \        val maxIndexListSize = maxIndexListSize.toInt\n        val maxIndexListSize\
    \ = maxIndexListSize.toLong\n        val maxIndexListSize = maxIndexListSize.toInt\n\
    \        val maxIndexListSize = maxIndexListSize.toLong\n        val maxIndexListSize\
    \ = maxIndexListSize.toInt\n        val maxIndexListSize = maxIndexListSize.toLong\n\
    \        val maxIndexListSize = maxIndexListSize.toInt\n        val maxIndexListSize\
    \ = maxIndexListSize.toLong\n        val maxIndex", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(x => {\n            val maxIndex = maxList.lastIndex\n\
    \            val maxValue = maxList(maxIndex)\n            if (x > maxValue) {\n\
    \                maxList += x\n            }\n        })\n        maxList.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max += ((x, x)))\n        numbers.reverse.foreach(x => max += ((x, x)))\n\
    \        numbers.reverse.foreach(x => max += ((x, x)))\n        numbers.reverse.foreach(x\
    \ => max += ((x, x)))\n        numbers.reverse.foreach(x => max += ((x, x)))\n\
    \        numbers.reverse.foreach(x => max += ((x, x)))\n        numbers.reverse.foreach(x\
    \ => max += ((x, x)))\n        numbers.reverse.foreach(x => max += ((x, x)))\n\
    \        numbers.reverse.foreach(x => max += ((x, x)))\n        numbers.reverse.foreach(x\
    \ => max += ((x, x)))\n        numbers.reverse.foreach(x => max += ((x, x)))\n\
    \        numbers.reverse.foreach(x => max += ((x, x)))\n        numbers.reverse.foreach(x\
    \ => max += ((x, x)))\n        numbers.reverse.foreach(x => max += ((x, x)))\n\
    \        numbers.reverse.foreach(x => max += ((x, x)))\n        numbers.reverse.foreach(x\
    \ => max += ((x, x)))\n        numbers.reverse.foreach(x => max += ((x, x)))\n\
    \        numbers.reverse.foreach(x => max += ((x, x)))\n        numbers.reverse.foreach(x\
    \ => max += ((x, x)))\n        numbers.reverse.foreach(x => max += ((x, x)))\n\
    \        numbers.reverse.foreach(x => max += ((x, x)))\n        numbers.reverse.foreach(x\
    \ => max += ((x, x)))\n        numbers.reverse.foreach(x => max += ((x, x)))\n\
    \        numbers.reverse.foreach(x => max += ((x, x)))\n        numbers.reverse.foreach(x\
    \ => max += ((x, x)))\n        numbers.reverse.foreach(x => max += ((x, x)))\n\
    \        numbers.reverse.foreach(x => max += ((x, x)))\n        numbers.reverse.foreach(x\
    \ => max += ((x, x)))\n        numbers.reverse.foreach(x => max += ((x, x)))\n\
    \        numbers.reverse.foreach(x => max += ((x, x)))\n        numbers.reverse.foreach(x\
    \ => max += ((x, x)))\n        numbers.reverse.foreach(x => max += ((x, x)))\n\
    \        numbers.reverse.foreach(x => max += ((x, x)))\n        numbers.reverse.foreach",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n\
    \ => {\n            if (max.containsKey(n)) {\n                max.put(n, max(n)\
    \ + 1)\n            } else {\n                max.put(n, 1l)\n            }\n\
    \        })\n        val maxList = new mutable.ListBuffer[Long]()\n        max.foreach(m\
    \ => {\n            if (m._2 > numbers.size) {\n                maxList += m._1\n\
    \            }\n        })\n        return maxList.toList", "        val max =\
    \ new mutable.HashMap[Long, Long]()\n        numbers.foreach(x => max += ((x,\
    \ x)))\n        val result: List[Long] = numbers.map(x => max.getOrElse(x, 0l))\n\
    \        result.sortWith((x, y) => x._2 > y._2)", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0L) + x))\n\
    \        val result = new mutable.ListBuffer[Long]()\n        max.values.foreach(x\
    \ => result += x)\n        result.toList", "        val maxList = mutable.ListBuffer[Long]()\n\
    \        val maxIndex = mutable.ListBuffer[Int]()\n        numbers.foreach { number\
    \ =>\n            number match {\n                case x if x > maxList.getOrElse(0)\
    \ =>\n                    maxList += x\n                    maxIndex += 0\n  \
    \              case x if x == maxList.getOrElse(0) =>\n                    maxIndex\
    \ += 0\n                case x if x > maxList.getOrElse(0) && x == maxList.getOrElse(maxIndex.get)\
    \ =>\n                    maxList += x\n                    maxIndex += 0\n  \
    \              case x if x == maxList.getOrElse(0) && x == maxList.getOrElse(maxIndex.get)\
    \ =>\n                    maxIndex += 0\n                case x if x > maxList.getOrElse(0)\
    \ && x == maxList.getOrElse(maxIndex.get) =>\n                    maxList += x\n\
    \                    maxIndex += 0\n                case x if x == maxList.getOrElse(0)\
    \ && x == maxList.getOrElse(maxIndex.get) =>\n                    maxIndex +=\
    \ 0\n                case x if x > maxList.getOrElse(0) && x == maxList.getOrElse(maxIndex.get)\
    \ =>\n                    maxList += x\n                    maxIndex += 0\n  \
    \              case x if x == maxList.getOrElse(0) && x == maxList.getOrElse(maxIndex.get)\
    \ =>\n                    maxIndex += 0\n                case x if x > maxList.getOrElse(0)\
    \ && x == maxList.getOrElse(maxIndex.get) =>\n                    maxList += x\n\
    \                    maxIndex += 0\n                case x if x == maxList.getOrElse(0)\
    \ && x == maxList.getOrElse(maxIndex.get) =>\n                    maxIndex +=\
    \ 0\n                case x if x > maxList.getOrElse(0) && x == maxList.getOrElse(maxIndex.get)\
    \ =>\n                    maxList += x\n                    maxIndex += 0\n  \
    \              case x if x == maxList.getOrElse(0) && x == maxList.getOrElse(maxIndex.get)\
    \ =>\n                    maxIndex += 0\n                case x if x > maxList.getOrElse(0)\
    \ && x == maxList.getOrElse(maxIndex.get) =>\n                    maxList += x\n\
    \                    maxIndex += 0\n                case x if x == maxList.getOrElse(0)\
    \ && x == maxList.getOrElse(maxIndex.get) =>\n                    maxIndex +=\
    \ 0\n                case x if x > maxList.getOrElse(0) && x == maxList.getOrElse(maxIndex",
  "        val rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n       \
    \     if (acc.isEmpty) List(x)\n            else {\n                val maxIndex\
    \ = acc.lastIndex\n                if (maxIndex == 0) List(x)\n              \
    \  else if (x > acc.last) List(x)\n                else {\n                  \
    \  val maxValue = acc.last\n                    val newMax = if (maxValue < x)\
    \ x else maxValue\n                    acc.init :+ newMax\n                }\n\
    \            }\n        })\n        rollingMax.reverse", "        val max = new\
    \ mutable.HashMap[Long, Long]()\n        numbers.foreach { n =>\n            val\
    \ maxKey = max(n, n)\n            if (maxKey > 0) max.put(maxKey, max(n, n))\n\
    \        }\n        max.values.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l)))\n  \
    \      val maxList = max.toList.sortBy(_._1).reverse\n        val maxElement =\
    \ maxList(0)\n        val maxElementList = maxList.takeWhile(_._1 == maxElement)\n\
    \        val maxElementListWithMax = maxElementList.map(_._2)\n        val maxElementListWithoutMax\
    \ = maxElementList.filter(_._2 != maxElement)\n        val maxElementListWithoutMaxWithMax\
    \ = maxElementListWithoutMax.map(_._2)\n        val maxElementListWithoutMaxWithoutMax\
    \ = maxElementListWithoutMax.filter(_._2 != maxElement)\n        val maxElementListWithoutMaxWithoutMaxWithMax\
    \ = maxElementListWithoutMaxWithoutMax.map(_._2)\n        val maxElementListWithoutMaxWithoutMaxWithoutMax\
    \ = maxElementListWithoutMaxWithoutMax.filter(_._2 != maxElement)\n        val\
    \ maxElementListWithoutMaxWithoutMaxWithoutMaxWithMax = maxElementListWithoutMaxWithoutMaxWithoutMax.map(_._2)\n\
    \        val maxElementListWithoutMaxWithoutMaxWithoutMaxWithoutMax = maxElementListWithoutMaxWithoutMaxWithoutMax.filter(_._2\
    \ != maxElement)\n        val maxElementListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithMax\
    \ = maxElementListWithoutMaxWithoutMaxWithoutMaxWithoutMax.map(_._2)\n       \
    \ val maxElementListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMax = maxElementListWithoutMaxWithoutMaxWithoutMaxWithoutMax.filter(_._2\
    \ != maxElement)\n        val maxElementListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithMax\
    \ = maxElementListWithoutMaxWithoutMaxWithoutMaxWithoutMax.map(_._2)\n       \
    \ val maxElementListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMax\
    \ = maxElementListWithoutMaxWithoutMaxWithoutMaxWithoutMax.filter(_._2 != maxElement)\n\
    \        val maxElementListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithMax\
    \ = maxElementListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMax.map(_._2)\n\
    \        val maxElementListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMax\
    \ = maxElementListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMax.filter(_._2\
    \ != maxElement)\n        val maxElementListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMax",
  "        val maxRollingNumbers = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            val rollingMax = number + maxRollingNumbers.last\n\
    \            maxRollingNumbers += rollingMax\n        }\n        maxRollingNumbers.toList",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        val maxIndex = -1\n\
    \        numbers.foreach(number => {\n            if (number > maxList(0)) {\n\
    \                maxList += number\n                maxIndex += 1\n          \
    \  }\n        })\n        maxList.take(maxIndex).toList", "        val rollingMax\
    \ = mutable.ListBuffer.empty[Long]\n        var max = 0\n        var i = 0\n \
    \       while(i < numbers.size) {\n            max = numbers(i)\n            while(i\
    \ < numbers.size && numbers(i) < max) {\n                max += numbers(i)\n \
    \               i += 1\n            }\n            rollingMax += max\n       \
    \ }\n        rollingMax.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { number =>\n            if (max.contains(number))\
    \ {\n                max += number\n            } else {\n                max\
    \ += number -> number\n            }\n        }\n        val maxList = max.toList.sortBy(_._1).reverse\n\
    \        val maxListWithIndex = maxList.zipWithIndex.map { case (number, index)\
    \ => (index, number) }\n        val maxListWithIndexSortedByIndex = maxListWithIndex.sortBy(_._1).reverse\n\
    \        val maxListWithIndexSortedByIndexWithIndex = maxListWithIndexSortedByIndex.zipWithIndex.map\
    \ { case (number, index) => (index, number) }\n        val maxListWithIndexSortedByIndexWithIndexSortedByIndex\
    \ = maxListWithIndexSortedByIndexWithIndex.sortBy(_._1).reverse\n        val maxListWithIndexSortedByIndexWithIndexSortedByIndexWithIndex\
    \ = maxListWithIndexSortedByIndexWithIndexSortedByIndex.zipWithIndex.map { case\
    \ (number, index) => (index, number) }\n        val maxListWithIndexSortedByIndexWithIndexSortedByIndexWithIndexSortedByIndex\
    \ = maxListWithIndexSortedByIndexWithIndexSortedByIndexWithIndex.sortBy(_._1).reverse\n\
    \        val maxListWithIndexSortedByIndexWithIndexSortedByIndexWithIndexSortedByIndexWithIndex\
    \ = maxListWithIndexSortedByIndexWithIndexSortedByIndexWithIndexSortedByIndex.zipWithIndex.map\
    \ { case (number, index) => (index, number) }\n        val maxListWithIndexSortedByIndexWithIndexSortedByIndexWithIndexSortedByIndexWithIndexSortedByIndex\
    \ = maxListWithIndexSortedByIndexWithIndexSortedByIndexWithIndexSortedByIndexWithIndex.sortBy(_._1).reverse\n\
    \        val maxListWithIndexSortedByIndexWithIndexSortedByIndexWithIndexSortedByIndexWithIndexSortedByIndexWithIndex\
    \ = maxListWithIndexSortedByIndexWithIndexSortedByIndexWithIndexSortedByIndexWithIndexSortedByIndex.zipWithIndex.map\
    \ { case (number, index) => (index, number) }\n        val maxListWithIndexSortedByIndexWithIndexSortedByIndexWithIndexSortedByIndexWithIndexSortedByIndexWithIndexSortedByIndex\
    \ = maxListWithIndexSortedByIndexWithIndexSortedByIndexWithIndexSortedByIndexWithIndexSortedByIndex.sortBy(_._1).reverse\n\
    \        val maxListWithIndexSortedByIndexWithIndexSortedByIndexWithIndexSortedByIndexWithIndexSortedByIndexWith",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0L) + x))\n        val maxes = max.toList.sortBy(_._1).reverse\n\
    \        val maxesWithMax = maxes.map(x => if (x._2 > 0) x._2 else x._1)\n   \
    \     val maxesWithMaxAndIndex = maxes.zipWithIndex.filter(x => x._2 > 0).map(x\
    \ => (x._2, x._1))\n        val maxesWithMaxAndIndexWithMax = maxesWithMaxAndIndex.map(x\
    \ => if (x._1 > 0) x._2 else x._1)\n        val maxesWithMaxAndIndexWithMaxAndIndex\
    \ = maxesWithMaxAndIndexWithMax.zipWithIndex.filter(x => x._2 > 0).map(x => (x._2,\
    \ x._1))\n        val maxesWithMaxAndIndexWithMaxAndIndexWithMax = maxesWithMaxAndIndexWithMaxAndIndex.map(x\
    \ => if (x._1 > 0) x._2 else x._1)\n        val maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndex\
    \ = maxesWithMaxAndIndexWithMaxAndIndexWithMax.zipWithIndex.filter(x => x._2 >\
    \ 0).map(x => (x._2, x._1))\n        val maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMax\
    \ = maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndex.map(x => if (x._1 > 0)\
    \ x._2 else x._1)\n        val maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndex\
    \ = maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMax.zipWithIndex.filter(x\
    \ => x._2 > 0).map(x => (x._2, x._1))\n        val maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMax\
    \ = maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndex.map(x =>\
    \ if (x._1 > 0) x._2 else x._1)\n        val maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndex\
    \ = maxesWithMaxAndIndexWithMaxAndIndexWithMaxAndIndexWithMaxAndIndex.zipWithIndex.filter(x\
    \ => x._2 > 0).map(x => (x._2, x._1))\n        val maxesWithMaxAndIndexWithMax",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach(number\
    \ => {\n            val maxElement = maxList.toList.max\n            if (number\
    \ > maxElement) {\n                maxList += number\n            }\n        })\n\
    \        maxList.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        val maxList = new mutable.ArrayList[Long]()\n        numbers.foreach(x\
    \ => {\n            val maxKey = max.keySet().iterator().next()\n            val\
    \ maxValue = max.get(maxKey)\n            if (maxValue < x) max.put(maxKey, x)\n\
    \            else maxList.add(maxValue)\n        })\n        maxList.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l) + x))\n        val maxList = max.toList.sortBy(_._1).reverse\n\
    \        val maxElement = maxList.head._2\n        val maxElements = maxList.tail.filter(_._2\
    \ > maxElement)\n        val maxElementsUntilMoment = maxElements.takeWhile(_._2\
    \ < maxElement)\n        val maxElementsUntilMomentList = maxElementsUntilMoment.toList\n\
    \        val maxElementsUntilMomentListWithMaxElement = maxElementsUntilMomentList.reverse.takeWhile(_._2\
    \ == maxElement)\n        val maxElementsUntilMomentListWithMaxElementWithMaxElement\
    \ = maxElementsUntilMomentListWithMaxElement.reverse.takeWhile(_._2 == maxElement)\n\
    \        val maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementsUntilMomentListWithMaxElementWithMaxElement.reverse.takeWhile(_._2\
    \ == maxElement)\n        val maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElement.reverse.takeWhile(_._2\
    \ == maxElement)\n        val maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElementWithMaxElement.reverse.takeWhile(_._2\
    \ == maxElement)\n        val maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement.reverse.takeWhile(_._2\
    \ == maxElement)\n        val maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement.reverse.takeWhile(_._2\
    \ == maxElement)\n        val maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementsUntilMomentListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement.reverse.takeWhile(_",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        val maxIndex = mutable.ListBuffer.empty[Int]\n\
    \        numbers.foreach { number =>\n            val index = maxList.size\n \
    \           if (number > maxList.getOrElse(index)) {\n                maxList\
    \ += number\n                maxIndex += index\n            }\n        }\n   \
    \     maxIndex.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(n => {\n            val max = max.getOrElseUpdate(n,\
    \ n)\n            max._2 += 1\n        })\n        val maxList = max.toList.sortWith((a,\
    \ b) => b._2 - a._2)\n        val rollingMax = maxList.takeWhile(x => x._2 <=\
    \ numbers.size).map(x => x._1)\n        rollingMax", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l) + x))\n\
    \        val result: List[Long] = numbers.map(x => max.getOrElse(x, 0l))\n   \
    \     result", "        val max = new mutable.ListBuffer[Long]()\n        numbers.foreach(x\
    \ => max.append(x))\n        val rollingMax = max.sliding(numbers.size, numbers.size)\n\
    \        rollingMax.map(_.max).reverse", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l) + x))\n\
    \        max.values.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(x => {\n            val max = max.getOrElse(x, x)\n \
    \           max.update(x, max.get(x))\n        })\n        max.toList.sortBy(_._2).reverse",
  "        val rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n       \
    \     val maxIndex = acc.indexWhere(x => x > x)\n            if (maxIndex == acc.length\
    \ - 1) acc :+ x\n            else acc :+ max(acc.take(maxIndex + 1), x)\n    \
    \    })\n        rollingMax.reverse", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(n => {\n            val maxKey = max.max.key\n\
    \            if (maxKey == n) return\n            val maxValue = max.max.value\n\
    \            if (maxValue < n) max.put(n, maxValue)\n        })\n        max.toList.sortBy(_._1).reverse",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ number =>\n            val maxKey = number.toLong\n            val maxValue\
    \ = max.getOrElse(maxKey, 0L)\n            val newMaxValue = maxValue + 1\n  \
    \          max.put(maxKey, newMaxValue)\n        }\n        val maxList = max.toList\n\
    \        val maxListSize = maxList.size\n        val maxListIterator = maxList.iterator\n\
    \        val maxListIteratorSize = maxListIterator.size\n        val maxListIteratorIndex\
    \ = maxListIterator.index\n        val maxListIteratorElement = maxListIterator.next()\n\
    \        val maxListIteratorElementSize = maxListIteratorElement.size\n      \
    \  val maxListIteratorElementIndex = maxListIteratorElement.index\n        val\
    \ maxListIteratorElementKey = maxListIteratorElement.key\n        val maxListIteratorElementValue\
    \ = maxListIteratorElement.value\n        val maxListIteratorElementKeySize =\
    \ maxListIteratorElementKey.size\n        val maxListIteratorElementKeyIndex =\
    \ maxListIteratorElementKey.index\n        val maxListIteratorElementKeyValue\
    \ = maxListIteratorElementKey.value\n        val maxListIteratorElementKeyValueSize\
    \ = maxListIteratorElementKeyValue.size\n        val maxListIteratorElementKeyValueIndex\
    \ = maxListIteratorElementKeyValue.size\n        val maxListIteratorElementKeyValueValue\
    \ = maxListIteratorElementKeyValue.value\n        val maxListIteratorElementKeyValueValueSize\
    \ = maxListIteratorElementKeyValueValue.size\n        val maxListIteratorElementKeyValueValueIndex\
    \ = maxListIteratorElementKeyValueValue.size\n        val maxListIteratorElementKeyValueValueValue\
    \ = maxListIteratorElementKeyValueValue.value\n        val maxListIteratorElementKeyValueValueValueSize\
    \ = maxListIteratorElementKeyValueValueValue.size\n        val maxListIteratorElementKeyValueValueValueIndex\
    \ = maxListIteratorElementKeyValueValueValue.size\n        val maxListIteratorElementKeyValueValueValueValue\
    \ = maxListIteratorElementKeyValueValueValue.value\n        val maxListIteratorElementKeyValueValueValueValueSize\
    \ = maxListIteratorElementKeyValueValueValueValue.size\n        val maxListIteratorElementKeyValueValueValueValueIndex\
    \ = maxListIteratorElementKeyValueValueValueValue.size\n        val maxListIteratorElementKeyValueValueValueValueValue\
    \ = maxListIteratorElementKeyValueValueValueValue.value\n        val maxListIteratorElementKeyValueValueValueValueValueSize\
    \ = maxListIteratorElementKeyValueValueValueValueValue.size\n        val maxListIteratorElementKeyValueValueValueValueValueIndex\
    \ = maxListIteratorElementKeyValueValueValueValue", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => {\n            val max = max.getOrElse(x,\
    \ 0l)\n            val cur = max\n            val next = Math.max(x, cur)\n  \
    \          max.put(next, next)\n        })\n        max.values.toList", "    \
    \    val maxList = mutable.ListBuffer[Long]()\n        numbers.foreach { number\
    \ =>\n            val maxNumber = numbers.max\n            if (number > maxNumber)\
    \ {\n                maxList += number\n            }\n        }\n        maxList.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ n =>\n            if (max.contains(n)) {\n                max += (n, n)\n  \
    \          } else {\n                max += (n, max)\n            }\n        }\n\
    \        val maxList = max.values.toList\n        val maxListSize = maxList.size\n\
    \        val maxListIndex = maxListSize - 1\n        val maxListElement = maxList(maxListIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementIndex = maxListElementIndex - 1\n        val maxListElementSize\
    \ = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementSize = maxListElementSize - 1\n        val maxListElementSize\
    \ = maxListElementSize - 1\n        val maxListElementSize = maxListElementSize\
    \ - 1\n        val maxListElementSize = maxListElementSize - 1\n        val maxListElementSize\
    \ = maxListElementSize - 1\n        val maxListElementSize = maxListElementSize\
    \ - 1\n        val maxListElementSize = maxListElementSize - 1\n        val maxListElementSize\
    \ = maxListElementSize - 1\n        val maxListElementSize = maxListElementSize\
    \ - 1\n        val maxListElementSize = maxListElementSize - 1\n        val maxListElementSize\
    \ = maxListElementSize - 1\n        val maxListElementSize = maxListElementSize\
    \ - 1\n        val maxListElementSize = maxListElementSize - 1\n        val maxListElementSize\
    \ = maxListElementSize - 1\n        val maxListElementSize = maxListElementSize\
    \ - 1\n        val maxListElementSize = maxListElementSize - 1\n        val maxListElementSize\
    \ = maxListElementSize - 1\n        val maxListElementSize = maxListElementSize\
    \ - 1\n        val maxListElementSize = maxListElementSize - 1\n        val maxListElementSize\
    \ = maxListElementSize - 1\n        val maxListElementSize = maxListElementSize\
    \ - 1\n        val maxListElementSize = maxListElementSize - 1\n        val maxListElementSize\
    \ = maxListElementSize - 1\n        val maxListElementSize = maxListElementSize\
    \ - 1\n        val maxListElementSize = maxListElementSize - 1\n        val maxListElementSize\
    \ = maxListElementSize - 1\n        val maxListElementSize = maxListElementSize\
    \ - 1\n        val maxListElementSize = maxListElementSize - 1\n        val maxListElementSize\
    \ = maxListElementSize - 1\n        val maxListElementSize = maxListElementSize\
    \ - 1\n        val maxListElementSize = maxListElementSize - 1\n        val ",
  "        val rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n       \
    \     val maxIndex = acc.indexWhere(y => y > x)\n            if (maxIndex == acc.length\
    \ - 1) acc :+ x\n            else acc :+ max(acc(maxIndex + 1), x)\n        })\n\
    \        rollingMax.reverse", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        var max = 0\n        var currentMax = 0\n        var currentIndex = 0\n\
    \        numbers.foreach { number =>\n            if (number > max) {\n      \
    \          max = number\n                currentMax = number\n               \
    \ currentIndex = 0\n            } else if (number == max) {\n                currentMax\
    \ = number\n                currentIndex += 1\n            } else {\n        \
    \        maxList += currentMax\n                currentMax = number\n        \
    \        currentIndex = 0\n            }\n        }\n        maxList += currentMax\n\
    \        maxList.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(n => {\n            if (max.containsKey(n)) {\n     \
    \           val max = max(n)\n                max.map(_ + n)\n            } else\
    \ {\n                val max = n\n                max.map(_ + n)\n           \
    \ }\n        })\n        max.values.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l) + x))\n\
    \        val maxList = max.values.toList\n        val maxIndex = max.keys.toList\n\
    \        val maxIndex = maxIndex.sortBy(x => -x)\n        val maxIndex = maxIndex.take(maxIndex.size\
    \ - maxIndex.size % maxList.size)\n        val maxIndex = maxIndex.map(x => maxList(x))\n\
    \        val maxIndex = maxIndex.map(x => x.toLong)\n        val maxIndex = maxIndex.map(x\
    \ => x - maxIndex.size)\n        val maxIndex = maxIndex.map(x => x + maxList.size)\n\
    \        val maxIndex = maxIndex.map(x => x + maxList.size)\n        val maxIndex\
    \ = maxIndex.map(x => x + maxList.size)\n        val maxIndex = maxIndex.map(x\
    \ => x + maxList.size)\n        val maxIndex = maxIndex.map(x => x + maxList.size)\n\
    \        val maxIndex = maxIndex.map(x => x + maxList.size)\n        val maxIndex\
    \ = maxIndex.map(x => x + maxList.size)\n        val maxIndex = maxIndex.map(x\
    \ => x + maxList.size)\n        val maxIndex = maxIndex.map(x => x + maxList.size)\n\
    \        val maxIndex = maxIndex.map(x => x + maxList.size)\n        val maxIndex\
    \ = maxIndex.map(x => x + maxList.size)\n        val maxIndex = maxIndex.map(x\
    \ => x + maxList.size)\n        val maxIndex = maxIndex.map(x => x + maxList.size)\n\
    \        val maxIndex = maxIndex.map(x => x + maxList.size)\n        val maxIndex\
    \ = maxIndex.map(x => x + maxList.size)\n        val maxIndex = maxIndex.map(x\
    \ => x + maxList.size)\n        val maxIndex = maxIndex.map(x => x + maxList.size)\n\
    \        val maxIndex = maxIndex.map(x => x + maxList.size)\n        val maxIndex\
    \ = maxIndex.map(x => x + maxList.size)\n        val maxIndex = maxIndex.map(x\
    \ => x + maxList.size)\n        val maxIndex = maxIndex.map(x => x + maxList.size)\n\
    \        val maxIndex = maxIndex.map(x => x + maxList.size)\n        val maxIndex\
    \ = maxIndex.map(x => x + maxList.size)\n        val maxIndex = maxIndex.map(x\
    \ => x + maxList.size)\n        val maxIndex = maxIndex.map(x => x + maxList.size)\n\
    \        val maxIndex = max", "        val maxes = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => maxes += x)\n        val maxesRollingMax = maxes.sliding(numbers.size)\n\
    \        val maxesRollingMaxMax = maxesRollingMax.map(_.max)\n        maxesRollingMaxMax.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0L) + x))\n        val maxList = new mutable.ListBuffer[Long]()\n\
    \        for(x <- max.keySet) {\n            val maxValue = max.get(x)\n     \
    \       val maxIndex = numbers.indexOf(x)\n            val maxIndex = maxIndex\
    \ + numbers.lastIndexOf(x)\n            val maxIndex = maxIndex + numbers.indexOf(maxValue)\n\
    \            val maxIndex = maxIndex + numbers.indexOf(maxValue)\n           \
    \ val maxIndex = maxIndex + numbers.indexOf(maxValue)\n            val maxIndex\
    \ = maxIndex + numbers.indexOf(maxValue)\n            val maxIndex = maxIndex\
    \ + numbers.indexOf(maxValue)\n            val maxIndex = maxIndex + numbers.indexOf(maxValue)\n\
    \            val maxIndex = maxIndex + numbers.indexOf(maxValue)\n           \
    \ val maxIndex = maxIndex + numbers.indexOf(maxValue)\n            val maxIndex\
    \ = maxIndex + numbers.indexOf(maxValue)\n            val maxIndex = maxIndex\
    \ + numbers.indexOf(maxValue)\n            val maxIndex = maxIndex + numbers.indexOf(maxValue)\n\
    \            val maxIndex = maxIndex + numbers.indexOf(maxValue)\n           \
    \ val maxIndex = maxIndex + numbers.indexOf(maxValue)\n            val maxIndex\
    \ = maxIndex + numbers.indexOf(maxValue)\n            val maxIndex = maxIndex\
    \ + numbers.indexOf(maxValue)\n            val maxIndex = maxIndex + numbers.indexOf(maxValue)\n\
    \            val maxIndex = maxIndex + numbers.indexOf(maxValue)\n           \
    \ val maxIndex = maxIndex + numbers.indexOf(maxValue)\n            val maxIndex\
    \ = maxIndex + numbers.indexOf(maxValue)\n            val maxIndex = maxIndex\
    \ + numbers.indexOf(maxValue)\n            val maxIndex = maxIndex + numbers.indexOf(maxValue)\n\
    \            val maxIndex = maxIndex + numbers.indexOf(maxValue)\n           \
    \ val maxIndex = maxIndex + numbers.indexOf(maxValue)\n            val maxIndex\
    \ = maxIndex + numbers.indexOf(maxValue)\n            val maxIndex = maxIndex\
    \ + numbers.indexOf(maxValue)\n            val maxIndex = maxIndex + numbers.indexOf(maxValue)\n\
    \            val maxIndex = maxIndex + numbers.indexOf(maxValue)\n           \
    \ val maxIndex = maxIndex + numbers.indexOf(maxValue)\n            val maxIndex\
    \ = maxIndex + numbers.indexOf(maxValue)\n            val maxIndex = maxIndex\
    \ + numbers.indexOf(maxValue)\n            val maxIndex = maxIndex + numbers.indexOf(maxValue)\n\
    \            val maxIndex = maxIndex + numbers.indexOf(maxValue)\n           \
    \ val maxIndex = maxIndex + numbers.indexOf(maxValue)\n            val maxIndex\
    \ = maxIndex + numbers.indexOf(maxValue)\n            val maxIndex = maxIndex\
    \ + numbers.indexOf(maxValue)\n            val maxIndex = maxIndex + numbers.",
  "        val maxes = mutable.ListBuffer.empty[Long]\n        var max = 0\n     \
    \   numbers.foreach(x => {\n            if (x > max) {\n                max =\
    \ x\n            }\n            maxes += max\n        })\n        maxes", "  \
    \      val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ n =>\n            val maxKey = max max n\n            if (maxKey == null) {\n\
    \                max += n -> n\n            } else {\n                max += n\
    \ -> maxKey\n            }\n        }\n        max max 0", "        val maxList\
    \ = mutable.ListBuffer[Long]()\n        numbers.foreach{ number =>\n         \
    \   val maxValue = number max maxList\n            maxList += maxValue\n     \
    \   }\n        maxList.toList", "        val maxList = mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => maxList += x)\n        val maxIndex = maxList.lastIndex\n\
    \        val maxElement = maxList(maxIndex)\n        val maxList = maxList.drop(maxIndex\
    \ + 1)\n        maxList", "        val max = new mutable.ListBuffer[Long]()\n\
    \        val maxIndex = new mutable.ListBuffer[Int]()\n        numbers.foreach(x\
    \ => {\n            if (max.length < x) {\n                max += x\n        \
    \        maxIndex += 0\n            } else {\n                if (max(x) < max(x))\
    \ {\n                    max += x\n                    maxIndex += 0\n       \
    \         } else {\n                    max += max(x)\n                    maxIndex\
    \ += 1\n                }\n            }\n        })\n        max.toList", " \
    \       val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ x =>\n            val max = max.getOrElse(x, x)\n            max.update(x, Math.max(max,\
    \ x))\n        }\n        val result = new mutable.ListBuffer[Long]()\n      \
    \  max.foreach { x =>\n            result.add(x)\n        }\n        result.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l) + x))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.values.foreach(x => if (x > result.last) result += x)\n        result",
  "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            if (number >\
    \ rollingMax(maxIndex)) {\n                rollingMax :+ number\n            }\
    \ else {\n                rollingMax\n            }\n        })\n        rollingMax.reverse",
  "        val rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n       \
    \     val maxIndex = acc.indexWhere(x => x > x)\n            if (maxIndex == acc.length\
    \ - 1) {\n                acc :+ x\n            } else {\n                acc\
    \ :+ acc.apply(maxIndex + 1)\n            }\n        })\n        rollingMax.reverse",
  "        val max = new mutable.HashMap[Long, Long]()\n        val maxes = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => max.put(x, max(x.getOrElse(x, 0l) + 1)));\n    \
    \    max.foreach { case (k, v) => maxes += v }\n        maxes", "        val max\
    \ = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x => max.put(x,\
    \ Math.max(max.getOrElse(x, 0), x)))\n        max.values.toList", "        val\
    \ max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x => max.put(x,\
    \ max.getOrElse(x, 0l)))\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        while(max.nonEmpty) {\n            val maxKey = max.max.key\n       \
    \     val maxValue = max.max.value\n            rollingMax.append(maxKey)\n  \
    \          max.remove(maxKey)\n            max.put(maxKey, maxValue)\n       \
    \ }\n        rollingMax.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max += ((x, x)))\n        val result:\
    \ List[Long] = new mutable.ArrayBuffer[Long]()\n        val curMax = max\n   \
    \     val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        val curMaxKey = curMax.keys.head\n        val curMaxValue = curMax.keys.head\n\
    \        ", "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l) + x))\n        val result: List[Long] = numbers.map(x\
    \ => max.getOrElse(x, 0l))\n        result", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { number =>\n            val max = number.max(max)\n\
    \        }\n        max.keys.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0L) + x))\n\
    \        max.values.toList", "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax,\
    \ number) => {\n            val maxIndex = rollingMax.lastIndex\n            if\
    \ (number > rollingMax(maxIndex)) {\n                rollingMax :+ number\n  \
    \          } else {\n                rollingMax\n            }\n        })\n \
    \       rollingMax", "        val max = new mutable.HashMap[Long, Long]()\n  \
    \      numbers.foreach(x => max.put(x, max.getOrElse(x, 0l) + x))\n        max.values.toList",
  "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            val maxValue\
    \ = rollingMax(maxIndex)\n            if (number > maxValue) {\n             \
    \   rollingMax :+ number\n            } else {\n                rollingMax\n \
    \           }\n        })\n        rollingMax.reverse", "        val max = new\
    \ mutable.HashMap[Long, Long]()\n        val maxes = new mutable.ArrayList[Long]()\n\
    \        numbers.foreach(n => {\n            val max = max.getOrElse(n, 0)\n \
    \           val maxes = maxes :+ max\n            max.update(n + 1, Math.max(n,\
    \ max.get(n) + 1))\n        })\n        maxes", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { number =>\n            val maxKey = number.toLong\n\
    \            if (max.contains(maxKey)) {\n                max.put(maxKey, max(maxKey,\
    \ number.toLong))\n            } else {\n                max.put(maxKey, number.toLong)\n\
    \            }\n        }\n        max.values.toList", "        val max = new\
    \ mutable.HashMap[Long, Long]()\n        numbers.foreach { n =>\n            val\
    \ maxKey = max.keySet().max\n            if (maxKey < n)\n                max\
    \ += n -> maxKey\n        }\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.foreach { case (k, v) =>\n            result += v -> k\n        }\n\
    \        result.toList", "        val rollingMax = numbers.foldLeft(List[Long]())((acc,\
    \ x) => {\n            val maxIndex = acc.indexWhere(x => x > x)\n           \
    \ if (maxIndex == acc.length - 1) {\n                acc :+ x\n            } else\
    \ {\n                acc :+ max(acc(maxIndex), x)\n            }\n        })\n\
    \        rollingMax.reverse", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach { x =>\n            if (max.containsKey(x)) {\n     \
    \           max.put(x, max.get(x) + x)\n            } else {\n               \
    \ max.put(x, x)\n            }\n        }\n        val result = new mutable.ArrayList[Long]()\n\
    \        max.foreach { case (k, v) =>\n            if (result.size < k) {\n  \
    \              result += v\n            } else {\n                val last = result.last\n\
    \                if (last < v) {\n                    result += v\n          \
    \      } else {\n                    result += last\n                }\n     \
    \       }\n        }\n        result", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxValue = number max maxList\n\
    \            maxList += maxValue\n        }\n        maxList.toList", "      \
    \  val maxes = new mutable.ListBuffer[Long]()\n        numbers.foreach(x => maxes\
    \ += x)\n        val maxesRollingMax = maxes.sliding(numbers.size)\n        val\
    \ maxesRollingMaxList = maxesRollingMax.toList\n        val maxesRollingMaxListReversed\
    \ = maxesRollingMaxList.reverse\n        val maxesRollingMaxListReversedList =\
    \ new mutable.ListBuffer[Long]()\n        maxesRollingMaxListReversed.foreach(x\
    \ => maxesRollingMaxListReversedList += x)\n        maxesRollingMaxListReversedList.reverse",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0L) + x))\n        val maxList = max.toList.sortBy(_._1).reverse\n\
    \        val maxListWithIndex = maxList.zipWithIndex.filter(_._2 % numbers.size==0)\n\
    \        val maxListWithoutIndex = maxList.filter(_._2 % numbers.size==0)\n  \
    \      val maxListWithIndexWithoutIndex = maxListWithoutIndex.zipWithIndex.filter(_._2\
    \ % numbers.size==0)\n        val maxListWithoutIndexWithoutIndex = maxListWithoutIndex.filter(_._2\
    \ % numbers.size==0)\n        val maxListWithIndexWithoutIndexWithoutIndex = maxListWithoutIndexWithoutIndex.zipWithIndex.filter(_._2\
    \ % numbers.size==0)\n        val maxListWithoutIndexWithoutIndexWithoutIndex\
    \ = maxListWithoutIndexWithoutIndex.filter(_._2 % numbers.size==0)\n        val\
    \ maxListWithIndexWithoutIndexWithoutIndexWithoutIndex = maxListWithoutIndexWithoutIndexWithoutIndex.zipWithIndex.filter(_._2\
    \ % numbers.size==0)\n        val maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndex\
    \ = maxListWithoutIndexWithoutIndexWithoutIndex.filter(_._2 % numbers.size==0)\n\
    \        val maxListWithIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndex\
    \ = maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndex.zipWithIndex.filter(_._2\
    \ % numbers.size==0)\n        val maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndex\
    \ = maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndex.filter(_._2 % numbers.size==0)\n\
    \        val maxListWithIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndex\
    \ = maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndex.zipWithIndex.filter(_._2\
    \ % numbers.size==0)\n        val maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndex\
    \ = maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndex.filter(_._2 % numbers.size==0)\n\
    \        val maxListWithIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndex\
    \ = maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndex.zipWithIndex.filter(_._2\
    \ % numbers.size==0)\n        val maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndex\
    \ = maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndex.filter(_._2 % numbers.size==0)\n\
    \        val maxListWithIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndex\
    \ = maxListWithoutIndexWithout", "        val max = new mutable.ListBuffer[Long]()\n\
    \        val current = new mutable.ListBuffer[Long]()\n        numbers.foreach(x\
    \ => {\n            current += x\n            if (current.size > max.size) {\n\
    \                max += current.head\n                current.clear()\n      \
    \      }\n        })\n        max += current.head\n        current.clear()\n \
    \       max.toList", "        val max = new mutable.ListBuffer[Long]()\n     \
    \   numbers.foreach(x => if (x > max.last) max += x)\n        max.toList", " \
    \       val max = new mutable.ListBuffer[Long]()\n        numbers.foreach(x =>\
    \ if (x > max.last) max += x)\n        max.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        val maxIndex = numbers.indexWhere(_ > numbers.last)\n        val maxValue\
    \ = numbers.last\n        numbers.drop(maxIndex).foreach { number =>\n       \
    \     if (number > maxValue) {\n                maxList += number\n          \
    \  }\n        }\n        maxList.toList", "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax,\
    \ number) => {\n            val maxIndex = rollingMax.lastIndex\n            if\
    \ (maxIndex == rollingMax.size - 1) {\n                rollingMax :+ number\n\
    \            } else {\n                rollingMax :+ rollingMax(maxIndex + 1)\n\
    \            }\n        })\n        rollingMax.reverse", "        val maxList\
    \ = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number =>\n    \
    \        val maxValue = maxList.lastOption.orElse(number)\n            if (maxValue\
    \ < number) {\n                maxList += number\n            }\n        }\n \
    \       maxList.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach { number =>\n            val maxKey = max max number\n\
    \            if (maxKey > number) {\n                max += number -> number\n\
    \            }\n        }\n        max map { case (number, maxValue) =>\n    \
    \        number\n        }", "        val maxList = mutable.ListBuffer[Long]()\n\
    \        numbers.foreach { number =>\n            val maxNumber = maxList.toList.max\n\
    \            if (number > maxNumber) {\n                maxList += number\n  \
    \          }\n        }\n        maxList.toList", "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax,\
    \ number) => {\n            val maxIndex = rollingMax.lastIndex\n            if\
    \ (maxIndex == rollingMax.size - 1) {\n                rollingMax.updated(maxIndex\
    \ + 1, number)\n            } else {\n                rollingMax.updated(maxIndex\
    \ + 1, rollingMax(maxIndex + 1) + number)\n            }\n        })\n       \
    \ rollingMax.reverse", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach { n =>\n            if (max.containsKey(n)) {\n     \
    \           max.put(n, max(n) + 1)\n            } else {\n                max.put(n,\
    \ 1l)\n            }\n        }\n        val maxList = new mutable.ListBuffer[Long]()\n\
    \        val maxKey = max.keys.toList\n        val maxValue = max.values.toList\n\
    \        val maxKeyIndex = maxKey.indexWhere(x => x > 0)\n        val maxValueIndex\
    \ = maxValue.indexWhere(x => x > 0)\n        val maxKeyValue = maxKey.take(maxKeyIndex)\n\
    \        val maxValueValue = maxValue.take(maxValueIndex)\n        maxKeyValue.foreach\
    \ { key =>\n            val value = maxValueValue\n            val index = maxValueIndex\n\
    \            val maxValue = maxValueValue\n            val maxKey = maxKeyValue\n\
    \            val maxKeyIndex = maxKey.indexWhere(x => x > 0)\n            val\
    \ maxValueIndex = maxValue.indexWhere(x => x > 0)\n            val maxKeyValue\
    \ = maxKey.take(maxKeyIndex)\n            val maxValueValue = maxValue.take(maxValueIndex)\n\
    \            val maxValueIndex = maxValue.indexWhere(x => x > 0)\n           \
    \ val maxValueValue = maxValue.take(maxValueIndex)\n            val maxValueIndex\
    \ = maxValue.indexWhere(x => x > 0)\n            val maxValueValue = maxValue.take(maxValueIndex)\n\
    \            val maxValueIndex = maxValue.indexWhere(x => x > 0)\n           \
    \ val maxValueValue = maxValue.take(maxValueIndex)\n            val maxValueIndex\
    \ = maxValue.indexWhere(x => x > 0)\n            val maxValueValue = maxValue.take(maxValueIndex)\n\
    \            val maxValueIndex = maxValue.indexWhere(x => x > 0)\n           \
    \ val maxValueValue = maxValue.take(maxValueIndex)\n            val maxValueIndex\
    \ = maxValue.indexWhere(x => x > 0)\n            val maxValueValue = maxValue.take(maxValueIndex)\n\
    \            val maxValueIndex = maxValue.indexWhere(x => x > 0)\n           \
    \ val maxValueValue = maxValue.take(maxValueIndex)\n            val maxValueIndex\
    \ = maxValue.indexWhere(x => x > 0)\n            val maxValueValue = maxValue.take(maxValueIndex)\n\
    \            val maxValueIndex = maxValue.indexWhere(x => x > 0)\n           \
    \ val maxValueValue = maxValue.take(maxValueIndex)\n            val maxValueIndex\
    \ = maxValue.indexWhere(x => x > 0)\n            val maxValueValue = maxValue.take(maxValue",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach(x\
    \ => {\n            val maxIndex = maxList.lastIndex\n            if (maxIndex\
    \ < 0) maxList += x\n            else maxList += maxList[maxIndex] + x\n     \
    \   })\n        maxList.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        val maxIndex = mutable.ListBuffer.empty[Int]\n        numbers.foreach\
    \ { number =>\n            if (number > maxList(0)) {\n                maxList\
    \ += number\n                maxIndex += 0\n            }\n            else {\n\
    \                maxIndex += 1 \n                if (maxIndex.size == numbers.size)\
    \ {\n                    maxList += number\n                    maxIndex += 0\n\
    \                }\n            }\n        }\n        maxList.toList", "     \
    \   val maxList = mutable.ListBuffer[Long]()\n        numbers.foreach(x => {\n\
    \            val maxIndex = maxList.lastIndex\n            if (maxIndex == -1)\
    \ {\n                maxList += x\n            } else {\n                if (x\
    \ > maxList(maxIndex)) {\n                    maxList += x\n                }\n\
    \            }\n        })\n        maxList.toList", "        val rollingMax =\
    \ numbers.foldLeft(List[Long]())((rollingMax, number) => {\n            val maxIndex\
    \ = rollingMax.lastIndex\n            val maxValue = rollingMax(maxIndex)\n  \
    \          if (number > maxValue) {\n                rollingMax :+ number\n  \
    \          } else {\n                rollingMax\n            }\n        })\n \
    \       rollingMax.reverse", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(x => max.put(x, max.getOrElse(x, 0L) + x))\n        val\
    \ result = new mutable.ListBuffer[Long]()\n        max.values.foreach(x => result.add(x))\
    \ // add all elements to result\n        result.takeWhile(x => x < numbers.last).reverse\
    \ // take all elements from result until the last one", "        val max = new\
    \ mutable.HashMap[Long, Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x,\
    \ 0l) + x))\n        val result = new mutable.ListBuffer[Long]()\n        max.foreach\
    \ {\n            case (k, v) => result += k\n        }\n        result.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ n =>\n            if (max.containsKey(n)) {\n                max.put(n, max(n)\
    \ + 1)\n            } else {\n                max.put(n, 1l)\n            }\n\
    \        }\n        val result = new mutable.ArrayList[Long]()\n        val keys\
    \ = max.keySet\n        val maxKeys = keys.toList\n        val maxValues = maxKeys.map(n\
    \ => max(n)).toList\n        val maxIndex = maxKeys.indexOf(0)\n        val maxValue\
    \ = maxValues(maxIndex)\n        val maxKey = maxKeys(maxIndex)\n        val maxKeyIndex\
    \ = keys.indexOf(maxKey)\n        val maxKeyValue = maxValues(maxKeyIndex)\n \
    \       val maxKeyIndex = keys.indexOf(maxKey)\n        val maxKeyValue = maxValues(maxKeyIndex)\n\
    \        val maxKeyIndex = keys.indexOf(maxKey)\n        val maxKeyValue = maxValues(maxKeyIndex)\n\
    \        val maxKeyIndex = keys.indexOf(maxKey)\n        val maxKeyValue = maxValues(maxKeyIndex)\n\
    \        val maxKeyIndex = keys.indexOf(maxKey)\n        val maxKeyValue = maxValues(maxKeyIndex)\n\
    \        val maxKeyIndex = keys.indexOf(maxKey)\n        val maxKeyValue = maxValues(maxKeyIndex)\n\
    \        val maxKeyIndex = keys.indexOf(maxKey)\n        val maxKeyValue = maxValues(maxKeyIndex)\n\
    \        val maxKeyIndex = keys.indexOf(maxKey)\n        val maxKeyValue = maxValues(maxKeyIndex)\n\
    \        val maxKeyIndex = keys.indexOf(maxKey)\n        val maxKeyValue = maxValues(maxKeyIndex)\n\
    \        val maxKeyIndex = keys.indexOf(maxKey)\n        val maxKeyValue = maxValues(maxKeyIndex)\n\
    \        val maxKeyIndex = keys.indexOf(maxKey)\n        val maxKeyValue = maxValues(maxKeyIndex)\n\
    \        val maxKeyIndex = keys.indexOf(maxKey)\n        val maxKeyValue = maxValues(maxKeyIndex)\n\
    \        val maxKeyIndex = keys.indexOf(maxKey)\n        val maxKeyValue = maxValues(maxKeyIndex)\n\
    \        val maxKeyIndex = keys.indexOf(maxKey)\n        val maxKeyValue = maxValues(maxKeyIndex)\n\
    \        val maxKeyIndex = keys.indexOf(maxKey)\n        val maxKeyValue = maxValues(maxKeyIndex)\n\
    \        val maxKeyIndex = keys.indexOf(maxKey)\n        val maxKeyValue = maxValues(maxKeyIndex)\n\
    \        val maxKeyIndex = keys.indexOf(maxKey)\n        val maxKeyValue = maxValues(maxKeyIndex)\n\
    \        val maxKeyIndex = keys.indexOf(maxKey)\n        val maxKeyValue = ",
  "        val rollingMax = numbers.foldLeft(List[Long]())((acc, number) => {\n  \
    \          val maxIndex = acc.lastIndexWhere(x => x > number)\n            if\
    \ (maxIndex == -1)\n                acc :+ number\n            else\n        \
    \        acc :+ max(acc.drop(maxIndex), number)\n        })\n        rollingMax.reverse",
  "        val maxList = mutable.ListBuffer[Long]()\n        numbers.foreach { number\
    \ =>\n            val maxElement = number + 1\n            maxList += maxElement\n\
    \        }\n        maxList.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxIndex = maxList.lastIndex\n\
    \            if (maxIndex == -1) {\n                maxList += number\n      \
    \      } else {\n                val maxValue = maxList(maxIndex)\n          \
    \      if (number > maxValue) {\n                    maxList += number\n     \
    \           }\n            }\n        }\n        maxList.toList", "        val\
    \ maxRollingNumbers = mutable.ListBuffer.empty[Long]\n        var maxRollingNumber\
    \ = 0L\n        var currentMaxRollingNumber = 0L\n        var currentMaxRollingNumberIndex\
    \ = 0\n        var currentMaxRollingNumberIndexMax = 0\n        var currentMaxRollingNumberIndexMin\
    \ = 0\n        var currentMaxRollingNumberIndexMinMax = 0\n        var currentMaxRollingNumberIndexMaxMin\
    \ = 0\n        var currentMaxRollingNumberIndexMaxMinMax = 0\n        var currentMaxRollingNumberIndexMinMaxMax\
    \ = 0\n        var currentMaxRollingNumberIndexMaxMinMaxMax = 0\n        var currentMaxRollingNumberIndexMinMaxMaxMax\
    \ = 0\n        var currentMaxRollingNumberIndexMaxMinMaxMax = 0\n        var currentMaxRollingNumberIndexMinMaxMaxMax\
    \ = 0\n        var currentMaxRollingNumberIndexMaxMinMaxMax = 0\n        var currentMaxRollingNumberIndexMinMaxMaxMax\
    \ = 0\n        var currentMaxRollingNumberIndexMaxMinMaxMax = 0\n        var currentMaxRollingNumberIndexMinMaxMaxMax\
    \ = 0\n        var currentMaxRollingNumberIndexMaxMinMaxMax = 0\n        var currentMaxRollingNumberIndexMinMaxMaxMax\
    \ = 0\n        var currentMaxRollingNumberIndexMaxMinMaxMax = 0\n        var currentMaxRollingNumberIndexMinMaxMaxMax\
    \ = 0\n        var currentMaxRollingNumberIndexMaxMinMaxMax = 0\n        var currentMaxRollingNumberIndexMinMaxMaxMax\
    \ = 0\n        var currentMaxRollingNumberIndexMaxMinMaxMax = 0\n        var currentMaxRollingNumberIndexMinMaxMaxMax\
    \ = 0\n        var currentMaxRollingNumberIndexMaxMinMaxMax = 0\n        var currentMaxRollingNumberIndexMinMaxMaxMax\
    \ = 0\n        var currentMaxRollingNumberIndexMaxMinMaxMax = 0\n        var currentMaxRollingNumberIndexMinMaxMaxMax\
    \ = 0\n        var currentMaxRollingNumberIndexMaxMinMaxMax = 0\n        var currentMaxRollingNumberIndexMinMaxMaxMax\
    \ = 0\n        var currentMaxRollingNumberIndexMaxMinMaxMax = 0\n        var currentMaxRollingNumberIndexMinMaxMaxMax\
    \ = 0\n        var currentMaxRollingNumberIndexMaxMinMaxMax = 0\n        var currentMaxRollingNumberIndexMinMaxMaxMax\
    \ = 0\n        var currentMaxRollingNumberIndexMaxMinMaxMax = 0\n        var currentMaxRollingNumberIndexMinMaxMaxMax\
    \ = 0\n        var currentMaxRollingNumberIndexMaxMinMaxMax = 0\n        var currentMaxRollingNumberIndexMinMaxMaxMax\
    \ = 0\n        var currentMaxRollingNumberIndexMaxMinMaxMax = 0\n        var ",
  "        val max = new mutable.ListBuffer[Long]()\n        numbers.foreach(x =>\
    \ if (x > max.last) max += x)\n        max.toList", "        val maxes = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach { n =>\n            val maxIndex = numbers.indexWhere(x\
    \ => x > n)\n            if (maxIndex < 0) maxes += n\n            else maxes\
    \ += numbers(maxIndex - 1)\n        }\n        maxes", "        val rollingMax\
    \ = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number =>\n    \
    \        rollingMax.append(number)\n            rollingMax.lastOption.getOrElse(rollingMax.lastOption.getOrElse(0l)\
    \ + number).foreach { rollingMax =>\n                rollingMax.append(rollingMax.lastOption.getOrElse(0l)\
    \ + number)\n            }\n        }\n        rollingMax.toList", "        val\
    \ max = new mutable.HashMap[Long, Long]()\n        val maxIndex = new mutable.HashMap[Long,\
    \ Int]()\n        numbers.foreach(n => {\n            val maxValue = max.getOrElse(n,\
    \ 0)\n            if (maxValue < n) max.update(n, maxValue + 1)\n            else\
    \ max.update(n, maxValue)\n        })\n        val maxIndexList = maxIndex.toList.sortBy(_._1).reverse\n\
    \        val maxIndexListWithIndex = maxIndexList.map(x => (x._1, x._2))\n   \
    \     val maxIndexListWithIndexWithMaxValue = maxIndexListWithIndex.map(x => (x._1,\
    \ x._2, x._3))\n        val maxIndexListWithIndexWithMaxValueWithMaxValue = maxIndexListWithIndexWithMaxValue.map(x\
    \ => (x._1, x._2, x._3, x._4))\n        val maxIndexListWithIndexWithMaxValueWithMaxValueWithMaxValue\
    \ = maxIndexListWithIndexWithMaxValueWithMaxValueWithMaxValue.map(x => (x._1,\
    \ x._2, x._3, x._4, x._5))\n        val maxIndexListWithIndexWithMaxValueWithMaxValueWithMaxValueWithMaxValue\
    \ = maxIndexListWithIndexWithMaxValueWithMaxValueWithMaxValueWithMaxValue.map(x\
    \ => (x._1, x._2, x._3, x._4, x._5, x._6))\n        val maxIndexListWithIndexWithMaxValueWithMaxValueWithMaxValueWithMaxValueWithMaxValue\
    \ = maxIndexListWithIndexWithMaxValueWithMaxValueWithMaxValueWithMaxValueWithMaxValue.map(x\
    \ => (x._1, x._2, x._3, x._4, x._5, x._6, x._7))\n        val maxIndexListWithIndexWithMaxValueWithMaxValueWithMaxValueWithMaxValueWithMaxValueWithMaxValue\
    \ = maxIndexListWithIndexWithMaxValueWithMaxValueWithMaxValueWithMaxValueWithMaxValueWithMaxValue.map(x\
    \ => (x._1, x._2, x._3, x._4, x._5, x._6, x._7, x._8))\n        val maxIndexListWithIndexWithMaxValueWithMaxValueWithMaxValueWithMaxValueWithMaxValueWithMaxValueWithMaxValue\
    \ = maxIndexListWithIndexWithMaxValueWithMaxValueWithMaxValueWithMaxValueWithMaxValueWithMaxValueWithMaxValue.map(x\
    \ => (x._1, x._2, x._3, x._4, x._5, x._6, x._7, x._8, x._9))\n        val maxIndexList",
  "        val maxRollingNumbers = mutable.ListBuffer.empty[Long]\n        var maxRollingNumbersIndex\
    \ = -1\n        var maxRollingNumbersValue = numbers(0)\n        var maxRollingNumbersIndexInCurrentRollingNumbers\
    \ = 0\n        for (i <- 0 until numbers.size) {\n            if (numbers(i) >\
    \ maxRollingNumbersValue) {\n                maxRollingNumbersIndex = i\n    \
    \            maxRollingNumbersValue = numbers(i)\n                maxRollingNumbersIndexInCurrentRollingNumbers\
    \ = 0\n            } else if (numbers(i) == maxRollingNumbersValue) {\n      \
    \          maxRollingNumbersIndexInCurrentRollingNumbers += 1\n            }\n\
    \            if (maxRollingNumbersIndexInCurrentRollingNumbers == maxRollingNumbersIndex)\
    \ {\n                maxRollingNumbers += numbers(i)\n            }\n        }\n\
    \        maxRollingNumbers", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach{ number =>\n            val maxNumber = maxList.max\n\
    \            if (number > maxNumber) {\n                maxList += number\n  \
    \          }\n        }\n        maxList.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach{ n =>\n            val maxKey = max(n, n)\n\
    \            if (maxKey > 0) max.put(maxKey, max(n, n))\n        }\n        max.values.toList",
  "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            if (number >\
    \ rollingMax(maxIndex)) rollingMax :+ number\n            else rollingMax\n  \
    \      })\n        rollingMax.reverse", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            if (max.containsKey(n))\
    \ {\n                max.put(n, Math.max(max(n), n))\n            } else {\n \
    \               max.put(n, n)\n            }\n        }\n        val result: List[Long]\
    \ = new mutable.ListBuffer[Long]()\n        max.foreach { case (k, v) =>\n   \
    \         result.add(v)\n        }\n        result.toList", "        val max =\
    \ new mutable.HashMap[Long, Long]()\n        numbers.foreach{ x =>\n         \
    \   val max = max.getOrElse(x, x)\n            max.update(x, max.get(x) + 1)\n\
    \        }\n        val result = new mutable.ListBuffer[Long]()\n        max.foreach{\
    \ x =>\n            result += x\n        }\n        result.toList", "        val\
    \ maxList = mutable.ListBuffer[Long]()\n        val rollingMax = mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(number => {\n            rollingMax.append(number)\n\
    \            if (rollingMax.size == numbers.size)\n                maxList.append(rollingMax.max)\n\
    \        })\n        return maxList.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        var maxValue = numbers(0)\n        var maxIndex = 0\n        var index\
    \ = 0\n        while(index < numbers.size) {\n            if(numbers(index) >\
    \ maxValue) {\n                maxValue = numbers(index)\n                maxIndex\
    \ = index\n            }\n            index += 1\n        }\n        maxList +=\
    \ maxValue\n        for(i <- 1 to maxIndex) {\n            maxList += numbers(i)\n\
    \        }\n        maxList.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { number =>\n            val max = number.toLong\n\
    \            val maxKey = max.toLong\n            if (max.toLong > maxKey(maxKey))\
    \ {\n                max.clear()\n                max.put(maxKey, number)\n  \
    \          }\n        }\n        max.values.toList", "        val rollingMax =\
    \ numbers.foldLeft(List[Long]())((acc, x) => {\n            val maxIndex = acc.indexWhere(x\
    \ => x > x)\n            if (maxIndex == acc.length - 1) {\n                acc\
    \ :+ x\n            } else {\n                acc :+ max(acc(maxIndex), x)\n \
    \           }\n        })\n        rollingMax.reverse", "        val max = new\
    \ mutable.HashMap[Long, Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x,\
    \ 0L) + x))\n        val maxList = max.toList.sortBy(_._1).reverse\n        val\
    \ rollingMax = maxList.takeWhile(_._2 > numbers(0)).map(_._1)\n        rollingMax",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach(number\
    \ => {\n            val maxValue = number match {\n                case x if x\
    \ > maxList.length => x\n                case x => maxList(x)\n            }\n\
    \            maxList += maxValue\n        })\n        maxList.toList", "     \
    \   val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) => {\n\
    \            if (rollingMax.isEmpty || number > rollingMax.last)\n           \
    \     rollingMax :+ number\n            else\n                rollingMax\n   \
    \     })\n        rollingMax.reverse", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach{ n =>\n            val maxIndex = numbers.indexWhere(x\
    \ => x > n)\n            if (maxIndex > 0) {\n                maxes += numbers(maxIndex)\n\
    \                numbers.remove(maxIndex)\n            }\n        }\n        maxes",
  "        val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number\
    \ =>\n            val maxIndex = numbers.indexWhere(_ > number)\n            if\
    \ (maxIndex == numbers.size) {\n                maxes += number\n            }\
    \ else {\n                maxes += numbers(maxIndex + 1)\n            }\n    \
    \    }\n        maxes", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(n => max.put(n, max.getOrElse(n, n) + n))\n        val\
    \ result = new mutable.ListBuffer[Long]()\n        max.values.foreach(n => result\
    \ += n)\n        result.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n        numbers.foreach\
    \ { number =>\n            val maxKey = max.keySet().toList.max\n            val\
    \ maxValue = max.get(maxKey)\n            if (maxValue < number) {\n         \
    \       max.put(number, number)\n            } else {\n                max.put(number,\
    \ maxValue + 1)\n            }\n        }\n        rollingMax.clear()\n      \
    \  max.foreach { case (number, maxValue) =>\n            rollingMax += number\n\
    \            if (maxValue > number) {\n                rollingMax += maxValue\n\
    \            }\n        }\n        rollingMax.toList", "        val max = new\
    \ mutable.HashMap[Long, Long]()\n        numbers.foreach { number =>\n       \
    \     val max = number.toLong\n            max.foreach { maxNumber =>\n      \
    \          val maxKey = maxNumber + max\n                if (max.contains(maxKey))\
    \ {\n                    max.remove(maxKey)\n                } else {\n      \
    \              max.put(maxKey, number)\n                }\n            }\n   \
    \     }\n        max.values.toList", "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax,\
    \ number) => {\n            val maxIndex = rollingMax.lastIndex\n            rollingMax.updated(maxIndex\
    \ + 1, number)\n        })\n        rollingMax.reverse", "        val max = new\
    \ mutable.HashMap[Long, Long]()\n        numbers.foreach{ n =>\n            val\
    \ maxKey = max.max.key\n            if (maxKey < n) max.updated(maxKey, n)\n \
    \       }\n        max.values.toList", "        val rollingMax = numbers.foldLeft(List[Long]())((acc,\
    \ x) => {\n            val max = acc.max\n            if (max < x) x :: acc\n\
    \            else acc :+ max\n        })\n        rollingMax.reverse", "     \
    \   val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max += ((x, x)))\n        val maxList = max.toList.sortBy(_._1).reverse.takeWhile(_._2\
    \ != _._2).map(_._1)\n        val maxList2 = max.toList.sortBy(_._1).reverse.takeWhile(_._2\
    \ != _._2).map(_._2)\n        val maxList3 = max.toList.sortBy(_._2).reverse.takeWhile(_._2\
    \ != _._1).map(_._1)\n        val maxList4 = max.toList.sortBy(_._2).reverse.takeWhile(_._2\
    \ != _._1).map(_._2)\n        val maxList5 = max.toList.sortBy(_._1).reverse.takeWhile(_._2\
    \ != _._2).map(_._1)\n        val maxList6 = max.toList.sortBy(_._1).reverse.takeWhile(_._2\
    \ != _._2).map(_._2)\n        val maxList7 = max.toList.sortBy(_._2).reverse.takeWhile(_._2\
    \ != _._1).map(_._1)\n        val maxList8 = max.toList.sortBy(_._2).reverse.takeWhile(_._2\
    \ != _._1).map(_._2)\n        val maxList9 = max.toList.sortBy(_._1).reverse.takeWhile(_._2\
    \ != _._2).map(_._1)\n        val maxList10 = max.toList.sortBy(_._1).reverse.takeWhile(_._2\
    \ != _._2).map(_._2)\n        val maxList11 = max.toList.sortBy(_._2).reverse.takeWhile(_._2\
    \ != _._1).map(_._1)\n        val maxList12 = max.toList.sortBy(_._2).reverse.takeWhile(_._2\
    \ != _._1).map(_._2)\n        val maxList13 = max.toList.sortBy(_._1).reverse.takeWhile(_._2\
    \ != _._2).map(_._1)\n        val maxList14 = max.toList.sortBy(_._1).reverse.takeWhile(_._2\
    \ != _._2).map(_._2)\n        val maxList15 = max.toList.sortBy(_._2).reverse.takeWhile(_._2\
    \ != _._1).map(_._1)\n        val maxList16 = max.toList.sortBy(_._2).reverse.takeWhile(_._2\
    \ != _._1).map(_._2)\n        val maxList17 = max.toList.sortBy(_._1).reverse.takeWhile",
  "        val maxList = mutable.ListBuffer[Long]()\n        numbers.foreach(x =>\
    \ maxList += x)\n        val maxIndex = maxList.indexOf(0)\n        val maxElement\
    \ = maxList.take(maxIndex)\n        val maxList = maxList.drop(maxIndex)\n   \
    \     val newList = maxList.take(numbers.size - maxList.size)\n        numbers\
    \ = numbers ++ newList\n        numbers", "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax,\
    \ number) => {\n            val maxIndex = rollingMax.lastIndex\n            if\
    \ (maxIndex == rollingMax.size - 1) {\n                rollingMax :+ number\n\
    \            } else {\n                val maxValue = rollingMax(maxIndex + 1)\n\
    \                if (number > maxValue) {\n                    rollingMax :+ number\n\
    \                } else {\n                    rollingMax\n                }\n\
    \            }\n        })\n        rollingMax", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            val max = max.getOrElseUpdate(n,\
    \ n)\n        }\n        val maxList = max.toList.sortWith(_ < _)\n        val\
    \ rollingMax = maxList.takeRight(numbers.size)\n        rollingMax.reverse", " \
    \       val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            val maxNumber = maxList.max\n            if (maxNumber\
    \ < number) {\n                maxList += number\n            }\n        }\n \
    \       maxList.toList", "        val rollingMax = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ math.max(acc(0), x))\n        rollingMax.reverse", "        val\
    \ rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n            val rollingMax\
    \ = acc.lastOption.filter(_ > x)\n            if (rollingMax.isEmpty) x :: acc\n\
    \            else x :: rollingMax\n        })\n        rollingMax.reverse", " \
    \       val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0L) + x))\n        val maxes = max.toList.sortBy(_._1).reverse\n\
    \        val maxesList = maxes.map(x => x._2)\n        val maxesList2 = maxes.map(x\
    \ => x._1)\n        val maxesList3 = maxes.map(x => x._2)\n        val maxesList4\
    \ = maxes.map(x => x._1)\n        val maxesList5 = maxes.map(x => x._2)\n    \
    \    val maxesList6 = maxes.map(x => x._1)\n        val maxesList7 = maxes.map(x\
    \ => x._2)\n        val maxesList8 = maxes.map(x => x._1)\n        val maxesList9\
    \ = maxes.map(x => x._2)\n        val maxesList10 = maxes.map(x => x._1)\n   \
    \     val maxesList11 = maxes.map(x => x._2)\n        val maxesList12 = maxes.map(x\
    \ => x._1)\n        val maxesList13 = maxes.map(x => x._2)\n        val maxesList14\
    \ = maxes.map(x => x._1)\n        val maxesList15 = maxes.map(x => x._2)\n   \
    \     val maxesList16 = maxes.map(x => x._1)\n        val maxesList17 = maxes.map(x\
    \ => x._2)\n        val maxesList18 = maxes.map(x => x._1)\n        val maxesList19\
    \ = maxes.map(x => x._2)\n        val maxesList20 = maxes.map(x => x._1)\n   \
    \     val maxesList21 = maxes.map(x => x._2)\n        val maxesList22 = maxes.map(x\
    \ => x._1)\n        val maxesList23 = maxes.map(x => x._2)\n        val maxesList24\
    \ = maxes.map(x => x._1)\n        val maxesList25 = maxes.map(x => x._2)\n   \
    \     val maxesList26 = maxes.map(x => x._1)\n        val maxesList27 = maxes.map(x\
    \ => x._2)\n        val maxesList28 = maxes.map(x => x._1)\n        val maxesList29\
    \ = maxes.map(x => x._2)\n        val maxesList30 = maxes.map(x => x._", "   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0L) + x))\n        max.values.toList", "       \
    \ val maxList = mutable.ListBuffer.empty[Long]\n        val maxIndex = -1\n  \
    \      numbers.foreach { number =>\n            number match {\n             \
    \   case x if x > maxList.getOrElse(maxIndex) =>\n                    maxIndex\
    \ += 1\n                    maxList += x\n                case x =>\n        \
    \            maxList += x\n            }\n        }\n        maxList.toList",
  "        val max = new mutable.ListBuffer[Long]()\n        val maxIndex = new mutable.ListBuffer[Long]()\n\
    \        val maxIndex2 = new mutable.ListBuffer[Long]()\n        numbers.foreach\
    \ { number =>\n            if (number.toLong > max.lastOption.getOrElse(0l)) {\n\
    \                max += number.toLong\n                maxIndex += number.toLong\n\
    \                maxIndex2 += number.toLong\n            }\n        }\n      \
    \  val maxIndex = maxIndex.sorted\n        val maxIndex2 = maxIndex2.sorted\n\
    \        val maxIndex3 = maxIndex2.zipWithIndex.filter(_._2 % 2 == 0).map(_._1).sorted\n\
    \        val maxIndex4 = maxIndex3.zipWithIndex.filter(_._2 % 2 == 1).map(_._1).sorted\n\
    \        val maxIndex5 = maxIndex4.zipWithIndex.filter(_._2 % 2 == 2).map(_._1).sorted\n\
    \        val maxIndex6 = maxIndex5.zipWithIndex.filter(_._2 % 2 == 3).map(_._1).sorted\n\
    \        val maxIndex7 = maxIndex6.zipWithIndex.filter(_._2 % 2 == 4).map(_._1).sorted\n\
    \        val maxIndex8 = maxIndex7.zipWithIndex.filter(_._2 % 2 == 5).map(_._1).sorted\n\
    \        val maxIndex9 = maxIndex8.zipWithIndex.filter(_._2 % 2 == 6).map(_._1).sorted\n\
    \        val maxIndex10 = maxIndex9.zipWithIndex.filter(_._2 % 2 == 7).map(_._1).sorted\n\
    \        val maxIndex11 = maxIndex10.zipWithIndex.filter(_._2 % 2 == 8).map(_._1).sorted\n\
    \        val maxIndex12 = maxIndex11.zipWithIndex.filter(_._2 % 2 == 9).map(_._1).sorted\n\
    \        val maxIndex13 = maxIndex12.zipWithIndex.filter(_._2 % 2 == 10).map(_._1).sorted\n\
    \        val maxIndex14 = maxIndex13.zipWithIndex.filter(_._2 % 2 == 11).map(_._1).sorted\n\
    \        val maxIndex15 = maxIndex14.zipWithIndex.filter(_._2 % 2 == 12).map(_._1).sorted\n\
    \        val maxIndex16 = maxIndex15.zipWithIndex.filter(_._2 % 2 == 13).map(_._1).sorted\n\
    \        val maxIndex17 = maxIndex16.zipWithIndex.filter(_._2 % 2 == 14).map(_._1).sorted\n\
    \        val maxIndex18 = maxIndex17.", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxIndex = maxList.lastIndex\n\
    \            if (maxIndex == -1) {\n                maxList += number\n      \
    \      } else {\n                val maxValue = maxList(maxIndex)\n          \
    \      if (number > maxValue) {\n                    maxList += number\n     \
    \           }\n            }\n        }\n        maxList.toList", "        val\
    \ rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n            val maxIndex\
    \ = acc.indexWhere(x => x > x)\n            if (maxIndex == acc.length - 1) acc\
    \ :+ x\n            else acc :+ acc.apply(maxIndex + 1)\n        })\n        rollingMax.reverse",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l) + x))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val rollingMax = max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max max max max max max max max max max\
    \ max max max max max max max max max max ", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            val maxKey = max.max.key\n\
    \            if (maxKey < n) max.updated(maxKey, n)\n            else max\n  \
    \      }\n        max.values.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            val maxKey = max.max.key\n\
    \            val maxValue = max.max.value\n            if (maxKey < n)\n     \
    \           max.put(maxKey, n)\n            else\n                max.put(maxKey,\
    \ maxValue + 1)\n        }\n        val result = new mutable.ArrayList[Long]()\n\
    \        max.foreach { case (k, v) =>\n            if (v > 1)\n              \
    \  result.add(k)\n        }\n        result.toList", "        val rollingMax =\
    \ numbers.foldLeft(List[Long]())((acc, x) => {\n            if (acc.isEmpty) {\n\
    \                acc :+ x\n            } else {\n                if (acc.last\
    \ > x) {\n                    acc :+ x\n                } else {\n           \
    \         acc\n                }\n            }\n        })\n        rollingMax",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l) + x))\n        val maxList = max.values.toList\n\
    \        val maxListWithIndex = numbers.zip(maxList).map { case (x, y) => x ->\
    \ y }.toMap\n        val maxListWithIndexSortedByValue = maxListWithIndex.sortBy(_._2)\n\
    \        val maxListWithIndexSortedByValueReversed = maxListWithIndexSortedByValue.reverse\n\
    \        val maxListWithIndexSortedByValueReversedWithIndex = maxListWithIndexSortedByValueReversed.map\
    \ { case (x, y) => y -> x }.toMap\n        val maxListWithIndexSortedByValueReversedWithIndexSortedByValue\
    \ = maxListWithIndexSortedByValueReversedWithIndex.sortBy(_._1)\n        maxListWithIndexSortedByValueReversedWithIndexSortedByValue.reverse",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ number =>\n            val maxKey = math.max(number, max.getOrElse(number, number))\n\
    \            max += number -> maxKey\n        }\n        max.values.toList", " \
    \       val rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n      \
    \      val maxIndex = acc.indexWhere(x => x > x)\n            if (maxIndex ==\
    \ acc.length - 1) acc :+ x\n            else acc :+ acc.apply(maxIndex + 1)\n\
    \        })\n        rollingMax.reverse", "        val rollingMax = numbers.foldLeft(List[Long]())((acc,\
    \ x) => {\n            val maxIndex = acc.indexWhere(x => x > x)\n           \
    \ if (maxIndex == acc.length - 1) {\n                acc :+ x\n            } else\
    \ {\n                acc :+ max(acc(maxIndex + 1), x)\n            }\n       \
    \ })\n        rollingMax.reverse", "        val rollingMax = numbers.foldLeft(List[Long]())((acc,\
    \ x) => if (acc.isEmpty) x :: acc else x :: acc.maxBy(_ > _))\n        rollingMax.reverse",
  "        val max = new mutable.HashMap[Long, Long]()\n        val rollingMax = new\
    \ mutable.ArrayBuffer[Long]()\n        numbers.foreach{ n =>\n            val\
    \ maxKey = max.getOrElse(n, 0)\n            val newMaxKey = maxKey + 1\n     \
    \       max.put(newMaxKey, n)\n            rollingMax.append(newMaxKey)\n    \
    \    }\n        rollingMax.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(n => max.put(n, Math.max(n, max.getOrElse(n,0L))))\n\
    \        val result = new mutable.ListBuffer[Long]()\n        max.foreach(n =>\
    \ result += n)\n        result.toList", "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax,\
    \ number) => {\n            val rollingMax = rollingMax.maxBy(x => math.abs(x\
    \ - number))\n            rollingMax :: rollingMax\n        })\n        rollingMax.reverse"]
stop_tokens:
- "\n    }\n"
