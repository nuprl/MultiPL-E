name: HumanEval_9_rolling_max
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers\
  \ : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
  \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
  \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
  \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
  \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
  \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
completions: ["        val max = new mutable.ListBuffer[Long]()\n        numbers.foreach{\
    \ n =>\n            val maxNr = max.maxBy(_.toLong)\n            if (maxNr < n.toLong)\
    \ {\n                max += n\n            }\n        }\n        max.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ number =>\n            val maxKey = number.toLong\n            val maxValue\
    \ = max.getOrElse(maxKey, 0L)\n            val newValue = maxValue + 1\n     \
    \       max.put(maxKey, newValue)\n        }\n        val result = new mutable.ArrayList[Long]()\n\
    \        max.foreach { case (maxKey, maxValue) =>\n            result.add(maxValue)\n\
    \        }\n        result", "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax,\
    \ number) => {\n            val maxIndex = rollingMax.lastIndex\n            val\
    \ maxValue = rollingMax(maxIndex)\n            if (number > maxValue) {\n    \
    \            rollingMax :+ number\n            } else {\n                rollingMax\n\
    \            }\n        })\n        rollingMax", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        var max = 0\n        var currentMax = 0\n        var currentIndex = 0\n\
    \        numbers.foreach{\n            number =>\n                max = number\n\
    \                currentMax = number\n                currentIndex = 0\n     \
    \   }\n        numbers.foreach{\n            number =>\n                currentMax\
    \ = number\n                currentIndex += 1\n                rollingMax.append(currentMax)\n\
    \        }\n        rollingMax.toList", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(x => maxes += x)\n        val maxesList = maxes.toList\n\
    \        val maxesListSize = maxesList.size\n        val maxesListIterator = maxesList.iterator\n\
    \        val maxesListIteratorSize = maxesListIterator.size\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = maxesListIterator.index\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = maxesListIterator.index\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = maxesListIterator.index\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = maxesListIterator.index\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = maxesListIterator.index\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = maxesListIterator.index\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = maxesListIterator.index\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = maxesListIterator.index\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = maxesListIterator.index\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = maxesListIterator.index\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndex\
    \ = maxesListIterator.index\n        val maxesListIteratorIndex = ", "       \
    \ val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n => max.put(n,\
    \ max.getOrElse(n, n) + n))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.values.foreach(n => result += n)\n        result.toList", "     \
    \   val rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n          \
    \  val maxIndex = acc.indexWhere(x => x > x)\n            if (maxIndex < acc.length)\
    \ x :: acc\n            else acc :+ x\n        })\n        rollingMax.reverse",
  "        val max = new mutable.HashMap[Long, Long]()\n        val maxList = new\
    \ mutable.ListBuffer[Long]()\n        numbers.foreach { n =>\n            val\
    \ maxKey = max.max.key\n            if (maxKey == null || n < maxKey) {\n    \
    \            max.put(n, n)\n            } else {\n                val maxValue\
    \ = max.max.value\n                if (maxValue < n) {\n                    max.put(n,\
    \ maxValue)\n                } else {\n                    max.remove(maxKey)\n\
    \                }\n            }\n        }\n        val maxList = max.values.toList\n\
    \        val maxList2 = maxList.sortWith(_ > _)\n        maxList2.reverse", " \
    \       val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l) + x))\n        val maxList = max.values.toList\n\
    \        val maxIndex = max.keys.toList\n        val maxElements = maxList.take(maxIndex.size)\n\
    \        val maxElementsIndex = maxIndex.zip(maxElements)\n        val maxElementsIndex\
    \ = maxElementsIndex.sortBy(_._1).reverse\n        val maxElementsIndex = maxElementsIndex.take(maxElementsIndex.size\
    \ - 1).map(_._2)\n        val maxElementsIndex = maxElementsIndex.map(x => max(x)\
    \ + x)\n        val maxElementsIndex = maxElementsIndex.take(maxElementsIndex.size\
    \ - 1).map(_._2)\n        val maxElementsIndex = maxElementsIndex.map(x => max(x)\
    \ + x)\n        val maxElementsIndex = maxElementsIndex.take(maxElementsIndex.size\
    \ - 1).map(_._2)\n        val maxElementsIndex = maxElementsIndex.map(x => max(x)\
    \ + x)\n        val maxElementsIndex = maxElementsIndex.take(maxElementsIndex.size\
    \ - 1).map(_._2)\n        val maxElementsIndex = maxElementsIndex.map(x => max(x)\
    \ + x)\n        val maxElementsIndex = maxElementsIndex.take(maxElementsIndex.size\
    \ - 1).map(_._2)\n        val maxElementsIndex = maxElementsIndex.map(x => max(x)\
    \ + x)\n        val maxElementsIndex = maxElementsIndex.take(maxElementsIndex.size\
    \ - 1).map(_._2)\n        val maxElementsIndex = maxElementsIndex.map(x => max(x)\
    \ + x)\n        val maxElementsIndex = maxElementsIndex.take(maxElementsIndex.size\
    \ - 1).map(_._2)\n        val maxElementsIndex = maxElementsIndex.map(x => max(x)\
    \ + x)\n        val maxElementsIndex = maxElementsIndex.take(maxElementsIndex.size\
    \ - 1).map(_._2)\n        val maxElementsIndex = maxElementsIndex.map(x => max(x)\
    \ + x)\n        val maxElementsIndex = maxElementsIndex.take(maxElementsIndex.size\
    \ - 1).map(_._2)\n        val maxElementsIndex = maxElementsIndex.map(x => max(x)\
    \ + x)\n        val maxElementsIndex = maxElementsIndex.take(maxElementsIndex.size\
    \ - ", "        val max = new mutable.ListBuffer[Long]()\n        val maxIndex\
    \ = new mutable.ListBuffer[Int]()\n        numbers.foreach(n => {\n          \
    \  if (max.length < n) {\n                max += n\n                maxIndex +=\
    \ 0\n            } else {\n                val index = maxIndex.last\n       \
    \         if (maxIndex.last < n) {\n                    max += n\n           \
    \         maxIndex += index + 1\n                } else {\n                  \
    \  maxIndex += index\n                }\n            }\n        })\n        max.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l) + x))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.values.foreach(x => if (x > result.last) result += x)\n        result.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l) + x))\n        val maxList = new mutable.ListBuffer[Long]()\n\
    \        max.foreach(x => maxList += x)\n        val maxList = maxList.toList\n\
    \        val maxIndex = maxList.lastIndex\n        val maxValue = maxList(maxIndex)\n\
    \        val maxList = maxList.drop(maxIndex)\n        val maxList = maxList.take(maxList.size\
    \ - maxIndex).toList\n        maxList.zip(maxValue).filter(_._1 > _._1).map(_._2)",
  "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            if (number >\
    \ rollingMax(maxIndex)) {\n                rollingMax :+ number\n            }\
    \ else {\n                rollingMax\n            }\n        })\n        rollingMax.reverse",
  "        val rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n       \
    \     val maxIndex = acc.indexWhere(x => x > x)\n            val maxValue = acc((maxIndex\
    \ + 1))\n            if (maxValue < x) acc else acc :+ maxValue\n        })\n\
    \        rollingMax.reverse", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(x => maxList += x)\n        val maxIndex = maxList.lastIndex\n\
    \        val maxElement = maxList(maxIndex)\n        val maxList2 = maxList.drop(maxIndex\
    \ + 1)\n        val maxElement2 = maxList2.last\n        val maxList3 = maxList2.drop(1)\n\
    \        val maxElement3 = maxList3.last\n        val maxList4 = maxList3.drop(2)\n\
    \        val maxElement4 = maxList4.last\n        val maxList5 = maxList4.drop(3)\n\
    \        val maxElement5 = maxList5.last\n        val maxList6 = maxList5.drop(4)\n\
    \        val maxElement6 = maxList6.last\n        val maxList7 = maxList6.drop(5)\n\
    \        val maxElement7 = maxList7.last\n        val maxList8 = maxList7.drop(6)\n\
    \        val maxElement8 = maxList8.last\n        val maxList9 = maxList8.drop(7)\n\
    \        val maxElement9 = maxList9.last\n        val maxList10 = maxList9.drop(8)\n\
    \        val maxElement10 = maxList10.last\n        val maxList11 = maxList10.drop(9)\n\
    \        val maxElement11 = maxList11.last\n        val maxList12 = maxList11.drop(10)\n\
    \        val maxElement12 = maxList12.last\n        val maxList13 = maxList12.drop(11)\n\
    \        val maxElement13 = maxList13.last\n        val maxList14 = maxList13.drop(12)\n\
    \        val maxElement14 = maxList14.last\n        val maxList15 = maxList14.drop(13)\n\
    \        val maxElement15 = maxList15.last\n        val maxList16 = maxList15.drop(14)\n\
    \        val maxElement16 = maxList16.last\n        val maxList17 = maxList16.drop(15)\n\
    \        val maxElement17 = maxList17.last\n        val maxList18 = maxList17.drop(16)\n\
    \        val maxElement18 = maxList18.last\n        val maxList19 = maxList18.drop(17)\n\
    \        val maxElement19 = maxList19.last\n        val maxList20 = maxList19.drop(18)\n\
    \        val maxElement20 = maxList20.last\n        val maxList21 = maxList20.drop(19)\n\
    \        val maxElement21 = maxList21.last\n        val maxList22 = maxList21.drop(20)\n\
    \        val ", "        val max = new mutable.HashMap[Long, Long]()\n       \
    \ numbers.foreach(n => max += (n->max.getOrElse(n,0)))\n        numbers.map(n\
    \ => max(n))", "        val rollingMax = numbers.foldLeft(List[Long]())((acc,\
    \ x) => if (acc.isEmpty) x :: acc else x :: acc.maxBy(_._2)._1)\n        rollingMax.reverse",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach(x\
    \ => {\n            val maxIndex = maxList.lastIndex\n            if (maxIndex\
    \ == -1) {\n                maxList += x\n            } else {\n             \
    \   val maxValue = maxList(maxIndex)\n                if (x > maxValue) {\n  \
    \                  maxList += x\n                }\n            }\n        })\n\
    \        maxList.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l) + x))\n        val\
    \ result = new mutable.ListBuffer[Long]()\n        max.foreach {\n           \
    \ case (k, v) => result += k\n        }\n        result.toList", "        val\
    \ maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number =>\n\
    \            val maxNumber = maxList.max\n            if (maxNumber < number)\
    \ {\n                maxList += number\n            }\n        }\n        maxList.toList"]
stop_tokens:
- "\n    }\n"
