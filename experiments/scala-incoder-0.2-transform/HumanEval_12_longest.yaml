name: HumanEval_12_longest
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Out of list of strings, return the longest one. Return the first one in\
  \ case of multiple\n    // strings of the same length. Return None in case the input\
  \ list is empty.\n    // >>> longest((List[String]()))\n    // None\n    // >>>\
  \ longest((List[String](\"a\", \"b\", \"c\")))\n    // \"a\"\n    // >>> longest((List[String](\"\
  a\", \"bb\", \"ccc\")))\n    // \"ccc\"\n    def longest(strings : List[String])\
  \ : Option[String] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(longest((List[String]())).equals(None));\n\
  \    assert(longest((List[String](\"x\", \"y\", \"z\"))).equals(\"x\"));\n    assert(longest((List[String](\"\
  x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"))).equals(\"zzzz\"));\n    }\n\
  \n}\n"
completions: ['        strings.foldLeft(List[String]())((acc, s) => if (acc.length
    < s.length) acc else s)', "        if (strings.isEmpty) None\n        else {\n\
    \            val longest = strings.foldLeft(\"\")( (max: String, current: String)\
    \ => if (current.length >= max.length) current else max )\n            strings.find(\
    \ s => s.equals(longest)) // Find the first string with the same length\n    \
    \    }", "        if (strings.isEmpty) None\n        else strings.foldLeft(\"\"\
    )( (acc, s) => if (acc.length < s.length) acc else s)", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n  \
    \      }", "        if (strings.isEmpty) None\n        else {\n            val\
    \ longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc\
    \ else s)\n            Some(longest)\n        }", "        if (strings.isEmpty)\
    \ None\n        else strings.foldLeft(\"\") { (longest, string) =>\n         \
    \   if (string.length() > longest.length) string else longest\n        }", " \
    \       strings.foldLeft(List[String]())((acc, s) => {\n            val length\
    \ = s.length\n            val list = acc match {\n                case Nil =>\
    \ List(s)\n                case _ => s.toList ::: acc\n            }\n       \
    \     if (list.length == length) Some(list.max)\n            else None\n     \
    \   })", "        if (strings.isEmpty) None\n        else strings.foldLeft(strings.head)\
    \ {\n            case (longest, string) =>\n                if (string.length\
    \ == longest.length) string\n                else if (string.length < longest.length)\
    \ longest\n                else string\n        }", "        if (strings.isEmpty)\
    \ None\n        else strings.foldLeft(strings.headOption)((longest, s) => if (longest.isEmpty\
    \ || longest.length < s.length) longest else s)", "        if (strings.length\
    \ == 0) None\n        else {\n            val longest = strings.sortWith(_ < _).last\n\
    \            val firstDuplicate = strings.groupBy(identity).values.find(_.length\
    \ == longest.length)\n            firstDuplicate.headOption.getOrElse(longest)\n\
    \        }", "        strings.foldLeft(List[String]()){\n            case (acc,\
    \ s) => acc match {\n                case Nil => Some(s)\n                case\
    \ x :: xs => if (x.length > s.length) x :: xs else x\n            }\n        }.maxBy(_.length)",
  "        if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc else s)\n\
    \            Some(longest)\n        }", "        if (strings.isEmpty) None\n \
    \       else {\n            val longest = strings.foldLeft(\"\")(_ + _.length)\n\
    \            strings.find(_.length == longest).map(_.toUpperCase)\n        }",
  "        strings.foldLeft(List[String]()){ (list, s) =>\n            if (list.length\
    \ < s.length) list :+ s\n            else s\n        }.maxBy(_.length)", "   \
    \     if (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        if (strings.isEmpty) None\n        else {\n            val\
    \ longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc\
    \ else s)\n            Some(longest)\n        }", "        strings.foldLeft(List[String]())((acc,\
    \ s) => {\n            if (acc.length < s.length) acc :+ s\n            else acc\n\
    \        })\n            .maxBy(_.length)", "        if (strings.isEmpty) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (acc, s) =>\
    \ if (acc.length < s.length) acc else s)\n            Some(longest)\n        }",
  "        strings.foldLeft(List[String]())((acc, s) => acc match {\n            case\
    \ Nil => Some(s)\n            case x :: xs => if (s.length() > x.length()) Some(s)\
    \ else x\n        })", "        strings.foldLeft(None: Option[String]){\n    \
    \        case (Some(longest), string) =>\n                val length = string.length\n\
    \                if (length > longest.length) Some(string)\n                else\
    \ None\n        }"]
stop_tokens:
- "\n    }\n"
