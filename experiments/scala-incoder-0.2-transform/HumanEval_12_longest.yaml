name: HumanEval_12_longest
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Out of list of strings, return the longest one. Return the first one in\
  \ case of multiple\n    // strings of the same length. Return None in case the input\
  \ list is empty.\n    // >>> longest((List[String]()))\n    // None\n    // >>>\
  \ longest((List[String](\"a\", \"b\", \"c\")))\n    // \"a\"\n    // >>> longest((List[String](\"\
  a\", \"bb\", \"ccc\")))\n    // \"ccc\"\n    def longest(strings : List[String])\
  \ : Option[String] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(longest((List[String]())).equals(None));\n\
  \    assert(longest((List[String](\"x\", \"y\", \"z\"))).equals(\"x\"));\n    assert(longest((List[String](\"\
  x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"))).equals(\"zzzz\"));\n    }\n\
  \n}\n"
completions: ['        strings.foldLeft(List[String]())((acc, s) => if (acc.length
    < s.length) acc else s)', "        if (strings.isEmpty) None\n        else {\n\
    \            val longest = strings.foldLeft(\"\")( (max: String, current: String)\
    \ => if (current.length >= max.length) current else max )\n            strings.find(\
    \ s => s.equals(longest)) // Find the first string with the same length\n    \
    \    }", "        if (strings.isEmpty) None\n        else strings.foldLeft(\"\"\
    )( (acc, s) => if (acc.length < s.length) acc else s)", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n  \
    \      }", "        if (strings.isEmpty) None\n        else {\n            val\
    \ longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc\
    \ else s)\n            Some(longest)\n        }", "        if (strings.isEmpty)\
    \ None\n        else strings.foldLeft(\"\") { (longest, string) =>\n         \
    \   if (string.length() > longest.length) string else longest\n        }", " \
    \       strings.foldLeft(List[String]())((acc, s) => {\n            val length\
    \ = s.length\n            val list = acc match {\n                case Nil =>\
    \ List(s)\n                case _ => s.toList ::: acc\n            }\n       \
    \     if (list.length == length) Some(list.max)\n            else None\n     \
    \   })", "        if (strings.isEmpty) None\n        else strings.foldLeft(strings.head)\
    \ {\n            case (longest, string) =>\n                if (string.length\
    \ == longest.length) string\n                else if (string.length < longest.length)\
    \ longest\n                else string\n        }", "        if (strings.isEmpty)\
    \ None\n        else strings.foldLeft(strings.headOption)((longest, s) => if (longest.isEmpty\
    \ || longest.length < s.length) longest else s)", "        if (strings.length\
    \ == 0) None\n        else {\n            val longest = strings.sortWith(_ < _).last\n\
    \            val firstDuplicate = strings.groupBy(identity).values.find(_.length\
    \ == longest.length)\n            firstDuplicate.headOption.getOrElse(longest)\n\
    \        }", "        strings.foldLeft(List[String]()){\n            case (acc,\
    \ s) => acc match {\n                case Nil => Some(s)\n                case\
    \ x :: xs => if (x.length > s.length) x :: xs else x\n            }\n        }.maxBy(_.length)",
  "        if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc else s)\n\
    \            Some(longest)\n        }", "        if (strings.isEmpty) None\n \
    \       else {\n            val longest = strings.foldLeft(\"\")(_ + _.length)\n\
    \            strings.find(_.length == longest).map(_.toUpperCase)\n        }",
  "        strings.foldLeft(List[String]()){ (list, s) =>\n            if (list.length\
    \ < s.length) list :+ s\n            else s\n        }.maxBy(_.length)", "   \
    \     if (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        if (strings.isEmpty) None\n        else {\n            val\
    \ longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc\
    \ else s)\n            Some(longest)\n        }", "        strings.foldLeft(List[String]())((acc,\
    \ s) => {\n            if (acc.length < s.length) acc :+ s\n            else acc\n\
    \        })\n            .maxBy(_.length)", "        if (strings.isEmpty) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (acc, s) =>\
    \ if (acc.length < s.length) acc else s)\n            Some(longest)\n        }",
  "        strings.foldLeft(List[String]())((acc, s) => acc match {\n            case\
    \ Nil => Some(s)\n            case x :: xs => if (s.length() > x.length()) Some(s)\
    \ else x\n        })", "        strings.foldLeft(None: Option[String]){\n    \
    \        case (Some(longest), string) =>\n                val length = string.length\n\
    \                if (length > longest.length) Some(string)\n                else\
    \ None\n        }", "        if (strings.length == 0) None\n        else {\n \
    \           val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length <\
    \ s.length) acc else s)\n            Some(longest)\n        }", "        if (strings.length\
    \ == 0) None\n        else {\n            val longest = strings.foldLeft(\"\"\
    )( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        if (strings.isEmpty) None\n        else {\n            val\
    \ longest = strings.foldLeft(\"\")( (a,b) => if (a.length < b.length) a else b\
    \ )\n            strings.find(s => s == longest).getOrElse(longest)\n        }",
  "        if (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        if (strings.length == 0) None\n        else {\n        \
    \    val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length)\
    \ acc else s)\n            Some(longest)\n        }", "        if (strings.isEmpty)\
    \ None\n        else strings.sortWith(_ < _).lastOption", "        strings.foldLeft(List[String]())((acc,\
    \ s) => acc match {\n            case Nil => Some(s)\n            case x :: xs\
    \ => if (x.length > s.length) x :: acc else acc match {\n                case\
    \ Nil => Some(s)\n                case x :: xs => if (x.length > s.length) x ::\
    \ acc else acc match {\n                    case Nil => Some(s)\n            \
    \        case x :: xs => x :: longest(xs)\n                }\n            }\n\
    \        })", "        strings.foldLeft(List[String]())((acc, s) => {\n      \
    \      if (acc.length < s.length) acc :+ s\n            else Some(acc)\n     \
    \   })", "        strings.foldLeft(List[String]())((list, str) => {\n        \
    \    if (list.isEmpty || list.length < str.length) {\n                list :+\
    \ str\n            } else {\n                list\n            }\n        }).maxBy(_.length)",
  "        strings.foldLeft(List[String]()){\n            (acc, s) =>\n          \
    \      if (acc.length < s.length) acc :+ s\n                else acc\n       \
    \ }.maxBy(_.length)", "        if (strings.isEmpty) None\n        else {\n   \
    \         val longest = strings.foldLeft(\"\")(_ + _.length).max\n           \
    \ strings.find(_.length == longest)\n        }", '        strings.foldLeft(List[String]())(
    (acc, s) => if (acc.length < s.length) acc else s)', '        strings.foldLeft(List[String]())((acc,
    s) => if (acc.length < s.length) acc else s)', "        if (strings.isEmpty) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (acc, s) =>\
    \ if (acc.length < s.length) acc else s)\n            Some(longest)\n        }",
  "        if (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", '        strings.foldLeft(List[String]())((list, str) => if (list.length
    < str.length) list else str)', "        if (strings.length == 0) None\n      \
    \  else {\n            val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length\
    \ < s.length) acc else s)\n            Some(longest)\n        }", "        if\
    \ (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => {\n                if (acc.length < s.length) acc else s\n  \
    \          })\n            Some(longest)\n        }", "        strings.length\
    \ match {\n            case 0 => None\n            case 1 => strings.headOption\n\
    \            case _ => {\n                val longest = strings.foldLeft(List[String]())((acc,\
    \ s) => {\n                    val len = s.length\n                    if (len\
    \ > acc.lastOption.map(_.length).getOrElse(len)) {\n                        acc\
    \ :+ s\n                    } else {\n                        acc\n          \
    \          }\n                })\n                longest.headOption\n       \
    \     }\n        }", "        strings.foldLeft(List[String]())((list, s) => {\n\
    \            if (list.length < s.length) list :+ s\n            else list\n  \
    \      })\n            .maxBy(_.length)", "        strings.foldLeft(List[String]())((list,\
    \ string) => {\n            val length = string.length\n            if (list.length\
    \ < length) list :+ string\n            else list\n        })\n            .maxBy(_.length)",
  "        strings.foldLeft(None)( (acc, s) => {\n            val len = s.length\n\
    \            if (len > acc._2) {\n                Some(s)\n            } else\
    \ {\n                acc\n            }\n        })", "        strings.foldLeft(List[String]())(\
    \ (acc, s) => {\n            if (acc.length < s.length) acc :+ s\n           \
    \ else acc\n        })\n            .maxBy(_.length)", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => {\n                if (acc.length < s.length) acc else s\n           \
    \ })\n            strings.find(s => s == longest) match {\n                case\
    \ Some(longest) => Some(longest)\n                case None => None\n        \
    \    }\n        }", "        strings.foldLeft(List[String]())(\n            list\
    \ => list match {\n                case Nil => None\n                case head\
    \ :: tail => if (head.length == list.head.length) head else list.head\n      \
    \      }\n        )", "        if (strings.isEmpty) None\n        else {\n   \
    \         val longest = strings.foldLeft(\"\")( (a, b) => if (a.length < b.length)\
    \ a else b )\n            strings.find(s => s == longest) match {\n          \
    \      case Some(longest) => Some(longest)\n                case None => None\n\
    \            }\n        }", "        if (strings.isEmpty) None\n        else {\n\
    \            val longest = strings.foldLeft(\"\")( (a,b) => if (a.length < b.length)\
    \ a else b )\n            strings.find(s => s == longest).getOrElse(longest)\n\
    \        }", '        strings.foldLeft(List[String]())((acc, s) => if (acc.length
    < s.length) acc else s)', "        if (strings.isEmpty) None\n        else {\n\
    \            val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length\
    \ < s.length) acc else s)\n            Some(longest)\n        }", "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            if (list.length < str.length) list :+ str\n         \
    \   else if (list.length == str.length) list :+ str\n            else None\n \
    \       })", "        if (strings.isEmpty) None\n        else {\n            val\
    \ longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc\
    \ else s)\n            Some(longest)\n        }", "        strings.foldLeft(List[String]())((list,\
    \ str) => list match {\n            case Nil => Some(str)\n            case head\
    \ :: tail => if (head.length == str.length) head :: list else tail\n        })",
  "        if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc else s)\n\
    \            Some(longest)\n        }", '        strings.foldLeft(List[String]())(
    (acc, s) => if (acc.length < s.length) acc else s)', "        strings.foldLeft(None)(\
    \ (maxLength, s) => {\n            val length = s.length\n            if (maxLength.isEmpty\
    \ || length > maxLength.get.length)\n                Some(s)\n            else\n\
    \                None\n        })", "        if (strings.isEmpty) None\n     \
    \   else {\n            val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length\
    \ < s.length) acc else s)\n            Some(longest)\n        }", "        if\
    \ (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        if (strings.length == 0) None\n        else {\n        \
    \    val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length)\
    \ acc else s)\n            Some(longest)\n        }", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n  \
    \      }", "        if (strings.length == 0) None\n        else strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)", '        strings.foldLeft(List[String]())((acc,
    s) => if (acc.length < s.length) acc else s)', "        strings.length match {\n\
    \            case 0 => None\n            case 1 => strings.headOption\n      \
    \      case _ => {\n                val longest = strings.foldLeft(List[String]())((acc,\
    \ s) => {\n                    if (acc.length < s.length) acc :+ s\n         \
    \           else acc\n                })\n                if (longest.length ==\
    \ strings.length) longest.headOption\n                else longest.headOption\n\
    \            }\n        }", "        if (strings.isEmpty) None\n        else {\n\
    \            val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length\
    \ < s.length) acc else s)\n            Some(longest)\n        }", "        strings.foldLeft(List[String]()){\n\
    \            case (acc, str) =>\n                val length = str.length\n   \
    \             if (acc.length < length) acc :+ str\n                else acc\n\
    \        }.maxBy(_.length)", "        if (strings.isEmpty) None\n        else\
    \ {\n            val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length\
    \ < s.length) acc else s)\n            Some(longest)\n        }", "        strings.foldLeft(List[String]())((acc,\
    \ s) => {\n            if (acc.length < s.length) acc :+ s\n            else Some(s)\n\
    \        })", "        strings.foldLeft(List[String]())( (acc, s) => acc match\
    \ {\n            case Nil => Some(s)\n            case _ => if (acc.length < s.length)\
    \ Some(s) else acc\n        })", "        strings.foldLeft(List[String]())((list,\
    \ string) => {\n            if (list.length < string.length) list :+ string\n\
    \            else list\n        })\n            .maxBy(_.length)", "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            if (list.isEmpty || list.length < str.length) list :+\
    \ str\n            else list\n        })\n            .maxBy(_.length)", "   \
    \     if (strings.length == 0) None\n        else {\n            val longest =\
    \ strings.maxBy(_.length)\n            strings.find(_.length == longest.length)\
    \ match {\n                case Some(longest) => Some(longest)\n             \
    \   case None => None\n            }\n        }", "        strings.foldLeft(List[String]())((acc,\
    \ s) => {\n            if (acc.length < s.length) acc :+ s\n            else Some(s)\n\
    \        })", "        strings.foldLeft(List[String]())((acc, s) => {\n      \
    \      if (acc.length < s.length) acc :+ s\n            else Some(s)\n       \
    \ })", '        strings.foldLeft(List[String]())( (acc, s) => if (acc.length <
    s.length) acc else s)', "        if (strings.isEmpty) None\n        else {\n \
    \           val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length <\
    \ s.length) acc else s)\n            Some(longest)\n        }", "        strings.foldLeft(List[String]())((list,\
    \ string) => {\n            if (list.length < string.length) list :+ string\n\
    \            else string\n        })", "        strings.length match {\n     \
    \       case 0 => None\n            case 1 => strings.headOption\n           \
    \ case _ => {\n                val longest = strings.foldLeft(List[String]())((acc,\
    \ s) => {\n                    if (acc.length < s.length) acc :+ s\n         \
    \           else s\n                })\n                longest.headOption\n \
    \           }\n        }", "        if (strings.isEmpty) None\n        else {\n\
    \            val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length\
    \ < s.length) acc else s)\n            Some(longest)\n        }", "        strings.length\
    \ match {\n            case 0 => None\n            case _ => {\n             \
    \   val longest = strings.foldLeft(\"\")( (acc, s) => {\n                    if\
    \ (acc.length < s.length) acc else s\n                })\n                Some(longest)\n\
    \            }\n        }", "        strings.foldLeft(List[String]())((list, str)\
    \ => {\n            if (list.isEmpty || list.length < str.length) list :+ str\n\
    \            else list\n        })\n            .maxBy(_.length)", "        strings.foldLeft(List[String]())(\
    \ (list, str) => list match {\n            case Nil => Some(str)\n           \
    \ case head :: tail => if (head.length == str.length) head else tail\n       \
    \ })", "        strings.foldLeft(List[String]())((list, string) => {\n       \
    \     val length = string.length\n            val index = list.indexWhere(s =>\
    \ s.length == length)\n            if (index >= 0) {\n                val newList\
    \ = list.updated(index, string)\n                if (newList.length == strings.length)\n\
    \                    Some(newList(0))\n                else\n                \
    \    longest(newList)\n            } else\n                list :+ string\n  \
    \      })", "        if (strings.isEmpty) None\n        else strings.maxBy(_.length)",
  "        strings.foldLeft(List[String]())((list, str) => {\n            if (list.isEmpty\
    \ || list.length < str.length) list :+ str\n            else list\n        })\n\
    \            .maxBy(_.length)", "        if (strings.isEmpty) None\n        else\
    \ strings.foldLeft(strings.head)((acc, s) => if (acc.length < s.length) acc else\
    \ s)", '        strings.foldLeft(List[String]())((acc, s) => if (acc.length <
    s.length) acc else s)', "        if (strings.isEmpty) None\n        else {\n \
    \           val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length <\
    \ s.length) acc else s)\n            Some(longest)\n        }", '        strings.foldLeft(List[String]())((acc,
    s) => if (acc.length < s.length) acc else s)', "        if (strings.isEmpty) None\n\
    \        else strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc\
    \ else s)", '        strings.foldLeft(List[String]())((acc, s) => if (acc.length
    < s.length) acc else s)', '        strings.foldLeft(List[String]())((acc, s) =>
    if (acc.length < s.length) acc else s)', "        if (strings.length == 0) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (acc, s) =>\
    \ if (acc.length < s.length) acc else s)\n            Some(longest)\n        }",
  "        if (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (a, b) => if (a.length < b.length) a else b )\n            strings.find(s\
    \ => s.equals(longest))\n        }", "        if (strings.isEmpty) None\n    \
    \    else {\n            val longest = strings.foldLeft(\"\")( (acc, s) => {\n\
    \                if (acc.length < s.length) acc else s\n            })\n     \
    \       Some(longest)\n        }", "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            if (list.length < str.length) list :+ str\n         \
    \   else str\n        })", "        if (strings.isEmpty) None\n        else {\n\
    \            val longest = strings.foldLeft(\"\")( (a, b) => if (a.length < b.length)\
    \ a else b )\n            strings.find(s => s == longest).getOrElse(longest)\n\
    \        }", "        if (strings.length == 0) None\n        else {\n        \
    \    val longest = strings.foldLeft(\"\")( (a, b) => if (a.length < b.length)\
    \ a else b)\n            strings.find(s => s == longest).map(s => longest)\n \
    \       }", "        if (strings.isEmpty) None\n        else {\n            val\
    \ longest = strings.foldLeft(\"\")( (acc, s) => {\n                if (acc.length\
    \ < s.length) acc else s\n            })\n            Some(longest)\n        }",
  "        if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.foldLeft(\"\")( (a,b) => if (a.length < b.length) a else b )\n   \
    \         strings.find(s => s == longest).getOrElse(longest)\n        }", '        strings.foldLeft(List[String]())((acc,
    s) => if (acc.length < s.length) acc else s)', "        if (strings.isEmpty) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (max: String,\
    \ current: String) => if (current.length >= max.length) current else max )\n \
    \           Some(longest)\n        }", "        strings.foldLeft(List[String]())((acc,\
    \ s) => {\n            val l = acc.length\n            if (l > s.length) Some(s)\
    \ else acc :+ s\n        })", "        strings.length match {\n            case\
    \ 0 => None\n            case 1 => Some(strings.head)\n            case _ => {\n\
    \                val maxLength = strings.foldLeft(0)(_ + _.length)\n         \
    \       strings.find(_.length == maxLength) match {\n                    case\
    \ Some(longest) => Some(longest)\n                    case None => None\n    \
    \            }\n            }\n        }", "        strings.foldLeft(List[String]())(\n\
    \            list => list.foldLeft(List[String]())(\n                list => list.foldLeft(List[String]())(\n\
    \                    list => list.foldLeft(List[String]())(\n                \
    \        list => list.foldLeft(List[String]())(\n                            list\
    \ => list.foldLeft(List[String]())(\n                                list => list.foldLeft(List[String]())(\n\
    \                                    list => list.foldLeft(List[String]())(\n\
    \                                        list => list.foldLeft(List[String]())(\n\
    \                                            list => list.foldLeft(List[String]())(\n\
    \                                                list => list.foldLeft(List[String]())(\n\
    \                                                    list => list.foldLeft(List[String]())(\n\
    \                                                        list => list.foldLeft(List[String]())(\n\
    \                                                            list => list.foldLeft(List[String]())(\n\
    \                                                                list => list.foldLeft(List[String]())(\n\
    \                                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                        list\
    \ => list.foldLeft(List[String]())(\n                                        \
    \                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \    list => list.foldLeft(List[String]())(\n                                \
    \                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \            list => list.foldLeft(List[String]())(\n                        \
    \                                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                    list => list.foldLeft(List[String]())(\n                \
    \                                                                            \
    \        list => list.foldLeft(List[String]())(\n                            \
    \                                                                            list\
    \ => list.foldLeft(List[String]())(\n                                        \
    \                                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                        list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                            list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                        list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                            list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                                list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                                    list => list.foldLeft(List[String]())(\n",
  "        if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.foldLeft(List[String]())((acc, s) => {\n                if (acc.length\
    \ < s.length) acc :+ s\n                else acc\n            })\n           \
    \ if (longest.length == strings.length) longest.headOption\n            else longest.headOption\n\
    \        }", "        strings.foldLeft(List[String]())((list, str) => {\n    \
    \        if (list.isEmpty || list.length < str.length) {\n                list\
    \ :+ str\n            } else {\n                list\n            }\n        }).maxBy(_.length)",
  "        if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.foldLeft(\"\")( (a, b) => if (a.length < b.length) a else b )\n  \
    \          strings.find(s => s == longest).map(s => longest)\n        }", "  \
    \      strings.foldLeft(List[String]())((list, str) => {\n            if (list.isEmpty\
    \ || list.length < str.length) {\n                list :+ str\n            } else\
    \ {\n                list\n            }\n        }).maxBy(_.length)", "     \
    \   strings.foldLeft(List[String]()){ (list, string) =>\n            if (list.length\
    \ < string.length) list :+ string\n            else string\n        }.maxBy(_.length)",
  "        if (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            longest.length\
    \ match {\n                case 1 => Some(longest)\n                case _ =>\
    \ longest.headOption\n            }\n        }", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n  \
    \      }", "        if (strings.isEmpty) None\n        else strings.sortWith(_\
    \ < _).lastOption", "        strings.foldLeft(List[String]())(\n            list\
    \ => list match {\n                case Nil => None\n                case head\
    \ :: tail => if (head.length == tail.length) head else tail.head\n           \
    \ }\n        )", "        strings.foldLeft(List[String]())((acc, s) => {\n   \
    \         if (acc.length < s.length) acc :+ s\n            else Some(s)\n    \
    \    })", "        if (strings.isEmpty) None\n        else {\n            val\
    \ longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc\
    \ else s)\n            Some(longest)\n        }", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (a,\
    \ b) => if (a.length < b.length) a else b)\n            strings.find(s => s.equals(longest))\n\
    \        }", "        strings.foldLeft(List[String]())((list, str) => {\n    \
    \        if (list.length < str.length) list :+ str\n            else if (list.length\
    \ == str.length) list :+ str\n            else None // Multiple strings of the\
    \ same length\n        })", "        strings.foldLeft(None) {\n            case\
    \ (Some(longest), s) =>\n                if (s.length() > longest.length)\n  \
    \                  Some(s)\n                else\n                    longest\n\
    \            case _ =>\n                None\n        }", "        strings.foldLeft(List[String]()){\n\
    \            case (acc, s) => if (acc.length < s.length) acc :+ s else acc\n \
    \       }.maxBy(_.length)", "        strings.foldLeft(List[String]())((list, string)\
    \ => {\n            if (list.length < string.length) list :+ string\n        \
    \    else string\n        })", "        strings.foldLeft(List[String]())((list,\
    \ s) => {\n            if (list.length < s.length) list :+ s\n            else\
    \ list\n        })\n            .maxBy(_.length)", "        strings.foldLeft(List[String]())((list,\
    \ string) => {\n            if (list.length >= string.length) list :+ string\n\
    \            else list\n        })", "        if (strings.isEmpty) None\n    \
    \    else strings.foldLeft(\"\")( (s, t) => if (s.length < t.length) s else t)",
  "        if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc else s)\n\
    \            Some(longest)\n        }", "        if (strings.isEmpty) None\n \
    \       else {\n            val longest = strings.foldLeft(\"\")( (acc, s) =>\
    \ if (acc.length < s.length) acc else s)\n            Some(longest)\n        }",
  "        strings.foldLeft(List[String]())((list, string) => {\n            val length\
    \ = string.length\n            if (list.length < length) list :+ string\n    \
    \        else list\n        })\n            .maxBy(_.length)", "        strings.foldLeft(List[String]()){\
    \ (list, str) =>\n            val len = str.length\n            list match {\n\
    \                case Nil => Some(str)\n                case head :: tail =>\n\
    \                    if (len > head.length) Some(str)\n                    else\
    \ longest(tail)\n            }\n        }", "        strings.foldLeft(List[String]())((list,\
    \ string) => {\n            if (list.length < string.length) list :+ string\n\
    \            else string\n        })", "        strings.foldLeft(List[String]())((acc,\
    \ s) => {\n            if (acc.length < s.length) acc :+ s\n            else acc\n\
    \        })", '        strings.foldLeft(List[String]())((acc, s) => if (acc.length
    < s.length) acc else s)', "        if (strings.length == 0) None\n        else\
    \ {\n            val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length\
    \ < s.length) acc else s)\n            longest.length match {\n              \
    \  case 1 => Some(longest)\n                case _ => longest\n            }\n\
    \        }", "        if (strings.length == 0) None\n        else strings.sortWith(_\
    \ < _).last", "        strings.foldLeft(List[String]())(\n            list =>\
    \ list match {\n                case Nil => None\n                case head ::\
    \ tail => if (head.length == list.head.length) head else list.head\n         \
    \   }\n        )", "        if (strings.length == 0) None\n        else {\n  \
    \          val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length <\
    \ s.length) acc else s)\n            Some(longest)\n        }", "        if (strings.isEmpty)\
    \ None\n        else strings.foldLeft(\"\") {\n            case (acc, str) =>\n\
    \                val len = str.length\n                if (acc.length < len) (str\
    \ :: acc)\n                else (str :: acc).takeWhile(_.length == len)\n    \
    \    }", "        if (strings.isEmpty) None\n        else {\n            val longest\
    \ = strings.foldLeft(\"\")( (acc, s) => {\n                if (acc.length < s.length)\
    \ acc else s\n            })\n            Some(longest)\n        }", "       \
    \ if (strings.length == 0) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => {\n                if (acc.length < s.length) acc else s\n  \
    \          })\n            Some(longest)\n        }", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => if (acc.length < s.length) acc else s)\n            longest.length match\
    \ {\n                case 1 => Some(longest)\n                case _ => longest.headOption\n\
    \            }\n        }", "        strings.foldLeft(List[String]()){\n     \
    \       case (acc, s) => if (acc.length < s.length) acc :+ s else acc\n      \
    \  }.maxBy(_.length)", "        if (strings.isEmpty) None\n        else {\n  \
    \          val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length <\
    \ s.length) acc else s)\n            Some(longest)\n        }", '        strings.foldLeft(List[String]())((acc,
    s) => if (acc.length < s.length) acc else s)', "        if (strings.length ==\
    \ 0) None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n  \
    \      }", "        if (strings.isEmpty) None\n        else strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)", "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            val len = str.length\n            if (len > list.last.length)\
    \ list :+ str\n            else list\n        })\n            .maxBy(_.length)",
  "        strings.foldLeft(List[String]())((list, str) => {\n            val length\
    \ = str.length\n            if (list.length < length) list :+ str\n          \
    \  else list\n        })\n            .maxBy(_.length)", "        strings.foldLeft(None:\
    \ Option[String]) { (max, str) =>\n            if (max.isEmpty || str.length >=\
    \ max.get.length) Some(str) else None\n        }", "        if (strings.length\
    \ == 0) None\n        else {\n            val longest = strings.foldLeft(\"\"\
    )( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        strings.length match {\n            case 0 => None\n   \
    \         case _ => {\n                val longest = strings.foldLeft(\"\")(_\
    \ + _.length).max\n                strings.find(_.length == longest).map(_.length)\n\
    \            }\n        }", "        if (strings.length == 0) None\n        else\
    \ {\n            val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length\
    \ < s.length) acc else s)\n            Some(longest)\n        }", "        if\
    \ (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        strings.foldLeft(List[String]())((list, string) => {\n \
    \           if (list.length < string.length) list :+ string\n            else\
    \ string\n        })", "        if (strings.isEmpty) None\n        else {\n  \
    \          val longest = strings.foldLeft(\"\")( (acc, s) => {\n             \
    \   if (acc.length < s.length) acc else s\n            })\n            Some(longest)\n\
    \        }", "        if (strings.isEmpty) None\n        else {\n            val\
    \ longest = strings.foldLeft(\"\")(_ + _.length)\n            strings.find(_.length\
    \ == longest).map(_.length)\n        }", "        if (strings.length == 0) None\n\
    \        else strings.sortWith(_ < _).last", "        if (strings.isEmpty) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (a,b) => if\
    \ (a.length < b.length) a else b )\n            strings.find(s => s == longest).getOrElse(longest)\n\
    \        }", "        if (strings.isEmpty) None\n        else strings.foldLeft(strings.head)\
    \ {\n            case (longest, current) => if (current.length >= longest.length)\
    \ current else longest\n        }", "        strings.foldLeft(List[String]())((list,\
    \ s) => {\n            if (list.isEmpty || s.length < list.last.length) list :+\
    \ s\n            else list\n        })\n            .sortWith((x, y) => x.length\
    \ > y.length)\n            .lastOption", "        if (strings.length == 0) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (acc, s) =>\
    \ if (acc.length < s.length) acc else s)\n            Some(longest)\n        }",
  "        if (strings.isEmpty) None\n        else strings.foldLeft(\"\") {\n    \
    \        case (acc, str) =>\n                if (acc.length < str.length) acc\
    \ else str\n        }", "        strings.foldLeft(List[String]())((acc, s) =>\
    \ {\n            if (acc.length < s.length) acc :+ s\n            else acc\n \
    \       })\n            .maxBy(_.length)", "        if (strings.isEmpty) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (acc, s) =>\
    \ {\n                if (acc.length < s.length) acc else s\n            })\n \
    \           Some(longest)\n        }", '        strings.foldLeft(List[String]())(
    (list, string) => if (string.length > list.head.length) list :+ string else list)',
  "        strings.foldLeft(List[String]())((acc, s) => {\n            if (acc.length\
    \ < s.length) acc :+ s\n            else Some(s)\n        })", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => {\n                if (acc.length < s.length) acc else s\n           \
    \ })\n            Some(longest)\n        }", "        strings.foldLeft(List[String]())((acc,\
    \ s) => {\n            if (acc.length < s.length) acc :+ s\n            else acc\n\
    \        })\n            .maxBy(_.length)", "        if (strings.isEmpty) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (acc, s) =>\
    \ if (acc.length < s.length) acc else s)\n            Some(longest)\n        }",
  "        strings.length match {\n            case 0 => None\n            case _\
    \ => {\n                strings.foldLeft(\"\") {\n                    case (acc,\
    \ s) => if (acc.length < s.length) acc else s\n                }\n           \
    \ }\n        }", "        if (strings.isEmpty) None\n        else strings.foldLeft(strings.head)\
    \ {\n            case (longest, next) =>\n                if (next.length < longest.length)\
    \ Some(next)\n                else longest\n        }", "        if (strings.isEmpty)\
    \ None\n        else strings.sortWith(_ < _).lastOption", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n  \
    \      }", "        strings.length match {\n            case 0 => None\n     \
    \       case _ => {\n                val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => {\n                    if (acc.length < s.length) acc else s\n       \
    \         })\n                Some(longest)\n            }\n        }", "    \
    \    if (strings.isEmpty) None\n        else strings.foldLeft(\"\")( (acc, s)\
    \ => if (acc.length < s.length) acc else s)", "        strings.foldLeft(List[String]()){\n\
    \            case (acc, s) => acc match {\n                case Nil => Some(s)\n\
    \                case _ => if (acc.length < s.length) Some(s) else acc\n     \
    \       }\n        }", "        if (strings.length == 0) None\n        else {\n\
    \            val longest = strings.foldLeft(\"\")( (acc, s) => {\n           \
    \     if (acc.length < s.length) acc else s\n            })\n            Some(longest)\n\
    \        }", "        strings.foldLeft(List[String]()){\n            case (acc,\
    \ s) => if (acc.length < s.length) acc :+ s else acc\n        }.maxBy(_.length)",
  '        strings.foldLeft(List[String]())((acc, s) => if (acc.length < s.length)
    acc else s)', "        strings.foldLeft(List[String]())(\n            list =>\
    \ list match {\n                case Nil => None\n                case head ::\
    \ tail => if (head.length == list.head.length) head else list.head\n         \
    \   }\n        )", "        if (strings.isEmpty) None\n        else strings.sortWith(_\
    \ < _).lastOption", "        strings.foldLeft(List[String]())((list, s) => {\n\
    \            if (list.length < s.length) list :+ s\n            else list\n  \
    \      })\n            .maxBy(_.length)", "        strings.foldLeft(List[String]()){\n\
    \            case (acc, s) => if (acc.length < s.length) acc :+ s else acc\n \
    \       }.maxBy(_.length)", "        if (strings.isEmpty) None\n        else {\n\
    \            val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length\
    \ < s.length) acc else s)\n            Some(longest)\n        }", "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            val len = str.length\n            list match {\n    \
    \            case Nil => List(str)\n                case _ => if (len > list.last.length)\
    \ list :+ str else list\n            }\n        })\n            .maxBy(_.length)",
  "        if (strings.isEmpty) None\n        else strings.foldLeft(\"\")( (acc, s)\
    \ => if (acc.length < s.length) acc else s)", '        strings.foldLeft(List[String]())((acc,
    s) => if (acc.length < s.length) acc else s)', "        if (strings.isEmpty) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (acc, s) =>\
    \ if (acc.length < s.length) acc else s)\n            Some(longest)\n        }",
  "        strings.length match {\n            case 0 => None\n            case 1\
    \ => strings.headOption\n            case _ => {\n                val longest\
    \ = strings.foldLeft(\"\")( (acc, s) => {\n                    if (acc.length\
    \ < s.length) acc else s\n                })\n                Some(longest)\n\
    \            }\n        }", "        if (strings.isEmpty) None\n        else {\n\
    \            val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length\
    \ < s.length) acc else s)\n            Some(longest)\n        }", "        strings.foldLeft(List[String]())((acc,\
    \ s) => {\n            if (acc.length < s.length) acc :+ s\n            else Some(acc)\n\
    \        })", "        if (strings.length == 0) None\n        else strings.maxBy(_.length)",
  "        if (strings.length == 0) None\n        else {\n            var maxLength\
    \ = 0\n            var maxString = \"\"\n            for (s <- strings) {\n  \
    \              if (s.length >= maxLength) {\n                    maxLength = s.length\n\
    \                    maxString = s\n                }\n            }\n       \
    \     Some(maxString)\n        }", "        strings.foldLeft(List[String]()){\n\
    \            case (acc, s) => acc match {\n                case Nil => Some(s)\n\
    \                case _ => if (acc.length < s.length) Some(s) else acc\n     \
    \       }\n        }", "        if (strings.length == 0) None\n        else {\n\
    \            val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length\
    \ < s.length) acc else s)\n            Some(longest)\n        }", "        strings.foldLeft(List[String]())((acc,\
    \ s) => {\n            if (acc.length < s.length) acc :+ s\n            else Some(s)\n\
    \        })", "        strings.foldLeft(None)(\n            { case (longest, s)\
    \ =>\n                if (longest.isEmpty || longest.length < s.length) Some(s)\
    \ else longest\n            }\n        )", "        if (strings.length == 0) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (acc, s) =>\
    \ if (acc.length < s.length) acc else s)\n            Some(longest)\n        }",
  "        if (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        strings.foldLeft(List[String]())((list, string) => {\n \
    \           val length = string.length\n            if (list.length < length)\
    \ list :+ string\n            else list\n        })\n            .sortWith((a,\
    \ b) => a.length <= b.length)\n            .headOption", "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            if (list.length < str.length) list :+ str\n         \
    \   else str\n        })", "        if (strings.length == 0) None\n        else\
    \ {\n            val longest = strings.sortWith(_ < _).last\n            longest.headOption\n\
    \        }", "        strings.foldLeft(List[String]())((list, str) => {\n    \
    \        if (list.length < str.length) {\n                list :+ str\n      \
    \      } else {\n                list\n            }\n        })", "        if\
    \ (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }"]
stop_tokens:
- "\n    }\n"
